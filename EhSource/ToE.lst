00001    ; Tower of Eightness OS
00002    
00003    
00004      .include "basic_ToE.asm"
00005    
00006    ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22p5 EL1
00007    
00008    ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
00009    
00010    ; 2.00      new revision numbers start here
00011    ; 2.01      fixed LCASE$() and UCASE$()
00012    ; 2.02      new get value routine done
00013    ; 2.03      changed RND() to galoise method
00014    ; 2.04      fixed SPC()
00015    ; 2.05      new get value routine fixed
00016    ; 2.06      changed USR() code
00017    ; 2.07      fixed STR$()
00018    ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
00019    ; 2.09      fixed RND()
00020    ; 2.10      integrated missed changes from an earlier version
00021    ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
00022    ; 2.21      fixed IF .. THEN RETURN to not cause error
00023    ; 2.22      fixed RND() breaking the get byte routine
00024    ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
00025    ;              (bugsnquirks.txt notes 2, 4 and 5)
00026    ;              tabs converted to spaces, tabwidth=6
00027    ; 2.22p2    fixed can't continue error on 1st statement after direct mode
00028    ;              changed INPUT to throw "break in line ##" on empty line input
00029    ; 2.22p3    fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
00030    ;              fix provided by github user mgcaret
00031    ; 2.22p4    fixed string compare of equal strings in direct mode returns FALSE
00032    ;              fixed FALSE stored to a variable after a string compare 
00033    ;                 is > 0 and < 1E-16
00034    ;              added additional stack floor protection for background interrupts
00035    ;              fixed conditional LOOP & NEXT cannot find their data strucure on stack
00036    ; 2.22p5    fixes issues reported by users Ruud and dclxvi on the 6502.org forum
00037    ;      5.0     http://forum.6502.org/viewtopic.php?f=5&t=5500
00038    ;              sanity check for RAM top allows values below RAM base
00039    ;      5.1-7   http://forum.6502.org/viewtopic.php?f=5&t=5606
00040    ;              1-7 coresponds to the bug# in the thread
00041    ;      5.1     TO expression with a subtract may evaluate with the sign bit flipped
00042    ;      5.3     call to LAB_1B5B may return to an address -$100 (page not incremented)
00043    ;      5.4     string concatenate followed by MINUS or NOT() crashes EhBASIC
00044    ;      5.5     garbage collection may cause an overlap with temporary strings
00045    ;      5.6     floating point multiply rounding bug
00046    ;      5.7     VAL() may cause string variables to be trashed
00047    
00048    ; Tower of Eightness additions:-
00049    ;
00050    ;      LOCATE command. Moves the text cursor on the ANSI display to x,y coordinate.
00051    ;      CLS command. Clears the ANSI display.
00052    ;      PLOT command. Sets/clears a pixel on the ANSI display.
00053    ;      CAT command. Displays the contents of (at present TowerTAPE only) currently selected file system.
00054    ;      LOAD and SAVE have real functionality.
00055    ;      VERIFY command.  Have you ever lost data?  HAVE YOU!!?  Let's be sure things are right before moving on.
00056    ;      SOUND command. Plays a sound on the AY until stopped.
00057    ;      ENVELOPE command. Defines period and mode of AY volume modulation.
00058    ;      I2C_START command.  Sends a start (S) on the SPI engine.
00059    ;      I2C_STOP command.  Sends a stop (P) on the SPI engine.
00060    ;      I2C_OUT() function.  Sends out a value and returns the status.
00061    ;      I2C_IN() functon.  Returns a value from the I2C engine taking either 0 (ACK) or 1 (NAK) as it's parameter.
00062    ;      I2C_INIT command.  Initialises the I2C engine.  This is necessary because not everyone wants to use the pins for I2C.
00063    
00064    
00065    ; zero page use ..
00066    
00067    ; the following locations are bulk initialized from StrTab at LAB_GMEM
00068      0000             LAB_WARM          = $00       ; BASIC warm start entry point
00069      0001             Wrmjpl            = LAB_WARM+1; BASIC warm start vector jump low byte
00070      0002             Wrmjph            = LAB_WARM+2; BASIC warm start vector jump high byte
00071    
00072      000A             Usrjmp            = $0A       ; USR function JMP address
00073      000B             Usrjpl            = Usrjmp+1  ; USR function JMP vector low byte
00074      000C             Usrjph            = Usrjmp+2  ; USR function JMP vector high byte
00075      000D             Nullct            = $0D       ; nulls output after each line
00076      000E             TPos              = $0E       ; BASIC terminal position byte
00077      000F             TWidth            = $0F       ; BASIC terminal width byte
00078      0010             Iclim             = $10       ; input column limit
00079      0011             Itempl            = $11       ; temporary integer low byte
00080      0012             Itemph            = Itempl+1  ; temporary integer high byte
00081    ; end bulk initialize from StrTab at LAB_GMEM
00082    
00083      0011             nums_1            = Itempl    ; number to bin/hex string convert MSB
00084      0012             nums_2            = nums_1+1  ; number to bin/hex string convert
00085      0013             nums_3            = nums_1+2  ; number to bin/hex string convert LSB
00086    
00087      005B             Srchc             = $5B       ; search character
00088      005B             Temp3             = Srchc     ; temp byte used in number routines
00089      005C             Scnquo            = $5C       ; scan-between-quotes flag
00090      005C             Asrch             = Scnquo    ; alt search character
00091    
00092      005B             XOAw_l            = Srchc     ; eXclusive OR, OR and AND word low byte
00093      005C             XOAw_h            = Scnquo    ; eXclusive OR, OR and AND word high byte
00094    
00095      005D             Ibptr             = $5D       ; input buffer pointer
00096      005D             Dimcnt            = Ibptr     ; # of dimensions
00097      005D             Tindx             = Ibptr     ; token index
00098    
00099      005E             Defdim            = $5E       ; default DIM flag
00100      005F             Dtypef            = $5F       ; data type flag, $FF=string, $00=numeric
00101      0060             Oquote            = $60       ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
00102      0060             Gclctd            = $60       ; garbage collected flag
00103      0061             Sufnxf            = $61       ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
00104      0062             Imode             = $62       ; input mode flag, $00=INPUT, $80=READ
00105    
00106      0063             Cflag             = $63       ; comparison evaluation flag
00107    
00108      0064             TabSiz            = $64       ; TAB step size (was input flag)
00109    
00110      0065             next_s            = $65       ; next descriptor stack address
00111    
00112                                  ; these two bytes form a word pointer to the item
00113                                  ; currently on top of the descriptor stack
00114      0066             last_sl           = $66       ; last descriptor stack address low byte
00115      0067             last_sh           = $67       ; last descriptor stack address high byte (always $00)
00116    
00117      0068             des_sk            = $68       ; descriptor stack start address (temp strings)
00118    
00119    ;                 = $70       ; End of descriptor stack
00120    
00121      0071             ut1_pl            = $71       ; utility pointer 1 low byte
00122      0072             ut1_ph            = ut1_pl+1  ; utility pointer 1 high byte
00123      0073             ut2_pl            = $73       ; utility pointer 2 low byte
00124      0074             ut2_ph            = ut2_pl+1  ; utility pointer 2 high byte
00125    
00126      0071             Temp_2            = ut1_pl    ; temp byte for block move    
00127    
00128      0075             FACt_1            = $75       ; FAC temp mantissa1
00129      0076             FACt_2            = FACt_1+1  ; FAC temp mantissa2
00130      0077             FACt_3            = FACt_2+1  ; FAC temp mantissa3
00131    
00132      0076             dims_l            = FACt_2    ; array dimension size low byte
00133      0077             dims_h            = FACt_3    ; array dimension size high byte
00134    
00135      0078             TempB             = $78       ; temp page 0 byte
00136    
00137      0079             Smeml             = $79       ; start of mem low byte       (Start-of-Basic)
00138      007A             Smemh             = Smeml+1   ; start of mem high byte      (Start-of-Basic)
00139      007B             Svarl             = $7B       ; start of vars low byte      (Start-of-Variables)
00140      007C             Svarh             = Svarl+1   ; start of vars high byte     (Start-of-Variables)
00141      007D             Sarryl            = $7D       ; var mem end low byte        (Start-of-Arrays)
00142      007E             Sarryh            = Sarryl+1  ; var mem end high byte       (Start-of-Arrays)
00143      007F             Earryl            = $7F       ; array mem end low byte      (End-of-Arrays)
00144      0080             Earryh            = Earryl+1  ; array mem end high byte     (End-of-Arrays)
00145      0081             Sstorl            = $81       ; string storage low byte     (String storage (moving down))
00146      0082             Sstorh            = Sstorl+1  ; string storage high byte    (String storage (moving down))
00147      0083             Sutill            = $83       ; string utility ptr low byte
00148      0084             Sutilh            = Sutill+1  ; string utility ptr high byte
00149      0085             Ememl             = $85       ; end of mem low byte         (Limit-of-memory)
00150      0086             Ememh             = Ememl+1   ; end of mem high byte        (Limit-of-memory)
00151      0087             Clinel            = $87       ; current line low byte       (Basic line number)
00152      0088             Clineh            = Clinel+1  ; current line high byte      (Basic line number)
00153      0089             Blinel            = $89       ; break line low byte         (Previous Basic line number)
00154      008A             Blineh            = Blinel+1  ; break line high byte        (Previous Basic line number)
00155    
00156      008B             Cpntrl            = $8B       ; continue pointer low byte
00157      008C             Cpntrh            = Cpntrl+1  ; continue pointer high byte
00158    
00159      008D             Dlinel            = $8D       ; current DATA line low byte
00160      008E             Dlineh            = Dlinel+1  ; current DATA line high byte
00161    
00162      008F             Dptrl             = $8F       ; DATA pointer low byte
00163      0090             Dptrh             = Dptrl+1   ; DATA pointer high byte
00164    
00165      0091             Rdptrl            = $91       ; read pointer low byte
00166      0092             Rdptrh            = Rdptrl+1  ; read pointer high byte
00167    
00168      0093             Varnm1            = $93       ; current var name 1st byte
00169      0094             Varnm2            = Varnm1+1  ; current var name 2nd byte
00170    
00171      0095             Cvaral            = $95       ; current var address low byte
00172      0096             Cvarah            = Cvaral+1  ; current var address high byte
00173    
00174      0097             Frnxtl            = $97       ; var pointer for FOR/NEXT low byte
00175      0098             Frnxth            = Frnxtl+1  ; var pointer for FOR/NEXT high byte
00176    
00177      0097             Tidx1             = Frnxtl    ; temp line index
00178    
00179      0097             Lvarpl            = Frnxtl    ; let var pointer low byte
00180      0098             Lvarph            = Frnxth    ; let var pointer high byte
00181    
00182      0099             prstk             = $99       ; precedence stacked flag
00183    
00184      009B             comp_f            = $9B       ; compare function flag, bits 0,1 and 2 used
00185                                  ; bit 2 set if >
00186                                  ; bit 1 set if =
00187                                  ; bit 0 set if <
00188    
00189      009C             func_l            = $9C       ; function pointer low byte
00190      009D             func_h            = func_l+1  ; function pointer high byte
00191    
00192      009C             garb_l            = func_l    ; garbage collection working pointer low byte
00193      009D             garb_h            = func_h    ; garbage collection working pointer high byte
00194    
00195      009E             des_2l            = $9E       ; string descriptor_2 pointer low byte
00196      009F             des_2h            = des_2l+1  ; string descriptor_2 pointer high byte
00197    
00198      00A0             g_step            = $A0       ; garbage collect step size
00199    
00200      00A1             Fnxjmp            = $A1       ; jump vector for functions
00201      00A2             Fnxjpl            = Fnxjmp+1  ; functions jump vector low byte
00202      00A3             Fnxjph            = Fnxjmp+2  ; functions jump vector high byte
00203    
00204      00A2             g_indx            = Fnxjpl    ; garbage collect temp index
00205    
00206      00A3             FAC2_r            = $A3       ; FAC2 rounding byte
00207    
00208      00A4             Adatal            = $A4       ; array data pointer low byte
00209      00A5             Adatah            = Adatal+1  ; array data pointer high  byte
00210    
00211      00A4             Nbendl            = Adatal    ; new block end pointer low byte
00212      00A5             Nbendh            = Adatah    ; new block end pointer high  byte
00213    
00214      00A6             Obendl            = $A6       ; old block end pointer low byte
00215      00A7             Obendh            = Obendl+1  ; old block end pointer high  byte
00216    
00217      00A8             numexp            = $A8       ; string to float number exponent count
00218      00A9             expcnt            = $A9       ; string to float exponent count
00219    
00220      00A8             numbit            = numexp    ; bit count for array element calculations
00221    
00222      00AA             numdpf            = $AA       ; string to float decimal point flag
00223      00AB             expneg            = $AB       ; string to float eval exponent -ve flag
00224    
00225      00AA             Astrtl            = numdpf    ; array start pointer low byte
00226      00AB             Astrth            = expneg    ; array start pointer high  byte
00227    
00228      00AA             Histrl            = numdpf    ; highest string low byte
00229      00AB             Histrh            = expneg    ; highest string high  byte
00230    
00231      00AA             Baslnl            = numdpf    ; BASIC search line pointer low byte
00232      00AB             Baslnh            = expneg    ; BASIC search line pointer high  byte
00233    
00234      00AA             Fvar_l            = numdpf    ; find/found variable pointer low byte
00235      00AB             Fvar_h            = expneg    ; find/found variable pointer high  byte
00236    
00237      00AA             Ostrtl            = numdpf    ; old block start pointer low byte
00238      00AB             Ostrth            = expneg    ; old block start pointer high  byte
00239    
00240      00AA             Vrschl            = numdpf    ; variable search pointer low byte
00241      00AB             Vrschh            = expneg    ; variable search pointer high  byte
00242    
00243      00AC             FAC1_e            = $AC       ; FAC1 exponent
00244      00AD             FAC1_1            = FAC1_e+1  ; FAC1 mantissa1
00245      00AE             FAC1_2            = FAC1_e+2  ; FAC1 mantissa2
00246      00AF             FAC1_3            = FAC1_e+3  ; FAC1 mantissa3
00247      00B0             FAC1_s            = FAC1_e+4  ; FAC1 sign (b7)
00248    
00249      00AC             str_ln            = FAC1_e    ; string length
00250      00AD             str_pl            = FAC1_1    ; string pointer low byte
00251      00AE             str_ph            = FAC1_2    ; string pointer high byte
00252    
00253      00AE             des_pl            = FAC1_2    ; string descriptor pointer low byte
00254      00AF             des_ph            = FAC1_3    ; string descriptor pointer high byte
00255    
00256      00AF             mids_l            = FAC1_3    ; MID$ string temp length byte
00257    
00258      00B1             negnum            = $B1       ; string to float eval -ve flag
00259      00B1             numcon            = $B1       ; series evaluation constant count
00260    
00261      00B2             FAC1_o            = $B2       ; FAC1 overflow byte
00262    
00263      00B3             FAC2_e            = $B3       ; FAC2 exponent
00264      00B4             FAC2_1            = FAC2_e+1  ; FAC2 mantissa1
00265      00B5             FAC2_2            = FAC2_e+2  ; FAC2 mantissa2
00266      00B6             FAC2_3            = FAC2_e+3  ; FAC2 mantissa3
00267      00B7             FAC2_s            = FAC2_e+4  ; FAC2 sign (b7)
00268    
00269      00B8             FAC_sc            = $B8       ; FAC sign comparison, Acc#1 vs #2
00270      00B9             FAC1_r            = $B9       ; FAC1 rounding byte
00271    
00272      00B8             ssptr_l           = FAC_sc    ; string start pointer low byte
00273      00B9             ssptr_h           = FAC1_r    ; string start pointer high byte
00274    
00275      00B8             sdescr            = FAC_sc    ; string descriptor pointer
00276    
00277      00BA             csidx             = $BA       ; line crunch save index
00278      00BA             Asptl             = csidx     ; array size/pointer low byte
00279      00BB             Aspth             = $BB       ; array size/pointer high byte
00280    
00281      00BA             Btmpl             = Asptl     ; BASIC pointer temp low byte
00282      00BB             Btmph             = Aspth     ; BASIC pointer temp low byte
00283    
00284      00BA             Cptrl             = Asptl     ; BASIC pointer temp low byte
00285      00BB             Cptrh             = Aspth     ; BASIC pointer temp low byte
00286    
00287      00BA             Sendl             = Asptl     ; BASIC pointer temp low byte
00288      00BB             Sendh             = Aspth     ; BASIC pointer temp low byte
00289    
00290    ; the following locations are bulk initialized from LAB_2CEE at LAB_2D4E
00291      00BC             LAB_IGBY          = $BC       ; get next BASIC byte subroutine
00292    
00293      00C2             LAB_GBYT          = $C2       ; get current BASIC byte subroutine
00294      00C3             Bpntrl            = $C3       ; BASIC execute (get byte) pointer low byte
00295      00C4             Bpntrh            = Bpntrl+1  ; BASIC execute (get byte) pointer high byte
00296    
00297    ;                 = $D7       ; end of get BASIC char subroutine
00298    ; end bulk initialize from LAB_2CEE at LAB_2D4E
00299    
00300      00D8             Rbyte4            = $D8       ; extra PRNG byte
00301      00D9             Rbyte1            = Rbyte4+1  ; most significant PRNG byte
00302      00DA             Rbyte2            = Rbyte4+2  ; middle PRNG byte
00303      00DB             Rbyte3            = Rbyte4+3  ; least significant PRNG byte
00304    
00305      00DC             NmiBase           = $DC       ; NMI handler enabled/setup/triggered flags
00306                                  ; bit function
00307                                  ; === ========
00308                                  ; 7   interrupt enabled
00309                                  ; 6   interrupt setup
00310                                  ; 5   interrupt happened
00311    ;                 = $DD       ; NMI handler addr low byte
00312    ;                 = $DE       ; NMI handler addr high byte
00313      00DF             IrqBase           = $DF       ; IRQ handler enabled/setup/triggered flags
00314    ;                 = $E0       ; IRQ handler addr low byte
00315    ;                 = $E1       ; IRQ handler addr high byte
00316    
00317    ; *** removed unused comments for $DE-$E1
00318    
00319    ;                 = $E2       ; TPB card temporary location
00320    ;                 = $E3       ; TPB card temporary location
00321    ;                 = $E4       ; TAPE tempoaray location.
00322    ;                 = $E5       ; TAPE BlockLo
00323    ;                 = $E6       ; TAPE blockHi
00324    ;                 = $E7       ; TOE_MemptrLo low byte general purpose pointer
00325    ;                 = $E8       ; TOE_MemptrHi high byte general purpose pointer.
00326    ;                 = $E9       ; unused
00327    ;                 = $EA       ; unused
00328    ;                 = $EB       ; unused
00329    ;                 = $EC       ; unused
00330    ;                 = $ED       ; unused
00331    ;                 = $EE       ; unused
00332    
00333      00EF             Decss             = $EF       ; number to decimal string start
00334      00F0             Decssp1           = Decss+1   ; number to decimal string start
00335    
00336    ;                 = $FF       ; decimal string end
00337    
00338    ; token values needed for BASIC
00339    
00340    ; primary command tokens (can start a statement)
00341    
00342      0080             TK_END            = $80             ; END token
00343      0081             TK_FOR            = TK_END+1        ; FOR token
00344      0082             TK_NEXT           = TK_FOR+1        ; NEXT token
00345      0083             TK_DATA           = TK_NEXT+1       ; DATA token
00346      0084             TK_INPUT          = TK_DATA+1       ; INPUT token
00347      0085             TK_DIM            = TK_INPUT+1      ; DIM token
00348      0086             TK_READ           = TK_DIM+1        ; READ token
00349      0087             TK_LET            = TK_READ+1       ; LET token
00350      0088             TK_DEC            = TK_LET+1        ; DEC token
00351      0089             TK_GOTO           = TK_DEC+1        ; GOTO token
00352      008A             TK_RUN            = TK_GOTO+1       ; RUN token
00353      008B             TK_IF             = TK_RUN+1        ; IF token
00354      008C             TK_RESTORE        = TK_IF+1         ; RESTORE token
00355      008D             TK_GOSUB          = TK_RESTORE+1    ; GOSUB token
00356      008E             TK_RETIRQ         = TK_GOSUB+1      ; RETIRQ token
00357      008F             TK_RETNMI         = TK_RETIRQ+1     ; RETNMI token
00358      0090             TK_RETURN         = TK_RETNMI+1     ; RETURN token
00359      0091             TK_REM            = TK_RETURN+1     ; REM token
00360      0092             TK_STOP           = TK_REM+1        ; STOP token
00361      0093             TK_ON             = TK_STOP+1       ; ON token
00362      0094             TK_NULL           = TK_ON+1         ; NULL token
00363      0095             TK_INC            = TK_NULL+1       ; INC token
00364      0096             TK_WAIT           = TK_INC+1        ; WAIT token
00365      0097             TK_LOAD           = TK_WAIT+1       ; LOAD token
00366      0098             TK_SAVE           = TK_LOAD+1       ; SAVE token
00367      0099             TK_DEF            = TK_SAVE+1       ; DEF token
00368      009A             TK_POKE           = TK_DEF+1        ; POKE token
00369      009B             TK_DOKE           = TK_POKE+1       ; DOKE token
00370      009C             TK_CALL           = TK_DOKE+1       ; CALL token
00371      009D             TK_DO             = TK_CALL+1       ; DO token
00372      009E             TK_LOOP           = TK_DO+1         ; LOOP token
00373      009F             TK_PRINT          = TK_LOOP+1       ; PRINT token
00374      00A0             TK_CONT           = TK_PRINT+1      ; CONT token
00375      00A1             TK_LIST           = TK_CONT+1       ; LIST token
00376      00A2             TK_CLEAR          = TK_LIST+1       ; CLEAR token
00377      00A3             TK_NEW            = TK_CLEAR+1      ; NEW token
00378      00A4             TK_WIDTH          = TK_NEW+1        ; WIDTH token
00379      00A5             TK_GET            = TK_WIDTH+1      ; GET token
00380      00A6             TK_SWAP           = TK_GET+1        ; SWAP token
00381      00A7             TK_BITSET         = TK_SWAP+1       ; BITSET token
00382      00A8             TK_BITCLR         = TK_BITSET+1     ; BITCLR token
00383      00A9             TK_IRQ            = TK_BITCLR+1     ; IRQ token
00384      00AA             TK_NMI            = TK_IRQ+1        ; NMI token
00385      00AB             TK_VERIFY         = TK_NMI+1        ; VERIFY token
00386      00AC             TK_CAT            = TK_VERIFY+1     ; CAT token
00387      00AD             TK_CLS            = TK_CAT+1        ; CLS token
00388      00AE             TK_LOCATE         = TK_CLS+1        ; LOCATE token
00389      00AF             TK_PLOT           = TK_LOCATE+1     ; PLOT token
00390      00B0             TK_SOUND          = TK_PLOT+1       ; SOUND token
00391      00B1             TK_ENVELOPE       = TK_SOUND+1      ; ENVELOPE token
00392      00B2             TK_I2C_START      = TK_ENVELOPE+1   ; I2C_START token
00393      00B3             TK_I2C_STOP       = TK_I2C_START+1  ; I2C_STOP token
00394      00B4             TK_I2C_INIT       = TK_I2C_STOP+1   ; I2C_INIT token
00395    
00396    
00397    ; secondary command tokens, can't start a statement
00398    
00399      00B5             TK_TAB            = TK_I2C_INIT+1   ; TAB token
00400      00B6             TK_ELSE           = TK_TAB+1        ; ELSE token
00401      00B7             TK_TO             = TK_ELSE+1       ; TO token
00402      00B8             TK_FN             = TK_TO+1         ; FN token
00403      00B9             TK_SPC            = TK_FN+1         ; SPC token
00404      00BA             TK_THEN           = TK_SPC+1        ; THEN token
00405      00BB             TK_NOT            = TK_THEN+1       ; NOT token
00406      00BC             TK_STEP           = TK_NOT+1        ; STEP token
00407      00BD             TK_UNTIL          = TK_STEP+1       ; UNTIL token
00408      00BE             TK_WHILE          = TK_UNTIL+1      ; WHILE token
00409      00BF             TK_OFF            = TK_WHILE+1      ; OFF token
00410    
00411    ; opperator tokens
00412    
00413      00C0             TK_PLUS           = TK_OFF+1        ; + token
00414      00C1             TK_MINUS          = TK_PLUS+1       ; - token
00415      00C2             TK_MUL            = TK_MINUS+1      ; * token
00416      00C3             TK_DIV            = TK_MUL+1        ; / token
00417      00C4             TK_POWER          = TK_DIV+1        ; ^ token
00418      00C5             TK_AND            = TK_POWER+1      ; AND token
00419      00C6             TK_EOR            = TK_AND+1        ; EOR token
00420      00C7             TK_OR             = TK_EOR+1        ; OR token
00421      00C8             TK_RSHIFT         = TK_OR+1         ; RSHIFT token
00422      00C9             TK_LSHIFT         = TK_RSHIFT+1     ; LSHIFT token
00423      00CA             TK_GT             = TK_LSHIFT+1     ; > token
00424      00CB             TK_EQUAL          = TK_GT+1         ; = token
00425      00CC             TK_LT             = TK_EQUAL+1      ; < token
00426    
00427    ; functions tokens
00428    
00429      00CD             TK_SGN            = TK_LT+1         ; SGN token
00430      00CE             TK_INT            = TK_SGN+1        ; INT token
00431      00CF             TK_ABS            = TK_INT+1        ; ABS token
00432      00D0             TK_USR            = TK_ABS+1        ; USR token
00433      00D1             TK_FRE            = TK_USR+1        ; FRE token
00434      00D2             TK_POS            = TK_FRE+1        ; POS token
00435      00D3             TK_SQR            = TK_POS+1        ; SQR token
00436      00D4             TK_RND            = TK_SQR+1        ; RND token
00437      00D5             TK_LOG            = TK_RND+1        ; LOG token
00438      00D6             TK_EXP            = TK_LOG+1        ; EXP token
00439      00D7             TK_COS            = TK_EXP+1        ; COS token
00440      00D8             TK_SIN            = TK_COS+1        ; SIN token
00441      00D9             TK_TAN            = TK_SIN+1        ; TAN token
00442      00DA             TK_ATN            = TK_TAN+1        ; ATN token
00443      00DB             TK_PEEK           = TK_ATN+1        ; PEEK token
00444      00DC             TK_DEEK           = TK_PEEK+1       ; DEEK token
00445      00DD             TK_SADD           = TK_DEEK+1       ; SADD token
00446      00DE             TK_LEN            = TK_SADD+1       ; LEN token
00447      00DF             TK_STRS           = TK_LEN+1        ; STR$ token
00448      00E0             TK_VAL            = TK_STRS+1       ; VAL token
00449      00E1             TK_ASC            = TK_VAL+1        ; ASC token
00450      00E2             TK_UCASES         = TK_ASC+1        ; UCASE$ token
00451      00E3             TK_LCASES         = TK_UCASES+1     ; LCASE$ token
00452      00E4             TK_CHRS           = TK_LCASES+1     ; CHR$ token
00453      00E5             TK_HEXS           = TK_CHRS+1       ; HEX$ token
00454      00E6             TK_BINS           = TK_HEXS+1       ; BIN$ token
00455      00E7             TK_BITTST         = TK_BINS+1       ; BITTST token
00456      00E8             TK_MAX            = TK_BITTST+1     ; MAX token
00457      00E9             TK_MIN            = TK_MAX+1        ; MIN token
00458      00EA             TK_PI             = TK_MIN+1        ; PI token
00459      00EB             TK_TWOPI          = TK_PI+1         ; TWOPI token
00460      00EC             TK_VPTR           = TK_TWOPI+1      ; VARPTR token
00461      00ED             TK_LEFTS          = TK_VPTR+1       ; LEFT$ token
00462      00EE             TK_RIGHTS         = TK_LEFTS+1      ; RIGHT$ token
00463      00EF             TK_MIDS           = TK_RIGHTS+1     ; MID$ token
00464      00F0             TK_I2C_OUT        = TK_MIDS+1       ; I2C_OUT token
00465      00F1             TK_I2C_IN         = TK_I2C_OUT+1    ; I2C_IN token
00466    
00467    ; offsets from a base of X or Y
00468    
00469      0000             PLUS_0            = $00       ; X or Y plus 0
00470      0001             PLUS_1            = $01       ; X or Y plus 1
00471      0002             PLUS_2            = $02       ; X or Y plus 2
00472      0003             PLUS_3            = $03       ; X or Y plus 3
00473    
00474      0100             LAB_STAK          = $0100     ; stack bottom, no offset
00475    
00476      01FE             LAB_SKFE          = LAB_STAK+$FE
00477                                  ; flushed stack address
00478      01FF             LAB_SKFF          = LAB_STAK+$FF
00479                                  ; flushed stack address
00480    
00481    ; the following locations are bulk initialized from PG2_TABS at LAB_COLD
00482      0200             ccflag            = $0200     ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
00483      0201             ccbyte            = ccflag+1  ; BASIC CTRL-C byte
00484      0202             ccnull            = ccbyte+1  ; BASIC CTRL-C byte timeout
00485    
00486      0203             VEC_CC            = ccnull+1  ; ctrl c check vector
00487    ; end bulk initialize from PG2_TABS at LAB_COLD
00488    
00489    ; the following locations are bulk initialized by min_mon.asm from LAB_vec at LAB_stlp
00490      0205             VEC_IN            = VEC_CC+2		; input vector
00491      0207             VEC_OUT           = VEC_IN+2		; output vector
00492      0209             VEC_LD            = VEC_OUT+2		; load vector
00493      020B             VEC_SV            = VEC_LD+2		; save vector
00494      020D             VEC_VERIFY        = VEC_SV+2		; verify vector
00495      020F             VEC_CAT           = VEC_VERIFY+2	; cat vector
00496    ; end bulk initialize by min_mon.asm from LAB_vec at LAB_stlp
00497    
00498    ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
00499    ; the input buffer must not cross a page boundary and must not overlap with
00500    ; program RAM pages!
00501    
00502    ; FINDME_LOWRAM
00503    
00504    ; $5D0-$5DF for I2C
00505    ; $5E0-$5EF for ToE_Mon
00506    ; $5F2-$7FF for TPB bus card
00507    ; $800-$8FF unallocated
00508    ; $900-$AFF Allocated to the cassette file system.  This is probably generous.
00509    ; $A00-$A1F reserved for the AY card
00510    ; $A20-$A49 Countdown timer IRQ memory
00511    ; $A4A-$AFF unallocated
00512    
00513    ;Ibuffs            = IRQ_vec+$14
00514      0B00             Ibuffs            = $B00       ; TODO: Create a method of allocation controlled from an
00515                                   ; external file
00516                                   ; start of input buffer after IRQ/NMI code
00517      0B7F             Ibuffe            = Ibuffs+$7F ; end of input buffer
00518    
00519      0C00             Ram_base          = $0C00      ; start of user RAM (set as needed, should be page aligned)
00520      C000             Ram_top           = $C000      ; end of user RAM+1 (set as needed, should be page aligned)
00521    
00522      0010             Stack_floor       = 16         ; bytes left free on stack for background interrupts
00523    
00524    ; This start can be changed to suit your system
00525    
00526    C100                     *=    $C100
00527    
00528    ; BASIC cold start entry point
00529    
00530    ; new page 2 initialisation, copy block to ccflag on
00531    
00532    LAB_COLD
00533    C100  A0 04              LDY   #PG2_TABE-PG2_TABS-1
00534                                  ; byte count-1
00535    LAB_2D13
00536    C102  B9 11 E2           LDA   PG2_TABS,Y        ; get byte
00537    C105  99 00 02           STA   ccflag,Y          ; store in page 2
00538    C108  88                 DEY                     ; decrement count
00539    C109  10 F7              BPL   LAB_2D13          ; loop if not done
00540    
00541    C10B  A2 FF              LDX   #$FF              ; set byte
00542    C10D  86 88              STX   Clineh            ; set current line high byte (set immediate mode)
00543    C10F  9A                 TXS                     ; reset stack pointer
00544    
00545    C110  A9 4C              LDA   #$4C              ; code for JMP
00546    C112  85 A1              STA   Fnxjmp            ; save for jump vector for functions
00547    
00548    ; copy block from LAB_2CEE to $00BC - $00D7
00549    
00550    C114  A2 1C              LDX   #StrTab-LAB_2CEE  ; set byte count
00551    LAB_2D4E
00552    C116  BD 15 E2           LDA   LAB_2CEE-1,X      ; get byte from table
00553    C119  95 BB              STA   LAB_IGBY-1,X      ; save byte in page zero
00554    C11B  CA                 DEX                     ; decrement count
00555    C11C  D0 F8              BNE   LAB_2D4E          ; loop if not all done
00556    
00557    ; copy block from StrTab to $0000 - $0012
00558    
00559    LAB_GMEM
00560    C11E  A2 12              LDX   #EndTab-StrTab-1  ; set byte count-1
00561    TabLoop
00562    C120  BD 32 E2           LDA   StrTab,X          ; get byte from table
00563    C123  95 00              STA   PLUS_0,X          ; save byte in page zero
00564    C125  CA                 DEX                     ; decrement count
00565    C126  10 F8              BPL   TabLoop           ; loop if not all done
00566    
00567    ; set-up start values
00568    
00569    C128  A9 00              LDA   #$00              ; clear A
00570    C12A  85 DC              STA   NmiBase           ; clear NMI handler enabled flag
00571    C12C  85 DF              STA   IrqBase           ; clear IRQ handler enabled flag
00572    C12E  85 B2              STA   FAC1_o            ; clear FAC1 overflow byte
00573    C130  85 67              STA   last_sh           ; clear descriptor stack top item pointer high byte
00574    
00575    C132  A9 0E              LDA   #$0E              ; set default tab size
00576    C134  85 64              STA   TabSiz            ; save it
00577    C136  A9 03              LDA   #$03              ; set garbage collect step size for descriptor stack
00578    C138  85 A0              STA   g_step            ; save it
00579    C13A  A2 68              LDX   #des_sk           ; descriptor stack start
00580    C13C  86 65              STX   next_s            ; set descriptor stack pointer
00581    C13E  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
00582    C141  A9 45              LDA   #<LAB_MSZM        ; point to memory size message (low addr)
00583    C143  A0 E2              LDY   #>LAB_MSZM        ; point to memory size message (high addr)
00584    C145  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00585    C148  20 43 C3           JSR   LAB_INLN          ; print "? " and get BASIC input
00586    C14B  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00587    C14D  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00588    C14F  20 C2 00           JSR   LAB_GBYT          ; get last byte back
00589    
00590    C152  D0 1F              BNE   LAB_2DAA          ; branch if not null (user typed something)
00591    
00592    C154  A0 00              LDY   #$00              ; else clear Y
00593                                  ; character was null so get memory size the hard way
00594                                  ; we get here with Y=0 and Itempl/h = Ram_base
00595    LAB_2D93
00596    C156  E6 11              INC   Itempl            ; increment temporary integer low byte
00597    C158  D0 08              BNE   LAB_2D99          ; branch if no overflow
00598    
00599    C15A  E6 12              INC   Itemph            ; increment temporary integer high byte
00600    C15C  A5 12              LDA   Itemph            ; get high byte
00601    C15E  C9 C0              CMP   #>Ram_top         ; compare with top of RAM+1
00602    C160  F0 1D              BEQ   LAB_2DB6          ; branch if match (end of user RAM)
00603    
00604    LAB_2D99
00605    C162  A9 55              LDA   #$55              ; set test byte
00606    C164  91 11              STA   (Itempl),Y        ; save via temporary integer
00607    C166  D1 11              CMP   (Itempl),Y        ; compare via temporary integer
00608    C168  D0 15              BNE   LAB_2DB6          ; branch if fail
00609    
00610    C16A  0A                 ASL                     ; shift test byte left (now $AA)
00611    C16B  91 11              STA   (Itempl),Y        ; save via temporary integer
00612    C16D  D1 11              CMP   (Itempl),Y        ; compare via temporary integer
00613    C16F  F0 E5              BEQ   LAB_2D93          ; if ok go do next byte
00614    
00615    C171  D0 0C              BNE   LAB_2DB6          ; branch if fail
00616    
00617    LAB_2DAA
00618    C173  20 B9 DA           JSR   LAB_2887          ; get FAC1 from string
00619    C176  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00620    C178  C9 98              CMP   #$98              ; compare with exponent = 2^24
00621    C17A  B0 A2              BCS   LAB_GMEM          ; if too large go try again
00622    
00623    C17C  20 0A D6           JSR   LAB_F2FU          ; save integer part of FAC1 in temporary integer
00624                                  ; (no range check)
00625    
00626    LAB_2DB6
00627    C17F  A5 11              LDA   Itempl            ; get temporary integer low byte
00628    C181  A4 12              LDY   Itemph            ; get temporary integer high byte
00629    ; *** begin patch  2.22p5.0 RAM top sanity check ***
00630    ; *** replace
00631    ;      CPY   #<Ram_base+1      ; compare with start of RAM+$100 high byte
00632    ; +++ with
00633    C183  C0 0D              CPY   #>Ram_base+1      ; compare with start of RAM+$100 high byte
00634    ; *** end patch    2.22p5.0 ***
00635    C185  90 97              BCC   LAB_GMEM          ; if too small go try again
00636    
00637    
00638    ; uncomment these lines if you want to check on the high limit of memory. Note if
00639    ; Ram_top is set too low then this will fail. default is ignore it and assume the
00640    ; users know what they're doing!
00641    
00642    ;     CPY   #>Ram_top         ; compare with top of RAM high byte
00643    ;     BCC   MEM_OK            ; branch if < RAM top
00644    
00645    ;     BNE   LAB_GMEM          ; if too large go try again
00646                                  ; else was = so compare low bytes
00647    ;     CMP   #<Ram_top         ; compare with top of RAM low byte
00648    ;     BEQ   MEM_OK            ; branch if = RAM top
00649    
00650    ;     BCS   LAB_GMEM          ; if too large go try again
00651    
00652    ;MEM_OK
00653    C187  85 85              STA   Ememl             ; set end of mem low byte
00654    C189  84 86              STY   Ememh             ; set end of mem high byte
00655    C18B  85 81              STA   Sstorl            ; set bottom of string space low byte
00656    C18D  84 82              STY   Sstorh            ; set bottom of string space high byte
00657    
00658    C18F  A0 00              LDY   #<Ram_base        ; set start addr low byte
00659    C191  A2 0C              LDX   #>Ram_base        ; set start addr high byte
00660    C193  84 79              STY   Smeml             ; save start of mem low byte
00661    C195  86 7A              STX   Smemh             ; save start of mem high byte
00662    
00663    ; this line is only needed if Ram_base is not $xx00
00664          .IF   Ram_base&$FF>0
00665    
00666    C197  98                 TYA                     ; clear A
00667    C198  91 79              STA   (Smeml),Y         ; clear first byte
00668    C19A  E6 79              INC   Smeml             ; increment start of mem low byte
00669    
00670    ; these two lines are only needed if Ram_base is $xxFF
00671          .IF   Ram_base&$FF==$FF
00672    
00673    C19C  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
00674    C19F  20 59 C4           JSR   LAB_1463          ; do "NEW" and "CLEAR"
00675    C1A2  A5 85              LDA   Ememl             ; get end of mem low byte
00676    C1A4  38                 SEC                     ; set carry for subtract
00677    C1A5  E5 79              SBC   Smeml             ; subtract start of mem low byte
00678    C1A7  AA                 TAX                     ; copy to X
00679    C1A8  A5 86              LDA   Ememh             ; get end of mem high byte
00680    C1AA  E5 7A              SBC   Smemh             ; subtract start of mem high byte
00681    C1AC  20 95 DB           JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
00682    C1AF  A9 54              LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
00683    C1B1  A0 E2              LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
00684    C1B3  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00685    C1B6  A9 5D              LDA   #<LAB_1274        ; warm start vector low byte
00686    C1B8  A0 C2              LDY   #>LAB_1274        ; warm start vector high byte
00687    C1BA  85 01              STA   Wrmjpl            ; save warm start vector low byte
00688    C1BC  84 02              STY   Wrmjph            ; save warm start vector high byte
00689    C1BE  6C 01 00           JMP   (Wrmjpl)          ; go do warm start
00690    
00691    ; open up space in memory
00692    ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00693    
00694    ; Nbendl,Nbendh - new block end address (A/Y)
00695    ; Obendl,Obendh - old block end address
00696    ; Ostrtl,Ostrth - old block start address
00697    
00698    ; returns with ..
00699    
00700    ; Nbendl,Nbendh - new block start address (high byte - $100)
00701    ; Obendl,Obendh - old block start address (high byte - $100)
00702    ; Ostrtl,Ostrth - old block start address (unchanged)
00703    
00704    LAB_11CF
00705    C1C1  20 0E C2           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
00706                                  ; addr to check is in AY (low/high)
00707    C1C4  85 7F              STA   Earryl            ; save new array mem end low byte
00708    C1C6  84 80              STY   Earryh            ; save new array mem end high byte
00709    
00710    ; open up space in memory
00711    ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00712    ; don't set array end
00713    
00714    LAB_11D6
00715    C1C8  38                 SEC                     ; set carry for subtract
00716    C1C9  A5 A6              LDA   Obendl            ; get block end low byte
00717    C1CB  E5 AA              SBC   Ostrtl            ; subtract block start low byte
00718    C1CD  A8                 TAY                     ; copy MOD(block length/$100) byte to Y
00719    C1CE  A5 A7              LDA   Obendh            ; get block end high byte
00720    C1D0  E5 AB              SBC   Ostrth            ; subtract block start high byte
00721    C1D2  AA                 TAX                     ; copy block length high byte to X
00722    C1D3  E8                 INX                     ; +1 to allow for count=0 exit
00723    C1D4  98                 TYA                     ; copy block length low byte to A
00724    C1D5  F0 24              BEQ   LAB_120A          ; branch if length low byte=0
00725    
00726                                  ; block is (X-1)*256+Y bytes, do the Y bytes first
00727    
00728    C1D7  38                 SEC                     ; set carry for add + 1, two's complement
00729    C1D8  49 FF              EOR   #$FF              ; invert low byte for subtract
00730    C1DA  65 A6              ADC   Obendl            ; add block end low byte
00731    
00732    C1DC  85 A6              STA   Obendl            ; save corrected old block end low byte
00733    C1DE  B0 03              BCS   LAB_11F3          ; branch if no underflow
00734    
00735    C1E0  C6 A7              DEC   Obendh            ; else decrement block end high byte
00736    C1E2  38                 SEC                     ; set carry for add + 1, two's complement
00737    LAB_11F3
00738    C1E3  98                 TYA                     ; get MOD(block length/$100) byte
00739    C1E4  49 FF              EOR   #$FF              ; invert low byte for subtract
00740    C1E6  65 A4              ADC   Nbendl            ; add destination end low byte
00741    C1E8  85 A4              STA   Nbendl            ; save modified new block end low byte
00742    C1EA  B0 08              BCS   LAB_1203          ; branch if no underflow
00743    
00744    C1EC  C6 A5              DEC   Nbendh            ; else decrement block end high byte
00745    C1EE  90 04              BCC   LAB_1203          ; branch always
00746    
00747    LAB_11FF
00748    C1F0  B1 A6              LDA   (Obendl),Y        ; get byte from source
00749    C1F2  91 A4              STA   (Nbendl),Y        ; copy byte to destination
00750    LAB_1203
00751    C1F4  88                 DEY                     ; decrement index
00752    C1F5  D0 F9              BNE   LAB_11FF          ; loop until Y=0
00753    
00754                                  ; now do Y=0 indexed byte
00755    C1F7  B1 A6              LDA   (Obendl),Y        ; get byte from source
00756    C1F9  91 A4              STA   (Nbendl),Y        ; save byte to destination
00757    LAB_120A
00758    C1FB  C6 A7              DEC   Obendh            ; decrement source pointer high byte
00759    C1FD  C6 A5              DEC   Nbendh            ; decrement destination pointer high byte
00760    C1FF  CA                 DEX                     ; decrement block count
00761    C200  D0 F2              BNE   LAB_1203          ; loop until count = $0
00762    
00763    C202  60                 RTS
00764    
00765    ; check room on stack for A bytes
00766    ; stack too deep? do OM error
00767    
00768    LAB_1212
00769    ; *** patch - additional stack floor protection for background interrupts
00770    ; *** add
00771          .IF   Stack_floor
00772    C203  18                 CLC                     ; prep ADC
00773    C204  69 10              ADC   #Stack_floor      ; stack pointer lower limit before interrupts
00774          .ENDIF
00775    ; *** end patch
00776    C206  85 78              STA   TempB             ; save result in temp byte
00777    C208  BA                 TSX                     ; copy stack
00778    C209  E4 78              CPX   TempB             ; compare new "limit" with stack
00779    C20B  90 30              BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
00780    
00781    C20D  60                 RTS
00782    
00783    ; check available memory, "Out of memory" error if no room
00784    ; addr to check is in AY (low/high)
00785    
00786    LAB_121F
00787    C20E  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
00788    C210  90 2A              BCC   LAB_124B          ; if less then exit (is ok)
00789    
00790    C212  D0 04              BNE   LAB_1229          ; skip next test if greater (tested <)
00791    
00792                                  ; high byte was =, now do low byte
00793    C214  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
00794    C216  90 24              BCC   LAB_124B          ; if less then exit (is ok)
00795    
00796                                  ; addr is > string storage ptr (oops!)
00797    LAB_1229
00798    C218  48                 PHA                     ; push addr low byte
00799    C219  A2 08              LDX   #$08              ; set index to save Adatal to expneg inclusive
00800    C21B  98                 TYA                     ; copy addr high byte (to push on stack)
00801    
00802                                  ; save misc numeric work area
00803    LAB_122D
00804    C21C  48                 PHA                     ; push byte
00805    C21D  B5 A3              LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
00806    C21F  CA                 DEX                     ; decrement index
00807    C220  10 FA              BPL   LAB_122D          ; loop until all done
00808    
00809    C222  20 F5 D2           JSR   LAB_GARB          ; garbage collection routine
00810    
00811                                  ; restore misc numeric work area
00812    C225  A2 00              LDX   #$00              ; clear the index to restore bytes
00813    LAB_1238
00814    C227  68                 PLA                     ; pop byte
00815    C228  95 A4              STA   Adatal,X          ; save byte to Adatal to expneg
00816    C22A  E8                 INX                     ; increment index
00817    C22B  E0 08              CPX   #$08              ; compare with end + 1
00818    C22D  30 F8              BMI   LAB_1238          ; loop if more to do
00819    
00820    C22F  68                 PLA                     ; pop addr high byte
00821    C230  A8                 TAY                     ; copy back to Y
00822    C231  68                 PLA                     ; pop addr low byte
00823    C232  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
00824    C234  90 06              BCC   LAB_124B          ; if less then exit (is ok)
00825    
00826    C236  D0 05              BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
00827    
00828                                  ; high byte was =, now do low byte
00829    C238  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
00830    C23A  B0 01              BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
00831    
00832                                  ; ok exit, carry clear
00833    LAB_124B
00834    C23C  60                 RTS
00835    
00836    ; do "Out of memory" error then warm start
00837    
00838    LAB_OMER
00839    C23D  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
00840    
00841    ; do error #X, then warm start
00842    
00843    LAB_XERR
00844    C23F  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
00845    
00846    C242  BD 61 E8           LDA   LAB_BAER,X        ; get error message pointer low byte
00847    C245  BC 62 E8           LDY   LAB_BAER+1,X      ; get error message pointer high byte
00848    C248  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00849    
00850    C24B  20 92 C4           JSR   LAB_1491          ; flush stack and clear continue flag
00851    C24E  A9 B2              LDA   #<LAB_EMSG        ; point to " Error" low addr
00852    C250  A0 E9              LDY   #>LAB_EMSG        ; point to " Error" high addr
00853    LAB_1269
00854    C252  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00855    C255  A4 88              LDY   Clineh            ; get current line high byte
00856    C257  C8                 INY                     ; increment it
00857    C258  F0 03              BEQ   LAB_1274          ; go do warm start (was immediate mode)
00858    
00859                                  ; else print line number
00860    C25A  20 8A DB           JSR   LAB_2953          ; print " in line [LINE #]"
00861    
00862    ; BASIC warm start entry point
00863    ; wait for Basic command
00864    
00865    LAB_1274
00866                                  ; clear ON IRQ/NMI bytes
00867    C25D  A9 00              LDA   #$00              ; clear A
00868    C25F  85 DF              STA   IrqBase           ; clear enabled byte
00869    C261  85 DC              STA   NmiBase           ; clear enabled byte
00870    C263  A9 C3              LDA   #<LAB_RMSG        ; point to "Ready" message low byte
00871    C265  A0 E9              LDY   #>LAB_RMSG        ; point to "Ready" message high byte
00872    
00873    C267  20 DA C9           JSR   LAB_18C3          ; go do print string
00874    
00875    ; wait for Basic command (no "Ready")
00876    
00877    LAB_127D
00878    C26A  20 50 C3           JSR   LAB_1357          ; call for BASIC input
00879    LAB_1280
00880    C26D  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00881    C26F  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00882    C271  20 C2 00           JSR   LAB_GBYT          ; scan memory
00883    C274  F0 F4              BEQ   LAB_127D          ; loop while null
00884    
00885    ; got to interpret input line now ..
00886    
00887    C276  A2 FF              LDX   #$FF              ; current line to null value
00888    C278  86 88              STX   Clineh            ; set current line high byte
00889    C27A  90 06              BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
00890    
00891                                  ; no line number .. immediate mode
00892    C27C  20 81 C3           JSR   LAB_13A6          ; crunch keywords into Basic tokens
00893    C27F  4C FB C5           JMP   LAB_15F6          ; go scan and interpret code
00894    
00895    ; handle new BASIC line
00896    
00897    LAB_1295
00898    C282  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00899    C285  20 81 C3           JSR   LAB_13A6          ; crunch keywords into Basic tokens
00900    C288  84 5D              STY   Ibptr             ; save index pointer to end of crunched line
00901    C28A  20 2D C4           JSR   LAB_SSLN          ; search BASIC for temp integer line number
00902    C28D  90 44              BCC   LAB_12E6          ; branch if not found
00903    
00904                                  ; aroooogah! line # already exists! delete it
00905    C28F  A0 01              LDY   #$01              ; set index to next line pointer high byte
00906    C291  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
00907    C293  85 72              STA   ut1_ph            ; save it
00908    C295  A5 7B              LDA   Svarl             ; get start of vars low byte
00909    C297  85 71              STA   ut1_pl            ; save it
00910    C299  A5 AB              LDA   Baslnh            ; get found line pointer high byte
00911    C29B  85 74              STA   ut2_ph            ; save it
00912    C29D  A5 AA              LDA   Baslnl            ; get found line pointer low byte
00913    C29F  88                 DEY                     ; decrement index
00914    C2A0  F1 AA              SBC   (Baslnl),Y        ; subtract next line pointer low byte
00915    C2A2  18                 CLC                     ; clear carry for add
00916    C2A3  65 7B              ADC   Svarl             ; add start of vars low byte
00917    C2A5  85 7B              STA   Svarl             ; save new start of vars low byte
00918    C2A7  85 73              STA   ut2_pl            ; save destination pointer low byte
00919    C2A9  A5 7C              LDA   Svarh             ; get start of vars high byte
00920    C2AB  69 FF              ADC   #$FF              ; -1 + carry
00921    C2AD  85 7C              STA   Svarh             ; save start of vars high byte
00922    C2AF  E5 AB              SBC   Baslnh            ; subtract found line pointer high byte
00923    C2B1  AA                 TAX                     ; copy to block count
00924    C2B2  38                 SEC                     ; set carry for subtract
00925    C2B3  A5 AA              LDA   Baslnl            ; get found line pointer low byte
00926    C2B5  E5 7B              SBC   Svarl             ; subtract start of vars low byte
00927    C2B7  A8                 TAY                     ; copy to bytes in first block count
00928    C2B8  B0 03              BCS   LAB_12D0          ; branch if overflow
00929    
00930    C2BA  E8                 INX                     ; increment block count (correct for =0 loop exit)
00931    C2BB  C6 74              DEC   ut2_ph            ; decrement destination high byte
00932    LAB_12D0
00933    C2BD  18                 CLC                     ; clear carry for add
00934    C2BE  65 71              ADC   ut1_pl            ; add source pointer low byte
00935    C2C0  90 03              BCC   LAB_12D8          ; branch if no overflow
00936    
00937    C2C2  C6 72              DEC   ut1_ph            ; else decrement source pointer high byte
00938    C2C4  18                 CLC                     ; clear carry
00939    
00940                                  ; close up memory to delete old line
00941    LAB_12D8
00942    C2C5  B1 71              LDA   (ut1_pl),Y        ; get byte from source
00943    C2C7  91 73              STA   (ut2_pl),Y        ; copy to destination
00944    C2C9  C8                 INY                     ; increment index
00945    C2CA  D0 F9              BNE   LAB_12D8          ; while <> 0 do this block
00946    
00947    C2CC  E6 72              INC   ut1_ph            ; increment source pointer high byte
00948    C2CE  E6 74              INC   ut2_ph            ; increment destination pointer high byte
00949    C2D0  CA                 DEX                     ; decrement block count
00950    C2D1  D0 F2              BNE   LAB_12D8          ; loop until all done
00951    
00952                                  ; got new line in buffer and no existing same #
00953    LAB_12E6
00954    C2D3  AD 00 0B           LDA   Ibuffs            ; get byte from start of input buffer
00955    C2D6  F0 3F              BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
00956    
00957                                  ; got new line and it isn't empty line
00958    C2D8  A5 85              LDA   Ememl             ; get end of mem low byte
00959    C2DA  A4 86              LDY   Ememh             ; get end of mem high byte
00960    C2DC  85 81              STA   Sstorl            ; set bottom of string space low byte
00961    C2DE  84 82              STY   Sstorh            ; set bottom of string space high byte
00962    C2E0  A5 7B              LDA   Svarl             ; get start of vars low byte  (end of BASIC)
00963    C2E2  85 A6              STA   Obendl            ; save old block end low byte
00964    C2E4  A4 7C              LDY   Svarh             ; get start of vars high byte (end of BASIC)
00965    C2E6  84 A7              STY   Obendh            ; save old block end high byte
00966    C2E8  65 5D              ADC   Ibptr             ; add input buffer pointer    (also buffer length)
00967    C2EA  90 01              BCC   LAB_1301          ; branch if no overflow from add
00968    
00969    C2EC  C8                 INY                     ; else increment high byte
00970    LAB_1301
00971    C2ED  85 A4              STA   Nbendl            ; save new block end low byte (move to, low byte)
00972    C2EF  84 A5              STY   Nbendh            ; save new block end high byte
00973    C2F1  20 C1 C1           JSR   LAB_11CF          ; open up space in memory
00974                                  ; old start pointer Ostrtl,Ostrth set by the find line call
00975    C2F4  A5 7F              LDA   Earryl            ; get array mem end low byte
00976    C2F6  A4 80              LDY   Earryh            ; get array mem end high byte
00977    C2F8  85 7B              STA   Svarl             ; save start of vars low byte
00978    C2FA  84 7C              STY   Svarh             ; save start of vars high byte
00979    C2FC  A4 5D              LDY   Ibptr             ; get input buffer pointer    (also buffer length)
00980    C2FE  88                 DEY                     ; adjust for loop type
00981    LAB_1311
00982    C2FF  B9 FC 0A           LDA   Ibuffs-4,Y        ; get byte from crunched line
00983    C302  91 AA              STA   (Baslnl),Y        ; save it to program memory
00984    C304  88                 DEY                     ; decrement count
00985    C305  C0 03              CPY   #$03              ; compare with first byte-1
00986    C307  D0 F6              BNE   LAB_1311          ; continue while count <> 3
00987    
00988    C309  A5 12              LDA   Itemph            ; get line # high byte
00989    C30B  91 AA              STA   (Baslnl),Y        ; save it to program memory
00990    C30D  88                 DEY                     ; decrement count
00991    C30E  A5 11              LDA   Itempl            ; get line # low byte
00992    C310  91 AA              STA   (Baslnl),Y        ; save it to program memory
00993    C312  88                 DEY                     ; decrement count
00994    C313  A9 FF              LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
00995                                  ; byte then a zero already here would stop the chain rebuild
00996                                  ; as it would think it was the [EOT] marker.
00997    C315  91 AA              STA   (Baslnl),Y        ; save it to program memory
00998    
00999    LAB_1319
01000    C317  20 6E C4           JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
01001    C31A  A6 79              LDX   Smeml             ; get start of mem low byte
01002    C31C  A5 7A              LDA   Smemh             ; get start of mem high byte
01003    C31E  A0 01              LDY   #$01              ; index to high byte of next line pointer
01004    LAB_1325
01005    C320  86 71              STX   ut1_pl            ; set line start pointer low byte
01006    C322  85 72              STA   ut1_ph            ; set line start pointer high byte
01007    C324  B1 71              LDA   (ut1_pl),Y        ; get it
01008    C326  F0 18              BEQ   LAB_133E          ; exit if end of program
01009    
01010    ; rebuild chaining of Basic lines
01011    
01012    C328  A0 04              LDY   #$04              ; point to first code byte of line
01013                                  ; there is always 1 byte + [EOL] as null entries are deleted
01014    LAB_1330
01015    C32A  C8                 INY                     ; next code byte
01016    C32B  B1 71              LDA   (ut1_pl),Y        ; get byte
01017    C32D  D0 FB              BNE   LAB_1330          ; loop if not [EOL]
01018    
01019    C32F  38                 SEC                     ; set carry for add + 1
01020    C330  98                 TYA                     ; copy end index
01021    C331  65 71              ADC   ut1_pl            ; add to line start pointer low byte
01022    C333  AA                 TAX                     ; copy to X
01023    C334  A0 00              LDY   #$00              ; clear index, point to this line's next line pointer
01024    C336  91 71              STA   (ut1_pl),Y        ; set next line pointer low byte
01025    C338  98                 TYA                     ; clear A
01026    C339  65 72              ADC   ut1_ph            ; add line start pointer high byte + carry
01027    C33B  C8                 INY                     ; increment index to high byte
01028    C33C  91 71              STA   (ut1_pl),Y        ; save next line pointer low byte
01029    C33E  90 E0              BCC   LAB_1325          ; go do next line, branch always, carry clear
01030    
01031    
01032    LAB_133E
01033    C340  4C 6A C2           JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
01034    
01035    ; print "? " and get BASIC input
01036    
01037    LAB_INLN
01038    C343  20 F2 C9           JSR   LAB_18E3          ; print "?" character
01039    C346  20 EF C9           JSR   LAB_18E0          ; print " "
01040    C349  D0 05              BNE   LAB_1357          ; call for BASIC input and return
01041    
01042    ; receive line from keyboard
01043    
01044                                  ; $08 as delete key (BACKSPACE on standard keyboard)
01045    LAB_134B
01046    C34B  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01047    C34E  CA                 DEX                     ; decrement the buffer counter (delete)
01048          .byte $2C               ; make LDX into BIT abs
01049    
01050    ; call for BASIC input (main entry point)
01051    
01052    LAB_1357
01053    C350  A2 00              LDX   #$00              ; clear BASIC line buffer pointer
01054    LAB_1359
01055    C352  20 FF E1           JSR   V_INPT            ; call scan input device
01056    C355  90 FB              BCC   LAB_1359          ; loop if no byte
01057    
01058    C357  F0 F9              BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
01059    
01060    C359  C9 07              CMP   #$07              ; compare with [BELL]
01061    C35B  F0 10              BEQ   LAB_1378          ; branch if [BELL]
01062    
01063    C35D  C9 0D              CMP   #$0D              ; compare with [CR]
01064    C35F  F0 19              BEQ   LAB_1384          ; do CR/LF exit if [CR]
01065    
01066    C361  E0 00              CPX   #$00              ; compare pointer with $00
01067    C363  D0 04              BNE   LAB_1374          ; branch if not empty
01068    
01069    ; next two lines ignore any non print character and [SPACE] if input buffer empty
01070    ; FINDME_INPUTMOD
01071    
01072    C365  C9 21              CMP   #$21              ; compare with [SP]+1
01073    C367  90 E9              BCC   LAB_1359          ; if < ignore character
01074    
01075    LAB_1374
01076    C369  C9 08              CMP   #$08              ; compare with [BACKSPACE] (delete last character)
01077    C36B  F0 DE              BEQ   LAB_134B          ; go delete last character
01078    
01079    LAB_1378
01080    C36D  E0 7F              CPX   #Ibuffe-Ibuffs    ; compare character count with max
01081    C36F  B0 0C              BCS   LAB_138E          ; skip store and do [BELL] if buffer full
01082    
01083    C371  9D 00 0B           STA   Ibuffs,X          ; else store in buffer
01084    C374  E8                 INX                     ; increment pointer
01085    LAB_137F
01086    C375  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01087    C378  D0 D8              BNE   LAB_1359          ; always loop for next character
01088    
01089    LAB_1384
01090    C37A  4C 90 C9           JMP   LAB_1866          ; do CR/LF exit to BASIC
01091    
01092    ; announce buffer full
01093    
01094    LAB_138E
01095    C37D  A9 07              LDA   #$07              ; [BELL] character into A
01096    C37F  D0 F4              BNE   LAB_137F          ; go print the [BELL] but ignore input character
01097                                  ; branch always
01098    
01099    ; crunch keywords into Basic tokens
01100    ; position independent buffer version ..
01101    ; faster, dictionary search version ....
01102    
01103    LAB_13A6
01104    C381  A0 FF              LDY   #$FF              ; set save index (makes for easy math later)
01105    
01106    C383  38                 SEC                     ; set carry for subtract
01107    C384  A5 C3              LDA   Bpntrl            ; get basic execute pointer low byte
01108    C386  E9 00              SBC   #<Ibuffs          ; subtract input buffer start pointer
01109    C388  AA                 TAX                     ; copy result to X (index past line # if any)
01110    
01111    C389  86 60              STX   Oquote            ; clear open quote/DATA flag
01112    LAB_13AC
01113    C38B  BD 00 0B           LDA   Ibuffs,X          ; get byte from input buffer
01114    C38E  F0 51              BEQ   LAB_13EC          ; if null save byte then exit
01115    
01116    C390  C9 5F              CMP   #'_'              ; compare with "_"
01117    C392  B0 4D              BCS   LAB_13EC          ; if >= go save byte then continue crunching
01118    
01119    C394  C9 3C              CMP   #'<'              ; compare with "<"
01120    C396  B0 0E              BCS   LAB_13CC          ; if >= go crunch now
01121    
01122    C398  C9 30              CMP   #'0'              ; compare with "0"
01123    C39A  B0 45              BCS   LAB_13EC          ; if >= go save byte then continue crunching
01124    
01125    C39C  85 5C              STA   Scnquo            ; save buffer byte as search character
01126    C39E  C9 22              CMP   #$22              ; is it quote character?
01127    C3A0  F0 61              BEQ   LAB_1410          ; branch if so (copy quoted string)
01128    
01129    C3A2  C9 2A              CMP   #'*'              ; compare with "*"
01130    C3A4  90 3B              BCC   LAB_13EC          ; if < go save byte then continue crunching
01131    
01132                                  ; else crunch now
01133    LAB_13CC
01134    C3A6  24 60              BIT   Oquote            ; get open quote/DATA token flag
01135    C3A8  70 37              BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
01136                                  ; go save byte then continue crunching
01137    
01138    C3AA  86 78              STX   TempB             ; save buffer read index
01139    C3AC  84 BA              STY   csidx             ; copy buffer save index
01140    C3AE  A0 4D              LDY   #<TAB_1STC        ; get keyword first character table low address
01141    C3B0  84 73              STY   ut2_pl            ; save pointer low byte
01142    C3B2  A0 E4              LDY   #>TAB_1STC        ; get keyword first character table high address
01143    C3B4  84 74              STY   ut2_ph            ; save pointer high byte
01144    C3B6  A0 00              LDY   #$00              ; clear table pointer
01145    
01146    LAB_13D0
01147    C3B8  D1 73              CMP   (ut2_pl),Y        ; compare with keyword first character table byte
01148    C3BA  F0 05              BEQ   LAB_13D1          ; go do word_table_chr if match
01149    
01150    C3BC  90 21              BCC   LAB_13EA          ; if < keyword first character table byte go restore
01151                                  ; Y and save to crunched
01152    
01153    C3BE  C8                 INY                     ; else increment pointer
01154    C3BF  D0 F7              BNE   LAB_13D0          ; and loop (branch always)
01155    
01156    ; have matched first character of some keyword
01157    
01158    LAB_13D1
01159    C3C1  98                 TYA                     ; copy matching index
01160    C3C2  0A                 ASL                     ; *2 (bytes per pointer)
01161    C3C3  AA                 TAX                     ; copy to new index
01162    C3C4  BD 6B E4           LDA   TAB_CHRT,X        ; get keyword table pointer low byte
01163    C3C7  85 73              STA   ut2_pl            ; save pointer low byte
01164    C3C9  BD 6C E4           LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
01165    C3CC  85 74              STA   ut2_ph            ; save pointer high byte
01166    
01167    C3CE  A0 FF              LDY   #$FF              ; clear table pointer (make -1 for start)
01168    
01169    C3D0  A6 78              LDX   TempB             ; restore buffer read index
01170    
01171    LAB_13D6
01172    C3D2  C8                 INY                     ; next table byte
01173    C3D3  B1 73              LDA   (ut2_pl),Y        ; get byte from table
01174    LAB_13D8
01175    C3D5  30 08              BMI   LAB_13EA          ; all bytes matched so go save token
01176    
01177    C3D7  E8                 INX                     ; next buffer byte
01178    C3D8  DD 00 0B           CMP   Ibuffs,X          ; compare with byte from input buffer
01179    C3DB  F0 F5              BEQ   LAB_13D6          ; go compare next if match
01180    
01181    C3DD  D0 2B              BNE   LAB_1417          ; branch if >< (not found keyword)
01182    
01183    LAB_13EA
01184    C3DF  A4 BA              LDY   csidx             ; restore save index
01185    
01186                                  ; save crunched to output
01187    LAB_13EC
01188    C3E1  E8                 INX                     ; increment buffer index (to next input byte)
01189    C3E2  C8                 INY                     ; increment save index (to next output byte)
01190    C3E3  99 00 0B           STA   Ibuffs,Y          ; save byte to output
01191    C3E6  C9 00              CMP   #$00              ; set the flags, set carry
01192    C3E8  F0 32              BEQ   LAB_142A          ; do exit if was null [EOL]
01193    
01194                                  ; A holds token or byte here
01195    C3EA  E9 3A              SBC   #':'              ; subtract ":" (carry set by CMP #00)
01196    C3EC  F0 04              BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
01197    
01198                                  ; A now holds token-$3A
01199    C3EE  C9 49              CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
01200    C3F0  D0 02              BNE   LAB_1401          ; branch if not DATA
01201    
01202                                  ; token was : or DATA
01203    LAB_13FF
01204    C3F2  85 60              STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
01205    LAB_1401
01206    C3F4  49 57              EOR   #TK_REM-$3A       ; effectively subtract REM token offset
01207    C3F6  D0 93              BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
01208    
01209    C3F8  85 5C              STA   Asrch             ; else was REM so set search for [EOL]
01210    
01211                                  ; loop for REM, "..." etc.
01212    LAB_1408
01213    C3FA  BD 00 0B           LDA   Ibuffs,X          ; get byte from input buffer
01214    C3FD  F0 E2              BEQ   LAB_13EC          ; branch if null [EOL]
01215    
01216    C3FF  C5 5C              CMP   Asrch             ; compare with stored character
01217    C401  F0 DE              BEQ   LAB_13EC          ; branch if match (end quote)
01218    
01219                                  ; entry for copy string in quotes, don't crunch
01220    LAB_1410
01221    C403  C8                 INY                     ; increment buffer save index
01222    C404  99 00 0B           STA   Ibuffs,Y          ; save byte to output
01223    C407  E8                 INX                     ; increment buffer read index
01224    C408  D0 F0              BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
01225    
01226                                  ; not found keyword this go
01227    LAB_1417
01228    C40A  A6 78              LDX   TempB             ; compare has failed, restore buffer index (start byte!)
01229    
01230                                  ; now find the end of this word in the table
01231    LAB_141B
01232    C40C  B1 73              LDA   (ut2_pl),Y        ; get table byte
01233    C40E  08                 PHP                     ; save status
01234    C40F  C8                 INY                     ; increment table index
01235    C410  28                 PLP                     ; restore byte status
01236    C411  10 F9              BPL   LAB_141B          ; if not end of keyword go do next
01237    
01238    C413  B1 73              LDA   (ut2_pl),Y        ; get byte from keyword table
01239    C415  D0 BE              BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
01240    
01241                                  ; reached end of table with no match
01242    C417  BD 00 0B           LDA   Ibuffs,X          ; restore byte from input buffer
01243    C41A  10 C3              BPL   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
01244                                  ; go save byte in output and continue crunching
01245    
01246                                  ; reached [EOL]
01247    LAB_142A
01248    C41C  C8                 INY                     ; increment pointer
01249    C41D  C8                 INY                     ; increment pointer (makes it next line pointer high byte)
01250    C41E  99 00 0B           STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
01251    C421  C8                 INY                     ; adjust for line copy
01252    C422  C8                 INY                     ; adjust for line copy
01253    C423  C8                 INY                     ; adjust for line copy
01254    ; *** begin patch for when Ibuffs is $xx00 - Daryl Rictor ***
01255    ; *** insert
01256          .IF   Ibuffs&$FF==0
01257    C424  A5 C3              LDA   Bpntrl            ; test for $00
01258    C426  D0 02              BNE   LAB_142P          ; not $00
01259    C428  C6 C4              DEC   Bpntrh            ; allow for increment when $xx00
01260    LAB_142P
01261          .ENDIF
01262    ; *** end   patch for when Ibuffs is $xx00 - Daryl Rictor ***
01263    ; end of patch
01264    C42A  C6 C3              DEC   Bpntrl            ; allow for increment
01265    C42C  60                 RTS
01266    
01267    ; search Basic for temp integer line number from start of mem
01268    
01269    LAB_SSLN
01270    C42D  A5 79              LDA   Smeml             ; get start of mem low byte
01271    C42F  A6 7A              LDX   Smemh             ; get start of mem high byte
01272    
01273    ; search Basic for temp integer line number from AX
01274    ; returns carry set if found
01275    ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
01276    
01277    ; old 541 new 507
01278    
01279    LAB_SHLN
01280    C431  A0 01              LDY   #$01              ; set index
01281    C433  85 AA              STA   Baslnl            ; save low byte as current
01282    C435  86 AB              STX   Baslnh            ; save high byte as current
01283    C437  B1 AA              LDA   (Baslnl),Y        ; get pointer high byte from addr
01284    C439  F0 1A              BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
01285    
01286    C43B  A0 03              LDY   #$03              ; set index to line # high byte
01287    C43D  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
01288    C43F  88                 DEY                     ; decrement index (point to low byte)
01289    C440  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01290    C442  D0 04              BNE   LAB_1455          ; if <> skip low byte check
01291    
01292    C444  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
01293    C446  C5 11              CMP   Itempl            ; compare with temporary integer low byte
01294    LAB_1455
01295    C448  B0 09              BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
01296    
01297    LAB_1456
01298    C44A  88                 DEY                     ; decrement index to next line ptr high byte
01299    C44B  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
01300    C44D  AA                 TAX                     ; copy to X
01301    C44E  88                 DEY                     ; decrement index to next line ptr low byte
01302    C44F  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
01303    C451  90 DE              BCC   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
01304                                  ; (carry always clear)
01305    
01306    LAB_145E
01307    C453  F0 01              BEQ   LAB_1460          ; exit if temp = found line #, carry is set
01308    
01309    LAB_145F
01310    C455  18                 CLC                     ; clear found flag
01311    LAB_1460
01312    C456  60                 RTS
01313    
01314    ; perform NEW
01315    
01316    LAB_NEW
01317    C457  D0 FD              BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
01318    
01319    LAB_1463
01320    C459  A9 00              LDA   #$00              ; clear A
01321    C45B  A8                 TAY                     ; clear Y
01322    C45C  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, low byte
01323    C45E  C8                 INY                     ; increment index
01324    C45F  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, high byte
01325    C461  18                 CLC                     ; clear carry
01326    C462  A5 79              LDA   Smeml             ; get start of mem low byte
01327    C464  69 02              ADC   #$02              ; calculate end of BASIC low byte
01328    C466  85 7B              STA   Svarl             ; save start of vars low byte
01329    C468  A5 7A              LDA   Smemh             ; get start of mem high byte
01330    C46A  69 00              ADC   #$00              ; add any carry
01331    C46C  85 7C              STA   Svarh             ; save start of vars high byte
01332    
01333    ; reset execution to start, clear vars and flush stack
01334    
01335    LAB_1477
01336    C46E  18                 CLC                     ; clear carry
01337    C46F  A5 79              LDA   Smeml             ; get start of mem low byte
01338    C471  69 FF              ADC   #$FF              ; -1
01339    C473  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01340    C475  A5 7A              LDA   Smemh             ; get start of mem high byte
01341    C477  69 FF              ADC   #$FF              ; -1+carry
01342    C479  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
01343    
01344    ; "CLEAR" command gets here
01345    
01346    LAB_147A
01347    C47B  A5 85              LDA   Ememl             ; get end of mem low byte
01348    C47D  A4 86              LDY   Ememh             ; get end of mem high byte
01349    C47F  85 81              STA   Sstorl            ; set bottom of string space low byte
01350    C481  84 82              STY   Sstorh            ; set bottom of string space high byte
01351    C483  A5 7B              LDA   Svarl             ; get start of vars low byte
01352    C485  A4 7C              LDY   Svarh             ; get start of vars high byte
01353    C487  85 7D              STA   Sarryl            ; save var mem end low byte
01354    C489  84 7E              STY   Sarryh            ; save var mem end high byte
01355    C48B  85 7F              STA   Earryl            ; save array mem end low byte
01356    C48D  84 80              STY   Earryh            ; save array mem end high byte
01357    C48F  20 46 C6           JSR   LAB_161A          ; perform RESTORE command
01358    
01359    ; flush stack and clear continue flag
01360    
01361    LAB_1491
01362    C492  A2 68              LDX   #des_sk           ; set descriptor stack pointer
01363    C494  86 65              STX   next_s            ; save descriptor stack pointer
01364    C496  68                 PLA                     ; pull return address low byte
01365    C497  AA                 TAX                     ; copy return address low byte
01366    C498  68                 PLA                     ; pull return address high byte
01367    C499  8E FE 01           STX   LAB_SKFE          ; save to cleared stack
01368    C49C  8D FF 01           STA   LAB_SKFF          ; save to cleared stack
01369    C49F  A2 FD              LDX   #$FD              ; new stack pointer
01370    C4A1  9A                 TXS                     ; reset stack
01371    C4A2  A9 00              LDA   #$00              ; clear byte
01372    ;*** fix p2: no longer necessary as the continue pointer is saved anyway
01373    ;      STA   Cpntrh            ; clear continue pointer high byte
01374    C4A4  85 61              STA   Sufnxf            ; clear subscript/FNX flag
01375    LAB_14A6
01376    C4A6  60                 RTS
01377    
01378    ; perform CLEAR
01379    
01380    LAB_CLEAR
01381    C4A7  F0 D2              BEQ   LAB_147A          ; if no following token go do "CLEAR"
01382    
01383                                  ; else there was a following token (go do syntax error)
01384    C4A9  60                 RTS
01385    
01386    ; perform LIST [n][-m]
01387    ; bigger, faster version (a _lot_ faster)
01388    
01389    LAB_LIST
01390    C4AA  90 06              BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
01391    
01392    C4AC  F0 04              BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
01393    
01394    C4AE  C9 C1              CMP   #TK_MINUS         ; compare with token for -
01395    C4B0  D0 F4              BNE   LAB_14A6          ; exit if not - (LIST -m)
01396    
01397                                  ; LIST [[n][-m]]
01398                                  ; this bit sets the n , if present, as the start and end
01399    LAB_14BD
01400    C4B2  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01401    C4B5  20 2D C4           JSR   LAB_SSLN          ; search BASIC for temp integer line number
01402                                  ; (pointer in Baslnl/Baslnh)
01403    C4B8  20 C2 00           JSR   LAB_GBYT          ; scan memory
01404    C4BB  F0 0C              BEQ   LAB_14D4          ; branch if no more characters
01405    
01406                                  ; this bit checks the - is present
01407    C4BD  C9 C1              CMP   #TK_MINUS         ; compare with token for -
01408    C4BF  D0 95              BNE   LAB_1460          ; return if not "-" (will be Syntax error)
01409    
01410                                  ; LIST [n]-m
01411                                  ; the - was there so set m as the end value
01412    C4C1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01413    C4C4  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01414    C4C7  D0 8D              BNE   LAB_1460          ; exit if not ok
01415    
01416    LAB_14D4
01417    C4C9  A5 11              LDA   Itempl            ; get temporary integer low byte
01418    C4CB  05 12              ORA   Itemph            ; OR temporary integer high byte
01419    C4CD  D0 06              BNE   LAB_14E2          ; branch if start set
01420    
01421    C4CF  A9 FF              LDA   #$FF              ; set for -1
01422    C4D1  85 11              STA   Itempl            ; set temporary integer low byte
01423    C4D3  85 12              STA   Itemph            ; set temporary integer high byte
01424    LAB_14E2
01425    C4D5  A0 01              LDY   #$01              ; set index for line
01426    C4D7  84 60              STY   Oquote            ; clear open quote flag
01427    C4D9  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
01428    C4DC  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
01429                                  ; pointer initially set by search at LAB_14BD
01430    C4DE  F0 3E              BEQ   LAB_152B          ; if null all done so exit
01431    C4E0  20 1C C6           JSR   LAB_1629          ; do CRTL-C check vector
01432    
01433    C4E3  C8                 INY                     ; increment index for line
01434    C4E4  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
01435    C4E6  AA                 TAX                     ; copy to X
01436    C4E7  C8                 INY                     ; increment index
01437    C4E8  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
01438    C4EA  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01439    C4EC  D0 04              BNE   LAB_14FF          ; branch if no high byte match
01440    
01441    C4EE  E4 11              CPX   Itempl            ; compare with temporary integer low byte
01442    C4F0  F0 02              BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
01443    
01444    LAB_14FF                      ; else ..
01445    C4F2  B0 2A              BCS   LAB_152B          ; if greater all done so exit
01446    
01447    LAB_1501
01448    C4F4  84 97              STY   Tidx1             ; save index for line
01449    C4F6  20 95 DB           JSR   LAB_295E          ; print XA as unsigned integer
01450    C4F9  A9 20              LDA   #$20              ; space is the next character
01451    LAB_1508
01452    C4FB  A4 97              LDY   Tidx1             ; get index for line
01453    C4FD  29 7F              AND   #$7F              ; mask top out bit of character
01454    LAB_150C
01455    C4FF  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01456    C502  C9 22              CMP   #$22              ; was it " character
01457    C504  D0 06              BNE   LAB_1519          ; branch if not
01458    
01459                                  ; we are either entering or leaving a pair of quotes
01460    C506  A5 60              LDA   Oquote            ; get open quote flag
01461    C508  49 FF              EOR   #$FF              ; toggle it
01462    C50A  85 60              STA   Oquote            ; save it back
01463    LAB_1519
01464    C50C  C8                 INY                     ; increment index
01465    C50D  B1 AA              LDA   (Baslnl),Y        ; get next byte
01466    C50F  D0 0E              BNE   LAB_152E          ; branch if not [EOL] (go print character)
01467    C511  A8                 TAY                     ; else clear index
01468    C512  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
01469    C514  AA                 TAX                     ; copy to X
01470    C515  C8                 INY                     ; increment index
01471    C516  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
01472    C518  86 AA              STX   Baslnl            ; set pointer to line low byte
01473    C51A  85 AB              STA   Baslnh            ; set pointer to line high byte
01474    C51C  D0 B7              BNE   LAB_14E2          ; go do next line if not [EOT]
01475                                  ; else ..
01476    LAB_152B
01477    C51E  60                 RTS
01478    
01479    LAB_152E
01480    C51F  10 DE              BPL   LAB_150C          ; just go print it if not token byte
01481    
01482                                  ; else was token byte so uncrunch it (maybe)
01483    C521  24 60              BIT   Oquote            ; test the open quote flag
01484    C523  30 DA              BMI   LAB_150C          ; just go print character if open quote set
01485    
01486    C525  A2 E6              LDX   #>LAB_KEYT        ; get table address high byte
01487    C527  0A                 ASL                     ; *2
01488    C528  0A                 ASL                     ; *4
01489    C529  90 02              BCC   LAB_152F          ; branch if no carry
01490    
01491    C52B  E8                 INX                     ; else increment high byte
01492    C52C  18                 CLC                     ; clear carry for add
01493    LAB_152F
01494    C52D  69 99              ADC   #<LAB_KEYT        ; add low byte
01495    C52F  90 01              BCC   LAB_1530          ; branch if no carry
01496    
01497    C531  E8                 INX                     ; else increment high byte
01498    LAB_1530
01499    C532  85 73              STA   ut2_pl            ; save table pointer low byte
01500    C534  86 74              STX   ut2_ph            ; save table pointer high byte
01501    C536  84 97              STY   Tidx1             ; save index for line
01502    C538  A0 00              LDY   #$00              ; clear index
01503    C53A  B1 73              LDA   (ut2_pl),Y        ; get length
01504    C53C  AA                 TAX                     ; copy length
01505    C53D  C8                 INY                     ; increment index
01506    C53E  B1 73              LDA   (ut2_pl),Y        ; get 1st character
01507    C540  CA                 DEX                     ; decrement length
01508    C541  F0 B8              BEQ   LAB_1508          ; if no more characters exit and print
01509    
01510    C543  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01511    C546  C8                 INY                     ; increment index
01512    C547  B1 73              LDA   (ut2_pl),Y        ; get keyword address low byte
01513    C549  48                 PHA                     ; save it for now
01514    C54A  C8                 INY                     ; increment index
01515    C54B  B1 73              LDA   (ut2_pl),Y        ; get keyword address high byte
01516    C54D  A0 00              LDY   #$00
01517    C54F  85 74              STA   ut2_ph            ; save keyword pointer high byte
01518    C551  68                 PLA                     ; pull low byte
01519    C552  85 73              STA   ut2_pl            ; save keyword pointer low byte
01520    LAB_1540
01521    C554  B1 73              LDA   (ut2_pl),Y        ; get character
01522    C556  CA                 DEX                     ; decrement character count
01523    C557  F0 A2              BEQ   LAB_1508          ; if last character exit and print
01524    
01525    C559  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01526    C55C  C8                 INY                     ; increment index
01527    C55D  D0 F5              BNE   LAB_1540          ; loop for next character
01528    
01529    ; perform FOR
01530    
01531    LAB_FOR
01532    C55F  A9 80              LDA   #$80              ; set FNX
01533    C561  85 61              STA   Sufnxf            ; set subscript/FNX flag
01534    C563  20 BB C8           JSR   LAB_LET           ; go do LET
01535    C566  68                 PLA                     ; pull return address
01536    C567  68                 PLA                     ; pull return address
01537    C568  A9 10              LDA   #$10              ; we need 16d bytes !
01538    C56A  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
01539    C56D  20 A1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
01540    C570  18                 CLC                     ; clear carry for add
01541    C571  98                 TYA                     ; copy index to A
01542    C572  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01543    C574  48                 PHA                     ; push onto stack
01544    C575  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
01545    C577  69 00              ADC   #$00              ; add carry
01546    C579  48                 PHA                     ; push onto stack
01547    C57A  A5 88              LDA   Clineh            ; get current line high byte
01548    C57C  48                 PHA                     ; push onto stack
01549    C57D  A5 87              LDA   Clinel            ; get current line low byte
01550    C57F  48                 PHA                     ; push onto stack
01551    C580  A9 B7              LDA   #TK_TO            ; get "TO" token
01552    C582  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
01553    C585  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
01554    C588  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
01555                                  ; else do type mismatch
01556    ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
01557    ; *** add
01558    C58B  20 EC D9           JSR   LAB_27BA          ; round FAC1
01559    ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
01560    C58E  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
01561    C590  09 7F              ORA   #$7F              ; set all non sign bits
01562    C592  25 AD              AND   FAC1_1            ; and FAC1 mantissa1
01563    C594  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
01564    C596  A9 A1              LDA   #<LAB_159F        ; set return address low byte
01565    C598  A0 C5              LDY   #>LAB_159F        ; set return address high byte
01566    C59A  85 71              STA   ut1_pl            ; save return address low byte
01567    C59C  84 72              STY   ut1_ph            ; save return address high byte
01568    C59E  4C 8D CC           JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
01569    
01570    LAB_159F
01571    C5A1  A9 01              LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
01572    C5A3  A0 E3              LDY   #>LAB_259C        ; set 1 pointer high addr
01573    C5A5  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
01574    C5A8  20 C2 00           JSR   LAB_GBYT          ; scan memory
01575    C5AB  C9 BC              CMP   #TK_STEP          ; compare with STEP token
01576    C5AD  D0 06              BNE   LAB_15B3          ; jump if not "STEP"
01577    
01578                                  ;.was step so ..
01579    C5AF  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01580    C5B2  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
01581                                  ; else do type mismatch
01582    LAB_15B3
01583    C5B5  20 FC D9           JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
01584    C5B8  85 B0              STA   FAC1_s            ; set FAC1 sign (b7)
01585                                  ; this is +1 for +ve step and -1 for -ve step, in NEXT we
01586                                  ; compare the FOR value and the TO value and return +1 if
01587                                  ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
01588                                  ; here (+/-1) is then compared to that result and if they
01589                                  ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
01590                                  ; the loop is done
01591                                 
01592    ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
01593    ; *** add
01594       .IF [* & $FF] == $FD
01595    ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
01596    C5BA  20 7F CC           JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
01597    C5BD  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
01598    C5BF  48                 PHA                     ; push on stack
01599    C5C0  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
01600    C5C2  48                 PHA                     ; push on stack
01601    C5C3  A9 81              LDA   #TK_FOR           ; get FOR token
01602    C5C5  48                 PHA                     ; push on stack
01603    
01604    ; interpreter inner loop
01605    
01606    LAB_15C2
01607    C5C6  20 1C C6           JSR   LAB_1629          ; do CRTL-C check vector
01608    C5C9  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
01609    C5CB  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
01610    
01611    C5CD  A6 88              LDX   Clineh            ; continue line is $FFxx for immediate mode
01612                                  ; ($00xx for RUN from immediate mode)
01613    C5CF  E8                 INX                     ; increment it (now $00 if immediate mode)
01614    ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
01615    ;      BEQ   LAB_15D1          ; branch if null (immediate mode)
01616    
01617    C5D0  85 8B              STA   Cpntrl            ; save continue pointer low byte
01618    C5D2  84 8C              STY   Cpntrh            ; save continue pointer high byte
01619    LAB_15D1
01620    C5D4  A0 00              LDY   #$00              ; clear index
01621    C5D6  B1 C3              LDA   (Bpntrl),Y        ; get next byte
01622    C5D8  F0 07              BEQ   LAB_15DC          ; branch if null [EOL]
01623    
01624    C5DA  C9 3A              CMP   #':'              ; compare with ":"
01625    C5DC  F0 1D              BEQ   LAB_15F6          ; branch if = (statement separator)
01626    
01627    LAB_15D9
01628    C5DE  4C 08 CD           JMP   LAB_SNER          ; else syntax error then warm start
01629    
01630                                  ; have reached [EOL]
01631    LAB_15DC
01632    C5E1  A0 02              LDY   #$02              ; set index
01633    C5E3  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
01634    C5E5  18                 CLC                     ; clear carry for no "BREAK" message
01635    C5E6  F0 50              BEQ   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
01636                                  ; marker)
01637    
01638    C5E8  C8                 INY                     ; increment index
01639    C5E9  B1 C3              LDA   (Bpntrl),Y        ; get line # low byte
01640    C5EB  85 87              STA   Clinel            ; save current line low byte
01641    C5ED  C8                 INY                     ; increment index
01642    C5EE  B1 C3              LDA   (Bpntrl),Y        ; get line # high byte
01643    C5F0  85 88              STA   Clineh            ; save current line high byte
01644    C5F2  98                 TYA                     ; A now = 4
01645    C5F3  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01646    C5F5  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01647    C5F7  90 02              BCC   LAB_15F6          ; branch if no overflow
01648    
01649    C5F9  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
01650    LAB_15F6
01651    C5FB  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01652    
01653    LAB_15F9
01654    C5FE  20 04 C6           JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
01655    
01656    LAB_15FC
01657    C601  4C C6 C5           JMP   LAB_15C2          ; loop
01658    
01659    ; interpret BASIC code from (Bpntrl)
01660    
01661    LAB_15FF
01662    C604  F0 4E              BEQ   LAB_1628          ; exit if zero [EOL]
01663    
01664    LAB_1602
01665    C606  0A                 ASL                     ; *2 bytes per vector and normalise token
01666    C607  B0 03              BCS   LAB_1609          ; branch if was token
01667    
01668    C609  4C BB C8           JMP   LAB_LET           ; else go do implied LET
01669    
01670    LAB_1609
01671    C60C  C9 6A              CMP   #[TK_TAB-$80]*2   ; compare normalised token * 2 with TAB
01672    C60E  B0 CE              BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
01673                                  ; only tokens before TAB can start a line
01674    C610  A8                 TAY                     ; copy to index
01675    C611  B9 29 E3           LDA   LAB_CTBL+1,Y      ; get vector high byte
01676    C614  48                 PHA                     ; onto stack
01677    C615  B9 28 E3           LDA   LAB_CTBL,Y        ; get vector low byte
01678    C618  48                 PHA                     ; onto stack
01679    C619  4C BC 00           JMP   LAB_IGBY          ; jump to increment and scan memory
01680                                  ; then "return" to vector
01681    
01682    ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
01683    ; key press is detected.
01684    
01685    LAB_1629
01686    C61C  6C 03 02           JMP   (VEC_CC)          ; ctrl c check vector
01687    
01688    ; if there was a key press it gets back here ..
01689    
01690    LAB_1636
01691    C61F  C9 03              CMP   #$03              ; compare with CTRL-C
01692    
01693    ; perform STOP
01694    
01695    LAB_STOP
01696    C621  B0 01              BCS   LAB_163B          ; branch if token follows STOP
01697                                  ; else just END
01698    ; END
01699    
01700    LAB_END
01701    C623  18                 CLC                     ; clear the carry, indicate a normal program end
01702    LAB_163B
01703    C624  D0 61              BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
01704    
01705    C626  A5 C4              LDA   Bpntrh            ; get the BASIC execute pointer high byte
01706    ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
01707    ;      EOR   #>Ibuffs          ; compare with buffer address high byte (Cb unchanged)
01708    ;      BEQ   LAB_164F          ; branch if the BASIC pointer is in the input buffer
01709    ;                              ; (can't continue in immediate mode)
01710    ;                              ; else ..
01711    ;      EOR   #>Ibuffs          ; correct the bits
01712    C628  A4 C3              LDY   Bpntrl            ; get BASIC execute pointer low byte
01713    C62A  84 8B              STY   Cpntrl            ; save continue pointer low byte
01714    C62C  85 8C              STA   Cpntrh            ; save continue pointer high byte
01715    LAB_1647
01716    C62E  A5 87              LDA   Clinel            ; get current line low byte
01717    C630  A4 88              LDY   Clineh            ; get current line high byte
01718    C632  85 89              STA   Blinel            ; save break line low byte
01719    C634  84 8A              STY   Blineh            ; save break line high byte
01720    LAB_164F
01721    C636  68                 PLA                     ; pull return address low
01722    C637  68                 PLA                     ; pull return address high
01723    LAB_1651
01724    C638  90 07              BCC   LAB_165E          ; if was program end just do warm start
01725    
01726                                  ; else ..
01727    C63A  A9 AA              LDA   #<LAB_BMSG        ; point to "Break" low byte
01728    C63C  A0 E9              LDY   #>LAB_BMSG        ; point to "Break" high byte
01729    C63E  4C 52 C2           JMP   LAB_1269          ; print "Break" and do warm start
01730    
01731    LAB_165E
01732    C641  4C 5D C2           JMP   LAB_1274          ; go do warm start
01733    
01734    ; perform RESTORE
01735    
01736    LAB_RESTORE
01737    C644  D0 0F              BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
01738    
01739    LAB_161A
01740    C646  38                 SEC                     ; set carry for subtract
01741    C647  A5 79              LDA   Smeml             ; get start of mem low byte
01742    C649  E9 01              SBC   #$01              ; -1
01743    C64B  A4 7A              LDY   Smemh             ; get start of mem high byte
01744    C64D  B0 01              BCS   LAB_1624          ; branch if no underflow
01745    
01746    LAB_uflow
01747    C64F  88                 DEY                     ; else decrement high byte
01748    LAB_1624
01749    C650  85 8F              STA   Dptrl             ; save DATA pointer low byte
01750    C652  84 90              STY   Dptrh             ; save DATA pointer high byte
01751    LAB_1628
01752    C654  60                 RTS
01753    
01754                                  ; is RESTORE n
01755    LAB_RESTOREn
01756    C655  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01757    C658  20 A4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
01758    C65B  A5 88              LDA   Clineh            ; get current line high byte
01759    C65D  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01760    C65F  B0 0B              BCS   LAB_reset_search  ; branch if >= (start search from beginning)
01761    
01762    C661  98                 TYA                     ; else copy line index to A
01763    C662  38                 SEC                     ; set carry (+1)
01764    C663  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01765    C665  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
01766    C667  90 07              BCC   LAB_go_search     ; branch if no overflow to high byte
01767    
01768    C669  E8                 INX                     ; increment high byte
01769    C66A  B0 04              BCS   LAB_go_search     ; branch always (can never be carry clear)
01770    
01771    ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
01772    
01773    LAB_reset_search
01774    C66C  A5 79              LDA   Smeml             ; get start of mem low byte
01775    C66E  A6 7A              LDX   Smemh             ; get start of mem high byte
01776    
01777    ; search for line # in temp (Itempl/Itemph) from (AX)
01778    
01779    LAB_go_search
01780    
01781    C670  20 31 C4           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
01782    C673  B0 03              BCS   LAB_line_found    ; if carry set go set pointer
01783    
01784    C675  4C 76 C7           JMP   LAB_16F7          ; else go do "Undefined statement" error
01785    
01786    LAB_line_found
01787                                  ; carry already set for subtract
01788    C678  A5 AA              LDA   Baslnl            ; get pointer low byte
01789    C67A  E9 01              SBC   #$01              ; -1
01790    C67C  A4 AB              LDY   Baslnh            ; get pointer high byte
01791    C67E  B0 D0              BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
01792    
01793    C680  90 CD              BCC   LAB_uflow         ; else decrement high byte then save DATA pointer and
01794                                  ; return (branch always)
01795    
01796    ; perform NULL
01797    
01798    LAB_NULL
01799    C682  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
01800    C685  86 0D              STX   Nullct            ; save new NULL count
01801    LAB_167A
01802    C687  60                 RTS
01803    
01804    ; perform CONT
01805    
01806    LAB_CONT
01807    C688  D0 FD              BNE   LAB_167A          ; if following byte exit to do syntax error
01808    
01809    C68A  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
01810    C68C  C0 0B              CPY   #>Ibuffs          ; *** fix p2: test direct mode
01811    C68E  D0 05              BNE   LAB_166C          ; go do continue if we can
01812    
01813    C690  A2 1E              LDX   #$1E              ; error code $1E ("Can't continue" error)
01814    C692  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
01815    
01816                                  ; we can continue so ..
01817    LAB_166C
01818    C695  A9 93              LDA   #TK_ON            ; set token for ON
01819    C697  20 29 E0           JSR   LAB_IRQ           ; set IRQ flags
01820    C69A  A9 93              LDA   #TK_ON            ; set token for ON
01821    C69C  20 2C E0           JSR   LAB_NMI           ; set NMI flags
01822    
01823    C69F  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
01824    C6A1  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
01825    C6A3  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01826    C6A5  A5 89              LDA   Blinel            ; get break line low byte
01827    C6A7  A4 8A              LDY   Blineh            ; get break line high byte
01828    C6A9  85 87              STA   Clinel            ; set current line low byte
01829    C6AB  84 88              STY   Clineh            ; set current line high byte
01830    C6AD  60                 RTS
01831    
01832    ; perform RUN
01833    
01834    LAB_RUN
01835    C6AE  D0 03              BNE   LAB_1696          ; branch if RUN n
01836    C6B0  4C 6E C4           JMP   LAB_1477          ; reset execution to start, clear variables, flush stack and
01837                                  ; return
01838    
01839    ; does RUN n
01840    
01841    LAB_1696
01842    C6B3  20 7B C4           JSR   LAB_147A          ; go do "CLEAR"
01843    C6B6  F0 2E              BEQ   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
01844    
01845    ; perform DO
01846    
01847    LAB_DO
01848    C6B8  A9 05              LDA   #$05              ; need 5 bytes for DO
01849    C6BA  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
01850    C6BD  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
01851    C6BF  48                 PHA                     ; push on stack
01852    C6C0  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
01853    C6C2  48                 PHA                     ; push on stack
01854    C6C3  A5 88              LDA   Clineh            ; get current line high byte
01855    C6C5  48                 PHA                     ; push on stack
01856    C6C6  A5 87              LDA   Clinel            ; get current line low byte
01857    C6C8  48                 PHA                     ; push on stack
01858    C6C9  A9 9D              LDA   #TK_DO            ; token for DO
01859    C6CB  48                 PHA                     ; push on stack
01860    C6CC  20 C2 00           JSR   LAB_GBYT          ; scan memory
01861    C6CF  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
01862    
01863    ; perform GOSUB
01864    
01865    LAB_GOSUB
01866    C6D2  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
01867    C6D4  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
01868    C6D7  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
01869    C6D9  48                 PHA                     ; push on stack
01870    C6DA  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
01871    C6DC  48                 PHA                     ; push on stack
01872    C6DD  A5 88              LDA   Clineh            ; get current line high byte
01873    C6DF  48                 PHA                     ; push on stack
01874    C6E0  A5 87              LDA   Clinel            ; get current line low byte
01875    C6E2  48                 PHA                     ; push on stack
01876    C6E3  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
01877    C6E5  48                 PHA                     ; push on stack
01878    LAB_16B0
01879    C6E6  20 C2 00           JSR   LAB_GBYT          ; scan memory
01880    C6E9  20 EF C6           JSR   LAB_GOTO          ; perform GOTO n
01881    C6EC  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
01882                                  ; (can't RTS, we used the stack!)
01883    
01884    ; perform GOTO
01885    
01886    LAB_GOTO
01887    C6EF  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01888    C6F2  20 A4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
01889    C6F5  A5 88              LDA   Clineh            ; get current line high byte
01890    C6F7  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01891    C6F9  B0 0B              BCS   LAB_16D0          ; branch if >= (start search from beginning)
01892    
01893    C6FB  98                 TYA                     ; else copy line index to A
01894    C6FC  38                 SEC                     ; set carry (+1)
01895    C6FD  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01896    C6FF  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
01897    C701  90 07              BCC   LAB_16D4          ; branch if no overflow to high byte
01898    
01899    C703  E8                 INX                     ; increment high byte
01900    C704  B0 04              BCS   LAB_16D4          ; branch always (can never be carry)
01901    
01902    ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
01903    
01904    LAB_16D0
01905    C706  A5 79              LDA   Smeml             ; get start of mem low byte
01906    C708  A6 7A              LDX   Smemh             ; get start of mem high byte
01907    
01908    ; search for line # in temp (Itempl/Itemph) from (AX)
01909    
01910    LAB_16D4
01911    C70A  20 31 C4           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
01912    C70D  90 67              BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
01913                                  ; (unspecified statement)
01914    
01915                                  ; carry already set for subtract
01916    C70F  A5 AA              LDA   Baslnl            ; get pointer low byte
01917    C711  E9 01              SBC   #$01              ; -1
01918    C713  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01919    C715  A5 AB              LDA   Baslnh            ; get pointer high byte
01920    C717  E9 00              SBC   #$00              ; subtract carry
01921    C719  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
01922    LAB_16E5
01923    C71B  60                 RTS
01924    
01925    LAB_DONOK
01926    C71C  A2 22              LDX   #$22              ; error code $22 ("LOOP without DO" error)
01927    C71E  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
01928    
01929    ; perform LOOP
01930    
01931    LAB_LOOP
01932    C721  A8                 TAY                     ; save following token
01933    C722  BA                 TSX                     ; copy stack pointer
01934    C723  BD 03 01           LDA   LAB_STAK+3,X      ; get token byte from stack
01935    C726  C9 9D              CMP   #TK_DO            ; compare with DO token
01936    C728  D0 F2              BNE   LAB_DONOK         ; branch if no matching DO
01937    
01938    C72A  E8                 INX                     ; dump calling routine return address
01939    C72B  E8                 INX                     ; dump calling routine return address
01940    C72C  9A                 TXS                     ; correct stack
01941    C72D  98                 TYA                     ; get saved following token back
01942    C72E  F0 20              BEQ   LoopAlways        ; if no following token loop forever
01943                                  ; (stack pointer in X)
01944    
01945    C730  C9 3A              CMP   #':'              ; could be ':'
01946    C732  F0 1C              BEQ   LoopAlways        ; if :... loop forever
01947    
01948    C734  E9 BD              SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
01949    C736  AA                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)
01950    C737  F0 04              BEQ   DoRest            ; branch if was UNTIL
01951    
01952    C739  CA                 DEX                     ; decrement result
01953    C73A  D0 62              BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
01954                                  ; only if the token was WHILE will this fail
01955    
01956    C73C  CA                 DEX                     ; set invert result byte
01957    DoRest
01958    C73D  86 98              STX   Frnxth            ; save invert result byte
01959    C73F  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01960    C742  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
01961    C745  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
01962    C747  F0 02              BEQ   DoCmp             ; if =0 go do straight compare
01963    
01964    C749  A9 FF              LDA   #$FF              ; else set all bits
01965    DoCmp
01966    C74B  BA                 TSX                     ; copy stack pointer
01967    C74C  45 98              EOR   Frnxth            ; EOR with invert byte
01968    C74E  D0 1A              BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
01969    
01970                                  ; loop condition wasn't met so do it again
01971    LoopAlways
01972    C750  BD 02 01           LDA   LAB_STAK+2,X      ; get current line low byte
01973    C753  85 87              STA   Clinel            ; save current line low byte
01974    C755  BD 03 01           LDA   LAB_STAK+3,X      ; get current line high byte
01975    C758  85 88              STA   Clineh            ; save current line high byte
01976    C75A  BD 04 01           LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
01977    C75D  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01978    C75F  BD 05 01           LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
01979    C762  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
01980    C764  20 C2 00           JSR   LAB_GBYT          ; scan memory
01981    C767  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
01982    
01983                                  ; clear stack and back to interpreter loop
01984    LoopDone
01985    C76A  E8                 INX                     ; dump DO token
01986    C76B  E8                 INX                     ; dump current line low byte
01987    C76C  E8                 INX                     ; dump current line high byte
01988    C76D  E8                 INX                     ; dump BASIC execute pointer low byte
01989    C76E  E8                 INX                     ; dump BASIC execute pointer high byte
01990    C76F  9A                 TXS                     ; correct stack
01991    C770  4C 90 C7           JMP   LAB_DATA          ; go perform DATA (find : or [EOL])
01992    
01993    ; do the return without gosub error
01994    
01995    LAB_16F4
01996    C773  A2 04              LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
01997          .byte $2C               ; makes next line BIT LAB_0EA2
01998    
01999    LAB_16F7                      ; do undefined statement error
02000    C776  A2 0E              LDX   #$0E              ; error code $0E ("Undefined statement" error)
02001    C778  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
02002    
02003    ; perform RETURN
02004    
02005    LAB_RETURN
02006    C77B  D0 9E              BNE   LAB_16E5          ; exit if following token (to allow syntax error)
02007    
02008    LAB_16E8
02009    C77D  68                 PLA                     ; dump calling routine return address
02010    C77E  68                 PLA                     ; dump calling routine return address
02011    C77F  68                 PLA                     ; pull token
02012    C780  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
02013    C782  D0 EF              BNE   LAB_16F4          ; branch if no matching GOSUB
02014    
02015    LAB_16FF
02016    C784  68                 PLA                     ; pull current line low byte
02017    C785  85 87              STA   Clinel            ; save current line low byte
02018    C787  68                 PLA                     ; pull current line high byte
02019    C788  85 88              STA   Clineh            ; save current line high byte
02020    C78A  68                 PLA                     ; pull BASIC execute pointer low byte
02021    C78B  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
02022    C78D  68                 PLA                     ; pull BASIC execute pointer high byte
02023    C78E  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
02024    
02025                                  ; now do the DATA statement as we could be returning into
02026                                  ; the middle of an ON <var> GOSUB n,m,p,q line
02027                                  ; (the return address used by the DATA statement is the one
02028                                  ; pushed before the GOSUB was executed!)
02029    
02030    ; perform DATA
02031    
02032    LAB_DATA
02033    C790  20 A1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
02034    
02035                                  ; set BASIC execute pointer
02036    LAB_170F
02037    C793  98                 TYA                     ; copy index to A
02038    C794  18                 CLC                     ; clear carry for add
02039    C795  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
02040    C797  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
02041    C799  90 02              BCC   LAB_1719          ; skip next if no carry
02042    
02043    C79B  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
02044    LAB_1719
02045    C79D  60                 RTS
02046    
02047    LAB_16FC
02048    C79E  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
02049    
02050    ; scan for next BASIC statement ([:] or [EOL])
02051    ; returns Y as index to [:] or [EOL]
02052    
02053    LAB_SNBS
02054    C7A1  A2 3A              LDX   #':'              ; set look for character = ":"
02055          .byte $2C               ; makes next line BIT $00A2
02056    
02057    ; scan for next BASIC line
02058    ; returns Y as index to [EOL]
02059    
02060    LAB_SNBL
02061    C7A4  A2 00              LDX   #$00              ; set alt search character = [EOL]
02062    C7A6  A0 00              LDY   #$00              ; set search character = [EOL]
02063    C7A8  84 5C              STY   Asrch             ; store search character
02064    LAB_1725
02065    C7AA  8A                 TXA                     ; get alt search character
02066    C7AB  45 5C              EOR   Asrch             ; toggle search character, effectively swap with $00
02067    C7AD  85 5C              STA   Asrch             ; save swapped search character
02068    LAB_172D
02069    C7AF  B1 C3              LDA   (Bpntrl),Y        ; get next byte
02070    C7B1  F0 EA              BEQ   LAB_1719          ; exit if null [EOL]
02071    
02072    C7B3  C5 5C              CMP   Asrch             ; compare with search character
02073    C7B5  F0 E6              BEQ   LAB_1719          ; exit if found
02074    
02075    C7B7  C8                 INY                     ; increment index
02076    C7B8  C9 22              CMP   #$22              ; compare current character with open quote
02077    C7BA  D0 F3              BNE   LAB_172D          ; if not open quote go get next character
02078    
02079    C7BC  F0 EC              BEQ   LAB_1725          ; if found go swap search character for alt search character
02080    
02081    ; perform IF
02082    
02083    LAB_IF
02084    C7BE  20 E7 CB           JSR   LAB_EVEX          ; evaluate the expression
02085    C7C1  20 C2 00           JSR   LAB_GBYT          ; scan memory
02086    C7C4  C9 BA              CMP   #TK_THEN          ; compare with THEN token
02087    C7C6  F0 11              BEQ   LAB_174B          ; if it was THEN go do IF
02088    
02089                                  ; wasn't IF .. THEN so must be IF .. GOTO
02090    C7C8  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
02091    C7CA  D0 D2              BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
02092    
02093    C7CC  A6 C3              LDX   Bpntrl            ; save the basic pointer low byte
02094    C7CE  A4 C4              LDY   Bpntrh            ; save the basic pointer high byte
02095    C7D0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02096    C7D3  B0 C9              BCS   LAB_16FC          ; if not numeric go do syntax error
02097    
02098    C7D5  86 C3              STX   Bpntrl            ; restore the basic pointer low byte
02099    C7D7  84 C4              STY   Bpntrh            ; restore the basic pointer high byte
02100    LAB_174B
02101    C7D9  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
02102    C7DB  F0 1E              BEQ   LAB_174E          ; if the result was zero go look for an ELSE
02103    
02104    C7DD  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
02105    C7E0  B0 03              BCS   LAB_174D          ; if not numeric go do var or keyword
02106    
02107    LAB_174C
02108    C7E2  4C EF C6           JMP   LAB_GOTO          ; else was numeric so do GOTO n
02109    
02110                                  ; is var or keyword
02111    LAB_174D
02112    ; *** patch       allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
02113    ; *** replace
02114    ;      CMP   #TK_RETURN        ; compare the byte with the token for RETURN
02115    ;      BNE   LAB_174G          ; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
02116    ;                              ; and return to this code to process any following code
02117    ;
02118    ;      JMP   LAB_1602          ; else it was RETURN so interpret BASIC code from (Bpntrl)
02119    ;                              ; but don't return here
02120    ;
02121    ;LAB_174G
02122    ;      JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
02123    ;
02124    ;; the IF was executed and there may be a following ELSE so the code needs to return
02125    ;; here to check and ignore the ELSE if present
02126    ;
02127    ;      LDY   #$00              ; clear the index
02128    ;      LDA   (Bpntrl),Y        ; get the next BASIC byte
02129    ;      CMP   #TK_ELSE          ; compare it with the token for ELSE
02130    ;      BEQ   LAB_DATA          ; if ELSE ignore the following statement
02131    ;
02132    ;; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
02133    ;; following ELSE will, correctly, cause a syntax error
02134    ;
02135    ;      RTS                     ; else return to the interpreter inner loop
02136    ;
02137    ; *** with
02138    C7E5  68                 PLA                     ; discard interpreter loop return address
02139    C7E6  68                 PLA                     ; so data structures are at the correct stack offset
02140    C7E7  20 C2 00           JSR   LAB_GBYT          ; restore token or variable
02141    C7EA  20 04 C6           JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
02142    
02143    ; the IF was executed and there may be a following ELSE so the code needs to return
02144    ; here to check and ignore the ELSE if present
02145    
02146    C7ED  A0 00              LDY   #$00              ; clear the index
02147    C7EF  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
02148    C7F1  C9 B6              CMP   #TK_ELSE          ; compare it with the token for ELSE
02149    C7F3  D0 03              BNE   LAB_no_ELSE       ; no - continue on this line
02150    C7F5  20 90 C7           JSR   LAB_DATA          ; yes - skip the rest of the line
02151    
02152    ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
02153    ; following ELSE will, correctly, cause a syntax error
02154    
02155    LAB_no_ELSE
02156    C7F8  4C C6 C5           JMP LAB_15C2            ; return to the interpreter inner loop
02157    ; *** end patch  allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
02158    
02159    ; perform ELSE after IF
02160    
02161    LAB_174E
02162    C7FB  A0 00              LDY   #$00              ; clear the BASIC byte index
02163    C7FD  A2 01              LDX   #$01              ; clear the nesting depth
02164    LAB_1750
02165    C7FF  C8                 INY                     ; increment the BASIC byte index
02166    C800  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
02167    C802  F0 0F              BEQ   LAB_1753          ; if EOL go add the pointer and return
02168    
02169    C804  C9 8B              CMP   #TK_IF            ; compare the byte with the token for IF
02170    C806  D0 03              BNE   LAB_1752          ; if not IF token skip the depth increment
02171    
02172    C808  E8                 INX                     ; else increment the nesting depth ..
02173    C809  D0 F4              BNE   LAB_1750          ; .. and continue looking
02174    
02175    LAB_1752
02176    C80B  C9 B6              CMP   #TK_ELSE          ; compare the byte with the token for ELSE
02177    C80D  D0 F0              BNE   LAB_1750          ; if not ELSE token continue looking
02178    
02179    C80F  CA                 DEX                     ; was ELSE so decrement the nesting depth
02180    C810  D0 ED              BNE   LAB_1750          ; loop if still nested
02181    
02182    C812  C8                 INY                     ; increment the BASIC byte index past the ELSE
02183    
02184    ; found the matching ELSE, now do <{n|statement}>
02185    
02186    LAB_1753
02187    C813  98                 TYA                     ; else copy line index to A
02188    C814  18                 CLC                     ; clear carry for add
02189    C815  65 C3              ADC   Bpntrl            ; add the BASIC execute pointer low byte
02190    C817  85 C3              STA   Bpntrl            ; save the BASIC execute pointer low byte
02191    C819  90 02              BCC   LAB_1754          ; branch if no overflow to high byte
02192    
02193    C81B  E6 C4              INC   Bpntrh            ; else increment the BASIC execute pointer high byte
02194    LAB_1754
02195    C81D  20 C2 00           JSR   LAB_GBYT          ; scan memory
02196    C820  90 C0              BCC   LAB_174C          ; if numeric do GOTO n
02197                                  ; the code will return to the interpreter loop at the
02198                                  ; tail end of the GOTO <n>
02199    
02200    C822  4C 04 C6           JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
02201                                  ; the code will return to the interpreter loop at the
02202                                  ; tail end of the <statement>
02203    
02204    ; perform REM, skip (rest of) line
02205    
02206    LAB_REM
02207    C825  20 A4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
02208    C828  4C 93 C7           JMP   LAB_170F          ; go set BASIC execute pointer and return, branch always
02209    
02210    LAB_16FD
02211    C82B  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
02212    
02213    ; perform ON
02214    
02215    LAB_ON
02216    C82E  C9 A9              CMP   #TK_IRQ           ; was it IRQ token ?
02217    C830  D0 03              BNE   LAB_NOIN          ; if not go check NMI
02218    
02219    C832  4C 4D E0           JMP   LAB_SIRQ          ; else go set-up IRQ
02220    
02221    LAB_NOIN
02222    C835  C9 AA              CMP   #TK_NMI           ; was it NMI token ?
02223    C837  D0 03              BNE   LAB_NONM          ; if not go do normal ON command
02224    
02225    C839  4C 51 E0           JMP   LAB_SNMI          ; else go set-up NMI
02226    
02227    LAB_NONM
02228    C83C  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
02229    C83F  48                 PHA                     ; push GOTO/GOSUB token
02230    C840  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
02231    C842  F0 04              BEQ   LAB_176B          ; branch if GOSUB
02232    
02233    C844  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
02234    LAB_1767
02235    C846  D0 E3              BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
02236    
02237    
02238    ; next character was GOTO or GOSUB
02239    
02240    LAB_176B
02241    C848  C6 AF              DEC   FAC1_3            ; decrement index (byte value)
02242    C84A  D0 04              BNE   LAB_1773          ; branch if not zero
02243    
02244    C84C  68                 PLA                     ; pull GOTO/GOSUB token
02245    C84D  4C 06 C6           JMP   LAB_1602          ; go execute it
02246    
02247    LAB_1773
02248    C850  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02249    C853  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
02250                                  ; (we could LDX #',' and JSR LAB_SNBL+2, then we
02251                                  ; just BNE LAB_176B for the loop. should be quicker ..
02252                                  ; no we can't, what if we meet a colon or [EOL]?)
02253    C856  C9 2C              CMP   #$2C              ; compare next character with ","
02254    C858  F0 EE              BEQ   LAB_176B          ; loop if ","
02255    
02256    LAB_177E
02257    C85A  68                 PLA                     ; else pull keyword token (run out of options)
02258                                  ; also dump +/-1 pointer low byte and exit
02259    LAB_177F
02260    C85B  60                 RTS
02261    
02262    ; takes n * 106 + 11 cycles where n is the number of digits
02263    
02264    ; get fixed-point number into temp integer
02265    
02266    LAB_GFPN
02267    C85C  A2 00              LDX   #$00              ; clear reg
02268    C85E  86 11              STX   Itempl            ; clear temporary integer low byte
02269    LAB_1785
02270    C860  86 12              STX   Itemph            ; save temporary integer high byte
02271    C862  B0 F7              BCS   LAB_177F          ; return if carry set, end of scan, character was
02272                                  ; not 0-9
02273    
02274    C864  E0 19              CPX   #$19              ; compare high byte with $19
02275    C866  A8                 TAY                     ; ensure Zb = 0 if the branch is taken
02276    C867  B0 DD              BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
02277                                  ; bit does *$0A, = 64000, compare at target will fail
02278                                  ; and do syntax error
02279    
02280    C869  E9 2F              SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
02281    C86B  A8                 TAY                     ; copy binary digit
02282    C86C  A5 11              LDA   Itempl            ; get temporary integer low byte
02283    C86E  0A                 ASL                     ; *2 low byte
02284    C86F  26 12              ROL   Itemph            ; *2 high byte
02285    C871  0A                 ASL                     ; *2 low byte
02286    C872  26 12              ROL   Itemph            ; *2 high byte, *4
02287    C874  65 11              ADC   Itempl            ; + low byte, *5
02288    C876  85 11              STA   Itempl            ; save it
02289    C878  8A                 TXA                     ; get high byte copy to A
02290    C879  65 12              ADC   Itemph            ; + high byte, *5
02291    C87B  06 11              ASL   Itempl            ; *2 low byte, *10d
02292    C87D  2A                 ROL                     ; *2 high byte, *10d
02293    C87E  AA                 TAX                     ; copy high byte back to X
02294    C87F  98                 TYA                     ; get binary digit back
02295    C880  65 11              ADC   Itempl            ; add number low byte
02296    C882  85 11              STA   Itempl            ; save number low byte
02297    C884  90 01              BCC   LAB_17B3          ; if no overflow to high byte get next character
02298    
02299    C886  E8                 INX                     ; else increment high byte
02300    LAB_17B3
02301    C887  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02302    C88A  4C 60 C8           JMP   LAB_1785          ; loop for next character
02303    
02304    ; perform DEC
02305    
02306    LAB_DEC
02307    C88D  A9 05              LDA   #<LAB_2AFD        ; set -1 pointer low byte
02308          .byte $2C               ; BIT abs to skip the LDA below
02309    
02310    ; perform INC
02311    
02312    LAB_INC
02313    C890  A9 01              LDA   #<LAB_259C        ; set 1 pointer low byte
02314    LAB_17B5
02315    C892  48                 PHA                     ; save +/-1 pointer low byte
02316    LAB_17B7
02317    C893  20 BE CE           JSR   LAB_GVAR          ; get var address
02318    C896  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
02319    C898  30 1E              BMI   IncrErr           ; exit if string
02320    
02321    C89A  85 97              STA   Lvarpl            ; save var address low byte
02322    C89C  84 98              STY   Lvarph            ; save var address high byte
02323    C89E  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
02324    C8A1  68                 PLA                     ; get +/-1 pointer low byte
02325    C8A2  48                 PHA                     ; save +/-1 pointer low byte
02326    C8A3  A0 E3              LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
02327    C8A5  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
02328    C8A8  20 B6 D9           JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
02329    
02330    C8AB  20 C2 00           JSR   LAB_GBYT          ; scan memory
02331    C8AE  C9 2C              CMP   #','              ; compare with ","
02332    C8B0  D0 A8              BNE   LAB_177E          ; exit if not "," (either end or error)
02333    
02334                                  ; was "," so another INCR variable to do
02335    C8B2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02336    C8B5  4C 93 C8           JMP   LAB_17B7          ; go do next var
02337    
02338    IncrErr
02339    C8B8  4C E2 CB           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
02340    
02341    ; perform LET
02342    
02343    LAB_LET
02344    C8BB  20 BE CE           JSR   LAB_GVAR          ; get var address
02345    C8BE  85 97              STA   Lvarpl            ; save var address low byte
02346    C8C0  84 98              STY   Lvarph            ; save var address high byte
02347    C8C2  A9 CB              LDA   #TK_EQUAL         ; get = token
02348    C8C4  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
02349    C8C7  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
02350    C8C9  48                 PHA                     ; push data type flag
02351    C8CA  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
02352    C8CD  68                 PLA                     ; pop data type flag
02353    C8CE  2A                 ROL                     ; set carry if type = string
02354    ; *** begin patch  result of a string compare stores string pointer to variable
02355    ;                  but should store FAC1 (true/false value)
02356    ; *** replace
02357    ;      JSR   LAB_CKTM          ; type match check, set C for string
02358    ;      BNE   LAB_17D5          ; branch if string
02359    ; *** with
02360    C8CF  20 D9 CB           JSR   LAB_CKTM          ; type match check, keep C (expected type)
02361    C8D2  B0 03              BCS   LAB_17D5          ; branch if string
02362    ; *** end patch
02363    
02364    C8D4  4C B6 D9           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
02365    
02366    ; string LET
02367    
02368    LAB_17D5
02369    C8D7  A0 02              LDY   #$02              ; set index to pointer high byte
02370    C8D9  B1 AE              LDA   (des_pl),Y        ; get string pointer high byte
02371    C8DB  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
02372    C8DD  90 17              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
02373    
02374    C8DF  D0 07              BNE   LAB_17E6          ; branch if >
02375                                  ; else was equal so compare low bytes
02376    C8E1  88                 DEY                     ; decrement index
02377    C8E2  B1 AE              LDA   (des_pl),Y        ; get pointer low byte
02378    C8E4  C5 81              CMP   Sstorl            ; compare bottom of string space low byte
02379    C8E6  90 0E              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
02380    
02381                                  ; pointer was >= to bottom of string space pointer
02382    LAB_17E6
02383    C8E8  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
02384    C8EA  C4 7C              CPY   Svarh             ; compare start of vars high byte
02385    C8EC  90 08              BCC   LAB_17F4          ; branch if less (descriptor is on stack)
02386    
02387    C8EE  D0 0D              BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
02388    
02389                                  ; else high bytes were equal so ..
02390    C8F0  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
02391    C8F2  C5 7B              CMP   Svarl             ; compare start of vars low byte
02392    C8F4  B0 07              BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
02393    
02394    LAB_17F4
02395    C8F6  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
02396    C8F8  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
02397    C8FA  4C 13 C9           JMP   LAB_1811          ; clean stack, copy descriptor to variable and return
02398    
02399                                  ; make space and copy string
02400    LAB_17FB
02401    C8FD  A0 00              LDY   #$00              ; index to length
02402    C8FF  B1 AE              LDA   (des_pl),Y        ; get string length
02403    C901  20 46 D2           JSR   LAB_209C          ; copy string
02404    C904  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
02405    C906  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
02406    C908  85 B8              STA   ssptr_l           ; save descriptor pointer low byte
02407    C90A  84 B9              STY   ssptr_h           ; save descriptor pointer high byte
02408    C90C  20 2B D4           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
02409    C90F  A9 AC              LDA   #<FAC1_e          ; set descriptor pointer low byte
02410    C911  A0 00              LDY   #>FAC1_e          ; get descriptor pointer high byte
02411    
02412                                  ; clean stack and assign value to string variable
02413    LAB_1811
02414    C913  85 9E              STA   des_2l            ; save descriptor_2 pointer low byte
02415    C915  84 9F              STY   des_2h            ; save descriptor_2 pointer high byte
02416    C917  20 8D D4           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
02417    C91A  A0 00              LDY   #$00              ; index to length
02418    C91C  B1 9E              LDA   (des_2l),Y        ; get string length
02419    C91E  91 97              STA   (Lvarpl),Y        ; copy to let string variable
02420    C920  C8                 INY                     ; index to string pointer low byte
02421    C921  B1 9E              LDA   (des_2l),Y        ; get string pointer low byte
02422    C923  91 97              STA   (Lvarpl),Y        ; copy to let string variable
02423    C925  C8                 INY                     ; index to string pointer high byte
02424    C926  B1 9E              LDA   (des_2l),Y        ; get string pointer high byte
02425    C928  91 97              STA   (Lvarpl),Y        ; copy to let string variable
02426    C92A  60                 RTS
02427    
02428    ; perform GET
02429    
02430    LAB_GET
02431    C92B  20 BE CE           JSR   LAB_GVAR          ; get var address
02432    C92E  85 97              STA   Lvarpl            ; save var address low byte
02433    C930  84 98              STY   Lvarph            ; save var address high byte
02434    C932  20 15 E0           JSR   INGET             ; get input byte
02435    C935  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
02436    C937  30 07              BMI   LAB_GETS          ; go get string character
02437    
02438                                  ; was numeric get
02439    C939  A8                 TAY                     ; copy character to Y
02440    C93A  20 7A D1           JSR   LAB_1FD0          ; convert Y to byte in FAC1
02441    C93D  4C B6 D9           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
02442    
02443    LAB_GETS
02444    C940  48                 PHA                     ; save character
02445    C941  A9 01              LDA   #$01              ; string is single byte
02446    C943  B0 01              BCS   LAB_IsByte        ; branch if byte received
02447    
02448    C945  68                 PLA                     ; string is null
02449    LAB_IsByte
02450    C946  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
02451                                  ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
02452    C949  F0 05              BEQ   LAB_NoSt          ; skip store if null string
02453    
02454    C94B  68                 PLA                     ; get character back
02455    C94C  A0 00              LDY   #$00              ; clear index
02456    C94E  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
02457    LAB_NoSt
02458    C950  20 9B D2           JSR   LAB_RTST          ; check for space on descriptor stack then put address
02459                                  ; and length on descriptor stack and update stack pointers
02460    
02461    C953  4C D7 C8           JMP   LAB_17D5          ; do string LET and return
02462    
02463    ; perform PRINT
02464    
02465    LAB_1829
02466    C956  20 DD C9           JSR   LAB_18C6          ; print string from Sutill/Sutilh
02467    LAB_182C
02468    C959  20 C2 00           JSR   LAB_GBYT          ; scan memory
02469    
02470    ; PRINT
02471    
02472    LAB_PRINT
02473    C95C  F0 3B              BEQ   LAB_CRLF          ; if nothing following just print CR/LF
02474    
02475    LAB_1831
02476    C95E  C9 B5              CMP   #TK_TAB           ; compare with TAB( token
02477    C960  F0 56              BEQ   LAB_18A2          ; go do TAB/SPC
02478    
02479    C962  C9 B9              CMP   #TK_SPC           ; compare with SPC( token
02480    C964  F0 52              BEQ   LAB_18A2          ; go do TAB/SPC
02481    
02482    C966  C9 2C              CMP   #','              ; compare with ","
02483    C968  F0 38              BEQ   LAB_188B          ; go do move to next TAB mark
02484    
02485    C96A  C9 3B              CMP   #';'              ; compare with ";"
02486    C96C  F0 66              BEQ   LAB_18BD          ; if ";" continue with PRINT processing
02487    
02488    C96E  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
02489    C971  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
02490    C973  30 E1              BMI   LAB_1829          ; branch if string
02491    
02492    C975  20 A8 DB           JSR   LAB_296E          ; convert FAC1 to string
02493    C978  20 58 D2           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
02494    C97B  A0 00              LDY   #$00              ; clear index
02495    
02496    ; don't check fit if terminal width byte is zero
02497    
02498    C97D  A5 0F              LDA   TWidth            ; get terminal width byte
02499    C97F  F0 0A              BEQ   LAB_185E          ; skip check if zero
02500    
02501    C981  38                 SEC                     ; set carry for subtract
02502    C982  E5 0E              SBC   TPos              ; subtract terminal position
02503    C984  F1 AE              SBC   (des_pl),Y        ; subtract string length
02504    C986  B0 03              BCS   LAB_185E          ; branch if less than terminal width
02505    
02506    C988  20 99 C9           JSR   LAB_CRLF          ; else print CR/LF
02507    LAB_185E
02508    C98B  20 DD C9           JSR   LAB_18C6          ; print string from Sutill/Sutilh
02509    C98E  F0 C9              BEQ   LAB_182C          ; always go continue processing line
02510    
02511    ; CR/LF return to BASIC from BASIC input handler
02512    
02513    LAB_1866
02514    C990  A9 00              LDA   #$00              ; clear byte
02515    C992  9D 00 0B           STA   Ibuffs,X          ; null terminate input
02516    C995  A2 00              LDX   #<Ibuffs          ; set X to buffer start-1 low byte
02517    C997  A0 0B              LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
02518    
02519    ; print CR/LF
02520    
02521    LAB_CRLF
02522    C999  A9 0D              LDA   #$0D              ; load [CR]
02523    C99B  20 F4 C9           JSR   LAB_PRNA          ; go print the character
02524    C99E  A9 0A              LDA   #$0A              ; load [LF]
02525    C9A0  D0 52              BNE   LAB_PRNA          ; go print the character and return, branch always
02526    
02527    LAB_188B
02528    C9A2  A5 0E              LDA   TPos              ; get terminal position
02529    C9A4  C5 10              CMP   Iclim             ; compare with input column limit
02530    C9A6  90 05              BCC   LAB_1897          ; branch if less
02531    
02532    C9A8  20 99 C9           JSR   LAB_CRLF          ; else print CR/LF (next line)
02533    C9AB  D0 27              BNE   LAB_18BD          ; continue with PRINT processing (branch always)
02534    
02535    LAB_1897
02536    C9AD  38                 SEC                     ; set carry for subtract
02537    LAB_1898
02538    C9AE  E5 64              SBC   TabSiz            ; subtract TAB size
02539    C9B0  B0 FC              BCS   LAB_1898          ; loop if result was +ve
02540    
02541    C9B2  49 FF              EOR   #$FF              ; complement it
02542    C9B4  69 01              ADC   #$01              ; +1 (twos complement)
02543    C9B6  D0 12              BNE   LAB_18B6          ; always print A spaces (result is never $00)
02544    
02545                                  ; do TAB/SPC
02546    LAB_18A2
02547    C9B8  48                 PHA                     ; save token
02548    C9B9  20 A3 D5           JSR   LAB_SGBY          ; scan and get byte parameter
02549    C9BC  C9 29              CMP   #$29              ; is next character )
02550    C9BE  D0 7B              BNE   LAB_1910          ; if not do syntax error then warm start
02551    
02552    C9C0  68                 PLA                     ; get token back
02553    C9C1  C9 B5              CMP   #TK_TAB           ; was it TAB ?
02554    C9C3  D0 06              BNE   LAB_18B7          ; if not go do SPC
02555    
02556                                  ; calculate TAB offset
02557    C9C5  8A                 TXA                     ; copy integer value to A
02558    C9C6  E5 0E              SBC   TPos              ; subtract terminal position
02559    C9C8  90 0A              BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
02560    
02561                                  ; print A spaces
02562    LAB_18B6
02563    C9CA  AA                 TAX                     ; copy result to X
02564    LAB_18B7
02565    C9CB  8A                 TXA                     ; set flags on size for SPC
02566    C9CC  F0 06              BEQ   LAB_18BD          ; branch if result was = $0, already here
02567    
02568                                  ; print X spaces
02569    LAB_18BA
02570    C9CE  20 EF C9           JSR   LAB_18E0          ; print " "
02571    C9D1  CA                 DEX                     ; decrement count
02572    C9D2  D0 FA              BNE   LAB_18BA          ; loop if not all done
02573    
02574                                  ; continue with PRINT processing
02575    LAB_18BD
02576    C9D4  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02577    C9D7  D0 85              BNE   LAB_1831          ; if more to print go do it
02578    
02579    C9D9  60                 RTS
02580    
02581    ; print null terminated string from memory
02582    
02583    LAB_18C3
02584    C9DA  20 58 D2           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
02585    
02586    ; print string from Sutill/Sutilh
02587    
02588    LAB_18C6
02589    C9DD  20 58 D4           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
02590                                  ; space returns with A = length, X=$71=pointer low byte,
02591                                  ; Y=$72=pointer high byte
02592    C9E0  A0 00              LDY   #$00              ; reset index
02593    C9E2  AA                 TAX                     ; copy length to X
02594    C9E3  F0 49              BEQ   LAB_188C          ; exit (RTS) if null string
02595    
02596    LAB_18CD
02597    
02598    C9E5  B1 71              LDA   (ut1_pl),Y        ; get next byte
02599    C9E7  20 F4 C9           JSR   LAB_PRNA          ; go print the character
02600    C9EA  C8                 INY                     ; increment index
02601    C9EB  CA                 DEX                     ; decrement count
02602    C9EC  D0 F7              BNE   LAB_18CD          ; loop if not done yet
02603    
02604    C9EE  60                 RTS
02605    
02606                                  ; Print single format character
02607    ; print " "
02608    
02609    LAB_18E0
02610    C9EF  A9 20              LDA   #$20              ; load " "
02611          .byte $2C               ; change next line to BIT LAB_3FA9
02612    
02613    ; print "?" character
02614    
02615    LAB_18E3
02616    C9F2  A9 3F              LDA   #$3F              ; load "?" character
02617    
02618    ; print character in A
02619    ; now includes the null handler
02620    ; also includes infinite line length code
02621    ; note! some routines expect this one to exit with Zb=0
02622    
02623    LAB_PRNA
02624    C9F4  C9 20              CMP   #' '              ; compare with " "
02625    C9F6  90 19              BCC   LAB_18F9          ; branch if less (non printing)
02626    
02627                                  ; else printable character
02628    C9F8  48                 PHA                     ; save the character
02629    
02630    ; don't check fit if terminal width byte is zero
02631    
02632    C9F9  A5 0F              LDA   TWidth            ; get terminal width
02633    C9FB  D0 0A              BNE   LAB_18F0          ; branch if not zero (not infinite length)
02634    
02635    ; is "infinite line" so check TAB position
02636    
02637    C9FD  A5 0E              LDA   TPos              ; get position
02638    C9FF  E5 64              SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
02639    CA01  D0 0B              BNE   LAB_18F7          ; skip reset if different
02640    
02641    CA03  85 0E              STA   TPos              ; else reset position
02642    CA05  F0 07              BEQ   LAB_18F7          ; go print character
02643    
02644    LAB_18F0
02645    CA07  C5 0E              CMP   TPos              ; compare with terminal character position
02646    CA09  D0 03              BNE   LAB_18F7          ; branch if not at end of line
02647    
02648    CA0B  20 99 C9           JSR   LAB_CRLF          ; else print CR/LF
02649    LAB_18F7
02650    CA0E  E6 0E              INC   TPos              ; increment terminal position
02651    CA10  68                 PLA                     ; get character back
02652    LAB_18F9
02653    CA11  20 02 E2           JSR   V_OUTP            ; output byte via output vector
02654    CA14  C9 0D              CMP   #$0D              ; compare with [CR]
02655    CA16  D0 14              BNE   LAB_188A          ; branch if not [CR]
02656    
02657                                  ; else print nullct nulls after the [CR]
02658    CA18  86 78              STX   TempB             ; save buffer index
02659    CA1A  A6 0D              LDX   Nullct            ; get null count
02660    CA1C  F0 0A              BEQ   LAB_1886          ; branch if no nulls
02661    
02662    CA1E  A9 00              LDA   #$00              ; load [NULL]
02663    LAB_1880
02664    CA20  20 F4 C9           JSR   LAB_PRNA          ; go print the character
02665    CA23  CA                 DEX                     ; decrement count
02666    CA24  D0 FA              BNE   LAB_1880          ; loop if not all done
02667    
02668    CA26  A9 0D              LDA   #$0D              ; restore the character (and set the flags)
02669    LAB_1886
02670    CA28  86 0E              STX   TPos              ; clear terminal position (X always = zero when we get here)
02671    CA2A  A6 78              LDX   TempB             ; restore buffer index
02672    LAB_188A
02673    CA2C  29 FF              AND   #$FF              ; set the flags
02674    LAB_188C
02675    CA2E  60                 RTS
02676    
02677    ; handle bad input data
02678    
02679    LAB_1904
02680    CA2F  A5 62              LDA   Imode             ; get input mode flag, $00=INPUT, $00=READ
02681    CA31  10 0B              BPL   LAB_1913          ; branch if INPUT (go do redo)
02682    
02683    CA33  A5 8D              LDA   Dlinel            ; get current DATA line low byte
02684    CA35  A4 8E              LDY   Dlineh            ; get current DATA line high byte
02685    CA37  85 87              STA   Clinel            ; save current line low byte
02686    CA39  84 88              STY   Clineh            ; save current line high byte
02687    LAB_1910
02688    CA3B  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
02689    
02690                                  ; mode was INPUT
02691    LAB_1913
02692    CA3E  A9 DE              LDA   #<LAB_REDO        ; point to redo message (low addr)
02693    CA40  A0 E9              LDY   #>LAB_REDO        ; point to redo message (high addr)
02694    CA42  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
02695    CA45  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
02696    CA47  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
02697    CA49  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
02698    CA4B  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
02699    CA4D  60                 RTS
02700    
02701    ; perform INPUT
02702    
02703    LAB_INPUT
02704    CA4E  C9 22              CMP   #$22              ; compare next byte with open quote
02705    CA50  D0 0B              BNE   LAB_1934          ; branch if no prompt string
02706    
02707    CA52  20 C4 CC           JSR   LAB_1BC1          ; print "..." string
02708    CA55  A9 3B              LDA   #$3B              ; load A with ";"
02709    CA57  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
02710    CA5A  20 DD C9           JSR   LAB_18C6          ; print string from Sutill/Sutilh
02711    
02712                                  ; done with prompt, now get data
02713    LAB_1934
02714    CA5D  20 7E D1           JSR   LAB_CKRN          ; check not Direct, back here if ok
02715    CA60  20 43 C3           JSR   LAB_INLN          ; print "? " and get BASIC input
02716    CA63  A9 00              LDA   #$00              ; set mode = INPUT
02717    CA65  CD 00 0B           CMP   Ibuffs            ; test first byte in buffer
02718    CA68  D0 09              BNE   LAB_1953          ; branch if not null input
02719    
02720    ; *** change p2: keep carry set to throw break message
02721    ;      CLC                     ; was null input so clear carry to exit program
02722    CA6A  4C 2E C6           JMP   LAB_1647          ; go do BREAK exit
02723    
02724    ; perform READ
02725    
02726    LAB_READ
02727    CA6D  A6 8F              LDX   Dptrl             ; get DATA pointer low byte
02728    CA6F  A4 90              LDY   Dptrh             ; get DATA pointer high byte
02729    CA71  A9 80              LDA   #$80              ; set mode = READ
02730    
02731    LAB_1953
02732    CA73  85 62              STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
02733    CA75  86 91              STX   Rdptrl            ; save READ pointer low byte
02734    CA77  84 92              STY   Rdptrh            ; save READ pointer high byte
02735    
02736                                  ; READ or INPUT next variable from list
02737    LAB_195B
02738    CA79  20 BE CE           JSR   LAB_GVAR          ; get (var) address
02739    CA7C  85 97              STA   Lvarpl            ; save address low byte
02740    CA7E  84 98              STY   Lvarph            ; save address high byte
02741    CA80  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
02742    CA82  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
02743    CA84  85 11              STA   Itempl            ; save as temporary integer low byte
02744    CA86  84 12              STY   Itemph            ; save as temporary integer high byte
02745    CA88  A6 91              LDX   Rdptrl            ; get READ pointer low byte
02746    CA8A  A4 92              LDY   Rdptrh            ; get READ pointer high byte
02747    CA8C  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
02748    CA8E  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
02749    CA90  20 C2 00           JSR   LAB_GBYT          ; scan memory
02750    CA93  D0 11              BNE   LAB_1988          ; branch if not null
02751    
02752                                  ; pointer was to null entry
02753    CA95  24 62              BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
02754    CA97  30 65              BMI   LAB_19DD          ; branch if READ
02755    
02756                                  ; mode was INPUT
02757    CA99  20 F2 C9           JSR   LAB_18E3          ; print "?" character (double ? for extended input)
02758    CA9C  20 43 C3           JSR   LAB_INLN          ; print "? " and get BASIC input
02759    CA9F  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
02760    CAA1  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
02761    LAB_1985
02762    CAA3  20 C2 00           JSR   LAB_GBYT          ; scan memory
02763    LAB_1988
02764    CAA6  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
02765    CAA8  10 24              BPL   LAB_19B0          ; branch if numeric
02766    
02767                                  ; else get string
02768    CAAA  85 5B              STA   Srchc             ; save search character
02769    CAAC  C9 22              CMP   #$22              ; was it " ?
02770    CAAE  F0 07              BEQ   LAB_1999          ; branch if so
02771    
02772    CAB0  A9 3A              LDA   #':'              ; else search character is ":"
02773    CAB2  85 5B              STA   Srchc             ; set new search character
02774    CAB4  A9 2C              LDA   #','              ; other search character is ","
02775    CAB6  18                 CLC                     ; clear carry for add
02776    LAB_1999
02777    CAB7  85 5C              STA   Asrch             ; set second search character
02778    CAB9  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
02779    CABB  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
02780    
02781    CABD  69 00              ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
02782    CABF  90 01              BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
02783    
02784    CAC1  C8                 INY                     ; else increment high byte
02785    LAB_19A4
02786    CAC2  20 5E D2           JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
02787    CAC5  20 E2 D5           JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
02788    CAC8  20 D7 C8           JSR   LAB_17D5          ; go do string LET
02789    CACB  4C D4 CA           JMP   LAB_19B6          ; go check string terminator
02790    
02791                                  ; get numeric INPUT
02792    LAB_19B0
02793    CACE  20 B9 DA           JSR   LAB_2887          ; get FAC1 from string
02794    CAD1  20 B6 D9           JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
02795    LAB_19B6
02796    CAD4  20 C2 00           JSR   LAB_GBYT          ; scan memory
02797    CAD7  F0 0A              BEQ   LAB_19C5          ; branch if null (last entry)
02798    
02799    CAD9  C9 2C              CMP   #','              ; else compare with ","
02800    CADB  F0 03              BEQ   LAB_19C2          ; branch if ","
02801    
02802    CADD  4C 2F CA           JMP   LAB_1904          ; else go handle bad input data
02803    
02804                                  ; got good input data
02805    LAB_19C2
02806    CAE0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02807    LAB_19C5
02808    CAE3  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
02809    CAE5  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
02810    CAE7  85 91              STA   Rdptrl            ; save for now
02811    CAE9  84 92              STY   Rdptrh            ; save for now
02812    CAEB  A5 11              LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
02813    CAED  A4 12              LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
02814    CAEF  85 C3              STA   Bpntrl            ; set BASIC execute pointer low byte
02815    CAF1  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
02816    CAF3  20 C2 00           JSR   LAB_GBYT          ; scan memory
02817    CAF6  F0 2C              BEQ   LAB_1A03          ; if null go do extra ignored message
02818    
02819    CAF8  20 04 CD           JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
02820    CAFB  4C 79 CA           JMP   LAB_195B          ; go INPUT next variable from list
02821    
02822                                  ; find next DATA statement or do "Out of DATA" error
02823    LAB_19DD
02824    CAFE  20 A1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
02825    CB01  C8                 INY                     ; increment index
02826    CB02  AA                 TAX                     ; copy character ([:] or [EOL])
02827    CB03  D0 12              BNE   LAB_19F6          ; branch if [:]
02828    
02829    CB05  A2 06              LDX   #$06              ; set for "Out of DATA" error
02830    CB07  C8                 INY                     ; increment index, now points to next line pointer high byte
02831    CB08  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
02832    CB0A  F0 73              BEQ   LAB_1A54          ; branch if end (eventually does error X)
02833    
02834    CB0C  C8                 INY                     ; increment index
02835    CB0D  B1 C3              LDA   (Bpntrl),Y        ; get next line # low byte
02836    CB0F  85 8D              STA   Dlinel            ; save current DATA line low byte
02837    CB11  C8                 INY                     ; increment index
02838    CB12  B1 C3              LDA   (Bpntrl),Y        ; get next line # high byte
02839    CB14  C8                 INY                     ; increment index
02840    CB15  85 8E              STA   Dlineh            ; save current DATA line high byte
02841    LAB_19F6
02842    CB17  B1 C3              LDA   (Bpntrl),Y        ; get byte
02843    CB19  C8                 INY                     ; increment index
02844    CB1A  AA                 TAX                     ; copy to X
02845    CB1B  20 93 C7           JSR   LAB_170F          ; set BASIC execute pointer
02846    CB1E  E0 83              CPX   #TK_DATA          ; compare with "DATA" token
02847    CB20  F0 81              BEQ   LAB_1985          ; was "DATA" so go do next READ
02848    
02849    CB22  D0 DA              BNE   LAB_19DD          ; go find next statement if not "DATA"
02850    
02851    ; end of INPUT/READ routine
02852    
02853    LAB_1A03
02854    CB24  A5 91              LDA   Rdptrl            ; get temp READ pointer low byte
02855    CB26  A4 92              LDY   Rdptrh            ; get temp READ pointer high byte
02856    CB28  A6 62              LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
02857    CB2A  10 03              BPL   LAB_1A0E          ; branch if INPUT
02858    
02859    CB2C  4C 50 C6           JMP   LAB_1624          ; save AY as DATA pointer and return
02860    
02861                                  ; we were getting INPUT
02862    LAB_1A0E
02863    CB2F  A0 00              LDY   #$00              ; clear index
02864    CB31  B1 91              LDA   (Rdptrl),Y        ; get next byte
02865    CB33  D0 01              BNE   LAB_1A1B          ; error if not end of INPUT
02866    
02867    CB35  60                 RTS
02868    
02869                                  ; user typed too much
02870    LAB_1A1B
02871    CB36  A9 CD              LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
02872    CB38  A0 E9              LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
02873    CB3A  4C DA C9           JMP   LAB_18C3          ; print null terminated string from memory and return
02874    
02875    ; search the stack for FOR activity
02876    ; exit with z=1 if FOR else exit with z=0
02877    
02878    LAB_11A1
02879    CB3D  BA                 TSX                     ; copy stack pointer
02880    CB3E  E8                 INX                     ; +1 pass return address
02881    CB3F  E8                 INX                     ; +2 pass return address
02882    CB40  E8                 INX                     ; +3 pass calling routine return address
02883    CB41  E8                 INX                     ; +4 pass calling routine return address
02884    LAB_11A6
02885    CB42  BD 01 01           LDA   LAB_STAK+1,X      ; get token byte from stack
02886    CB45  C9 81              CMP   #TK_FOR           ; is it FOR token
02887    CB47  D0 21              BNE   LAB_11CE          ; exit if not FOR token
02888    
02889                                  ; was FOR token
02890    CB49  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
02891    CB4B  D0 0A              BNE   LAB_11BB          ; branch if not null
02892    
02893    CB4D  BD 02 01           LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
02894    CB50  85 97              STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
02895    CB52  BD 03 01           LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
02896    CB55  85 98              STA   Frnxth            ; save var pointer for FOR/NEXT high byte
02897    LAB_11BB
02898    CB57  DD 03 01           CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
02899    CB5A  D0 07              BNE   LAB_11C7          ; branch if no match
02900    
02901    CB5C  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
02902    CB5E  DD 02 01           CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
02903    CB61  F0 07              BEQ   LAB_11CE          ; exit if match found
02904    
02905    LAB_11C7
02906    CB63  8A                 TXA                     ; copy index
02907    CB64  18                 CLC                     ; clear carry for add
02908    CB65  69 10              ADC   #$10              ; add FOR stack use size
02909    CB67  AA                 TAX                     ; copy back to index
02910    CB68  D0 D8              BNE   LAB_11A6          ; loop if not at start of stack
02911    
02912    LAB_11CE
02913    CB6A  60                 RTS
02914    
02915    ; perform NEXT
02916    
02917    LAB_NEXT
02918    CB6B  D0 04              BNE   LAB_1A46          ; branch if NEXT var
02919    
02920    CB6D  A0 00              LDY   #$00              ; else clear Y
02921    CB6F  F0 03              BEQ   LAB_1A49          ; branch always (no variable to search for)
02922    
02923    ; NEXT var
02924    
02925    LAB_1A46
02926    CB71  20 BE CE           JSR   LAB_GVAR          ; get variable address
02927    LAB_1A49
02928    CB74  85 97              STA   Frnxtl            ; store variable pointer low byte
02929    CB76  84 98              STY   Frnxth            ; store variable pointer high byte
02930                                  ; (both cleared if no variable defined)
02931    CB78  20 3D CB           JSR   LAB_11A1          ; search the stack for FOR activity
02932    CB7B  F0 04              BEQ   LAB_1A56          ; branch if found
02933    
02934    CB7D  A2 00              LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
02935    LAB_1A54
02936    CB7F  F0 63              BEQ   LAB_1ABE          ; do error #X, then warm start
02937    
02938    LAB_1A56
02939    CB81  9A                 TXS                     ; set stack pointer, X set by search, dumps return addresses
02940    
02941    CB82  8A                 TXA                     ; copy stack pointer
02942    CB83  38                 SEC                     ; set carry for subtract
02943    CB84  E9 F7              SBC   #$F7              ; point to TO var
02944    CB86  85 73              STA   ut2_pl            ; save pointer to TO var for compare
02945    CB88  69 FB              ADC   #$FB              ; point to STEP var
02946    
02947    CB8A  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
02948    CB8C  20 90 D9           JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
02949    CB8F  BA                 TSX                     ; get stack pointer back
02950    CB90  BD 08 01           LDA   LAB_STAK+8,X      ; get step sign
02951    CB93  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
02952    CB95  A5 97              LDA   Frnxtl            ; get FOR variable pointer low byte
02953    CB97  A4 98              LDY   Frnxth            ; get FOR variable pointer high byte
02954    CB99  20 D1 D6           JSR   LAB_246C          ; add (FOR variable) to FAC1
02955    CB9C  20 B6 D9           JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
02956    CB9F  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
02957    CBA1  20 2C DA           JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
02958    CBA4  BA                 TSX                     ; get stack pointer back
02959    CBA5  DD 08 01           CMP   LAB_STAK+8,X      ; compare step sign
02960    CBA8  F0 17              BEQ   LAB_1A9B          ; branch if = (loop complete)
02961    
02962                                  ; loop back and do it all again
02963    CBAA  BD 0D 01           LDA   LAB_STAK+$0D,X    ; get FOR line low byte
02964    CBAD  85 87              STA   Clinel            ; save current line low byte
02965    CBAF  BD 0E 01           LDA   LAB_STAK+$0E,X    ; get FOR line high byte
02966    CBB2  85 88              STA   Clineh            ; save current line high byte
02967    CBB4  BD 10 01           LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
02968    CBB7  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
02969    CBB9  BD 0F 01           LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
02970    CBBC  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
02971    LAB_1A98
02972    CBBE  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
02973    
02974                                  ; loop complete so carry on
02975    LAB_1A9B
02976    CBC1  8A                 TXA                     ; stack copy to A
02977    CBC2  69 0F              ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
02978    CBC4  AA                 TAX                     ; copy back to index
02979    CBC5  9A                 TXS                     ; copy to stack pointer
02980    CBC6  20 C2 00           JSR   LAB_GBYT          ; scan memory
02981    CBC9  C9 2C              CMP   #','              ; compare with ","
02982    CBCB  D0 F1              BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
02983    
02984                                  ; was "," so another NEXT variable to do
02985    CBCD  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
02986    CBD0  20 71 CB           JSR   LAB_1A46          ; do NEXT (var)
02987    
02988    ; evaluate expression and check is numeric, else do type mismatch
02989    
02990    LAB_EVNM
02991    CBD3  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
02992    
02993    ; check if source is numeric, else do type mismatch
02994    
02995    LAB_CTNM
02996    CBD6  18                 CLC                     ; destination is numeric
02997          .byte $24               ; makes next line BIT $38
02998    
02999    ; check if source is string, else do type mismatch
03000    
03001    LAB_CTST
03002    CBD8  38                 SEC                     ; required type is string
03003    
03004    ; type match check, set C for string, clear C for numeric
03005    
03006    LAB_CKTM
03007    CBD9  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
03008    CBDB  30 03              BMI   LAB_1ABA          ; branch if data type is string
03009    
03010                                  ; else data type was numeric
03011    CBDD  B0 03              BCS   LAB_1ABC          ; if required type is string do type mismatch error
03012    LAB_1AB9
03013    CBDF  60                 RTS
03014    
03015                                  ; data type was string, now check required type
03016    LAB_1ABA
03017    CBE0  B0 FD              BCS   LAB_1AB9          ; exit if required type is string
03018    
03019                                  ; else do type mismatch error
03020    LAB_1ABC
03021    CBE2  A2 18              LDX   #$18              ; error code $18 ("Type mismatch" error)
03022    LAB_1ABE
03023    CBE4  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
03024    
03025    ; evaluate expression
03026    
03027    LAB_EVEX
03028    CBE7  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
03029    CBE9  D0 02              BNE   LAB_1AC7          ; skip next if not zero
03030    
03031    CBEB  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
03032    LAB_1AC7
03033    CBED  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
03034    
03035    LAB_EVEZ
03036    CBEF  A9 00              LDA   #$00              ; set null precedence (flag done)
03037    LAB_1ACC
03038    CBF1  48                 PHA                     ; push precedence byte
03039    CBF2  A9 02              LDA   #$02              ; 2 bytes
03040    CBF4  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
03041    CBF7  20 D3 CC           JSR   LAB_GVAL          ; get value from line
03042    CBFA  A9 00              LDA   #$00              ; clear A
03043    CBFC  85 9B              STA   comp_f            ; clear compare function flag
03044    LAB_1ADB
03045    CBFE  20 C2 00           JSR   LAB_GBYT          ; scan memory
03046    LAB_1ADE
03047    CC01  38                 SEC                     ; set carry for subtract
03048    CC02  E9 CA              SBC   #TK_GT            ; subtract token for > (lowest comparison function)
03049    CC04  90 17              BCC   LAB_1AFA          ; branch if < TK_GT
03050    
03051    CC06  C9 03              CMP   #$03              ; compare with ">" to "<" tokens
03052    CC08  B0 13              BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
03053    
03054                                  ; was token for > = or < (A = 0, 1 or 2)
03055    CC0A  C9 01              CMP   #$01              ; compare with token for =
03056    CC0C  2A                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
03057                                  ; (A = 0, 3 or 5)
03058    CC0D  49 01              EOR   #$01              ; toggle b0
03059                                  ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
03060    CC0F  45 9B              EOR   comp_f            ; EOR with compare function flag bits
03061    CC11  C5 9B              CMP   comp_f            ; compare with compare function flag
03062    CC13  90 67              BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
03063                                  ; was more than one <, = or >)
03064    
03065    CC15  85 9B              STA   comp_f            ; save new compare function flag
03066    CC17  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03067    CC1A  4C 01 CC           JMP   LAB_1ADE          ; go do next character
03068    
03069                                  ; token is < ">" or > "<" tokens
03070    LAB_1AFA
03071    CC1D  A6 9B              LDX   comp_f            ; get compare function flag
03072    CC1F  D0 2C              BNE   LAB_1B2A          ; branch if compare function
03073    
03074    CC21  B0 79              BCS   LAB_1B78          ; go do functions
03075    
03076                                  ; else was <  TK_GT so is operator or lower
03077    CC23  69 0A              ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
03078    CC25  90 75              BCC   LAB_1B78          ; branch if < + operator
03079    
03080                                  ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
03081    CC27  D0 07              BNE   LAB_1B0B          ; branch if not + token
03082    
03083    CC29  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
03084    CC2B  10 03              BPL   LAB_1B0B          ; branch if not string
03085    
03086                                  ; will only be $00 if type is string and token was +
03087    CC2D  4C EE D3           JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
03088                                  ; is in line, and return
03089    
03090    LAB_1B0B
03091    CC30  85 71              STA   ut1_pl            ; save it
03092    CC32  0A                 ASL                     ; *2
03093    CC33  65 71              ADC   ut1_pl            ; *3
03094    CC35  A8                 TAY                     ; copy to index
03095    LAB_1B13
03096    CC36  68                 PLA                     ; pull previous precedence
03097    CC37  D9 26 E4           CMP   LAB_OPPT,Y        ; compare with precedence byte
03098    CC3A  B0 65              BCS   LAB_1B7D          ; branch if A >=
03099    
03100    CC3C  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
03101    LAB_1B1C
03102    CC3F  48                 PHA                     ; save precedence
03103    LAB_1B1D
03104    CC40  20 68 CC           JSR   LAB_1B43          ; get vector, execute function then continue evaluation
03105    CC43  68                 PLA                     ; restore precedence
03106    CC44  A4 99              LDY   prstk             ; get precedence stacked flag
03107    CC46  10 19              BPL   LAB_1B3C          ; branch if stacked values
03108    
03109    CC48  AA                 TAX                     ; copy precedence (set flags)
03110    CC49  F0 76              BEQ   LAB_1B9D          ; exit if done
03111    
03112    CC4B  D0 5D              BNE   LAB_1B86          ; else pop FAC2 and return, branch always
03113    
03114    LAB_1B2A
03115    CC4D  26 5F              ROL   Dtypef            ; shift data type flag into Cb
03116    CC4F  8A                 TXA                     ; copy compare function flag
03117    CC50  85 5F              STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
03118    CC52  2A                 ROL                     ; shift data type into compare function byte b0
03119    CC53  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
03120    CC55  D0 02              BNE   LAB_1B34          ; branch if no underflow
03121    
03122    CC57  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
03123    LAB_1B34
03124    CC59  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
03125      000C             TK_LT_PLUS  = TK_LT-TK_PLUS
03126    CC5B  A0 24              LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
03127    CC5D  85 9B              STA   comp_f            ; save new compare function flag
03128    CC5F  D0 D5              BNE   LAB_1B13          ; branch always
03129    
03130    LAB_1B3C
03131    CC61  D9 26 E4           CMP   LAB_OPPT,Y        ;.compare with stacked function precedence
03132    CC64  B0 44              BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
03133    
03134    CC66  90 D7              BCC   LAB_1B1C          ; branch always
03135    
03136    ;.get vector, execute function then continue evaluation
03137    
03138    LAB_1B43
03139    CC68  B9 28 E4           LDA   LAB_OPPT+2,Y      ; get function vector high byte
03140    CC6B  48                 PHA                     ; onto stack
03141    CC6C  B9 27 E4           LDA   LAB_OPPT+1,Y      ; get function vector low byte
03142    CC6F  48                 PHA                     ; onto stack
03143                                  ; now push sign, round FAC1 and put on stack
03144    ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
03145    ; *** add
03146       .IF [* & $FF] == $FD
03147    ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
03148    CC70  20 7F CC           JSR   LAB_1B5B          ; function will return here, then the next RTS will call
03149                                  ; the function
03150    CC73  A5 9B              LDA   comp_f            ; get compare function flag
03151    CC75  48                 PHA                     ; push compare evaluation byte
03152    CC76  B9 26 E4           LDA   LAB_OPPT,Y        ; get precedence byte
03153    CC79  4C F1 CB           JMP   LAB_1ACC          ; continue evaluating expression
03154    
03155    LAB_1B53
03156    CC7C  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
03157    
03158    ; push sign, round FAC1 and put on stack
03159    
03160    LAB_1B5B
03161    CC7F  68                 PLA                     ; get return addr low byte
03162    CC80  85 71              STA   ut1_pl            ; save it
03163    CC82  E6 71              INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
03164                                  ; note! no check is made on the high byte! if the calling
03165                                  ; routine assembles to a page edge then this all goes
03166                                  ; horribly wrong !!!
03167    CC84  68                 PLA                     ; get return addr high byte
03168    CC85  85 72              STA   ut1_ph            ; save it
03169    CC87  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
03170    CC89  48                 PHA                     ; push sign
03171    
03172    ; round FAC1 and put on stack
03173    
03174    ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
03175    ; *** replace
03176    ;LAB_1B66
03177    ;      JSR   LAB_27BA          ; round FAC1
03178    ; *** with
03179    CC8A  20 EC D9           JSR   LAB_27BA          ; round FAC1
03180    LAB_1B66
03181    ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
03182    CC8D  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03183    CC8F  48                 PHA                     ; push on stack
03184    CC90  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03185    CC92  48                 PHA                     ; push on stack
03186    CC93  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
03187    CC95  48                 PHA                     ; push on stack
03188    CC96  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03189    CC98  48                 PHA                     ; push on stack
03190    CC99  6C 71 00           JMP   (ut1_pl)          ; return, sort of
03191    
03192    ; do functions
03193    
03194    LAB_1B78
03195    CC9C  A0 FF              LDY   #$FF              ; flag function
03196    CC9E  68                 PLA                     ; pull precedence byte
03197    LAB_1B7B
03198    CC9F  F0 20              BEQ   LAB_1B9D          ; exit if done
03199    
03200    LAB_1B7D
03201    CCA1  C9 64              CMP   #$64              ; compare previous precedence with $64
03202    CCA3  F0 03              BEQ   LAB_1B84          ; branch if was $64 (< function)
03203    
03204    CCA5  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
03205    LAB_1B84
03206    CCA8  84 99              STY   prstk             ; save precedence stacked flag
03207    
03208                                  ; pop FAC2 and return
03209    LAB_1B86
03210    CCAA  68                 PLA                     ; pop byte
03211    CCAB  4A                 LSR                     ; shift out comparison evaluation lowest bit
03212    CCAC  85 63              STA   Cflag             ; save comparison evaluation flag
03213    CCAE  68                 PLA                     ; pop exponent
03214    CCAF  85 B3              STA   FAC2_e            ; save FAC2 exponent
03215    CCB1  68                 PLA                     ; pop mantissa1
03216    CCB2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
03217    CCB4  68                 PLA                     ; pop mantissa2
03218    CCB5  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
03219    CCB7  68                 PLA                     ; pop mantissa3
03220    CCB8  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
03221    CCBA  68                 PLA                     ; pop sign
03222    CCBB  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
03223    CCBD  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
03224    CCBF  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
03225    LAB_1B9D
03226    CCC1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03227    CCC3  60                 RTS
03228    
03229    ; print "..." string to string util area
03230    
03231    LAB_1BC1
03232    CCC4  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
03233    CCC6  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
03234    CCC8  69 00              ADC   #$00              ; add carry to low byte
03235    CCCA  90 01              BCC   LAB_1BCA          ; branch if no overflow
03236    
03237    CCCC  C8                 INY                     ; increment high byte
03238    LAB_1BCA
03239    CCCD  20 58 D2           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
03240    CCD0  4C E2 D5           JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
03241    
03242    ; get value from line
03243    
03244    LAB_GVAL
03245    CCD3  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03246    CCD6  B0 03              BCS   LAB_1BAC          ; branch if not numeric character
03247    
03248                                  ; else numeric string found (e.g. 123)
03249    LAB_1BA9
03250    CCD8  4C B9 DA           JMP   LAB_2887          ; get FAC1 from string and return
03251    
03252    ; get value from line .. continued
03253    
03254                                  ; wasn't a number so ..
03255    LAB_1BAC
03256    CCDB  AA                 TAX                     ; set the flags
03257    CCDC  30 2F              BMI   LAB_1BD0          ; if -ve go test token values
03258    
03259                                  ; else it is either a string, number, variable or (<expr>)
03260    CCDE  C9 24              CMP   #'$'              ; compare with "$"
03261    CCE0  F0 F6              BEQ   LAB_1BA9          ; branch if "$", hex number
03262    
03263    CCE2  C9 25              CMP   #'%'              ; else compare with "%"
03264    CCE4  F0 F2              BEQ   LAB_1BA9          ; branch if "%", binary number
03265    
03266    CCE6  C9 2E              CMP   #'.'              ; compare with "."
03267    CCE8  F0 EE              BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
03268    
03269                                  ; it wasn't any sort of number so ..
03270    CCEA  C9 22              CMP   #$22              ; compare with "
03271    CCEC  F0 D6              BEQ   LAB_1BC1          ; branch if open quote
03272    
03273                                  ; wasn't any sort of number so ..
03274    
03275    ; evaluate expression within parentheses
03276    
03277    CCEE  C9 28              CMP   #'('              ; compare with "("
03278    CCF0  D0 5B              BNE   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
03279    
03280    LAB_1BF7
03281    CCF2  20 EF CB           JSR   LAB_EVEZ          ; evaluate expression, no decrement
03282    
03283    ; all the 'scan for' routines return the character after the sought character
03284    
03285    ; scan for ")" , else do syntax error then warm start
03286    
03287    LAB_1BFB
03288    CCF5  A9 29              LDA   #$29              ; load A with ")"
03289    
03290    ; scan for CHR$(A) , else do syntax error then warm start
03291    
03292    LAB_SCCA
03293    CCF7  A0 00              LDY   #$00              ; clear index
03294    CCF9  D1 C3              CMP   (Bpntrl),Y        ; check next byte is = A
03295    CCFB  D0 0B              BNE   LAB_SNER          ; if not do syntax error then warm start
03296    
03297    CCFD  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then return
03298    
03299    ; scan for "(" , else do syntax error then warm start
03300    
03301    LAB_1BFE
03302    CD00  A9 28              LDA   #$28              ; load A with "("
03303    CD02  D0 F3              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
03304                                  ; (branch always)
03305    
03306    ; scan for "," , else do syntax error then warm start
03307    
03308    LAB_1C01
03309    CD04  A9 2C              LDA   #$2C              ; load A with ","
03310    CD06  D0 EF              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
03311                                  ; (branch always)
03312    
03313    ; syntax error then warm start
03314    
03315    LAB_SNER
03316    CD08  A2 02              LDX   #$02              ; error code $02 ("Syntax" error)
03317    CD0A  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
03318    
03319    ; get value from line .. continued
03320    ; do tokens
03321    
03322    LAB_1BD0
03323    CD0D  C9 C1              CMP   #TK_MINUS         ; compare with token for -
03324    CD0F  F0 29              BEQ   LAB_1C11          ; branch if - token (do set-up for functions)
03325    
03326                                  ; wasn't -n so ..
03327    CD11  C9 C0              CMP   #TK_PLUS          ; compare with token for +
03328    CD13  F0 BE              BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
03329    
03330    CD15  C9 BB              CMP   #TK_NOT           ; compare with token for NOT
03331    CD17  D0 13              BNE   LAB_1BE7          ; branch if not token for NOT
03332    
03333                                  ; was NOT token
03334      000B             TK_EQUAL_PLUS     = TK_EQUAL-TK_PLUS
03335    CD19  A0 21              LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
03336    CD1B  D0 1F              BNE   LAB_1C13          ; do set-up for function then execute (branch always)
03337    
03338    ; do = compare
03339    
03340    LAB_EQUAL
03341    CD1D  20 BA CF           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
03342    CD20  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03343    CD22  49 FF              EOR   #$FF              ; invert it
03344    CD24  A8                 TAY                     ; copy it
03345    CD25  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03346    CD27  49 FF              EOR   #$FF              ; invert it
03347    CD29  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03348    
03349    ; get value from line .. continued
03350    
03351                                  ; wasn't +, -, or NOT so ..
03352    LAB_1BE7
03353    CD2C  C9 B8              CMP   #TK_FN            ; compare with token for FN
03354    CD2E  D0 03              BNE   LAB_1BEE          ; branch if not token for FN
03355    
03356    CD30  4C C8 D1           JMP   LAB_201E          ; go evaluate FNx
03357    
03358    ; get value from line .. continued
03359    
03360                                  ; wasn't +, -, NOT or FN so ..
03361    LAB_1BEE
03362    CD33  E9 CD              SBC   #TK_SGN           ; subtract with token for SGN
03363    CD35  B0 27              BCS   LAB_1C27          ; if a function token go do it
03364    
03365    CD37  4C 08 CD           JMP   LAB_SNER          ; else do syntax error
03366    
03367    ; set-up for functions
03368    
03369    LAB_1C11
03370      000A             TK_GT_PLUS  = TK_GT-TK_PLUS
03371    CD3A  A0 1E              LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
03372    LAB_1C13
03373    CD3C  68                 PLA                     ; dump return address low byte
03374    ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
03375    ; *** replace
03376    ;      PLA                     ; dump return address high byte
03377    ;      JMP   LAB_1B1D          ; execute function then continue evaluation
03378    ; *** with
03379    CD3D  AA                 TAX                     ; save to trap concatenate
03380    CD3E  68                 PLA                     ; dump return address high byte
03381    CD3F  E0 F6              CPX   #<[LAB_224Da+2]   ; from concatenate low return address?
03382    CD41  D0 04              BNE   LAB_1C13b         ; No - continue!
03383    CD43  C9 D3              CMP   #>[LAB_224Da+2]   ; from concatenate high return address?
03384    CD45  F0 03              BEQ   LAB_1C13a         ; Yes - error!
03385    LAB_1C13b
03386    CD47  4C 40 CC           JMP   LAB_1B1D          ; execute function then continue evaluation
03387    LAB_1C13a
03388    CD4A  4C E2 CB           JMP   LAB_1ABC          ; throw "type mismatch error" then warm start      
03389    ; *** end   patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
03390    
03391    ; variable name set-up
03392    ; get (var), return value in FAC_1 and $ flag
03393    
03394    LAB_1C18
03395    CD4D  20 BE CE           JSR   LAB_GVAR          ; get (var) address
03396    CD50  85 AE              STA   FAC1_2            ; save address low byte in FAC1 mantissa2
03397    CD52  84 AF              STY   FAC1_3            ; save address high byte in FAC1 mantissa3
03398    CD54  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
03399    CD56  30 03              BMI   LAB_1C25          ; if string then return (does RTS)
03400    
03401    LAB_1C24
03402    CD58  4C 90 D9           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
03403    
03404    LAB_1C25
03405    ; *** begin patch  string pointer high byte trashed when moved to stack
03406    ; *** add
03407    CD5B  46 B9              LSR   FAC1_r            ; clear bit 7 (<$80) = do not round up
03408    ; *** end patch 
03409    CD5D  60                 RTS
03410    
03411    ; get value from line .. continued
03412    ; only functions left so ..
03413    
03414    ; set up function references
03415    
03416    ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
03417    ; to process function calls. now the function vector is computed and pushed on the stack
03418    ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
03419    ; is calculated and the routine called, if not this routine just does RTS. whichever
03420    ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
03421    ; the function code
03422    
03423    ; this also removes some less than elegant code that was used to bypass type checking
03424    ; for functions that returned strings
03425    
03426    LAB_1C27
03427    CD5E  0A                 ASL                     ; *2 (2 bytes per function address)
03428    CD5F  A8                 TAY                     ; copy to index
03429    
03430    CD60  B9 DD E3           LDA   LAB_FTBM,Y        ; get function jump vector high byte
03431    CD63  48                 PHA                     ; push functions jump vector high byte
03432    CD64  B9 DC E3           LDA   LAB_FTBL,Y        ; get function jump vector low byte
03433    CD67  48                 PHA                     ; push functions jump vector low byte
03434    
03435    CD68  B9 93 E3           LDA   LAB_FTPM,Y        ; get function pre process vector high byte
03436    CD6B  F0 05              BEQ   LAB_1C56          ; skip pre process if null vector
03437    
03438    CD6D  48                 PHA                     ; push functions pre process vector high byte
03439    CD6E  B9 92 E3           LDA   LAB_FTPL,Y        ; get function pre process vector low byte
03440    CD71  48                 PHA                     ; push functions pre process vector low byte
03441    
03442    LAB_1C56
03443    CD72  60                 RTS                     ; do function, or pre process, call
03444    
03445    ; process string expression in parenthesis
03446    
03447    LAB_PPFS
03448    CD73  20 F2 CC           JSR   LAB_1BF7          ; process expression in parenthesis
03449    CD76  4C D8 CB           JMP   LAB_CTST          ; check if source is string then do function,
03450                                  ; else do type mismatch
03451    
03452    ; process numeric expression in parenthesis
03453    
03454    LAB_PPFN
03455    CD79  20 F2 CC           JSR   LAB_1BF7          ; process expression in parenthesis
03456    CD7C  4C D6 CB           JMP   LAB_CTNM          ; check if source is numeric then do function,
03457                                  ; else do type mismatch
03458    
03459    ; set numeric data type and increment BASIC execute pointer
03460    
03461    LAB_PPBI
03462    CD7F  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
03463    CD81  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then do function
03464    
03465    ; process string for LEFT$, RIGHT$ or MID$
03466    
03467    LAB_LRMS
03468    CD84  20 EF CB           JSR   LAB_EVEZ          ; evaluate (should be string) expression
03469    CD87  20 04 CD           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
03470    CD8A  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
03471    
03472    CD8D  68                 PLA                     ; get function jump vector low byte
03473    CD8E  AA                 TAX                     ; save functions jump vector low byte
03474    CD8F  68                 PLA                     ; get function jump vector high byte
03475    CD90  A8                 TAY                     ; save functions jump vector high byte
03476    CD91  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
03477    CD93  48                 PHA                     ; push string pointer high byte
03478    CD94  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
03479    CD96  48                 PHA                     ; push string pointer low byte
03480    CD97  98                 TYA                     ; get function jump vector high byte back
03481    CD98  48                 PHA                     ; save functions jump vector high byte
03482    CD99  8A                 TXA                     ; get function jump vector low byte back
03483    CD9A  48                 PHA                     ; save functions jump vector low byte
03484    CD9B  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
03485    CD9E  8A                 TXA                     ; copy byte parameter to A
03486    CD9F  60                 RTS                     ; go do function
03487    
03488    ; process numeric expression(s) for BIN$ or HEX$
03489    
03490    LAB_BHSS
03491    CDA0  20 EF CB           JSR   LAB_EVEZ          ; process expression
03492    CDA3  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
03493    CDA6  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03494    CDA8  C9 98              CMP   #$98              ; compare with exponent = 2^24
03495    CDAA  B0 20              BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
03496    
03497    CDAC  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
03498    CDAF  A2 02              LDX   #$02              ; 3 bytes to do
03499    LAB_CFAC
03500    CDB1  B5 AD              LDA   FAC1_1,X          ; get byte from FAC1
03501    CDB3  95 11              STA   nums_1,X          ; save byte to temp
03502    CDB5  CA                 DEX                     ; decrement index
03503    CDB6  10 F9              BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
03504    
03505    CDB8  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
03506    CDBB  A2 00              LDX   #$00              ; set default to no leading "0"s
03507    CDBD  C9 29              CMP   #')'              ; compare with close bracket
03508    CDBF  F0 0A              BEQ   LAB_1C54          ; if ")" go do rest of function
03509    
03510    CDC1  20 F1 D5           JSR   LAB_SCGB          ; scan for "," and get byte
03511    CDC4  20 C2 00           JSR   LAB_GBYT          ; get last byte back
03512    CDC7  C9 29              CMP   #')'              ; is next character )
03513    CDC9  D0 01              BNE   LAB_BHER          ; if not ")" go do error
03514    
03515    LAB_1C54
03516    CDCB  60                 RTS                     ; else do function
03517    
03518    LAB_BHER
03519    CDCC  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
03520    
03521    ; perform EOR
03522    
03523    ; added operator format is the same as AND or OR, precedence is the same as OR
03524    
03525    ; this bit worked first time but it took a while to sort out the operator table
03526    ; pointers and offsets afterwards!
03527    
03528    LAB_EOR
03529    CDCF  20 F6 CD           JSR   GetFirst          ; get first integer expression (no sign check)
03530    CDD2  45 5B              EOR   XOAw_l            ; EOR with expression 1 low byte
03531    CDD4  A8                 TAY                     ; save in Y
03532    CDD5  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03533    CDD7  45 5C              EOR   XOAw_h            ; EOR with expression 1 high byte
03534    CDD9  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03535    
03536    ; perform OR
03537    
03538    LAB_OR
03539    CDDC  20 F6 CD           JSR   GetFirst          ; get first integer expression (no sign check)
03540    CDDF  05 5B              ORA   XOAw_l            ; OR with expression 1 low byte
03541    CDE1  A8                 TAY                     ; save in Y
03542    CDE2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03543    CDE4  05 5C              ORA   XOAw_h            ; OR with expression 1 high byte
03544    CDE6  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03545    
03546    ; perform AND
03547    
03548    LAB_AND
03549    CDE9  20 F6 CD           JSR   GetFirst          ; get first integer expression (no sign check)
03550    CDEC  25 5B              AND   XOAw_l            ; AND with expression 1 low byte
03551    CDEE  A8                 TAY                     ; save in Y
03552    CDEF  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03553    CDF1  25 5C              AND   XOAw_h            ; AND with expression 1 high byte
03554    CDF3  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03555    
03556    ; get first value for OR, AND or EOR
03557    
03558    GetFirst
03559    CDF6  20 BA CF           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
03560    CDF9  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03561    CDFB  85 5C              STA   XOAw_h            ; save it
03562    CDFD  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03563    CDFF  85 5B              STA   XOAw_l            ; save it
03564    CE01  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
03565    CE04  20 BA CF           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
03566    CE07  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03567    LAB_1C95
03568    CE09  60                 RTS
03569    
03570    ; perform comparisons
03571    
03572    ; do < compare
03573    
03574    LAB_LTHAN
03575    CE0A  20 D9 CB           JSR   LAB_CKTM          ; type match check, set C for string
03576    CE0D  B0 13              BCS   LAB_1CAE          ; branch if string
03577    
03578                                  ; do numeric < compare
03579    CE0F  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
03580    CE11  09 7F              ORA   #$7F              ; set all non sign bits
03581    CE13  25 B4              AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
03582    CE15  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
03583    CE17  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
03584    CE19  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
03585    CE1B  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
03586    CE1E  AA                 TAX                     ; copy result
03587    CE1F  4C 53 CE           JMP   LAB_1CE1          ; go evaluate result
03588    
03589                                  ; do string < compare
03590    LAB_1CAE
03591    CE22  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
03592    CE24  C6 9B              DEC   comp_f            ; clear < bit in compare function flag
03593    CE26  20 58 D4           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
03594                                  ; space returns with A = length, X=pointer low byte,
03595                                  ; Y=pointer high byte
03596    CE29  85 AC              STA   str_ln            ; save length
03597    CE2B  86 AD              STX   str_pl            ; save string pointer low byte
03598    CE2D  84 AE              STY   str_ph            ; save string pointer high byte
03599    CE2F  A5 B5              LDA   FAC2_2            ; get descriptor pointer low byte
03600    CE31  A4 B6              LDY   FAC2_3            ; get descriptor pointer high byte
03601    CE33  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
03602                                  ; returns with A = length, X=pointer low byte,
03603                                  ; Y=pointer high byte
03604    CE36  86 B5              STX   FAC2_2            ; save string pointer low byte
03605    CE38  84 B6              STY   FAC2_3            ; save string pointer high byte
03606    CE3A  AA                 TAX                     ; copy length
03607    CE3B  38                 SEC                     ; set carry for subtract
03608    CE3C  E5 AC              SBC   str_ln            ; subtract string 1 length
03609    CE3E  F0 08              BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
03610    
03611    CE40  A9 01              LDA   #$01              ; set str 1 length > string 2 length
03612    CE42  90 04              BCC   LAB_1CD6          ; branch if so
03613    
03614    CE44  A6 AC              LDX   str_ln            ; get string 1 length
03615    CE46  A9 FF              LDA   #$FF              ; set str 1 length < string 2 length
03616    LAB_1CD6
03617    CE48  85 B0              STA   FAC1_s            ; save length compare
03618    CE4A  A0 FF              LDY   #$FF              ; set index
03619    CE4C  E8                 INX                     ; adjust for loop
03620    LAB_1CDB
03621    CE4D  C8                 INY                     ; increment index
03622    CE4E  CA                 DEX                     ; decrement count
03623    CE4F  D0 07              BNE   LAB_1CE6          ; branch if still bytes to do
03624    
03625    CE51  A6 B0              LDX   FAC1_s            ; get length compare back
03626    LAB_1CE1
03627    CE53  30 0F              BMI   LAB_1CF2          ; branch if str 1 < str 2
03628    
03629    CE55  18                 CLC                     ; flag str 1 <= str 2
03630    CE56  90 0C              BCC   LAB_1CF2          ; go evaluate result
03631    
03632    LAB_1CE6
03633    CE58  B1 B5              LDA   (FAC2_2),Y        ; get string 2 byte
03634    CE5A  D1 AD              CMP   (FAC1_1),Y        ; compare with string 1 byte
03635    CE5C  F0 EF              BEQ   LAB_1CDB          ; loop if bytes =
03636    
03637    CE5E  A2 FF              LDX   #$FF              ; set str 1 < string 2
03638    CE60  B0 02              BCS   LAB_1CF2          ; branch if so
03639    
03640    CE62  A2 01              LDX   #$01              ;  set str 1 > string 2
03641    LAB_1CF2
03642    CE64  E8                 INX                     ; x = 0, 1 or 2
03643    CE65  8A                 TXA                     ; copy to A
03644    CE66  2A                 ROL                     ; *2 (1, 2 or 4)
03645    CE67  25 63              AND   Cflag             ; AND with comparison evaluation flag
03646    CE69  F0 02              BEQ   LAB_1CFB          ; branch if 0 (compare is false)
03647    
03648    CE6B  A9 FF              LDA   #$FF              ; else set result true
03649    LAB_1CFB
03650    CE6D  4C 0D DA           JMP   LAB_27DB          ; save A as integer byte and return
03651    
03652    LAB_1CFE
03653    CE70  20 04 CD           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
03654    
03655    ; perform DIM
03656    
03657    LAB_DIM
03658    CE73  AA                 TAX                     ; copy "DIM" flag to X
03659    CE74  20 C3 CE           JSR   LAB_1D10          ; search for variable
03660    CE77  20 C2 00           JSR   LAB_GBYT          ; scan memory
03661    CE7A  D0 F4              BNE   LAB_1CFE          ; scan for "," and loop if not null
03662    
03663    CE7C  60                 RTS
03664    
03665    ; perform << (left shift)
03666    
03667    LAB_LSHIFT
03668    CE7D  20 B3 CE           JSR   GetPair           ; get integer expression and byte (no sign check)
03669    CE80  A5 AE              LDA   FAC1_2            ; get expression high byte
03670    CE82  A6 78              LDX   TempB             ; get shift count
03671    CE84  F0 22              BEQ   NoShift           ; branch if zero
03672    
03673    CE86  E0 10              CPX   #$10              ; compare bit count with 16d
03674    CE88  B0 23              BCS   TooBig            ; branch if >=
03675    
03676    Ls_loop
03677    CE8A  06 AF              ASL   FAC1_3            ; shift low byte
03678    CE8C  2A                 ROL                     ; shift high byte
03679    CE8D  CA                 DEX                     ; decrement bit count
03680    CE8E  D0 FA              BNE   Ls_loop           ; loop if shift not complete
03681    
03682    CE90  A4 AF              LDY   FAC1_3            ; get expression low byte
03683    CE92  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03684    
03685    ; perform >> (right shift)
03686    
03687    LAB_RSHIFT
03688    CE95  20 B3 CE           JSR   GetPair           ; get integer expression and byte (no sign check)
03689    CE98  A5 AE              LDA   FAC1_2            ; get expression high byte
03690    CE9A  A6 78              LDX   TempB             ; get shift count
03691    CE9C  F0 0A              BEQ   NoShift           ; branch if zero
03692    
03693    CE9E  E0 10              CPX   #$10              ; compare bit count with 16d
03694    CEA0  B0 0B              BCS   TooBig            ; branch if >=
03695    
03696    Rs_loop
03697    CEA2  4A                 LSR                     ; shift high byte
03698    CEA3  66 AF              ROR   FAC1_3            ; shift low byte
03699    CEA5  CA                 DEX                     ; decrement bit count
03700    CEA6  D0 FA              BNE   Rs_loop           ; loop if shift not complete
03701    
03702    NoShift
03703    CEA8  A4 AF              LDY   FAC1_3            ; get expression low byte
03704    CEAA  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03705    
03706    TooBig
03707    CEAD  A9 00              LDA   #$00              ; clear high byte
03708    CEAF  A8                 TAY                     ; copy to low byte
03709    CEB0  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03710    
03711    GetPair
03712    CEB3  20 A9 D5           JSR   LAB_EVBY          ; evaluate byte expression, result in X
03713    CEB6  86 78              STX   TempB             ; save it
03714    CEB8  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
03715    CEBB  4C BA CF           JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
03716    
03717    ; search for variable
03718    
03719    ; return pointer to variable in Cvaral/Cvarah
03720    
03721    LAB_GVAR
03722    CEBE  A2 00              LDX   #$00              ; set DIM flag = $00
03723    CEC0  20 C2 00           JSR   LAB_GBYT          ; scan memory (1st character)
03724    LAB_1D10
03725    CEC3  86 5E              STX   Defdim            ; save DIM flag
03726    LAB_1D12
03727    CEC5  85 93              STA   Varnm1            ; save 1st character
03728    CEC7  29 7F              AND   #$7F              ; clear FN flag bit
03729    CEC9  20 32 CF           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
03730    CECC  B0 03              BCS   LAB_1D1F          ; branch if ok
03731    
03732    CECE  4C 08 CD           JMP   LAB_SNER          ; else syntax error then warm start
03733    
03734                                  ; was variable name so ..
03735    LAB_1D1F
03736    CED1  A2 00              LDX   #$00              ; clear 2nd character temp
03737    CED3  86 5F              STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
03738    CED5  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (2nd character)
03739    CED8  90 05              BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
03740    
03741                                  ; 2nd character wasn't "0" to "9" so ..
03742    CEDA  20 32 CF           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
03743    CEDD  90 0B              BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
03744    
03745    LAB_1D2D
03746    CEDF  AA                 TAX                     ; copy 2nd character
03747    
03748                                  ; ignore further (valid) characters in the variable name
03749    LAB_1D2E
03750    CEE0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (3rd character)
03751    CEE3  90 FB              BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
03752    
03753    CEE5  20 32 CF           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
03754    CEE8  B0 F6              BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
03755    
03756                                  ; check if string variable
03757    LAB_1D38
03758    CEEA  C9 24              CMP   #'$'              ; compare with "$"
03759    CEEC  D0 0B              BNE   LAB_1D47          ; branch if not string
03760    
03761    ; to introduce a new variable type (% suffix for integers say) then this branch
03762    ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
03763    
03764                                  ; type is string
03765    CEEE  A9 FF              LDA   #$FF              ; set data type = string
03766    CEF0  85 5F              STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
03767    CEF2  8A                 TXA                     ; get 2nd character back
03768    CEF3  09 80              ORA   #$80              ; set top bit (indicate string var)
03769    CEF5  AA                 TAX                     ; copy back to 2nd character temp
03770    CEF6  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03771    
03772    ; after we have determined the variable type we need to come back here to determine
03773    ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
03774    
03775    
03776    LAB_1D47                      ; gets here with character after var name in A
03777    CEF9  86 94              STX   Varnm2            ; save 2nd character
03778    CEFB  05 61              ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
03779    CEFD  C9 28              CMP   #'('              ; compare with "("
03780    CEFF  D0 03              BNE   LAB_1D53          ; branch if not "("
03781    
03782    CF01  4C CC CF           JMP   LAB_1E17          ; go find, or make, array
03783    
03784    ; either find or create var
03785    ; var name (1st two characters only!) is in Varnm1,Varnm2
03786    
03787                                  ; variable name wasn't var(... so look for plain var
03788    LAB_1D53
03789    CF04  A9 00              LDA   #$00              ; clear A
03790    CF06  85 61              STA   Sufnxf            ; clear subscript/FNX flag
03791    CF08  A5 7B              LDA   Svarl             ; get start of vars low byte
03792    CF0A  A6 7C              LDX   Svarh             ; get start of vars high byte
03793    CF0C  A0 00              LDY   #$00              ; clear index
03794    LAB_1D5D
03795    CF0E  86 AB              STX   Vrschh            ; save search address high byte
03796    LAB_1D5F
03797    CF10  85 AA              STA   Vrschl            ; save search address low byte
03798    CF12  E4 7E              CPX   Sarryh            ; compare high address with var space end
03799    CF14  D0 04              BNE   LAB_1D69          ; skip next compare if <>
03800    
03801                                  ; high addresses were = so compare low addresses
03802    CF16  C5 7D              CMP   Sarryl            ; compare low address with var space end
03803    CF18  F0 2C              BEQ   LAB_1D8B          ; if not found go make new var
03804    
03805    LAB_1D69
03806    CF1A  A5 93              LDA   Varnm1            ; get 1st character of var to find
03807    CF1C  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 1st character
03808    CF1E  D0 08              BNE   LAB_1D77          ; branch if no match
03809    
03810                                  ; 1st characters match so compare 2nd characters
03811    CF20  A5 94              LDA   Varnm2            ; get 2nd character of var to find
03812    CF22  C8                 INY                     ; index to point to variable name 2nd character
03813    CF23  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 2nd character
03814    CF25  F0 69              BEQ   LAB_1DD7          ; branch if match (found var)
03815    
03816    CF27  88                 DEY                     ; else decrement index (now = $00)
03817    LAB_1D77
03818    CF28  18                 CLC                     ; clear carry for add
03819    CF29  A5 AA              LDA   Vrschl            ; get search address low byte
03820    CF2B  69 06              ADC   #$06              ; +6 (offset to next var name)
03821    CF2D  90 E1              BCC   LAB_1D5F          ; loop if no overflow to high byte
03822    
03823    CF2F  E8                 INX                     ; else increment high byte
03824    CF30  D0 DC              BNE   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
03825    
03826    ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
03827    
03828    LAB_CASC
03829    CF32  C9 61              CMP   #'a'              ; compare with "a"
03830    CF34  B0 0A              BCS   LAB_1D83          ; go check <"z"+1
03831    
03832    ; check byte, return C=0 if<"A" or >"Z"
03833    
03834    LAB_1D82
03835    CF36  C9 41              CMP   #'A'              ; compare with "A"
03836    CF38  90 05              BCC   LAB_1D8A          ; exit if less
03837    
03838                                  ; carry is set
03839    CF3A  E9 5B              SBC   #$5B              ; subtract "Z"+1
03840    CF3C  38                 SEC                     ; set carry
03841    CF3D  E9 A5              SBC   #$A5              ; subtract $A5 (restore byte)
03842                                  ; carry clear if byte>$5A
03843    LAB_1D8A
03844    CF3F  60                 RTS
03845    
03846    LAB_1D83
03847    CF40  E9 7B              SBC   #$7B              ; subtract "z"+1
03848    CF42  38                 SEC                     ; set carry
03849    CF43  E9 85              SBC   #$85              ; subtract $85 (restore byte)
03850                                  ; carry clear if byte>$7A
03851    CF45  60                 RTS
03852    
03853                                  ; reached end of variable mem without match
03854                                  ; .. so create new variable
03855    LAB_1D8B
03856    CF46  68                 PLA                     ; pop return address low byte
03857    CF47  48                 PHA                     ; push return address low byte
03858      CD4F             LAB_1C18p2  = LAB_1C18+2
03859    CF48  C9 4F              CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
03860    CF4A  D0 05              BNE   LAB_1D98          ; if not get (var) go create new var
03861    
03862    ; This will only drop through if the call was from LAB_1C18 and is only called
03863    ; from there if it is searching for a variable from the RHS of a LET a=b statement
03864    ; it prevents the creation of variables not assigned a value.
03865    
03866    ; value returned by this is either numeric zero (exponent byte is $00) or null string
03867    ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
03868    
03869    ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
03870    
03871    ; this is where you would put the undefined variable error call e.g.
03872    
03873    ;                             ; variable doesn't exist so flag error
03874    ;     LDX   #$24              ; error code $24 ("undefined variable" error)
03875    ;     JMP   LAB_XERR          ; do error #X then warm start
03876    
03877    ; the above code has been tested and works a treat! (it replaces the three code lines
03878    ; below)
03879    
03880                                  ; else return dummy null value
03881    CF4C  A9 02              LDA   #<LAB_1D96        ; low byte point to $00,$00
03882                                  ; (uses part of misc constants table)
03883    CF4E  A0 E3              LDY   #>LAB_1D96        ; high byte point to $00,$00
03884    CF50  60                 RTS
03885    
03886                                  ; create new numeric variable
03887    LAB_1D98
03888    CF51  A5 7D              LDA   Sarryl            ; get var mem end low byte
03889    CF53  A4 7E              LDY   Sarryh            ; get var mem end high byte
03890    CF55  85 AA              STA   Ostrtl            ; save old block start low byte
03891    CF57  84 AB              STY   Ostrth            ; save old block start high byte
03892    CF59  A5 7F              LDA   Earryl            ; get array mem end low byte
03893    CF5B  A4 80              LDY   Earryh            ; get array mem end high byte
03894    CF5D  85 A6              STA   Obendl            ; save old block end low byte
03895    CF5F  84 A7              STY   Obendh            ; save old block end high byte
03896    CF61  18                 CLC                     ; clear carry for add
03897    CF62  69 06              ADC   #$06              ; +6 (space for one var)
03898    CF64  90 01              BCC   LAB_1DAE          ; branch if no overflow to high byte
03899    
03900    CF66  C8                 INY                     ; else increment high byte
03901    LAB_1DAE
03902    CF67  85 A4              STA   Nbendl            ; set new block end low byte
03903    CF69  84 A5              STY   Nbendh            ; set new block end high byte
03904    CF6B  20 C1 C1           JSR   LAB_11CF          ; open up space in memory
03905    CF6E  A5 A4              LDA   Nbendl            ; get new start low byte
03906    CF70  A4 A5              LDY   Nbendh            ; get new start high byte (-$100)
03907    CF72  C8                 INY                     ; correct high byte
03908    CF73  85 7D              STA   Sarryl            ; save new var mem end low byte
03909    CF75  84 7E              STY   Sarryh            ; save new var mem end high byte
03910    CF77  A0 00              LDY   #$00              ; clear index
03911    CF79  A5 93              LDA   Varnm1            ; get var name 1st character
03912    CF7B  91 AA              STA   (Vrschl),Y        ; save var name 1st character
03913    CF7D  C8                 INY                     ; increment index
03914    CF7E  A5 94              LDA   Varnm2            ; get var name 2nd character
03915    CF80  91 AA              STA   (Vrschl),Y        ; save var name 2nd character
03916    CF82  A9 00              LDA   #$00              ; clear A
03917    CF84  C8                 INY                     ; increment index
03918    CF85  91 AA              STA   (Vrschl),Y        ; initialise var byte
03919    CF87  C8                 INY                     ; increment index
03920    CF88  91 AA              STA   (Vrschl),Y        ; initialise var byte
03921    CF8A  C8                 INY                     ; increment index
03922    CF8B  91 AA              STA   (Vrschl),Y        ; initialise var byte
03923    CF8D  C8                 INY                     ; increment index
03924    CF8E  91 AA              STA   (Vrschl),Y        ; initialise var byte
03925    
03926                                  ; found a match for var ((Vrschl) = ptr)
03927    LAB_1DD7
03928    CF90  A5 AA              LDA   Vrschl            ; get var address low byte
03929    CF92  18                 CLC                     ; clear carry for add
03930    CF93  69 02              ADC   #$02              ; +2 (offset past var name bytes)
03931    CF95  A4 AB              LDY   Vrschh            ; get var address high byte
03932    CF97  90 01              BCC   LAB_1DE1          ; branch if no overflow from add
03933    
03934    CF99  C8                 INY                     ; else increment high byte
03935    LAB_1DE1
03936    CF9A  85 95              STA   Cvaral            ; save current var address low byte
03937    CF9C  84 96              STY   Cvarah            ; save current var address high byte
03938    CF9E  60                 RTS
03939    
03940    ; set-up array pointer (Adatal/h) to first element in array
03941    ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
03942    
03943    LAB_1DE6
03944    CF9F  A5 5D              LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
03945    CFA1  0A                 ASL                     ; *2 (also clears the carry !)
03946    CFA2  69 05              ADC   #$05              ; +5 (result is 7, 9 or 11 here)
03947    CFA4  65 AA              ADC   Astrtl            ; add array start pointer low byte
03948    CFA6  A4 AB              LDY   Astrth            ; get array pointer high byte
03949    CFA8  90 01              BCC   LAB_1DF2          ; branch if no overflow
03950    
03951    CFAA  C8                 INY                     ; else increment high byte
03952    LAB_1DF2
03953    CFAB  85 A4              STA   Adatal            ; save array data pointer low byte
03954    CFAD  84 A5              STY   Adatah            ; save array data pointer high byte
03955    CFAF  60                 RTS
03956    
03957    ; evaluate integer expression
03958    
03959    LAB_EVIN
03960    CFB0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03961    CFB3  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
03962                                  ; else do type mismatch
03963    
03964    ; evaluate integer expression (no check)
03965    
03966    LAB_EVPI
03967    CFB6  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
03968    CFB8  30 0D              BMI   LAB_1E12          ; do function call error if -ve
03969    
03970    ; evaluate integer expression (no sign check)
03971    
03972    LAB_EVIR
03973    CFBA  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03974    CFBC  C9 90              CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
03975    CFBE  90 09              BCC   LAB_1E14          ; branch if n<2^16 (is ok)
03976    
03977    CFC0  A9 09              LDA   #<LAB_1DF7        ; set pointer low byte to -32768
03978    CFC2  A0 E3              LDY   #>LAB_1DF7        ; set pointer high byte to -32768
03979    CFC4  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
03980    LAB_1E12
03981    CFC7  D0 74              BNE   LAB_FCER          ; if <> do function call error then warm start
03982    
03983    LAB_1E14
03984    CFC9  4C 63 DA           JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
03985    
03986    ; find or make array
03987    
03988    LAB_1E17
03989    CFCC  A5 5E              LDA   Defdim            ; get DIM flag
03990    CFCE  48                 PHA                     ; push it
03991    CFCF  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
03992    CFD1  48                 PHA                     ; push it
03993    CFD2  A0 00              LDY   #$00              ; clear dimensions count
03994    
03995    ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
03996    
03997    LAB_1E1F
03998    CFD4  98                 TYA                     ; copy dimensions count
03999    CFD5  48                 PHA                     ; save it
04000    CFD6  A5 94              LDA   Varnm2            ; get array name 2nd byte
04001    CFD8  48                 PHA                     ; save it
04002    CFD9  A5 93              LDA   Varnm1            ; get array name 1st byte
04003    CFDB  48                 PHA                     ; save it
04004    CFDC  20 B0 CF           JSR   LAB_EVIN          ; evaluate integer expression
04005    CFDF  68                 PLA                     ; pull array name 1st byte
04006    CFE0  85 93              STA   Varnm1            ; restore array name 1st byte
04007    CFE2  68                 PLA                     ; pull array name 2nd byte
04008    CFE3  85 94              STA   Varnm2            ; restore array name 2nd byte
04009    CFE5  68                 PLA                     ; pull dimensions count
04010    CFE6  A8                 TAY                     ; restore it
04011    CFE7  BA                 TSX                     ; copy stack pointer
04012    CFE8  BD 02 01           LDA   LAB_STAK+2,X      ; get DIM flag
04013    CFEB  48                 PHA                     ; push it
04014    CFEC  BD 01 01           LDA   LAB_STAK+1,X      ; get data type flag
04015    CFEF  48                 PHA                     ; push it
04016    CFF0  A5 AE              LDA   FAC1_2            ; get this dimension size high byte
04017    CFF2  9D 02 01           STA   LAB_STAK+2,X      ; stack before flag bytes
04018    CFF5  A5 AF              LDA   FAC1_3            ; get this dimension size low byte
04019    CFF7  9D 01 01           STA   LAB_STAK+1,X      ; stack before flag bytes
04020    CFFA  C8                 INY                     ; increment dimensions count
04021    CFFB  20 C2 00           JSR   LAB_GBYT          ; scan memory
04022    CFFE  C9 2C              CMP   #','              ; compare with ","
04023    D000  F0 D2              BEQ   LAB_1E1F          ; if found go do next dimension
04024    
04025    D002  84 5D              STY   Dimcnt            ; store dimensions count
04026    D004  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
04027    D007  68                 PLA                     ; pull data type flag
04028    D008  85 5F              STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
04029    D00A  68                 PLA                     ; pull DIM flag
04030    D00B  85 5E              STA   Defdim            ; restore DIM flag
04031    D00D  A6 7D              LDX   Sarryl            ; get array mem start low byte
04032    D00F  A5 7E              LDA   Sarryh            ; get array mem start high byte
04033    
04034    ; now check to see if we are at the end of array memory (we would be if there were
04035    ; no arrays).
04036    
04037    LAB_1E5C
04038    D011  86 AA              STX   Astrtl            ; save as array start pointer low byte
04039    D013  85 AB              STA   Astrth            ; save as array start pointer high byte
04040    D015  C5 80              CMP   Earryh            ; compare with array mem end high byte
04041    D017  D0 04              BNE   LAB_1E68          ; branch if not reached array mem end
04042    
04043    D019  E4 7F              CPX   Earryl            ; else compare with array mem end low byte
04044    D01B  F0 39              BEQ   LAB_1EA1          ; go build array if not found
04045    
04046                                  ; search for array
04047    LAB_1E68
04048    D01D  A0 00              LDY   #$00              ; clear index
04049    D01F  B1 AA              LDA   (Astrtl),Y        ; get array name first byte
04050    D021  C8                 INY                     ; increment index to second name byte
04051    D022  C5 93              CMP   Varnm1            ; compare with this array name first byte
04052    D024  D0 06              BNE   LAB_1E77          ; branch if no match
04053    
04054    D026  A5 94              LDA   Varnm2            ; else get this array name second byte
04055    D028  D1 AA              CMP   (Astrtl),Y        ; compare with array name second byte
04056    D02A  F0 16              BEQ   LAB_1E8D          ; array found so branch
04057    
04058                                  ; no match
04059    LAB_1E77
04060    D02C  C8                 INY                     ; increment index
04061    D02D  B1 AA              LDA   (Astrtl),Y        ; get array size low byte
04062    D02F  18                 CLC                     ; clear carry for add
04063    D030  65 AA              ADC   Astrtl            ; add array start pointer low byte
04064    D032  AA                 TAX                     ; copy low byte to X
04065    D033  C8                 INY                     ; increment index
04066    D034  B1 AA              LDA   (Astrtl),Y        ; get array size high byte
04067    D036  65 AB              ADC   Astrth            ; add array mem pointer high byte
04068    D038  90 D7              BCC   LAB_1E5C          ; if no overflow go check next array
04069    
04070    ; do array bounds error
04071    
04072    LAB_1E85
04073    D03A  A2 10              LDX   #$10              ; error code $10 ("Array bounds" error)
04074          .byte $2C               ; makes next bit BIT LAB_08A2
04075    
04076    ; do function call error
04077    
04078    LAB_FCER
04079    D03D  A2 08              LDX   #$08              ; error code $08 ("Function call" error)
04080    LAB_1E8A
04081    D03F  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
04082    
04083                                  ; found array, are we trying to dimension it?
04084    LAB_1E8D
04085    D042  A2 12              LDX   #$12              ; set error $12 ("Double dimension" error)
04086    D044  A5 5E              LDA   Defdim            ; get DIM flag
04087    D046  D0 F7              BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
04088                                  ; start
04089    
04090    ; found the array and we're not dimensioning it so we must find an element in it
04091    
04092    D048  20 9F CF           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
04093                                  ; (Astrtl,Astrth points to start of array)
04094    D04B  A5 5D              LDA   Dimcnt            ; get dimensions count
04095    D04D  A0 04              LDY   #$04              ; set index to array's # of dimensions
04096    D04F  D1 AA              CMP   (Astrtl),Y        ; compare with no of dimensions
04097    D051  D0 E7              BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
04098                                  ; dimensions" error here .. if we want a different
04099                                  ; error message
04100    
04101    D053  4C D9 D0           JMP   LAB_1F28          ; found array so go get element
04102                                  ; (could jump to LAB_1F28 as all LAB_1F24 does is take
04103                                  ; Dimcnt and save it at (Astrtl),Y which is already the
04104                                  ; same or we would have taken the BNE)
04105    
04106                                  ; array not found, so build it
04107    LAB_1EA1
04108    D056  20 9F CF           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
04109                                  ; (Astrtl,Astrth points to start of array)
04110    D059  20 0E C2           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
04111                                  ; addr to check is in AY (low/high)
04112    D05C  A0 00              LDY   #$00              ; clear Y (don't need to clear A)
04113    D05E  84 BB              STY   Aspth             ; clear array data size high byte
04114    D060  A5 93              LDA   Varnm1            ; get variable name 1st byte
04115    D062  91 AA              STA   (Astrtl),Y        ; save array name 1st byte
04116    D064  C8                 INY                     ; increment index
04117    D065  A5 94              LDA   Varnm2            ; get variable name 2nd byte
04118    D067  91 AA              STA   (Astrtl),Y        ; save array name 2nd byte
04119    D069  A5 5D              LDA   Dimcnt            ; get dimensions count
04120    D06B  A0 04              LDY   #$04              ; index to dimension count
04121    D06D  84 BA              STY   Asptl             ; set array data size low byte (four bytes per element)
04122    D06F  91 AA              STA   (Astrtl),Y        ; set array's dimensions count
04123    
04124                                  ; now calculate the size of the data space for the array
04125    D071  18                 CLC                     ; clear carry for add (clear on subsequent loops)
04126    LAB_1EC0
04127    D072  A2 0B              LDX   #$0B              ; set default dimension value low byte
04128    D074  A9 00              LDA   #$00              ; set default dimension value high byte
04129    D076  24 5E              BIT   Defdim            ; test default DIM flag
04130    D078  50 07              BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
04131    
04132    D07A  68                 PLA                     ; else pull dimension value low byte
04133    D07B  69 01              ADC   #$01              ; +1 (allow for zeroeth element)
04134    D07D  AA                 TAX                     ; copy low byte to X
04135    D07E  68                 PLA                     ; pull dimension value high byte
04136    D07F  69 00              ADC   #$00              ; add carry from low byte
04137    
04138    LAB_1ED0
04139    D081  C8                 INY                     ; index to dimension value high byte
04140    D082  91 AA              STA   (Astrtl),Y        ; save dimension value high byte
04141    D084  C8                 INY                     ; index to dimension value high byte
04142    D085  8A                 TXA                     ; get dimension value low byte
04143    D086  91 AA              STA   (Astrtl),Y        ; save dimension value low byte
04144    D088  20 28 D1           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
04145    D08B  86 BA              STX   Asptl             ; save array data size low byte
04146    D08D  85 BB              STA   Aspth             ; save array data size high byte
04147    D08F  A4 71              LDY   ut1_pl            ; restore index (saved by subroutine)
04148    D091  C6 5D              DEC   Dimcnt            ; decrement dimensions count
04149    D093  D0 DD              BNE   LAB_1EC0          ; loop while not = 0
04150    
04151    D095  65 A5              ADC   Adatah            ; add size high byte to first element high byte
04152                                  ; (carry is always clear here)
04153    D097  B0 5D              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
04154    
04155    D099  85 A5              STA   Adatah            ; save end of array high byte
04156    D09B  A8                 TAY                     ; copy end high byte to Y
04157    D09C  8A                 TXA                     ; get array size low byte
04158    D09D  65 A4              ADC   Adatal            ; add array start low byte
04159    D09F  90 03              BCC   LAB_1EF3          ; branch if no carry
04160    
04161    D0A1  C8                 INY                     ; else increment end of array high byte
04162    D0A2  F0 52              BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
04163    
04164                                  ; set-up mostly complete, now zero the array
04165    LAB_1EF3
04166    D0A4  20 0E C2           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
04167                                  ; addr to check is in AY (low/high)
04168    D0A7  85 7F              STA   Earryl            ; save array mem end low byte
04169    D0A9  84 80              STY   Earryh            ; save array mem end high byte
04170    D0AB  A9 00              LDA   #$00              ; clear byte for array clear
04171    D0AD  E6 BB              INC   Aspth             ; increment array size high byte (now block count)
04172    D0AF  A4 BA              LDY   Asptl             ; get array size low byte (now index to block)
04173    D0B1  F0 05              BEQ   LAB_1F07          ; branch if low byte = $00
04174    
04175    LAB_1F02
04176    D0B3  88                 DEY                     ; decrement index (do 0 to n-1)
04177    D0B4  91 A4              STA   (Adatal),Y        ; zero byte
04178    D0B6  D0 FB              BNE   LAB_1F02          ; loop until this block done
04179    
04180    LAB_1F07
04181    D0B8  C6 A5              DEC   Adatah            ; decrement array pointer high byte
04182    D0BA  C6 BB              DEC   Aspth             ; decrement block count high byte
04183    D0BC  D0 F5              BNE   LAB_1F02          ; loop until all blocks done
04184    
04185    D0BE  E6 A5              INC   Adatah            ; correct for last loop
04186    D0C0  38                 SEC                     ; set carry for subtract
04187    D0C1  A0 02              LDY   #$02              ; index to array size low byte
04188    D0C3  A5 7F              LDA   Earryl            ; get array mem end low byte
04189    D0C5  E5 AA              SBC   Astrtl            ; subtract array start low byte
04190    D0C7  91 AA              STA   (Astrtl),Y        ; save array size low byte
04191    D0C9  C8                 INY                     ; index to array size high byte
04192    D0CA  A5 80              LDA   Earryh            ; get array mem end high byte
04193    D0CC  E5 AB              SBC   Astrth            ; subtract array start high byte
04194    D0CE  91 AA              STA   (Astrtl),Y        ; save array size high byte
04195    D0D0  A5 5E              LDA   Defdim            ; get default DIM flag
04196    D0D2  D0 53              BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
04197    
04198                                  ; else, find element
04199    D0D4  C8                 INY                     ; index to # of dimensions
04200    
04201    LAB_1F24
04202    D0D5  B1 AA              LDA   (Astrtl),Y        ; get array's dimension count
04203    D0D7  85 5D              STA   Dimcnt            ; save it
04204    
04205    ; we have found, or built, the array. now we need to find the element
04206    
04207    LAB_1F28
04208    D0D9  A9 00              LDA   #$00              ; clear byte
04209    D0DB  85 BA              STA   Asptl             ; clear array data pointer low byte
04210    LAB_1F2C
04211    D0DD  85 BB              STA   Aspth             ; save array data pointer high byte
04212    D0DF  C8                 INY                     ; increment index (point to array bound high byte)
04213    D0E0  68                 PLA                     ; pull array index low byte
04214    D0E1  AA                 TAX                     ; copy to X
04215    D0E2  85 AE              STA   FAC1_2            ; save index low byte to FAC1 mantissa2
04216    D0E4  68                 PLA                     ; pull array index high byte
04217    D0E5  85 AF              STA   FAC1_3            ; save index high byte to FAC1 mantissa3
04218    D0E7  D1 AA              CMP   (Astrtl),Y        ; compare with array bound high byte
04219    D0E9  90 0E              BCC   LAB_1F48          ; branch if within bounds
04220    
04221    D0EB  D0 06              BNE   LAB_1F42          ; if outside bounds do array bounds error
04222    
04223                                  ; else high byte was = so test low bytes
04224    D0ED  C8                 INY                     ; index to array bound low byte
04225    D0EE  8A                 TXA                     ; get array index low byte
04226    D0EF  D1 AA              CMP   (Astrtl),Y        ; compare with array bound low byte
04227    D0F1  90 07              BCC   LAB_1F49          ; branch if within bounds
04228    
04229    LAB_1F42
04230    D0F3  4C 3A D0           JMP   LAB_1E85          ; else do array bounds error
04231    
04232    LAB_1F45
04233    D0F6  4C 3D C2           JMP   LAB_OMER          ; do "Out of memory" error then warm start
04234    
04235    LAB_1F48
04236    D0F9  C8                 INY                     ; index to array bound low byte
04237    LAB_1F49
04238    D0FA  A5 BB              LDA   Aspth             ; get array data pointer high byte
04239    D0FC  05 BA              ORA   Asptl             ; OR with array data pointer low byte
04240    D0FE  F0 0A              BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
04241    
04242    D100  20 28 D1           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
04243    D103  8A                 TXA                     ; get result low byte
04244    D104  65 AE              ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
04245    D106  AA                 TAX                     ; save result low byte
04246    D107  98                 TYA                     ; get result high byte
04247    D108  A4 71              LDY   ut1_pl            ; restore index
04248    LAB_1F5A
04249    D10A  65 AF              ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
04250    D10C  86 BA              STX   Asptl             ; save array data pointer low byte
04251    D10E  C6 5D              DEC   Dimcnt            ; decrement dimensions count
04252    D110  D0 CB              BNE   LAB_1F2C          ; loop if dimensions still to do
04253    
04254    D112  06 BA              ASL   Asptl             ; array data pointer low byte * 2
04255    D114  2A                 ROL                     ; array data pointer high byte * 2
04256    D115  06 BA              ASL   Asptl             ; array data pointer low byte * 4
04257    D117  2A                 ROL                     ; array data pointer high byte * 4
04258    D118  A8                 TAY                     ; copy high byte
04259    D119  A5 BA              LDA   Asptl             ; get low byte
04260    D11B  65 A4              ADC   Adatal            ; add array data start pointer low byte
04261    D11D  85 95              STA   Cvaral            ; save as current var address low byte
04262    D11F  98                 TYA                     ; get high byte back
04263    D120  65 A5              ADC   Adatah            ; add array data start pointer high byte
04264    D122  85 96              STA   Cvarah            ; save as current var address high byte
04265    D124  A8                 TAY                     ; copy high byte to Y
04266    D125  A5 95              LDA   Cvaral            ; get current var address low byte
04267    LAB_1F7B
04268    D127  60                 RTS
04269    
04270    ; does XY = (Astrtl),Y * (Asptl)
04271    
04272    LAB_1F7C
04273    D128  84 71              STY   ut1_pl            ; save index
04274    D12A  B1 AA              LDA   (Astrtl),Y        ; get dimension size low byte
04275    D12C  85 76              STA   dims_l            ; save dimension size low byte
04276    D12E  88                 DEY                     ; decrement index
04277    D12F  B1 AA              LDA   (Astrtl),Y        ; get dimension size high byte
04278    D131  85 77              STA   dims_h            ; save dimension size high byte
04279    
04280    D133  A9 10              LDA   #$10              ; count = $10 (16 bit multiply)
04281    D135  85 A8              STA   numbit            ; save bit count
04282    D137  A2 00              LDX   #$00              ; clear result low byte
04283    D139  A0 00              LDY   #$00              ; clear result high byte
04284    LAB_1F8F
04285    D13B  8A                 TXA                     ; get result low byte
04286    D13C  0A                 ASL                     ; *2
04287    D13D  AA                 TAX                     ; save result low byte
04288    D13E  98                 TYA                     ; get result high byte
04289    D13F  2A                 ROL                     ; *2
04290    D140  A8                 TAY                     ; save result high byte
04291    D141  B0 B3              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
04292    
04293    D143  06 BA              ASL   Asptl             ; shift multiplier low byte
04294    D145  26 BB              ROL   Aspth             ; shift multiplier high byte
04295    D147  90 0B              BCC   LAB_1FA8          ; skip add if no carry
04296    
04297    D149  18                 CLC                     ; else clear carry for add
04298    D14A  8A                 TXA                     ; get result low byte
04299    D14B  65 76              ADC   dims_l            ; add dimension size low byte
04300    D14D  AA                 TAX                     ; save result low byte
04301    D14E  98                 TYA                     ; get result high byte
04302    D14F  65 77              ADC   dims_h            ; add dimension size high byte
04303    D151  A8                 TAY                     ; save result high byte
04304    D152  B0 A2              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
04305    
04306    LAB_1FA8
04307    D154  C6 A8              DEC   numbit            ; decrement bit count
04308    D156  D0 E3              BNE   LAB_1F8F          ; loop until all done
04309    
04310    D158  60                 RTS
04311    
04312    ; perform FRE()
04313    
04314    LAB_FRE
04315    D159  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
04316    D15B  10 03              BPL   LAB_1FB4          ; branch if numeric
04317    
04318    D15D  20 58 D4           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
04319                                  ; space returns with A = length, X=$71=pointer low byte,
04320                                  ; Y=$72=pointer high byte
04321    
04322                                  ; FRE(n) was numeric so do this
04323    LAB_1FB4
04324    D160  20 F5 D2           JSR   LAB_GARB          ; go do garbage collection
04325    D163  38                 SEC                     ; set carry for subtract
04326    D164  A5 81              LDA   Sstorl            ; get bottom of string space low byte
04327    D166  E5 7F              SBC   Earryl            ; subtract array mem end low byte
04328    D168  A8                 TAY                     ; copy result to Y
04329    D169  A5 82              LDA   Sstorh            ; get bottom of string space high byte
04330    D16B  E5 80              SBC   Earryh            ; subtract array mem end high byte
04331    
04332    ; save and convert integer AY to FAC1
04333    
04334    LAB_AYFC
04335    D16D  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
04336    D16F  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
04337    D171  84 AE              STY   FAC1_2            ; save FAC1 mantissa2
04338    D173  A2 90              LDX   #$90              ; set exponent=2^16 (integer)
04339    D175  4C 15 DA           JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
04340    
04341    ; perform POS()
04342    
04343    LAB_POS
04344    D178  A4 0E              LDY   TPos              ; get terminal position
04345    
04346    ; convert Y to byte in FAC1
04347    
04348    LAB_1FD0
04349    D17A  A9 00              LDA   #$00              ; clear high byte
04350    D17C  F0 EF              BEQ   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
04351    
04352    ; check not Direct (used by DEF and INPUT)
04353    
04354    LAB_CKRN
04355    D17E  A6 88              LDX   Clineh            ; get current line high byte
04356    D180  E8                 INX                     ; increment it
04357    D181  D0 A4              BNE   LAB_1F7B          ; return if can continue not direct mode
04358    
04359                                  ; else do illegal direct error
04360    LAB_1FD9
04361    D183  A2 16              LDX   #$16              ; error code $16 ("Illegal direct" error)
04362    LAB_1FDB
04363    D185  4C 3F C2           JMP   LAB_XERR          ; go do error #X, then warm start
04364    
04365    ; perform DEF
04366    
04367    LAB_DEF
04368    D188  20 B9 D1           JSR   LAB_200B          ; check FNx syntax
04369    D18B  85 9C              STA   func_l            ; save function pointer low byte
04370    D18D  84 9D              STY   func_h            ; save function pointer high byte
04371    D18F  20 7E D1           JSR   LAB_CKRN          ; check not Direct (back here if ok)
04372    D192  20 00 CD           JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
04373    D195  A9 80              LDA   #$80              ; set flag for FNx
04374    D197  85 61              STA   Sufnxf            ; save subscript/FNx flag
04375    D199  20 BE CE           JSR   LAB_GVAR          ; get (var) address
04376    D19C  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
04377    D19F  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
04378    D1A2  A9 CB              LDA   #TK_EQUAL         ; get = token
04379    D1A4  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
04380    D1A7  A5 96              LDA   Cvarah            ; get current var address high byte
04381    D1A9  48                 PHA                     ; push it
04382    D1AA  A5 95              LDA   Cvaral            ; get current var address low byte
04383    D1AC  48                 PHA                     ; push it
04384    D1AD  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
04385    D1AF  48                 PHA                     ; push it
04386    D1B0  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
04387    D1B2  48                 PHA                     ; push it
04388    D1B3  20 90 C7           JSR   LAB_DATA          ; go perform DATA
04389    D1B6  4C 28 D2           JMP   LAB_207A          ; put execute pointer and variable pointer into function
04390                                  ; and return
04391    
04392    ; check FNx syntax
04393    
04394    LAB_200B
04395    D1B9  A9 B8              LDA   #TK_FN            ; get FN" token
04396    D1BB  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
04397                                  ; return character after A
04398    D1BE  09 80              ORA   #$80              ; set FN flag bit
04399    D1C0  85 61              STA   Sufnxf            ; save FN flag so array variable test fails
04400    D1C2  20 C5 CE           JSR   LAB_1D12          ; search for FN variable
04401    D1C5  4C D6 CB           JMP   LAB_CTNM          ; check if source is numeric and return, else do type
04402                                  ; mismatch
04403    
04404                                  ; Evaluate FNx
04405    LAB_201E
04406    D1C8  20 B9 D1           JSR   LAB_200B          ; check FNx syntax
04407    D1CB  48                 PHA                     ; push function pointer low byte
04408    D1CC  98                 TYA                     ; copy function pointer high byte
04409    D1CD  48                 PHA                     ; push function pointer high byte
04410    D1CE  20 00 CD           JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
04411    D1D1  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
04412    D1D4  20 F5 CC           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
04413    D1D7  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
04414    D1DA  68                 PLA                     ; pop function pointer high byte
04415    D1DB  85 9D              STA   func_h            ; restore it
04416    D1DD  68                 PLA                     ; pop function pointer low byte
04417    D1DE  85 9C              STA   func_l            ; restore it
04418    D1E0  A2 20              LDX   #$20              ; error code $20 ("Undefined function" error)
04419    D1E2  A0 03              LDY   #$03              ; index to variable pointer high byte
04420    D1E4  B1 9C              LDA   (func_l),Y        ; get variable pointer high byte
04421    D1E6  F0 9D              BEQ   LAB_1FDB          ; if zero go do undefined function error
04422    
04423    D1E8  85 96              STA   Cvarah            ; save variable address high byte
04424    D1EA  88                 DEY                     ; index to variable address low byte
04425    D1EB  B1 9C              LDA   (func_l),Y        ; get variable address low byte
04426    D1ED  85 95              STA   Cvaral            ; save variable address low byte
04427    D1EF  AA                 TAX                     ; copy address low byte
04428    
04429                                  ; now stack the function variable value before use
04430    D1F0  C8                 INY                     ; index to mantissa_3
04431    LAB_2043
04432    D1F1  B1 95              LDA   (Cvaral),Y        ; get byte from variable
04433    D1F3  48                 PHA                     ; stack it
04434    D1F4  88                 DEY                     ; decrement index
04435    D1F5  10 FA              BPL   LAB_2043          ; loop until variable stacked
04436    
04437    D1F7  A4 96              LDY   Cvarah            ; get variable address high byte
04438    D1F9  20 BA D9           JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
04439                                  ; (function variable), return Y=0, always
04440    D1FC  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
04441    D1FE  48                 PHA                     ; push it
04442    D1FF  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
04443    D201  48                 PHA                     ; push it
04444    D202  B1 9C              LDA   (func_l),Y        ; get function execute pointer low byte
04445    D204  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
04446    D206  C8                 INY                     ; index to high byte
04447    D207  B1 9C              LDA   (func_l),Y        ; get function execute pointer high byte
04448    D209  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
04449    D20B  A5 96              LDA   Cvarah            ; get variable address high byte
04450    D20D  48                 PHA                     ; push it
04451    D20E  A5 95              LDA   Cvaral            ; get variable address low byte
04452    D210  48                 PHA                     ; push it
04453    D211  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
04454                                  ; else do type mismatch
04455    D214  68                 PLA                     ; pull variable address low byte
04456    D215  85 9C              STA   func_l            ; save variable address low byte
04457    D217  68                 PLA                     ; pull variable address high byte
04458    D218  85 9D              STA   func_h            ; save variable address high byte
04459    D21A  20 C2 00           JSR   LAB_GBYT          ; scan memory
04460    D21D  F0 03              BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
04461    
04462    D21F  4C 08 CD           JMP   LAB_SNER          ; else syntax error then warm start
04463    
04464    ; restore Bpntrl,Bpntrh and function variable from stack
04465    
04466    LAB_2074
04467    D222  68                 PLA                     ; pull BASIC execute pointer low byte
04468    D223  85 C3              STA   Bpntrl            ; restore BASIC execute pointer low byte
04469    D225  68                 PLA                     ; pull BASIC execute pointer high byte
04470    D226  85 C4              STA   Bpntrh            ; restore BASIC execute pointer high byte
04471    
04472    ; put execute pointer and variable pointer into function
04473    
04474    LAB_207A
04475    D228  A0 00              LDY   #$00              ; clear index
04476    D22A  68                 PLA                     ; pull BASIC execute pointer low byte
04477    D22B  91 9C              STA   (func_l),Y        ; save to function
04478    D22D  C8                 INY                     ; increment index
04479    D22E  68                 PLA                     ; pull BASIC execute pointer high byte
04480    D22F  91 9C              STA   (func_l),Y        ; save to function
04481    D231  C8                 INY                     ; increment index
04482    D232  68                 PLA                     ; pull current var address low byte
04483    D233  91 9C              STA   (func_l),Y        ; save to function
04484    D235  C8                 INY                     ; increment index
04485    D236  68                 PLA                     ; pull current var address high byte
04486    D237  91 9C              STA   (func_l),Y        ; save to function
04487    D239  60                 RTS
04488    
04489    ; perform STR$()
04490    
04491    LAB_STRS
04492    D23A  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
04493    D23D  20 A8 DB           JSR   LAB_296E          ; convert FAC1 to string
04494    D240  A9 F0              LDA   #<Decssp1         ; set result string low pointer
04495    D242  A0 00              LDY   #>Decssp1         ; set result string high pointer
04496    D244  F0 12              BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
04497    
04498    ; Do string vector
04499    ; copy des_pl/h to des_2l/h and make string space A bytes long
04500    
04501    LAB_209C
04502    D246  A6 AE              LDX   des_pl            ; get descriptor pointer low byte
04503    D248  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
04504    D24A  86 9E              STX   des_2l            ; save descriptor pointer low byte
04505    D24C  84 9F              STY   des_2h            ; save descriptor pointer high byte
04506    
04507    ; make string space A bytes long
04508    ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
04509    
04510    LAB_MSSP
04511    D24E  20 C3 D2           JSR   LAB_2115          ; make space in string memory for string A long
04512                                  ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
04513    D251  86 AD              STX   str_pl            ; save string pointer low byte
04514    D253  84 AE              STY   str_ph            ; save string pointer high byte
04515    D255  85 AC              STA   str_ln            ; save length
04516    D257  60                 RTS
04517    
04518    ; Scan, set up string
04519    ; print " terminated string to Sutill/Sutilh
04520    
04521    LAB_20AE
04522    D258  A2 22              LDX   #$22              ; set terminator to "
04523    D25A  86 5B              STX   Srchc             ; set search character (terminator 1)
04524    D25C  86 5C              STX   Asrch             ; set terminator 2
04525    
04526    ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
04527    ; source is AY
04528    
04529    LAB_20B4
04530    D25E  85 B8              STA   ssptr_l           ; store string start low byte
04531    D260  84 B9              STY   ssptr_h           ; store string start high byte
04532    D262  85 AD              STA   str_pl            ; save string pointer low byte
04533    D264  84 AE              STY   str_ph            ; save string pointer high byte
04534    D266  A0 FF              LDY   #$FF              ; set length to -1
04535    LAB_20BE
04536    D268  C8                 INY                     ; increment length
04537    D269  B1 B8              LDA   (ssptr_l),Y       ; get byte from string
04538    D26B  F0 0C              BEQ   LAB_20CF          ; exit loop if null byte [EOS]
04539    
04540    D26D  C5 5B              CMP   Srchc             ; compare with search character (terminator 1)
04541    D26F  F0 04              BEQ   LAB_20CB          ; branch if terminator
04542    
04543    D271  C5 5C              CMP   Asrch             ; compare with terminator 2
04544    D273  D0 F3              BNE   LAB_20BE          ; loop if not terminator 2
04545    
04546    LAB_20CB
04547    D275  C9 22              CMP   #$22              ; compare with "
04548    D277  F0 01              BEQ   LAB_20D0          ; branch if " (carry set if = !)
04549    
04550    LAB_20CF
04551    D279  18                 CLC                     ; clear carry for add (only if [EOL] terminated string)
04552    LAB_20D0
04553    D27A  84 AC              STY   str_ln            ; save length in FAC1 exponent
04554    D27C  98                 TYA                     ; copy length to A
04555    D27D  65 B8              ADC   ssptr_l           ; add string start low byte
04556    D27F  85 BA              STA   Sendl             ; save string end low byte
04557    D281  A6 B9              LDX   ssptr_h           ; get string start high byte
04558    D283  90 01              BCC   LAB_20DC          ; branch if no low byte overflow
04559    
04560    D285  E8                 INX                     ; else increment high byte
04561    LAB_20DC
04562    D286  86 BB              STX   Sendh             ; save string end high byte
04563    D288  A5 B9              LDA   ssptr_h           ; get string start high byte
04564    ; *** begin RAM above code / Ibuff above EhBASIC patch V2 ***
04565    ; *** replace
04566    ;      CMP   #>Ram_base        ; compare with start of program memory
04567    ;      BCS   LAB_RTST          ; branch if not in utility area
04568    ; *** with
04569    D28A  F0 04              BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
04570    D28C  C9 0B              CMP   #>Ibuffs          ; compare with location of input buffer page
04571    D28E  D0 0B              BNE   LAB_RTST          ; branch if not in utility area
04572    LAB_MVST      
04573    ; *** end   RAM above code / Ibuff above EhBASIC patch V2 ***
04574    
04575                                  ; string in utility area, move to string memory
04576    D290  98                 TYA                     ; copy length to A
04577    D291  20 46 D2           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
04578                                  ; long
04579    D294  A6 B8              LDX   ssptr_l           ; get string start low byte
04580    D296  A4 B9              LDY   ssptr_h           ; get string start high byte
04581    D298  20 39 D4           JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
04582    
04583    ; check for space on descriptor stack then ..
04584    ; put string address and length on descriptor stack and update stack pointers
04585    
04586    LAB_RTST
04587    D29B  A6 65              LDX   next_s            ; get string stack pointer
04588    D29D  E0 71              CPX   #des_sk+$09       ; compare with max+1
04589    D29F  D0 05              BNE   LAB_20F8          ; branch if space on string stack
04590    
04591                                  ; else do string too complex error
04592    D2A1  A2 1C              LDX   #$1C              ; error code $1C ("String too complex" error)
04593    LAB_20F5
04594    D2A3  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
04595    
04596    ; put string address and length on descriptor stack and update stack pointers
04597    
04598    LAB_20F8
04599    D2A6  A5 AC              LDA   str_ln            ; get string length
04600    D2A8  95 00              STA   PLUS_0,X          ; put on string stack
04601    D2AA  A5 AD              LDA   str_pl            ; get string pointer low byte
04602    D2AC  95 01              STA   PLUS_1,X          ; put on string stack
04603    D2AE  A5 AE              LDA   str_ph            ; get string pointer high byte
04604    D2B0  95 02              STA   PLUS_2,X          ; put on string stack
04605    D2B2  A0 00              LDY   #$00              ; clear Y
04606    D2B4  86 AE              STX   des_pl            ; save string descriptor pointer low byte
04607    D2B6  84 AF              STY   des_ph            ; save string descriptor pointer high byte (always $00)
04608    D2B8  88                 DEY                     ; Y = $FF
04609    D2B9  84 5F              STY   Dtypef            ; save data type flag, $FF=string
04610    D2BB  86 66              STX   last_sl           ; save old stack pointer (current top item)
04611    D2BD  E8                 INX                     ; update stack pointer
04612    D2BE  E8                 INX                     ; update stack pointer
04613    D2BF  E8                 INX                     ; update stack pointer
04614    D2C0  86 65              STX   next_s            ; save new top item value
04615    D2C2  60                 RTS
04616    
04617    ; Build descriptor
04618    ; make space in string memory for string A long
04619    ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
04620    
04621    LAB_2115
04622    D2C3  46 60              LSR   Gclctd            ; clear garbage collected flag (b7)
04623    
04624                                  ; make space for string A long
04625    LAB_2117
04626    D2C5  48                 PHA                     ; save string length
04627    D2C6  49 FF              EOR   #$FF              ; complement it
04628    D2C8  38                 SEC                     ; set carry for subtract (twos comp add)
04629    D2C9  65 81              ADC   Sstorl            ; add bottom of string space low byte (subtract length)
04630    D2CB  A4 82              LDY   Sstorh            ; get bottom of string space high byte
04631    D2CD  B0 01              BCS   LAB_2122          ; skip decrement if no underflow
04632    
04633    D2CF  88                 DEY                     ; decrement bottom of string space high byte
04634    LAB_2122
04635    D2D0  C4 80              CPY   Earryh            ; compare with array mem end high byte
04636    D2D2  90 11              BCC   LAB_2137          ; do out of memory error if less
04637    
04638    D2D4  D0 04              BNE   LAB_212C          ; if not = skip next test
04639    
04640    D2D6  C5 7F              CMP   Earryl            ; compare with array mem end low byte
04641    D2D8  90 0B              BCC   LAB_2137          ; do out of memory error if less
04642    
04643    LAB_212C
04644    D2DA  85 81              STA   Sstorl            ; save bottom of string space low byte
04645    D2DC  84 82              STY   Sstorh            ; save bottom of string space high byte
04646    D2DE  85 83              STA   Sutill            ; save string utility ptr low byte
04647    D2E0  84 84              STY   Sutilh            ; save string utility ptr high byte
04648    D2E2  AA                 TAX                     ; copy low byte to X
04649    D2E3  68                 PLA                     ; get string length back
04650    D2E4  60                 RTS
04651    
04652    LAB_2137
04653    D2E5  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
04654    D2E7  A5 60              LDA   Gclctd            ; get garbage collected flag
04655    D2E9  30 B8              BMI   LAB_20F5          ; if set then do error code X
04656    
04657    D2EB  20 F5 D2           JSR   LAB_GARB          ; else go do garbage collection
04658    D2EE  A9 80              LDA   #$80              ; flag for garbage collected
04659    D2F0  85 60              STA   Gclctd            ; set garbage collected flag
04660    D2F2  68                 PLA                     ; pull length
04661    D2F3  D0 D0              BNE   LAB_2117          ; go try again (loop always, length should never be = $00)
04662    
04663    ; garbage collection routine
04664    
04665    LAB_GARB
04666    D2F5  A6 85              LDX   Ememl             ; get end of mem low byte
04667    D2F7  A5 86              LDA   Ememh             ; get end of mem high byte
04668    
04669    ; re-run routine from last ending
04670    
04671    LAB_214B
04672    D2F9  86 81              STX   Sstorl            ; set string storage low byte
04673    D2FB  85 82              STA   Sstorh            ; set string storage high byte
04674    D2FD  A0 00              LDY   #$00              ; clear index
04675    D2FF  84 9D              STY   garb_h            ; clear working pointer high byte (flag no strings to move)
04676    ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
04677    ; *** add
04678    D301  84 9C              STY   garb_l            ; clear working pointer low byte (flag no strings to move)
04679    ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
04680    D303  A5 7F              LDA   Earryl            ; get array mem end low byte
04681    D305  A6 80              LDX   Earryh            ; get array mem end high byte
04682    D307  85 AA              STA   Histrl            ; save as highest string low byte
04683    D309  86 AB              STX   Histrh            ; save as highest string high byte
04684    D30B  A9 68              LDA   #des_sk           ; set descriptor stack pointer
04685    D30D  85 71              STA   ut1_pl            ; save descriptor stack pointer low byte
04686    D30F  84 72              STY   ut1_ph            ; save descriptor stack pointer high byte ($00)
04687    LAB_2161
04688    D311  C5 65              CMP   next_s            ; compare with descriptor stack pointer
04689    D313  F0 05              BEQ   LAB_216A          ; branch if =
04690    
04691    D315  20 7B D3           JSR   LAB_21D7          ; go garbage collect descriptor stack
04692    D318  F0 F7              BEQ   LAB_2161          ; loop always
04693    
04694                                  ; done stacked strings, now do string vars
04695    LAB_216A
04696    D31A  06 A0              ASL   g_step            ; set step size = $06
04697    D31C  A5 7B              LDA   Svarl             ; get start of vars low byte
04698    D31E  A6 7C              LDX   Svarh             ; get start of vars high byte
04699    D320  85 71              STA   ut1_pl            ; save as pointer low byte
04700    D322  86 72              STX   ut1_ph            ; save as pointer high byte
04701    LAB_2176
04702    D324  E4 7E              CPX   Sarryh            ; compare start of arrays high byte
04703    D326  D0 04              BNE   LAB_217E          ; branch if no high byte match
04704    
04705    D328  C5 7D              CMP   Sarryl            ; else compare start of arrays low byte
04706    D32A  F0 05              BEQ   LAB_2183          ; branch if = var mem end
04707    
04708    LAB_217E
04709    D32C  20 75 D3           JSR   LAB_21D1          ; go garbage collect strings
04710    D32F  F0 F3              BEQ   LAB_2176          ; loop always
04711    
04712                                  ; done string vars, now do string arrays
04713    LAB_2183
04714    D331  85 A4              STA   Nbendl            ; save start of arrays low byte as working pointer
04715    D333  86 A5              STX   Nbendh            ; save start of arrays high byte as working pointer
04716    D335  A9 04              LDA   #$04              ; set step size
04717    D337  85 A0              STA   g_step            ; save step size
04718    LAB_218B
04719    D339  A5 A4              LDA   Nbendl            ; get pointer low byte
04720    D33B  A6 A5              LDX   Nbendh            ; get pointer high byte
04721    LAB_218F
04722    D33D  E4 80              CPX   Earryh            ; compare with array mem end high byte
04723    D33F  D0 04              BNE   LAB_219A          ; branch if not at end
04724    
04725    D341  C5 7F              CMP   Earryl            ; else compare with array mem end low byte
04726    D343  F0 75              BEQ   LAB_2216          ; tidy up and exit if at end
04727    
04728    LAB_219A
04729    D345  85 71              STA   ut1_pl            ; save pointer low byte
04730    D347  86 72              STX   ut1_ph            ; save pointer high byte
04731    D349  A0 02              LDY   #$02              ; set index
04732    D34B  B1 71              LDA   (ut1_pl),Y        ; get array size low byte
04733    D34D  65 A4              ADC   Nbendl            ; add start of this array low byte
04734    D34F  85 A4              STA   Nbendl            ; save start of next array low byte
04735    D351  C8                 INY                     ; increment index
04736    D352  B1 71              LDA   (ut1_pl),Y        ; get array size high byte
04737    D354  65 A5              ADC   Nbendh            ; add start of this array high byte
04738    D356  85 A5              STA   Nbendh            ; save start of next array high byte
04739    D358  A0 01              LDY   #$01              ; set index
04740    D35A  B1 71              LDA   (ut1_pl),Y        ; get name second byte
04741    D35C  10 DB              BPL   LAB_218B          ; skip if not string array
04742    
04743    ; was string array so ..
04744    
04745    D35E  A0 04              LDY   #$04              ; set index
04746    D360  B1 71              LDA   (ut1_pl),Y        ; get # of dimensions
04747    D362  0A                 ASL                     ; *2
04748    D363  69 05              ADC   #$05              ; +5 (array header size)
04749    D365  20 AD D3           JSR   LAB_2208          ; go set up for first element
04750    LAB_21C4
04751    D368  E4 A5              CPX   Nbendh            ; compare with start of next array high byte
04752    D36A  D0 04              BNE   LAB_21CC          ; branch if <> (go do this array)
04753    
04754    D36C  C5 A4              CMP   Nbendl            ; else compare element pointer low byte with next array
04755                                  ; low byte
04756    D36E  F0 CD              BEQ   LAB_218F          ; if equal then go do next array
04757    
04758    LAB_21CC
04759    D370  20 7B D3           JSR   LAB_21D7          ; go defrag array strings
04760    D373  F0 F3              BEQ   LAB_21C4          ; go do next array string (loop always)
04761    
04762    ; defrag string variables
04763    ; enter with XA = variable pointer
04764    ; return with XA = next variable pointer
04765    
04766    LAB_21D1
04767    D375  C8                 INY                     ; increment index (Y was $00)
04768    D376  B1 71              LDA   (ut1_pl),Y        ; get var name byte 2
04769    D378  10 30              BPL   LAB_2206          ; if not string, step pointer to next var and return
04770    
04771    D37A  C8                 INY                     ; else increment index
04772    LAB_21D7
04773    D37B  B1 71              LDA   (ut1_pl),Y        ; get string length
04774    D37D  F0 2B              BEQ   LAB_2206          ; if null, step pointer to next string and return
04775    
04776    D37F  C8                 INY                     ; else increment index
04777    D380  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte
04778    D382  AA                 TAX                     ; copy to X
04779    D383  C8                 INY                     ; increment index
04780    D384  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte
04781    D386  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
04782    D388  90 06              BCC   LAB_21EC          ; branch if less
04783    
04784    D38A  D0 1E              BNE   LAB_2206          ; if greater, step pointer to next string and return
04785    
04786                                  ; high bytes were = so compare low bytes
04787    D38C  E4 81              CPX   Sstorl            ; compare bottom of string space low byte
04788    D38E  B0 1A              BCS   LAB_2206          ; if >=, step pointer to next string and return
04789    
04790                                  ; string pointer is < string storage pointer (pos in mem)
04791    LAB_21EC
04792    D390  C5 AB              CMP   Histrh            ; compare to highest string high byte
04793    D392  90 17              BCC   LAB_2207          ; if <, step pointer to next string and return
04794    
04795    D394  D0 04              BNE   LAB_21F6          ; if > update pointers, step to next and return
04796    
04797                                  ; high bytes were = so compare low bytes
04798    D396  E4 AA              CPX   Histrl            ; compare to highest string low byte
04799    D398  90 11              BCC   LAB_2207          ; if <, step pointer to next string and return
04800    
04801                                  ; string is in string memory space
04802    LAB_21F6
04803    D39A  86 AA              STX   Histrl            ; save as new highest string low byte
04804    D39C  85 AB              STA   Histrh            ; save as new highest string high byte
04805    D39E  A5 71              LDA   ut1_pl            ; get start of vars(descriptors) low byte
04806    D3A0  A6 72              LDX   ut1_ph            ; get start of vars(descriptors) high byte
04807    D3A2  85 9C              STA   garb_l            ; save as working pointer low byte
04808    D3A4  86 9D              STX   garb_h            ; save as working pointer high byte
04809    D3A6  88                 DEY                     ; decrement index DIFFERS
04810    D3A7  88                 DEY                     ; decrement index (should point to descriptor start)
04811    D3A8  84 A2              STY   g_indx            ; save index pointer
04812    
04813                                  ; step pointer to next string
04814    LAB_2206
04815    D3AA  18                 CLC                     ; clear carry for add
04816    LAB_2207
04817    D3AB  A5 A0              LDA   g_step            ; get step size
04818    LAB_2208
04819    D3AD  65 71              ADC   ut1_pl            ; add pointer low byte
04820    D3AF  85 71              STA   ut1_pl            ; save pointer low byte
04821    D3B1  90 02              BCC   LAB_2211          ; branch if no overflow
04822    
04823    D3B3  E6 72              INC   ut1_ph            ; else increment high byte
04824    LAB_2211
04825    D3B5  A6 72              LDX   ut1_ph            ; get pointer high byte
04826    D3B7  A0 00              LDY   #$00              ; clear Y
04827    D3B9  60                 RTS
04828    
04829    ; search complete, now either exit or set-up and move string
04830    
04831    LAB_2216
04832    D3BA  C6 A0              DEC   g_step            ; decrement step size (now $03 for descriptor stack)
04833    ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
04834    ; *** replace
04835    ;      LDX   garb_h            ; get string to move high byte
04836    ; *** with
04837    D3BC  A5 9D              LDA   garb_h            ; any string to move?
04838    D3BE  05 9C              ORA   garb_l
04839    ; *** end   patch  2.22p5.5  garbage collection may overlap temporary strings
04840    D3C0  F0 F3              BEQ   LAB_2211          ; exit if nothing to move
04841    
04842    D3C2  A4 A2              LDY   g_indx            ; get index byte back (points to descriptor)
04843    D3C4  18                 CLC                     ; clear carry for add
04844    D3C5  B1 9C              LDA   (garb_l),Y        ; get string length
04845    D3C7  65 AA              ADC   Histrl            ; add highest string low byte
04846    D3C9  85 A6              STA   Obendl            ; save old block end low pointer
04847    D3CB  A5 AB              LDA   Histrh            ; get highest string high byte
04848    D3CD  69 00              ADC   #$00              ; add any carry
04849    D3CF  85 A7              STA   Obendh            ; save old block end high byte
04850    D3D1  A5 81              LDA   Sstorl            ; get bottom of string space low byte
04851    D3D3  A6 82              LDX   Sstorh            ; get bottom of string space high byte
04852    D3D5  85 A4              STA   Nbendl            ; save new block end low byte
04853    D3D7  86 A5              STX   Nbendh            ; save new block end high byte
04854    D3D9  20 C8 C1           JSR   LAB_11D6          ; open up space in memory, don't set array end
04855    D3DC  A4 A2              LDY   g_indx            ; get index byte
04856    D3DE  C8                 INY                     ; point to descriptor low byte
04857    D3DF  A5 A4              LDA   Nbendl            ; get string pointer low byte
04858    D3E1  91 9C              STA   (garb_l),Y        ; save new string pointer low byte
04859    D3E3  AA                 TAX                     ; copy string pointer low byte
04860    D3E4  E6 A5              INC   Nbendh            ; correct high byte (move sets high byte -1)
04861    D3E6  A5 A5              LDA   Nbendh            ; get new string pointer high byte
04862    D3E8  C8                 INY                     ; point to descriptor high byte
04863    D3E9  91 9C              STA   (garb_l),Y        ; save new string pointer high byte
04864    D3EB  4C F9 D2           JMP   LAB_214B          ; re-run routine from last ending
04865                                  ; (but don't collect this string)
04866    
04867    ; concatenate
04868    ; add strings, string 1 is in descriptor des_pl, string 2 is in line
04869    
04870    LAB_224D
04871    D3EE  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
04872    D3F0  48                 PHA                     ; put on stack
04873    D3F1  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
04874    D3F3  48                 PHA                     ; put on stack
04875    ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
04876    ; *** add extra label to verify originating function
04877    LAB_224Da
04878    ; *** end patch    2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
04879    D3F4  20 D3 CC           JSR   LAB_GVAL          ; get value from line
04880    D3F7  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
04881    D3FA  68                 PLA                     ; get descriptor pointer low byte back
04882    D3FB  85 B8              STA   ssptr_l           ; set pointer low byte
04883    D3FD  68                 PLA                     ; get descriptor pointer high byte back
04884    D3FE  85 B9              STA   ssptr_h           ; set pointer high byte
04885    D400  A0 00              LDY   #$00              ; clear index
04886    D402  B1 B8              LDA   (ssptr_l),Y       ; get length_1 from descriptor
04887    D404  18                 CLC                     ; clear carry for add
04888    D405  71 AE              ADC   (des_pl),Y        ; add length_2
04889    D407  90 05              BCC   LAB_226D          ; branch if no overflow
04890    
04891    D409  A2 1A              LDX   #$1A              ; else set error code $1A ("String too long" error)
04892    D40B  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
04893    
04894    LAB_226D
04895    D40E  20 46 D2           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
04896                                  ; long
04897    D411  20 2B D4           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
04898    D414  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
04899    D416  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
04900    D418  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
04901                                  ; returns with A = length, ut1_pl = pointer low byte,
04902                                  ; ut1_ph = pointer high byte
04903    D41B  20 3D D4           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
04904    D41E  A5 B8              LDA   ssptr_l           ;.set descriptor pointer low byte
04905    D420  A4 B9              LDY   ssptr_h           ;.set descriptor pointer high byte
04906    D422  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
04907                                  ; returns with A = length, X=ut1_pl=pointer low byte,
04908                                  ; Y=ut1_ph=pointer high byte
04909    D425  20 9B D2           JSR   LAB_RTST          ; check for space on descriptor stack then put string
04910                                  ; address and length on descriptor stack and update stack
04911                                  ; pointers
04912    D428  4C FE CB           JMP   LAB_1ADB          ;.continue evaluation
04913    
04914    ; copy string from descriptor (sdescr) to (Sutill)
04915    
04916    LAB_228A
04917    D42B  A0 00              LDY   #$00              ; clear index
04918    D42D  B1 B8              LDA   (sdescr),Y        ; get string length
04919    D42F  48                 PHA                     ; save on stack
04920    D430  C8                 INY                     ; increment index
04921    D431  B1 B8              LDA   (sdescr),Y        ; get source string pointer low byte
04922    D433  AA                 TAX                     ; copy to X
04923    D434  C8                 INY                     ; increment index
04924    D435  B1 B8              LDA   (sdescr),Y        ; get source string pointer high byte
04925    D437  A8                 TAY                     ; copy to Y
04926    D438  68                 PLA                     ; get length back
04927    
04928    ; store string A bytes long from YX to (Sutill)
04929    
04930    LAB_2298
04931    D439  86 71              STX   ut1_pl            ; save source string pointer low byte
04932    D43B  84 72              STY   ut1_ph            ; save source string pointer high byte
04933    
04934    ; store string A bytes long from (ut1_pl) to (Sutill)
04935    
04936    LAB_229C
04937    D43D  AA                 TAX                     ; copy length to index (don't count with Y)
04938    D43E  F0 14              BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
04939    
04940    D440  A0 00              LDY   #$00              ; zero pointer (copy forward)
04941    LAB_22A0
04942    D442  B1 71              LDA   (ut1_pl),Y        ; get source byte
04943    D444  91 83              STA   (Sutill),Y        ; save destination byte
04944    
04945    D446  C8                 INY                     ; increment index
04946    D447  CA                 DEX                     ; decrement counter
04947    D448  D0 F8              BNE   LAB_22A0          ; loop while <> 0
04948    
04949    D44A  98                 TYA                     ; restore length from Y
04950    LAB_22A9
04951    D44B  18                 CLC                     ; clear carry for add
04952    D44C  65 83              ADC   Sutill            ; add string utility ptr low byte
04953    D44E  85 83              STA   Sutill            ; save string utility ptr low byte
04954    D450  90 02              BCC   LAB_22B2          ; branch if no carry
04955    
04956    D452  E6 84              INC   Sutilh            ; else increment string utility ptr high byte
04957    LAB_22B2
04958    D454  60                 RTS
04959    
04960    ; evaluate string
04961    
04962    LAB_EVST
04963    D455  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
04964    
04965    ; pop string off descriptor stack, or from top of string space
04966    ; returns with A = length, X=pointer low byte, Y=pointer high byte
04967    
04968    LAB_22B6
04969    D458  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
04970    D45A  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
04971    
04972    ; pop (YA) descriptor off stack or from top of string space
04973    ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
04974    
04975    LAB_22BA
04976    D45C  85 71              STA   ut1_pl            ; save descriptor pointer low byte
04977    D45E  84 72              STY   ut1_ph            ; save descriptor pointer high byte
04978    D460  20 8D D4           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
04979    D463  08                 PHP                     ; save status flags
04980    D464  A0 00              LDY   #$00              ; clear index
04981    D466  B1 71              LDA   (ut1_pl),Y        ; get length from string descriptor
04982    D468  48                 PHA                     ; put on stack
04983    D469  C8                 INY                     ; increment index
04984    D46A  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
04985    D46C  AA                 TAX                     ; copy to X
04986    D46D  C8                 INY                     ; increment index
04987    D46E  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
04988    D470  A8                 TAY                     ; copy to Y
04989    D471  68                 PLA                     ; get string length back
04990    D472  28                 PLP                     ; restore status
04991    D473  D0 13              BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
04992    
04993    D475  C4 82              CPY   Sstorh            ; compare bottom of string space high byte
04994    D477  D0 0F              BNE   LAB_22E6          ; branch if <>
04995    
04996    D479  E4 81              CPX   Sstorl            ; else compare bottom of string space low byte
04997    D47B  D0 0B              BNE   LAB_22E6          ; branch if <>
04998    
04999    D47D  48                 PHA                     ; save string length
05000    D47E  18                 CLC                     ; clear carry for add
05001    D47F  65 81              ADC   Sstorl            ; add bottom of string space low byte
05002    D481  85 81              STA   Sstorl            ; save bottom of string space low byte
05003    D483  90 02              BCC   LAB_22E5          ; skip increment if no overflow
05004    
05005    D485  E6 82              INC   Sstorh            ; increment bottom of string space high byte
05006    LAB_22E5
05007    D487  68                 PLA                     ; restore string length
05008    LAB_22E6
05009    D488  86 71              STX   ut1_pl            ; save string pointer low byte
05010    D48A  84 72              STY   ut1_ph            ; save string pointer high byte
05011    D48C  60                 RTS
05012    
05013    ; clean descriptor stack, YA = pointer
05014    ; checks if AY is on the descriptor stack, if so does a stack discard
05015    
05016    LAB_22EB
05017    D48D  C4 67              CPY   last_sh           ; compare pointer high byte
05018    D48F  D0 0C              BNE   LAB_22FB          ; exit if <>
05019    
05020    D491  C5 66              CMP   last_sl           ; compare pointer low byte
05021    D493  D0 08              BNE   LAB_22FB          ; exit if <>
05022    
05023    D495  85 65              STA   next_s            ; save descriptor stack pointer
05024    D497  E9 03              SBC   #$03              ; -3
05025    D499  85 66              STA   last_sl           ; save low byte -3
05026    D49B  A0 00              LDY   #$00              ; clear high byte
05027    LAB_22FB
05028    D49D  60                 RTS
05029    
05030    ; perform CHR$()
05031    
05032    LAB_CHRS
05033    D49E  20 A9 D5           JSR   LAB_EVBY          ; evaluate byte expression, result in X
05034    D4A1  8A                 TXA                     ; copy to A
05035    D4A2  48                 PHA                     ; save character
05036    D4A3  A9 01              LDA   #$01              ; string is single byte
05037    D4A5  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
05038                                  ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
05039    D4A8  68                 PLA                     ; get character back
05040    D4A9  A0 00              LDY   #$00              ; clear index
05041    D4AB  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
05042    D4AD  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put string
05043                                  ; address and length on descriptor stack and update stack
05044                                  ; pointers
05045    
05046    ; perform LEFT$()
05047    
05048    LAB_LEFT
05049    D4B0  48                 PHA                     ; push byte parameter
05050    D4B1  20 11 D5           JSR   LAB_236F          ; pull string data and byte parameter from stack
05051                                  ; return pointer in des_2l/h, byte in A (and X), Y=0
05052    D4B4  D1 9E              CMP   (des_2l),Y        ; compare byte parameter with string length
05053    D4B6  98                 TYA                     ; clear A
05054    D4B7  F0 09              BEQ   LAB_2316          ; go do string copy (branch always)
05055    
05056    ; perform RIGHT$()
05057    
05058    LAB_RIGHT
05059    D4B9  48                 PHA                     ; push byte parameter
05060    D4BA  20 11 D5           JSR   LAB_236F          ; pull string data and byte parameter from stack
05061                                  ; return pointer in des_2l/h, byte in A (and X), Y=0
05062    D4BD  18                 CLC                     ; clear carry for add-1
05063    D4BE  F1 9E              SBC   (des_2l),Y        ; subtract string length
05064    D4C0  49 FF              EOR   #$FF              ; invert it (A=LEN(expression$)-l)
05065    
05066    LAB_2316
05067    D4C2  90 04              BCC   LAB_231C          ; branch if string length > byte parameter
05068    
05069    D4C4  B1 9E              LDA   (des_2l),Y        ; else make parameter = length
05070    D4C6  AA                 TAX                     ; copy to byte parameter copy
05071    D4C7  98                 TYA                     ; clear string start offset
05072    LAB_231C
05073    D4C8  48                 PHA                     ; save string start offset
05074    LAB_231D
05075    D4C9  8A                 TXA                     ; copy byte parameter (or string length if <)
05076    LAB_231E
05077    D4CA  48                 PHA                     ; save string length
05078    D4CB  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
05079                                  ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
05080    D4CE  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
05081    D4D0  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
05082    D4D2  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
05083                                  ; returns with A = length, X=ut1_pl=pointer low byte,
05084                                  ; Y=ut1_ph=pointer high byte
05085    D4D5  68                 PLA                     ; get string length back
05086    D4D6  A8                 TAY                     ; copy length to Y
05087    D4D7  68                 PLA                     ; get string start offset back
05088    D4D8  18                 CLC                     ; clear carry for add
05089    D4D9  65 71              ADC   ut1_pl            ; add start offset to string start pointer low byte
05090    D4DB  85 71              STA   ut1_pl            ; save string start pointer low byte
05091    D4DD  90 02              BCC   LAB_2335          ; branch if no overflow
05092    
05093    D4DF  E6 72              INC   ut1_ph            ; else increment string start pointer high byte
05094    LAB_2335
05095    D4E1  98                 TYA                     ; copy length to A
05096    D4E2  20 3D D4           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
05097    D4E5  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put string
05098                                  ; address and length on descriptor stack and update stack
05099                                  ; pointers
05100    
05101    ; perform MID$()
05102    
05103    LAB_MIDS
05104    D4E8  48                 PHA                     ; push byte parameter
05105    D4E9  A9 FF              LDA   #$FF              ; set default length = 255
05106    D4EB  85 AF              STA   mids_l            ; save default length
05107    D4ED  20 C2 00           JSR   LAB_GBYT          ; scan memory
05108    D4F0  C9 29              CMP   #')'              ; compare with ")"
05109    D4F2  F0 06              BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
05110    
05111    D4F4  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05112    D4F7  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
05113    LAB_2358
05114    D4FA  20 11 D5           JSR   LAB_236F          ; pull string data and byte parameter from stack
05115                                  ; return pointer in des_2l/h, byte in A (and X), Y=0
05116    D4FD  CA                 DEX                     ; decrement start index
05117    D4FE  8A                 TXA                     ; copy to A
05118    D4FF  48                 PHA                     ; save string start offset
05119    D500  18                 CLC                     ; clear carry for sub-1
05120    D501  A2 00              LDX   #$00              ; clear output string length
05121    D503  F1 9E              SBC   (des_2l),Y        ; subtract string length
05122    D505  B0 C2              BCS   LAB_231D          ; if start>string length go do null string
05123    
05124    D507  49 FF              EOR   #$FF              ; complement -length
05125    D509  C5 AF              CMP   mids_l            ; compare byte parameter
05126    D50B  90 BD              BCC   LAB_231E          ; if length>remaining string go do RIGHT$
05127    
05128    D50D  A5 AF              LDA   mids_l            ; get length byte
05129    D50F  B0 B9              BCS   LAB_231E          ; go do string copy (branch always)
05130    
05131    ; pull string data and byte parameter from stack
05132    ; return pointer in des_2l/h, byte in A (and X), Y=0
05133    
05134    LAB_236F
05135    D511  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
05136    D514  68                 PLA                     ; pull return address low byte (return address)
05137    D515  85 A2              STA   Fnxjpl            ; save functions jump vector low byte
05138    D517  68                 PLA                     ; pull return address high byte (return address)
05139    D518  85 A3              STA   Fnxjph            ; save functions jump vector high byte
05140    D51A  68                 PLA                     ; pull byte parameter
05141    D51B  AA                 TAX                     ; copy byte parameter to X
05142    D51C  68                 PLA                     ; pull string pointer low byte
05143    D51D  85 9E              STA   des_2l            ; save it
05144    D51F  68                 PLA                     ; pull string pointer high byte
05145    D520  85 9F              STA   des_2h            ; save it
05146    D522  A0 00              LDY   #$00              ; clear index
05147    D524  8A                 TXA                     ; copy byte parameter
05148    D525  F0 79              BEQ   LAB_23A8          ; if null do function call error then warm start
05149    
05150    D527  E6 A2              INC   Fnxjpl            ; increment function jump vector low byte
05151                                  ; (JSR pushes return addr-1. this is all very nice
05152                                  ; but will go tits up if either call is on a page
05153                                  ; boundary!)
05154    D529  6C A2 00           JMP   (Fnxjpl)          ; in effect, RTS
05155    
05156    ; perform LCASE$()
05157    
05158    LAB_LCASE
05159    D52C  20 55 D4           JSR   LAB_EVST          ; evaluate string
05160    D52F  85 AC              STA   str_ln            ; set string length
05161    D531  A8                 TAY                     ; copy length to Y
05162    D532  F0 38              BEQ   NoString          ; branch if null string
05163    
05164    D534  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=length,
05165                                  ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
05166    D537  86 AD              STX   str_pl            ; save string pointer low byte
05167    D539  84 AE              STY   str_ph            ; save string pointer high byte
05168    D53B  A8                 TAY                     ; get string length back
05169    
05170    LC_loop
05171    D53C  88                 DEY                     ; decrement index
05172    D53D  B1 71              LDA   (ut1_pl),Y        ; get byte from string
05173    D53F  20 36 CF           JSR   LAB_1D82          ; is character "A" to "Z"
05174    D542  90 02              BCC   NoUcase           ; branch if not upper case alpha
05175    
05176    D544  09 20              ORA   #$20              ; convert upper to lower case
05177    NoUcase
05178    D546  91 83              STA   (Sutill),Y        ; save byte back to string
05179    D548  98                 TYA                     ; test index
05180    D549  D0 F1              BNE   LC_loop           ; loop if not all done
05181    
05182    D54B  F0 1F              BEQ   NoString          ; tidy up and exit, branch always
05183    
05184    ; perform UCASE$()
05185    
05186    LAB_UCASE
05187    D54D  20 55 D4           JSR   LAB_EVST          ; evaluate string
05188    D550  85 AC              STA   str_ln            ; set string length
05189    D552  A8                 TAY                     ; copy length to Y
05190    D553  F0 17              BEQ   NoString          ; branch if null string
05191    
05192    D555  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=length,
05193                                  ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
05194    D558  86 AD              STX   str_pl            ; save string pointer low byte
05195    D55A  84 AE              STY   str_ph            ; save string pointer high byte
05196    D55C  A8                 TAY                     ; get string length back
05197    
05198    UC_loop
05199    D55D  88                 DEY                     ; decrement index
05200    D55E  B1 71              LDA   (ut1_pl),Y        ; get byte from string
05201    D560  20 32 CF           JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
05202    D563  90 02              BCC   NoLcase           ; branch if not alpha
05203    
05204    D565  29 DF              AND   #$DF              ; convert lower to upper case
05205    NoLcase
05206    D567  91 83              STA   (Sutill),Y        ; save byte back to string
05207    D569  98                 TYA                     ; test index
05208    D56A  D0 F1              BNE   UC_loop           ; loop if not all done
05209    
05210    NoString
05211    D56C  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put string
05212                                  ; address and length on descriptor stack and update stack
05213                                  ; pointers
05214    
05215    ; perform SADD()
05216    
05217    LAB_SADD
05218    D56F  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
05219    D572  20 BE CE           JSR   LAB_GVAR          ; get var address
05220    
05221    D575  20 F5 CC           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
05222    D578  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
05223    
05224    D57B  A0 02              LDY   #$02              ; index to string pointer high byte
05225    D57D  B1 95              LDA   (Cvaral),Y        ; get string pointer high byte
05226    D57F  AA                 TAX                     ; copy string pointer high byte to X
05227    D580  88                 DEY                     ; index to string pointer low byte
05228    D581  B1 95              LDA   (Cvaral),Y        ; get string pointer low byte
05229    D583  A8                 TAY                     ; copy string pointer low byte to Y
05230    D584  8A                 TXA                     ; copy string pointer high byte to A
05231    D585  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
05232    
05233    ; perform LEN()
05234    
05235    LAB_LENS
05236    D588  20 8E D5           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
05237    D58B  4C 7A D1           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
05238    
05239    ; evaluate string, get length in Y
05240    
05241    LAB_ESGL
05242    D58E  20 55 D4           JSR   LAB_EVST          ; evaluate string
05243    D591  A8                 TAY                     ; copy length to Y
05244    D592  60                 RTS
05245    
05246    ; perform ASC()
05247    
05248    LAB_ASC
05249    D593  20 8E D5           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
05250    D596  F0 08              BEQ   LAB_23A8          ; if null do function call error then warm start
05251    
05252    D598  A0 00              LDY   #$00              ; set index to first character
05253    D59A  B1 71              LDA   (ut1_pl),Y        ; get byte
05254    D59C  A8                 TAY                     ; copy to Y
05255    D59D  4C 7A D1           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
05256    
05257    ; do function call error then warm start
05258    
05259    LAB_23A8
05260    D5A0  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
05261    
05262    ; scan and get byte parameter
05263    
05264    LAB_SGBY
05265    D5A3  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
05266    
05267    ; get byte parameter
05268    
05269    LAB_GTBY
05270    D5A6  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05271                                  ; else do type mismatch
05272    
05273    ; evaluate byte expression, result in X
05274    
05275    LAB_EVBY
05276    D5A9  20 B6 CF           JSR   LAB_EVPI          ; evaluate integer expression (no check)
05277    
05278    D5AC  A4 AE              LDY   FAC1_2            ; get FAC1 mantissa2
05279    D5AE  D0 F0              BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
05280    
05281    D5B0  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
05282    D5B2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
05283    
05284    ; perform VAL()
05285    
05286    LAB_VAL
05287    D5B5  20 8E D5           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
05288    D5B8  D0 03              BNE   LAB_23C5          ; branch if not null string
05289    
05290                                  ; string was null so set result = $00
05291    D5BA  4C 63 D7           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
05292    
05293    LAB_23C5
05294    ; *** begin patch  2.22p5.7  VAL() may cause string variables to be trashed
05295    ; *** replace     
05296    ;      LDX   Bpntrl            ; get BASIC execute pointer low byte
05297    ;      LDY   Bpntrh            ; get BASIC execute pointer high byte
05298    ;      STX   Btmpl             ; save BASIC execute pointer low byte
05299    ;      STY   Btmph             ; save BASIC execute pointer high byte
05300    ;      LDX   ut1_pl            ; get string pointer low byte
05301    ;      STX   Bpntrl            ; save as BASIC execute pointer low byte
05302    ;      CLC                     ; clear carry
05303    ;      ADC   ut1_pl            ; add string length
05304    ;      STA   ut2_pl            ; save string end low byte
05305    ;      LDA   ut1_ph            ; get string pointer high byte
05306    ;      STA   Bpntrh            ; save as BASIC execute pointer high byte
05307    ;      ADC   #$00              ; add carry to high byte
05308    ;      STA   ut2_ph            ; save string end high byte
05309    ;      LDY   #$00              ; set index to $00
05310    ;      LDA   (ut2_pl),Y        ; get string end +1 byte
05311    ;      PHA                     ; push it
05312    ;      TYA                     ; clear A
05313    ;      STA   (ut2_pl),Y        ; terminate string with $00
05314    ;      JSR   LAB_GBYT          ; scan memory
05315    ;      JSR   LAB_2887          ; get FAC1 from string
05316    ;      PLA                     ; restore string end +1 byte
05317    ;      LDY   #$00              ; set index to zero
05318    ;      STA   (ut2_pl),Y        ; put string end byte back
05319    ; *** with
05320    D5BD  48                 PHA                     ; save length
05321    D5BE  C8                 INY                     ; string length +1
05322    D5BF  98                 TYA
05323    D5C0  20 4E D2           JSR   LAB_MSSP          ; allocate temp string +1 bytes long
05324    D5C3  68                 PLA                     ; get length back
05325    D5C4  20 3D D4           JSR   LAB_229C          ; copy string (ut1_pl) -> (Sutill) for A bytes
05326    D5C7  A9 00              LDA   #0                ; add delimiter to end of string
05327    D5C9  A8                 TAY
05328    D5CA  91 83              STA   (Sutill),Y
05329    D5CC  A6 C3              LDX   Bpntrl            ; save BASIC execute pointer low byte
05330    D5CE  A4 C4              LDY   Bpntrh
05331    D5D0  86 BA              STX   Btmpl
05332    D5D2  84 BB              STY   Btmph
05333    D5D4  A6 AD              LDX   str_pl            ; point to temporary string
05334    D5D6  A4 AE              LDY   str_ph
05335    D5D8  86 C3              STX   Bpntrl
05336    D5DA  84 C4              STY   Bpntrh
05337    D5DC  20 C2 00           JSR   LAB_GBYT          ; scan memory
05338    D5DF  20 B9 DA           JSR   LAB_2887          ; get FAC1 from string
05339    ; *** end patch    2.22p5.7  VAL() may cause string variables to be trashed
05340    
05341    ; restore BASIC execute pointer from temp (Btmpl/Btmph)
05342    
05343    LAB_23F3
05344    D5E2  A6 BA              LDX   Btmpl             ; get BASIC execute pointer low byte back
05345    D5E4  A4 BB              LDY   Btmph             ; get BASIC execute pointer high byte back
05346    D5E6  86 C3              STX   Bpntrl            ; save BASIC execute pointer low byte
05347    D5E8  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
05348    D5EA  60                 RTS
05349    
05350    ; get two parameters for POKE or WAIT
05351    
05352    LAB_GADB
05353    D5EB  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05354                                  ; else do type mismatch
05355    D5EE  20 04 D6           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
05356    
05357    ; scan for "," and get byte, else do Syntax error then warm start
05358    
05359    LAB_SCGB
05360    D5F1  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05361    D5F4  A5 12              LDA   Itemph            ; save temporary integer high byte
05362    D5F6  48                 PHA                     ; on stack
05363    D5F7  A5 11              LDA   Itempl            ; save temporary integer low byte
05364    D5F9  48                 PHA                     ; on stack
05365    D5FA  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
05366    D5FD  68                 PLA                     ; pull low byte
05367    D5FE  85 11              STA   Itempl            ; restore temporary integer low byte
05368    D600  68                 PLA                     ; pull high byte
05369    D601  85 12              STA   Itemph            ; restore temporary integer high byte
05370    D603  60                 RTS
05371    
05372    ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
05373    ; -ve and converts it into a right truncated integer in Itempl and Itemph
05374    
05375    ; save unsigned 16 bit integer part of FAC1 in temporary integer
05376    
05377    LAB_F2FX
05378    D604  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05379    D606  C9 98              CMP   #$98              ; compare with exponent = 2^24
05380    D608  B0 96              BCS   LAB_23A8          ; if >= do function call error then warm start
05381    
05382    LAB_F2FU
05383    D60A  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
05384    D60D  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05385    D60F  A4 AF              LDY   FAC1_3            ; get FAC1 mantissa3
05386    D611  84 11              STY   Itempl            ; save temporary integer low byte
05387    D613  85 12              STA   Itemph            ; save temporary integer high byte
05388    D615  60                 RTS
05389    
05390    ; perform PEEK()
05391    
05392    LAB_PEEK
05393    D616  20 04 D6           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
05394    D619  A2 00              LDX   #$00              ; clear index
05395    D61B  A1 11              LDA   (Itempl,X)        ; get byte via temporary integer (addr)
05396    D61D  A8                 TAY                     ; copy byte to Y
05397    D61E  4C 7A D1           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
05398    
05399    ; perform POKE
05400    
05401    LAB_POKE
05402    D621  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
05403    D624  8A                 TXA                     ; copy byte argument to A
05404    D625  A2 00              LDX   #$00              ; clear index
05405    D627  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
05406    D629  60                 RTS
05407    
05408    ; perform DEEK()
05409    
05410    LAB_DEEK
05411    D62A  20 04 D6           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
05412    D62D  A2 00              LDX   #$00              ; clear index
05413    D62F  A1 11              LDA   (Itempl,X)        ; PEEK low byte
05414    D631  A8                 TAY                     ; copy to Y
05415    D632  E6 11              INC   Itempl            ; increment pointer low byte
05416    D634  D0 02              BNE   Deekh             ; skip high increment if no rollover
05417    
05418    D636  E6 12              INC   Itemph            ; increment pointer high byte
05419    Deekh
05420    D638  A1 11              LDA   (Itempl,X)        ; PEEK high byte
05421    D63A  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
05422    
05423    ; perform DOKE
05424    
05425    LAB_DOKE
05426    D63D  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05427                                  ; else do type mismatch
05428    D640  20 04 D6           JSR   LAB_F2FX          ; convert floating-to-fixed
05429    
05430    D643  84 97              STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
05431    D645  85 98              STA   Frnxth            ; save pointer high byte
05432    
05433    D647  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05434    D64A  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05435                                  ; else do type mismatch
05436    D64D  20 04 D6           JSR   LAB_F2FX          ; convert floating-to-fixed
05437    
05438    D650  98                 TYA                     ; copy value low byte (float to fixed returns word in AY)
05439    D651  A2 00              LDX   #$00              ; clear index
05440    D653  81 97              STA   (Frnxtl,X)        ; POKE low byte
05441    D655  E6 97              INC   Frnxtl            ; increment pointer low byte
05442    D657  D0 02              BNE   Dokeh             ; skip high increment if no rollover
05443    
05444    D659  E6 98              INC   Frnxth            ; increment pointer high byte
05445    Dokeh
05446    D65B  A5 12              LDA   Itemph            ; get value high byte
05447    D65D  81 97              STA   (Frnxtl,X)        ; POKE high byte
05448    D65F  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
05449    
05450    ; perform SWAP
05451    
05452    LAB_SWAP
05453    D662  20 BE CE           JSR   LAB_GVAR          ; get var1 address
05454    D665  85 97              STA   Lvarpl            ; save var1 address low byte
05455    D667  84 98              STY   Lvarph            ; save var1 address high byte
05456    D669  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
05457    D66B  48                 PHA                     ; save data type flag
05458    
05459    D66C  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05460    D66F  20 BE CE           JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
05461    D672  68                 PLA                     ; pull var1 data type flag
05462    D673  45 5F              EOR   Dtypef            ; compare with var2 data type
05463    D675  10 10              BPL   SwapErr           ; exit if not both the same type
05464    
05465    D677  A0 03              LDY   #$03              ; four bytes to swap (either value or descriptor+1)
05466    SwapLp
05467    D679  B1 97              LDA   (Lvarpl),Y        ; get byte from var1
05468    D67B  AA                 TAX                     ; save var1 byte
05469    D67C  B1 95              LDA   (Cvaral),Y        ; get byte from var2
05470    D67E  91 97              STA   (Lvarpl),Y        ; save byte to var1
05471    D680  8A                 TXA                     ; restore var1 byte
05472    D681  91 95              STA   (Cvaral),Y        ; save byte to var2
05473    D683  88                 DEY                     ; decrement index
05474    D684  10 F3              BPL   SwapLp            ; loop until done
05475    
05476    D686  60                 RTS
05477    
05478    SwapErr
05479    D687  4C E2 CB           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
05480    
05481    ; perform CALL
05482    
05483    LAB_CALL
05484    D68A  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05485                                  ; else do type mismatch
05486    D68D  20 04 D6           JSR   LAB_F2FX          ; convert floating-to-fixed
05487    D690  A9 D6              LDA   #>CallExit        ; set return address high byte
05488    D692  48                 PHA                     ; put on stack
05489    D693  A9 98              LDA   #<CallExit-1      ; set return address low byte
05490    D695  48                 PHA                     ; put on stack
05491    D696  6C 11 00           JMP   (Itempl)          ; do indirect jump to user routine
05492    
05493    ; if the called routine exits correctly then it will return to here. this will then get
05494    ; the next byte for the interpreter and return
05495    
05496    CallExit
05497    D699  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
05498    
05499    ; perform WAIT
05500    
05501    LAB_WAIT
05502    D69C  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
05503    D69F  86 97              STX   Frnxtl            ; save byte
05504    D6A1  A2 00              LDX   #$00              ; clear mask
05505    D6A3  20 C2 00           JSR   LAB_GBYT          ; scan memory
05506    D6A6  F0 03              BEQ   LAB_2441          ; skip if no third argument
05507    
05508    D6A8  20 F1 D5           JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
05509    LAB_2441
05510    D6AB  86 98              STX   Frnxth            ; save EOR argument
05511    LAB_2445
05512    D6AD  B1 11              LDA   (Itempl),Y        ; get byte via temporary integer (addr)
05513    D6AF  45 98              EOR   Frnxth            ; EOR with second argument (mask)
05514    D6B1  25 97              AND   Frnxtl            ; AND with first argument (byte)
05515    D6B3  F0 F8              BEQ   LAB_2445          ; loop if result is zero
05516    
05517    LAB_244D
05518    D6B5  60                 RTS
05519    
05520    ; perform subtraction, FAC1 from (AY)
05521    
05522    LAB_2455
05523    D6B6  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
05524    
05525    ; perform subtraction, FAC1 from FAC2
05526    
05527    LAB_SUBTRACT
05528    D6B9  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
05529    D6BB  49 FF              EOR   #$FF              ; complement it
05530    D6BD  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05531    D6BF  45 B7              EOR   FAC2_s            ; EOR with FAC2 sign (b7)
05532    D6C1  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
05533    D6C3  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05534    D6C5  4C D4 D6           JMP   LAB_ADD           ; go add FAC2 to FAC1
05535    
05536    ; perform addition
05537    
05538    LAB_2467
05539    D6C8  20 ED D7           JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
05540    D6CB  90 4D              BCC   LAB_24A8          ;.go subtract mantissas
05541    
05542    ; add 0.5 to FAC1
05543    
05544    LAB_244E
05545    D6CD  A9 0A              LDA   #<LAB_2A96        ; set 0.5 pointer low byte
05546    D6CF  A0 E3              LDY   #>LAB_2A96        ; set 0.5 pointer high byte
05547    
05548    ; add (AY) to FAC1
05549    
05550    LAB_246C
05551    D6D1  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
05552    
05553    ; add FAC2 to FAC1
05554    
05555    LAB_ADD
05556    D6D4  D0 10              BNE   LAB_2474          ; branch if FAC1 was not zero
05557    
05558    ; copy FAC2 to FAC1
05559    
05560    LAB_279B
05561    D6D6  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
05562    
05563    ; save FAC1 sign and copy ABS(FAC2) to FAC1
05564    
05565    LAB_279D
05566    D6D8  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05567    D6DA  A2 04              LDX   #$04              ; 4 bytes to copy
05568    LAB_27A1
05569    D6DC  B5 B2              LDA   FAC1_o,X          ; get byte from FAC2,X
05570    D6DE  95 AB              STA   FAC1_e-1,X        ; save byte at FAC1,X
05571    D6E0  CA                 DEX                     ; decrement count
05572    D6E1  D0 F9              BNE   LAB_27A1          ; loop if not all done
05573    
05574    D6E3  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
05575    D6E5  60                 RTS
05576    
05577                                  ; FAC1 is non zero
05578    LAB_2474
05579    D6E6  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
05580    D6E8  86 A3              STX   FAC2_r            ; save as FAC2 rounding byte
05581    D6EA  A2 B3              LDX   #FAC2_e           ; set index to FAC2 exponent addr
05582    D6EC  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
05583    LAB_247C
05584    D6EE  A8                 TAY                     ; copy exponent
05585    D6EF  F0 C4              BEQ   LAB_244D          ; exit if zero
05586    
05587    D6F1  38                 SEC                     ; set carry for subtract
05588    D6F2  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
05589    D6F4  F0 24              BEQ   LAB_24A8          ; branch if = (go add mantissa)
05590    
05591    D6F6  90 12              BCC   LAB_2498          ; branch if <
05592    
05593                                  ; FAC2>FAC1
05594    D6F8  84 AC              STY   FAC1_e            ; save FAC1 exponent
05595    D6FA  A4 B7              LDY   FAC2_s            ; get FAC2 sign (b7)
05596    D6FC  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
05597    D6FE  49 FF              EOR   #$FF              ; complement A
05598    D700  69 00              ADC   #$00              ; +1 (twos complement, carry is set)
05599    D702  A0 00              LDY   #$00              ; clear Y
05600    D704  84 A3              STY   FAC2_r            ; clear FAC2 rounding byte
05601    D706  A2 AC              LDX   #FAC1_e           ; set index to FAC1 exponent addr
05602    D708  D0 04              BNE   LAB_249C          ; branch always
05603    
05604    LAB_2498
05605    D70A  A0 00              LDY   #$00              ; clear Y
05606    D70C  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
05607    LAB_249C
05608    D70E  C9 F9              CMP   #$F9              ; compare exponent diff with $F9
05609    D710  30 B6              BMI   LAB_2467          ; branch if range $79-$F8
05610    
05611    D712  A8                 TAY                     ; copy exponent difference to Y
05612    D713  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05613    D715  56 01              LSR   PLUS_1,X          ; shift FAC? mantissa1
05614    D717  20 04 D8           JSR   LAB_2592          ; shift FACX Y times right
05615    
05616                                  ; exponents are equal now do mantissa subtract
05617    LAB_24A8
05618    D71A  24 B8              BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
05619    D71C  10 4C              BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
05620    
05621    D71E  A0 AC              LDY   #FAC1_e           ; set index to FAC1 exponent addr
05622    D720  E0 B3              CPX   #FAC2_e           ; compare X to FAC2 exponent addr
05623    D722  F0 02              BEQ   LAB_24B4          ; branch if =
05624    
05625    D724  A0 B3              LDY   #FAC2_e           ; else set index to FAC2 exponent addr
05626    
05627                                  ; subtract smaller from bigger (take sign of bigger)
05628    LAB_24B4
05629    D726  38                 SEC                     ; set carry for subtract
05630    D727  49 FF              EOR   #$FF              ; ones complement A
05631    D729  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
05632    D72B  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
05633    D72D  B9 03 00           LDA   PLUS_3,Y          ; get FACY mantissa3
05634    D730  F5 03              SBC   PLUS_3,X          ; subtract FACX mantissa3
05635    D732  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
05636    D734  B9 02 00           LDA   PLUS_2,Y          ; get FACY mantissa2
05637    D737  F5 02              SBC   PLUS_2,X          ; subtract FACX mantissa2
05638    D739  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
05639    D73B  B9 01 00           LDA   PLUS_1,Y          ; get FACY mantissa1
05640    D73E  F5 01              SBC   PLUS_1,X          ; subtract FACX mantissa1
05641    D740  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
05642    
05643    ; do ABS and normalise FAC1
05644    
05645    LAB_24D0
05646    D742  B0 03              BCS   LAB_24D5          ; branch if number is +ve
05647    
05648    D744  20 A9 D7           JSR   LAB_2537          ; negate FAC1
05649    
05650    ; normalise FAC1
05651    
05652    LAB_24D5
05653    D747  A0 00              LDY   #$00              ; clear Y
05654    D749  98                 TYA                     ; clear A
05655    D74A  18                 CLC                     ; clear carry for add
05656    LAB_24D9
05657    D74B  A6 AD              LDX   FAC1_1            ; get FAC1 mantissa1
05658    D74D  D0 3E              BNE   LAB_251B          ; if not zero normalise FAC1
05659    
05660    D74F  A6 AE              LDX   FAC1_2            ; get FAC1 mantissa2
05661    D751  86 AD              STX   FAC1_1            ; save FAC1 mantissa1
05662    D753  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
05663    D755  86 AE              STX   FAC1_2            ; save FAC1 mantissa2
05664    D757  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
05665    D759  86 AF              STX   FAC1_3            ; save FAC1 mantissa3
05666    D75B  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
05667    D75D  69 08              ADC   #$08              ; add x to exponent offset
05668    D75F  C9 18              CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
05669    D761  D0 E8              BNE   LAB_24D9          ; loop if not max
05670    
05671    ; clear FAC1 exponent and sign
05672    
05673    LAB_24F1
05674    D763  A9 00              LDA   #$00              ; clear A
05675    LAB_24F3
05676    D765  85 AC              STA   FAC1_e            ; set FAC1 exponent
05677    
05678    ; save FAC1 sign
05679    
05680    LAB_24F5
05681    D767  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05682    D769  60                 RTS
05683    
05684    ; add FAC2 mantissa to FAC1 mantissa
05685    
05686    LAB_24F8
05687    D76A  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
05688    D76C  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
05689    D76E  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
05690    D770  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
05691    D772  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
05692    D774  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05693    D776  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
05694    D778  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
05695    D77A  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
05696    D77C  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
05697    D77E  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
05698    D780  B0 1A              BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
05699    
05700    D782  60                 RTS                     ; else just exit
05701    
05702    LAB_2511
05703    D783  69 01              ADC   #$01              ; add 1 to exponent offset
05704    D785  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
05705    D787  26 AF              ROL   FAC1_3            ; shift FAC1 mantissa3
05706    D789  26 AE              ROL   FAC1_2            ; shift FAC1 mantissa2
05707    D78B  26 AD              ROL   FAC1_1            ; shift FAC1 mantissa1
05708    
05709    ; normalise FAC1
05710    
05711    LAB_251B
05712    D78D  10 F4              BPL   LAB_2511          ; loop if not normalised
05713    
05714    D78F  38                 SEC                     ; set carry for subtract
05715    D790  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
05716    D792  B0 CF              BCS   LAB_24F1          ; branch if underflow (set result = $0)
05717    
05718    D794  49 FF              EOR   #$FF              ; complement exponent
05719    D796  69 01              ADC   #$01              ; +1 (twos complement)
05720    D798  85 AC              STA   FAC1_e            ; save FAC1 exponent
05721    
05722    ; test and normalise FAC1 for C=0/1
05723    
05724    LAB_2528
05725    D79A  90 0C              BCC   LAB_2536          ; exit if no overflow
05726    
05727    ; normalise FAC1 for C=1
05728    
05729    LAB_252A
05730    D79C  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
05731    D79E  F0 36              BEQ   LAB_2564          ; if zero do overflow error and warm start
05732    
05733    D7A0  66 AD              ROR   FAC1_1            ; shift FAC1 mantissa1
05734    D7A2  66 AE              ROR   FAC1_2            ; shift FAC1 mantissa2
05735    D7A4  66 AF              ROR   FAC1_3            ; shift FAC1 mantissa3
05736    D7A6  66 B9              ROR   FAC1_r            ; shift FAC1 rounding byte
05737    LAB_2536
05738    D7A8  60                 RTS
05739    
05740    ; negate FAC1
05741    
05742    LAB_2537
05743    D7A9  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
05744    D7AB  49 FF              EOR   #$FF              ; complement it
05745    D7AD  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05746    
05747    ; twos complement FAC1 mantissa
05748    
05749    LAB_253D
05750    D7AF  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
05751    D7B1  49 FF              EOR   #$FF              ; complement it
05752    D7B3  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
05753    D7B5  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05754    D7B7  49 FF              EOR   #$FF              ; complement it
05755    D7B9  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
05756    D7BB  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
05757    D7BD  49 FF              EOR   #$FF              ; complement it
05758    D7BF  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
05759    D7C1  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05760    D7C3  49 FF              EOR   #$FF              ; complement it
05761    D7C5  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
05762    D7C7  E6 B9              INC   FAC1_r            ; increment FAC1 rounding byte
05763    D7C9  D0 0A              BNE   LAB_2563          ; exit if no overflow
05764    
05765    ; increment FAC1 mantissa
05766    
05767    LAB_2559
05768    D7CB  E6 AF              INC   FAC1_3            ; increment FAC1 mantissa3
05769    D7CD  D0 06              BNE   LAB_2563          ; finished if no rollover
05770    
05771    D7CF  E6 AE              INC   FAC1_2            ; increment FAC1 mantissa2
05772    D7D1  D0 02              BNE   LAB_2563          ; finished if no rollover
05773    
05774    D7D3  E6 AD              INC   FAC1_1            ; increment FAC1 mantissa1
05775    LAB_2563
05776    D7D5  60                 RTS
05777    
05778    ; do overflow error (overflow exit)
05779    
05780    LAB_2564
05781    D7D6  A2 0A              LDX   #$0A              ; error code $0A ("Overflow" error)
05782    D7D8  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
05783    
05784    ; shift FCAtemp << A+8 times
05785    
05786    LAB_2569
05787    D7DB  A2 74              LDX   #FACt_1-1         ; set offset to FACtemp
05788    LAB_256B
05789    D7DD  B4 03              LDY   PLUS_3,X          ; get FACX mantissa3
05790    D7DF  84 B9              STY   FAC1_r            ; save as FAC1 rounding byte
05791    D7E1  B4 02              LDY   PLUS_2,X          ; get FACX mantissa2
05792    D7E3  94 03              STY   PLUS_3,X          ; save FACX mantissa3
05793    D7E5  B4 01              LDY   PLUS_1,X          ; get FACX mantissa1
05794    D7E7  94 02              STY   PLUS_2,X          ; save FACX mantissa2
05795    D7E9  A4 B2              LDY   FAC1_o            ; get FAC1 overflow byte
05796    D7EB  94 01              STY   PLUS_1,X          ; save FACX mantissa1
05797    
05798    ; shift FACX -A times right (> 8 shifts)
05799    
05800    LAB_257B
05801    D7ED  69 08              ADC   #$08              ; add 8 to shift count
05802    D7EF  30 EC              BMI   LAB_256B          ; go do 8 shift if still -ve
05803    
05804    D7F1  F0 EA              BEQ   LAB_256B          ; go do 8 shift if zero
05805    
05806    D7F3  E9 08              SBC   #$08              ; else subtract 8 again
05807    D7F5  A8                 TAY                     ; save count to Y
05808    D7F6  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05809    D7F8  B0 12              BCS   LAB_259A          ;.
05810    
05811    LAB_2588
05812    D7FA  16 01              ASL   PLUS_1,X          ; shift FACX mantissa1
05813    D7FC  90 02              BCC   LAB_258E          ; branch if +ve
05814    
05815    D7FE  F6 01              INC   PLUS_1,X          ; this sets b7 eventually
05816    LAB_258E
05817    D800  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
05818    D802  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
05819    
05820    ; shift FACX Y times right
05821    
05822    LAB_2592
05823    D804  76 02              ROR   PLUS_2,X          ; shift FACX mantissa2
05824    D806  76 03              ROR   PLUS_3,X          ; shift FACX mantissa3
05825    D808  6A                 ROR                     ; shift FACX rounding byte
05826    D809  C8                 INY                     ; increment exponent diff
05827    D80A  D0 EE              BNE   LAB_2588          ; branch if range adjust not complete
05828    
05829    LAB_259A
05830    D80C  18                 CLC                     ; just clear it
05831    D80D  60                 RTS
05832    
05833    ; perform LOG()
05834    
05835    LAB_LOG
05836    D80E  20 FC D9           JSR   LAB_27CA          ; test sign and zero
05837    D811  F0 02              BEQ   LAB_25C4          ; if zero do function call error then warm start
05838    
05839    D813  10 03              BPL   LAB_25C7          ; skip error if +ve
05840    
05841    LAB_25C4
05842    D815  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start (-ve)
05843    
05844    LAB_25C7
05845    D818  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05846    D81A  E9 7F              SBC   #$7F              ; normalise it
05847    D81C  48                 PHA                     ; save it
05848    D81D  A9 80              LDA   #$80              ; set exponent to zero
05849    D81F  85 AC              STA   FAC1_e            ; save FAC1 exponent
05850    D821  A9 8A              LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
05851    D823  A0 E2              LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
05852    D825  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
05853    D828  A9 8E              LDA   #<LAB_25B1        ; set root2 pointer low byte
05854    D82A  A0 E2              LDY   #>LAB_25B1        ; set root2 pointer high byte
05855    D82C  20 14 D9           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
05856    D82F  A9 01              LDA   #<LAB_259C        ; set 1 pointer low byte
05857    D831  A0 E3              LDY   #>LAB_259C        ; set 1 pointer high byte
05858    D833  20 B6 D6           JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
05859    D836  A9 7D              LDA   #<LAB_25A0        ; set pointer low byte to counter
05860    D838  A0 E2              LDY   #>LAB_25A0        ; set pointer high byte to counter
05861    D83A  20 64 DD           JSR   LAB_2B6E          ; ^2 then series evaluation
05862    D83D  A9 92              LDA   #<LAB_25B5        ; set -0.5 pointer low byte
05863    D83F  A0 E2              LDY   #>LAB_25B5        ; set -0.5 pointer high byte
05864    D841  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
05865    D844  68                 PLA                     ; restore FAC1 exponent
05866    D845  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
05867    D848  A9 96              LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
05868    D84A  A0 E2              LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
05869    
05870    ; do convert AY, FCA1*(AY)
05871    
05872    LAB_25FB
05873    D84C  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
05874    LAB_MULTIPLY
05875    D84F  F0 4C              BEQ   LAB_264C          ; exit if zero
05876    
05877    D851  20 C4 D8           JSR   LAB_2673          ; test and adjust accumulators
05878    D854  A9 00              LDA   #$00              ; clear A
05879    D856  85 75              STA   FACt_1            ; clear temp mantissa1
05880    D858  85 76              STA   FACt_2            ; clear temp mantissa2
05881    D85A  85 77              STA   FACt_3            ; clear temp mantissa3
05882    D85C  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05883    D85E  20 73 D8           JSR   LAB_2622          ; go do shift/add FAC2
05884    D861  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
05885    D863  20 73 D8           JSR   LAB_2622          ; go do shift/add FAC2
05886    D866  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05887    D868  20 73 D8           JSR   LAB_2622          ; go do shift/add FAC2
05888    D86B  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
05889    D86D  20 79 D8           JSR   LAB_2627          ; go do shift/add FAC2
05890    D870  4C 81 D9           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
05891    
05892    LAB_2622
05893    D873  D0 04              BNE   LAB_2627          ; branch if byte <> zero
05894    ; *** begin patch  2.22p5.6  floating point multiply rounding bug
05895    ; *** replace
05896    ;      JMP   LAB_2569          ; shift FCAtemp << A+8 times
05897    ;
05898    ;                              ; else do shift and add
05899    ;LAB_2627
05900    ;      LSR                     ; shift byte
05901    ;      ORA   #$80              ; set top bit (mark for 8 times)
05902    ; *** with
05903    D875  38                 SEC
05904    D876  4C DB D7           JMP   LAB_2569          ; shift FACtemp << A+8 times
05905    
05906                                  ; else do shift and add
05907    LAB_2627
05908    D879  38                 SEC                     ; set top bit (mark for 8 times)
05909    D87A  6A                 ROR
05910    ; *** end patch    2.22p5.6  floating point multiply rounding bug
05911    LAB_262A
05912    D87B  A8                 TAY                     ; copy result
05913    D87C  90 13              BCC   LAB_2640          ; skip next if bit was zero
05914    
05915    D87E  18                 CLC                     ; clear carry for add
05916    D87F  A5 77              LDA   FACt_3            ; get temp mantissa3
05917    D881  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
05918    D883  85 77              STA   FACt_3            ; save temp mantissa3
05919    D885  A5 76              LDA   FACt_2            ; get temp mantissa2
05920    D887  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
05921    D889  85 76              STA   FACt_2            ; save temp mantissa2
05922    D88B  A5 75              LDA   FACt_1            ; get temp mantissa1
05923    D88D  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
05924    D88F  85 75              STA   FACt_1            ; save temp mantissa1
05925    LAB_2640
05926    D891  66 75              ROR   FACt_1            ; shift temp mantissa1
05927    D893  66 76              ROR   FACt_2            ; shift temp mantissa2
05928    D895  66 77              ROR   FACt_3            ; shift temp mantissa3
05929    D897  66 B9              ROR   FAC1_r            ; shift temp rounding byte
05930    D899  98                 TYA                     ; get byte back
05931    D89A  4A                 LSR                     ; shift byte
05932    D89B  D0 DE              BNE   LAB_262A          ; loop if all bits not done
05933    
05934    LAB_264C
05935    D89D  60                 RTS
05936    
05937    ; unpack memory (AY) into FAC2
05938    
05939    LAB_264D
05940    D89E  85 71              STA   ut1_pl            ; save pointer low byte
05941    D8A0  84 72              STY   ut1_ph            ; save pointer high byte
05942    D8A2  A0 03              LDY   #$03              ; 4 bytes to get (0-3)
05943    D8A4  B1 71              LDA   (ut1_pl),Y        ; get mantissa3
05944    D8A6  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
05945    D8A8  88                 DEY                     ; decrement index
05946    D8A9  B1 71              LDA   (ut1_pl),Y        ; get mantissa2
05947    D8AB  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
05948    D8AD  88                 DEY                     ; decrement index
05949    D8AE  B1 71              LDA   (ut1_pl),Y        ; get mantissa1+sign
05950    D8B0  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
05951    D8B2  45 B0              EOR   FAC1_s            ; EOR with FAC1 sign (b7)
05952    D8B4  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
05953    D8B6  A5 B7              LDA   FAC2_s            ; recover FAC2 sign (b7)
05954    D8B8  09 80              ORA   #$80              ; set 1xxx xxx (set normal bit)
05955    D8BA  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
05956    D8BC  88                 DEY                     ; decrement index
05957    D8BD  B1 71              LDA   (ut1_pl),Y        ; get exponent byte
05958    D8BF  85 B3              STA   FAC2_e            ; save FAC2 exponent
05959    D8C1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05960    D8C3  60                 RTS
05961    
05962    ; test and adjust accumulators
05963    
05964    LAB_2673
05965    D8C4  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
05966    LAB_2675
05967    D8C6  F0 1D              BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
05968    
05969    D8C8  18                 CLC                     ; clear carry for add
05970    D8C9  65 AC              ADC   FAC1_e            ; add FAC1 exponent
05971    D8CB  90 04              BCC   LAB_2680          ; branch if sum of exponents <$0100
05972    
05973    D8CD  30 31              BMI   LAB_269B          ; do overflow error
05974    
05975    D8CF  18                 CLC                     ; clear carry for the add
05976          .byte $2C               ; makes next line BIT $1410
05977    LAB_2680
05978    D8D1  10 12              BPL   LAB_2696          ; if +ve go handle underflow
05979    
05980    D8D3  69 80              ADC   #$80              ; adjust exponent
05981    D8D5  85 AC              STA   FAC1_e            ; save FAC1 exponent
05982    D8D7  D0 03              BNE   LAB_268B          ; branch if not zero
05983    
05984    D8D9  4C 67 D7           JMP   LAB_24F5          ; save FAC1 sign and return
05985    
05986    LAB_268B
05987    D8DC  A5 B8              LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
05988    D8DE  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05989    LAB_268F
05990    D8E0  60                 RTS
05991    
05992    ; handle overflow and underflow
05993    
05994    LAB_2690
05995    D8E1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
05996    D8E3  10 1B              BPL   LAB_269B          ; do overflow error
05997    
05998                                  ; handle underflow
05999    LAB_2696
06000    D8E5  68                 PLA                     ; pop return address low byte
06001    D8E6  68                 PLA                     ; pop return address high byte
06002    D8E7  4C 63 D7           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
06003    
06004    ; multiply by 10
06005    
06006    LAB_269E
06007    D8EA  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
06008    D8ED  AA                 TAX                     ; copy exponent (set the flags)
06009    D8EE  F0 F0              BEQ   LAB_268F          ; exit if zero
06010    
06011    D8F0  18                 CLC                     ; clear carry for add
06012    D8F1  69 02              ADC   #$02              ; add two to exponent (*4)
06013    D8F3  B0 0B              BCS   LAB_269B          ; do overflow error if > $FF
06014    
06015    D8F5  A2 00              LDX   #$00              ; clear byte
06016    D8F7  86 B8              STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
06017    D8F9  20 EE D6           JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
06018    D8FC  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*10)
06019    D8FE  D0 E0              BNE   LAB_268F          ; if non zero just do RTS
06020    
06021    LAB_269B
06022    D900  4C D6 D7           JMP   LAB_2564          ; do overflow error and warm start
06023    
06024    ; divide by 10
06025    
06026    LAB_26B9
06027    D903  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
06028    D906  A9 12              LDA   #<LAB_26B5        ; set pointer to 10d low addr
06029    D908  A0 E3              LDY   #>LAB_26B5        ; set pointer to 10d high addr
06030    D90A  A2 00              LDX   #$00              ; clear sign
06031    
06032    ; divide by (AY) (X=sign)
06033    
06034    LAB_26C2
06035    D90C  86 B8              STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
06036    D90E  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
06037    D911  4C 17 D9           JMP   LAB_DIVIDE        ; do FAC2/FAC1
06038    
06039                                  ; Perform divide-by
06040    ; convert AY and do (AY)/FAC1
06041    
06042    LAB_26CA
06043    D914  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
06044    
06045                                  ; Perform divide-into
06046    LAB_DIVIDE
06047    D917  F0 63              BEQ   LAB_2737          ; if zero go do /0 error
06048    
06049    D919  20 EC D9           JSR   LAB_27BA          ; round FAC1
06050    D91C  A9 00              LDA   #$00              ; clear A
06051    D91E  38                 SEC                     ; set carry for subtract
06052    D91F  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
06053    D921  85 AC              STA   FAC1_e            ; save FAC1 exponent
06054    D923  20 C4 D8           JSR   LAB_2673          ; test and adjust accumulators
06055    D926  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
06056    D928  F0 D6              BEQ   LAB_269B          ; if zero do overflow error
06057    
06058    D92A  A2 FF              LDX   #$FF              ; set index for pre increment
06059    D92C  A9 01              LDA   #$01              ; set bit to flag byte save
06060    LAB_26E4
06061    D92E  A4 B4              LDY   FAC2_1            ; get FAC2 mantissa1
06062    D930  C4 AD              CPY   FAC1_1            ; compare FAC1 mantissa1
06063    D932  D0 0A              BNE   LAB_26F4          ; branch if <>
06064    
06065    D934  A4 B5              LDY   FAC2_2            ; get FAC2 mantissa2
06066    D936  C4 AE              CPY   FAC1_2            ; compare FAC1 mantissa2
06067    D938  D0 04              BNE   LAB_26F4          ; branch if <>
06068    
06069    D93A  A4 B6              LDY   FAC2_3            ; get FAC2 mantissa3
06070    D93C  C4 AF              CPY   FAC1_3            ; compare FAC1 mantissa3
06071    LAB_26F4
06072    D93E  08                 PHP                     ; save FAC2-FAC1 compare status
06073    D93F  2A                 ROL                     ; shift the result byte
06074    D940  90 0E              BCC   LAB_2702          ; if no carry skip the byte save
06075    
06076    D942  A0 01              LDY   #$01              ; set bit to flag byte save
06077    D944  E8                 INX                     ; else increment the index to FACt
06078    D945  E0 02              CPX   #$02              ; compare with the index to FACt_3
06079    D947  30 04              BMI   LAB_2701          ; if not last byte just go save it
06080    
06081    D949  D0 28              BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
06082                                  ; return
06083    
06084    D94B  A0 40              LDY   #$40              ; set bit to flag byte save for the rounding byte
06085    LAB_2701
06086    D94D  95 75              STA   FACt_1,X          ; write result byte to FACt_1 + index
06087    D94F  98                 TYA                     ; copy the next save byte flag
06088    LAB_2702
06089    D950  28                 PLP                     ; restore FAC2-FAC1 compare status
06090    D951  90 14              BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
06091    
06092    D953  A8                 TAY                     ; save FAC2-FAC1 compare status
06093    D954  A5 B6              LDA   FAC2_3            ; get FAC2 mantissa3
06094    D956  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
06095    D958  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
06096    D95A  A5 B5              LDA   FAC2_2            ; get FAC2 mantissa2
06097    D95C  E5 AE              SBC   FAC1_2            ; subtract FAC1 mantissa2
06098    D95E  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
06099    D960  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
06100    D962  E5 AD              SBC   FAC1_1            ; subtract FAC1 mantissa1
06101    D964  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
06102    D966  98                 TYA                     ; restore FAC2-FAC1 compare status
06103    
06104                                  ; FAC2 = FAC2*2
06105    LAB_2704
06106    D967  06 B6              ASL   FAC2_3            ; shift FAC2 mantissa3
06107    D969  26 B5              ROL   FAC2_2            ; shift FAC2 mantissa2
06108    D96B  26 B4              ROL   FAC2_1            ; shift FAC2 mantissa1
06109    D96D  B0 CF              BCS   LAB_26F4          ; loop with no compare
06110    
06111    D96F  30 BD              BMI   LAB_26E4          ; loop with compare
06112    
06113    D971  10 CB              BPL   LAB_26F4          ; loop always with no compare
06114    
06115    ; do A<<6, save as FAC1 rounding byte, normalise and return
06116    
06117    LAB_272B
06118    D973  4A                 LSR                     ; shift b1 - b0 ..
06119    D974  6A                 ROR                     ; ..
06120    D975  6A                 ROR                     ; .. to b7 - b6
06121    D976  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
06122    D978  28                 PLP                     ; dump FAC2-FAC1 compare status
06123    D979  4C 81 D9           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
06124    
06125    ; do "Divide by zero" error
06126    
06127    LAB_2737
06128    D97C  A2 14              LDX   #$14              ; error code $14 ("Divide by zero" error)
06129    D97E  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
06130    
06131    ; copy temp to FAC1 and normalise
06132    
06133    LAB_273C
06134    D981  A5 75              LDA   FACt_1            ; get temp mantissa1
06135    D983  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06136    D985  A5 76              LDA   FACt_2            ; get temp mantissa2
06137    D987  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
06138    D989  A5 77              LDA   FACt_3            ; get temp mantissa3
06139    D98B  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
06140    D98D  4C 47 D7           JMP   LAB_24D5          ; normalise FAC1 and return
06141    
06142    ; unpack memory (AY) into FAC1
06143    
06144    LAB_UFAC
06145    D990  85 71              STA   ut1_pl            ; save pointer low byte
06146    D992  84 72              STY   ut1_ph            ; save pointer high byte
06147    D994  A0 03              LDY   #$03              ; 4 bytes to do
06148    D996  B1 71              LDA   (ut1_pl),Y        ; get last byte
06149    D998  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
06150    D99A  88                 DEY                     ; decrement index
06151    D99B  B1 71              LDA   (ut1_pl),Y        ; get last-1 byte
06152    D99D  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
06153    D99F  88                 DEY                     ; decrement index
06154    D9A0  B1 71              LDA   (ut1_pl),Y        ; get second byte
06155    D9A2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
06156    D9A4  09 80              ORA   #$80              ; set 1xxx xxxx (add normal bit)
06157    D9A6  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06158    D9A8  88                 DEY                     ; decrement index
06159    D9A9  B1 71              LDA   (ut1_pl),Y        ; get first byte (exponent)
06160    D9AB  85 AC              STA   FAC1_e            ; save FAC1 exponent
06161    D9AD  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
06162    D9AF  60                 RTS
06163    
06164    ; pack FAC1 into Adatal
06165    
06166    LAB_276E
06167    D9B0  A2 A4              LDX   #<Adatal          ; set pointer low byte
06168    LAB_2770
06169    D9B2  A0 00              LDY   #>Adatal          ; set pointer high byte
06170    D9B4  F0 04              BEQ   LAB_2778          ; pack FAC1 into (XY) and return
06171    
06172    ; pack FAC1 into (Lvarpl)
06173    
06174    LAB_PFAC
06175    D9B6  A6 97              LDX   Lvarpl            ; get destination pointer low byte
06176    D9B8  A4 98              LDY   Lvarph            ; get destination pointer high byte
06177    
06178    ; pack FAC1 into (XY)
06179    
06180    LAB_2778
06181    D9BA  20 EC D9           JSR   LAB_27BA          ; round FAC1
06182    D9BD  86 71              STX   ut1_pl            ; save pointer low byte
06183    D9BF  84 72              STY   ut1_ph            ; save pointer high byte
06184    D9C1  A0 03              LDY   #$03              ; set index
06185    D9C3  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
06186    D9C5  91 71              STA   (ut1_pl),Y        ; store in destination
06187    D9C7  88                 DEY                     ; decrement index
06188    D9C8  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
06189    D9CA  91 71              STA   (ut1_pl),Y        ; store in destination
06190    D9CC  88                 DEY                     ; decrement index
06191    D9CD  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06192    D9CF  09 7F              ORA   #$7F              ; set bits x111 1111
06193    D9D1  25 AD              AND   FAC1_1            ; AND in FAC1 mantissa1
06194    D9D3  91 71              STA   (ut1_pl),Y        ; store in destination
06195    D9D5  88                 DEY                     ; decrement index
06196    D9D6  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06197    D9D8  91 71              STA   (ut1_pl),Y        ; store in destination
06198    D9DA  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
06199    D9DC  60                 RTS
06200    
06201    ; round and copy FAC1 to FAC2
06202    
06203    LAB_27AB
06204    D9DD  20 EC D9           JSR   LAB_27BA          ; round FAC1
06205    
06206    ; copy FAC1 to FAC2
06207    
06208    LAB_27AE
06209    D9E0  A2 05              LDX   #$05              ; 5 bytes to copy
06210    LAB_27B0
06211    D9E2  B5 AB              LDA   FAC1_e-1,X        ; get byte from FAC1,X
06212    D9E4  95 B2              STA   FAC1_o,X          ; save byte at FAC2,X
06213    D9E6  CA                 DEX                     ; decrement count
06214    D9E7  D0 F9              BNE   LAB_27B0          ; loop if not all done
06215    
06216    D9E9  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
06217    LAB_27B9
06218    D9EB  60                 RTS
06219    
06220    ; round FAC1
06221    
06222    LAB_27BA
06223    D9EC  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06224    D9EE  F0 FB              BEQ   LAB_27B9          ; exit if zero
06225    
06226    D9F0  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
06227    D9F2  90 F7              BCC   LAB_27B9          ; exit if no overflow
06228    
06229    ; round FAC1 (no check)
06230    
06231    LAB_27C2
06232    D9F4  20 CB D7           JSR   LAB_2559          ; increment FAC1 mantissa
06233    D9F7  D0 F2              BNE   LAB_27B9          ; branch if no overflow
06234    
06235    D9F9  4C 9C D7           JMP   LAB_252A          ; normalise FAC1 for C=1 and return
06236    
06237    ; get FAC1 sign
06238    ; return A=FF,C=1/-ve A=01,C=0/+ve
06239    
06240    LAB_27CA
06241    D9FC  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06242    D9FE  F0 09              BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
06243    
06244    ; return A=FF,C=1/-ve A=01,C=0/+ve
06245    ; no = 0 check
06246    
06247    LAB_27CE
06248    DA00  A5 B0              LDA   FAC1_s            ; else get FAC1 sign (b7)
06249    
06250    ; return A=FF,C=1/-ve A=01,C=0/+ve
06251    ; no = 0 check, sign in A
06252    
06253    LAB_27D0
06254    DA02  2A                 ROL                     ; move sign bit to carry
06255    DA03  A9 FF              LDA   #$FF              ; set byte for -ve result
06256    DA05  B0 02              BCS   LAB_27D7          ; return if sign was set (-ve)
06257    
06258    DA07  A9 01              LDA   #$01              ; else set byte for +ve result
06259    LAB_27D7
06260    DA09  60                 RTS
06261    
06262    ; perform SGN()
06263    
06264    LAB_SGN
06265    DA0A  20 FC D9           JSR   LAB_27CA          ; get FAC1 sign
06266                                  ; return A=$FF/-ve A=$01/+ve
06267    ; save A as integer byte
06268    
06269    LAB_27DB
06270    DA0D  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06271    DA0F  A9 00              LDA   #$00              ; clear A
06272    DA11  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
06273    DA13  A2 88              LDX   #$88              ; set exponent
06274    
06275    ; set exp=X, clearFAC1 mantissa3 and normalise
06276    
06277    LAB_27E3
06278    DA15  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
06279    DA17  49 FF              EOR   #$FF              ; complement it
06280    DA19  2A                 ROL                     ; sign bit into carry
06281    
06282    ; set exp=X, clearFAC1 mantissa3 and normalise
06283    
06284    LAB_STFA
06285    DA1A  A9 00              LDA   #$00              ; clear A
06286    DA1C  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
06287    DA1E  86 AC              STX   FAC1_e            ; set FAC1 exponent
06288    DA20  85 B9              STA   FAC1_r            ; clear FAC1 rounding byte
06289    DA22  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
06290    DA24  4C 42 D7           JMP   LAB_24D0          ; do ABS and normalise FAC1
06291    
06292    ; perform ABS()
06293    
06294    LAB_ABS
06295    DA27  46 B0              LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
06296    DA29  60                 RTS
06297    
06298    ; compare FAC1 with (AY)
06299    ; returns A=$00 if FAC1 = (AY)
06300    ; returns A=$01 if FAC1 > (AY)
06301    ; returns A=$FF if FAC1 < (AY)
06302    
06303    LAB_27F8
06304    DA2A  85 73              STA   ut2_pl            ; save pointer low byte
06305    LAB_27FA
06306    DA2C  84 74              STY   ut2_ph            ; save pointer high byte
06307    DA2E  A0 00              LDY   #$00              ; clear index
06308    DA30  B1 73              LDA   (ut2_pl),Y        ; get exponent
06309    DA32  C8                 INY                     ; increment index
06310    DA33  AA                 TAX                     ; copy (AY) exponent to X
06311    DA34  F0 C6              BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
06312                                  ; A=FF,C=1/-ve A=01,C=0/+ve
06313    
06314    DA36  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
06315    DA38  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
06316    DA3A  30 C4              BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
06317                                  ; A=01,C=0/+ve and return
06318    
06319    DA3C  E4 AC              CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
06320    DA3E  D0 1A              BNE   LAB_2828          ; branch if different
06321    
06322    DA40  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
06323    DA42  09 80              ORA   #$80              ; normalise top bit
06324    DA44  C5 AD              CMP   FAC1_1            ; compare with FAC1 mantissa1
06325    DA46  D0 12              BNE   LAB_2828          ; branch if different
06326    
06327    DA48  C8                 INY                     ; increment index
06328    DA49  B1 73              LDA   (ut2_pl),Y        ; get mantissa2
06329    DA4B  C5 AE              CMP   FAC1_2            ; compare with FAC1 mantissa2
06330    DA4D  D0 0B              BNE   LAB_2828          ; branch if different
06331    
06332    DA4F  C8                 INY                     ; increment index
06333    DA50  A9 7F              LDA   #$7F              ; set for 1/2 value rounding byte
06334    DA52  C5 B9              CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
06335    DA54  B1 73              LDA   (ut2_pl),Y        ; get mantissa3
06336    DA56  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
06337    DA58  F0 28              BEQ   LAB_2850          ; exit if mantissa3 equal
06338    
06339    ; gets here if number <> FAC1
06340    
06341    LAB_2828
06342    DA5A  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06343    DA5C  90 02              BCC   LAB_282E          ; branch if FAC1 > (AY)
06344    
06345    DA5E  49 FF              EOR   #$FF              ; else toggle FAC1 sign
06346    LAB_282E
06347    DA60  4C 02 DA           JMP   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
06348    
06349    ; convert FAC1 floating-to-fixed
06350    
06351    LAB_2831
06352    DA63  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06353    DA65  F0 4A              BEQ   LAB_287F          ; if zero go clear FAC1 and return
06354    
06355    DA67  38                 SEC                     ; set carry for subtract
06356    DA68  E9 98              SBC   #$98              ; subtract maximum integer range exponent
06357    DA6A  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
06358    DA6C  10 09              BPL   LAB_2845          ; branch if FAC1 +ve
06359    
06360                                  ; FAC1 was -ve
06361    DA6E  AA                 TAX                     ; copy subtracted exponent
06362    DA6F  A9 FF              LDA   #$FF              ; overflow for -ve number
06363    DA71  85 B2              STA   FAC1_o            ; set FAC1 overflow byte
06364    DA73  20 AF D7           JSR   LAB_253D          ; twos complement FAC1 mantissa
06365    DA76  8A                 TXA                     ; restore subtracted exponent
06366    LAB_2845
06367    DA77  A2 AC              LDX   #FAC1_e           ; set index to FAC1
06368    DA79  C9 F9              CMP   #$F9              ; compare exponent result
06369    DA7B  10 06              BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
06370    
06371    DA7D  20 ED D7           JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
06372    DA80  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
06373    LAB_2850
06374    DA82  60                 RTS
06375    
06376    ; shift FAC1 A times right
06377    
06378    LAB_2851
06379    DA83  A8                 TAY                     ; copy shift count
06380    DA84  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06381    DA86  29 80              AND   #$80              ; mask sign bit only (x000 0000)
06382    DA88  46 AD              LSR   FAC1_1            ; shift FAC1 mantissa1
06383    DA8A  05 AD              ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
06384    DA8C  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06385    DA8E  20 04 D8           JSR   LAB_2592          ; shift FAC1 Y times right
06386    DA91  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
06387    DA93  60                 RTS
06388    
06389    ; perform INT()
06390    
06391    LAB_INT
06392    DA94  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06393    DA96  C9 98              CMP   #$98              ; compare with max int
06394    DA98  B0 1E              BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
06395    
06396    DA9A  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
06397    DA9D  84 B9              STY   FAC1_r            ; save FAC1 rounding byte
06398    DA9F  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06399    DAA1  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
06400    DAA3  49 80              EOR   #$80              ; toggle FAC1 sign
06401    DAA5  2A                 ROL                     ; shift into carry
06402    DAA6  A9 98              LDA   #$98              ; set new exponent
06403    DAA8  85 AC              STA   FAC1_e            ; save FAC1 exponent
06404    DAAA  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
06405    DAAC  85 5B              STA   Temp3             ; save for EXP() function
06406    DAAE  4C 42 D7           JMP   LAB_24D0          ; do ABS and normalise FAC1
06407    
06408    ; clear FAC1 and return
06409    
06410    LAB_287F
06411    DAB1  85 AD              STA   FAC1_1            ; clear FAC1 mantissa1
06412    DAB3  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
06413    DAB5  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
06414    DAB7  A8                 TAY                     ; clear Y
06415    LAB_2886
06416    DAB8  60                 RTS
06417    
06418    ; get FAC1 from string
06419    ; this routine now handles hex and binary values from strings
06420    ; starting with "$" and "%" respectively
06421    
06422    LAB_2887
06423    DAB9  A0 00              LDY   #$00              ; clear Y
06424    DABB  84 5F              STY   Dtypef            ; clear data type flag, $FF=string, $00=numeric
06425    DABD  A2 09              LDX   #$09              ; set index
06426    LAB_288B
06427    DABF  94 A8              STY   numexp,X          ; clear byte
06428    DAC1  CA                 DEX                     ; decrement index
06429    DAC2  10 FB              BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
06430    
06431    DAC4  90 7F              BCC   LAB_28FE          ; branch if 1st character numeric
06432    
06433    ; get FAC1 from string .. first character wasn't numeric
06434    
06435    DAC6  C9 2D              CMP   #'-'              ; else compare with "-"
06436    DAC8  D0 04              BNE   LAB_289A          ; branch if not "-"
06437    
06438    DACA  86 B1              STX   negnum            ; set flag for -ve number (X = $FF)
06439    DACC  F0 04              BEQ   LAB_289C          ; branch always (go scan and check for hex/bin)
06440    
06441    ; get FAC1 from string .. first character wasn't numeric or -
06442    
06443    LAB_289A
06444    DACE  C9 2B              CMP   #'+'              ; else compare with "+"
06445    DAD0  D0 05              BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
06446    
06447    ; was "+" or "-" to start, so get next character
06448    
06449    LAB_289C
06450    DAD2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
06451    DAD5  90 6E              BCC   LAB_28FE          ; branch if numeric character
06452    
06453    ; code here for hex and binary numbers
06454    
06455    LAB_289D
06456    DAD7  C9 24              CMP   #'$'              ; else compare with "$"
06457    DAD9  D0 03              BNE   LAB_NHEX          ; branch if not "$"
06458    
06459    DADB  4C 83 DF           JMP   LAB_CHEX          ; branch if "$"
06460    
06461    LAB_NHEX
06462    DADE  C9 25              CMP   #'%'              ; else compare with "%"
06463    DAE0  D0 08              BNE   LAB_28A3          ; branch if not "%" (continue original code)
06464    
06465    DAE2  4C B1 DF           JMP   LAB_CBIN          ; branch if "%"
06466    
06467    LAB_289E
06468    DAE5  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
06469    LAB_28A1
06470    DAE8  90 5B              BCC   LAB_28FE          ; branch if numeric character
06471    
06472    ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
06473    
06474    LAB_28A3
06475    DAEA  C9 2E              CMP   #'.'              ; else compare with "."
06476    DAEC  F0 2E              BEQ   LAB_28D5          ; branch if "."
06477    
06478    ; get FAC1 from string .. character wasn't numeric, -, + or .
06479    
06480    DAEE  C9 45              CMP   #'E'              ; else compare with "E"
06481    DAF0  D0 30              BNE   LAB_28DB          ; branch if not "E"
06482    
06483                                  ; was "E" so evaluate exponential part
06484    DAF2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
06485    DAF5  90 17              BCC   LAB_28C7          ; branch if numeric character
06486    
06487    DAF7  C9 C1              CMP   #TK_MINUS         ; else compare with token for -
06488    DAF9  F0 0E              BEQ   LAB_28C2          ; branch if token for -
06489    
06490    DAFB  C9 2D              CMP   #'-'              ; else compare with "-"
06491    DAFD  F0 0A              BEQ   LAB_28C2          ; branch if "-"
06492    
06493    DAFF  C9 C0              CMP   #TK_PLUS          ; else compare with token for +
06494    DB01  F0 08              BEQ   LAB_28C4          ; branch if token for +
06495    
06496    DB03  C9 2B              CMP   #'+'              ; else compare with "+"
06497    DB05  F0 04              BEQ   LAB_28C4          ; branch if "+"
06498    
06499    DB07  D0 07              BNE   LAB_28C9          ; branch always
06500    
06501    LAB_28C2
06502    DB09  66 AB              ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
06503    LAB_28C4
06504    DB0B  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
06505    LAB_28C7
06506    DB0E  90 5B              BCC   LAB_2925          ; branch if numeric character
06507    
06508    LAB_28C9
06509    DB10  24 AB              BIT   expneg            ; test exponent -ve flag
06510    DB12  10 0E              BPL   LAB_28DB          ; if +ve go evaluate exponent
06511    
06512                                  ; else do exponent = -exponent 
06513    DB14  A9 00              LDA   #$00              ; clear result
06514    DB16  38                 SEC                     ; set carry for subtract
06515    DB17  E5 A9              SBC   expcnt            ; subtract exponent byte
06516    DB19  4C 24 DB           JMP   LAB_28DD          ; go evaluate exponent
06517    
06518    LAB_28D5
06519    DB1C  66 AA              ROR   numdpf            ; set decimal point flag
06520    DB1E  24 AA              BIT   numdpf            ; test decimal point flag
06521    DB20  50 C3              BVC   LAB_289E          ; branch if only one decimal point so far
06522    
06523                                  ; evaluate exponent
06524    LAB_28DB
06525    DB22  A5 A9              LDA   expcnt            ; get exponent count byte
06526    LAB_28DD
06527    DB24  38                 SEC                     ; set carry for subtract
06528    DB25  E5 A8              SBC   numexp            ; subtract numerator exponent
06529    DB27  85 A9              STA   expcnt            ; save exponent count byte
06530    DB29  F0 12              BEQ   LAB_28F6          ; branch if no adjustment
06531    
06532    DB2B  10 09              BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
06533    
06534                                  ; else go do FAC1/10^(0-expcnt)
06535    LAB_28E6
06536    DB2D  20 03 D9           JSR   LAB_26B9          ; divide by 10
06537    DB30  E6 A9              INC   expcnt            ; increment exponent count byte
06538    DB32  D0 F9              BNE   LAB_28E6          ; loop until all done
06539    
06540    DB34  F0 07              BEQ   LAB_28F6          ; branch always
06541    
06542    LAB_28EF
06543    DB36  20 EA D8           JSR   LAB_269E          ; multiply by 10
06544    DB39  C6 A9              DEC   expcnt            ; decrement exponent count byte
06545    DB3B  D0 F9              BNE   LAB_28EF          ; loop until all done
06546    
06547    LAB_28F6
06548    DB3D  A5 B1              LDA   negnum            ; get -ve flag
06549    DB3F  30 01              BMI   LAB_28FB          ; if -ve do - FAC1 and return
06550    
06551    DB41  60                 RTS
06552    
06553    ; do - FAC1 and return
06554    
06555    LAB_28FB
06556    DB42  4C 07 DD           JMP   LAB_GTHAN         ; do - FAC1 and return
06557    
06558    ; do unsigned FAC1*10+number
06559    
06560    LAB_28FE
06561    DB45  48                 PHA                     ; save character
06562    DB46  24 AA              BIT   numdpf            ; test decimal point flag
06563    DB48  10 02              BPL   LAB_2905          ; skip exponent increment if not set
06564    
06565    DB4A  E6 A8              INC   numexp            ; else increment number exponent
06566    LAB_2905
06567    DB4C  20 EA D8           JSR   LAB_269E          ; multiply FAC1 by 10
06568    DB4F  68                 PLA                     ; restore character
06569    DB50  29 0F              AND   #$0F              ; convert to binary
06570    DB52  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
06571    DB55  4C E5 DA           JMP   LAB_289E          ; go do next character
06572    
06573    ; evaluate new ASCII digit
06574    
06575    LAB_2912
06576    DB58  48                 PHA                     ; save digit
06577    DB59  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
06578    DB5C  68                 PLA                     ; restore digit
06579    DB5D  20 0D DA           JSR   LAB_27DB          ; save A as integer byte
06580    DB60  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
06581    DB62  45 B0              EOR   FAC1_s            ; toggle with FAC1 sign (b7)
06582    DB64  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
06583    DB66  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
06584    DB68  4C D4 D6           JMP   LAB_ADD           ; add FAC2 to FAC1 and return
06585    
06586    ; evaluate next character of exponential part of number
06587    
06588    LAB_2925
06589    DB6B  A5 A9              LDA   expcnt            ; get exponent count byte
06590    DB6D  C9 0A              CMP   #$0A              ; compare with 10 decimal
06591    DB6F  90 09              BCC   LAB_2934          ; branch if less
06592    
06593    DB71  A9 64              LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
06594    DB73  24 AB              BIT   expneg            ; test exponent -ve flag
06595    DB75  30 0E              BMI   LAB_2942          ; branch if -ve
06596    
06597    DB77  4C D6 D7           JMP   LAB_2564          ; else do overflow error
06598    
06599    LAB_2934
06600    DB7A  0A                 ASL                     ; * 2
06601    DB7B  0A                 ASL                     ; * 4
06602    DB7C  65 A9              ADC   expcnt            ; * 5
06603    DB7E  0A                 ASL                     ; * 10
06604    DB7F  A0 00              LDY   #$00              ; set index
06605    DB81  71 C3              ADC   (Bpntrl),Y        ; add character (will be $30 too much!)
06606    DB83  E9 2F              SBC   #'0'-1            ; convert character to binary
06607    LAB_2942
06608    DB85  85 A9              STA   expcnt            ; save exponent count byte
06609    DB87  4C 0B DB           JMP   LAB_28C4          ; go get next character
06610    
06611    ; print " in line [LINE #]"
06612    
06613    LAB_2953
06614    DB8A  A9 B9              LDA   #<LAB_LMSG        ; point to " in line " message low byte
06615    DB8C  A0 E9              LDY   #>LAB_LMSG        ; point to " in line " message high byte
06616    DB8E  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
06617    
06618                                  ; print Basic line #
06619    DB91  A5 88              LDA   Clineh            ; get current line high byte
06620    DB93  A6 87              LDX   Clinel            ; get current line low byte
06621    
06622    ; print XA as unsigned integer
06623    
06624    LAB_295E
06625    DB95  85 AD              STA   FAC1_1            ; save low byte as FAC1 mantissa1
06626    DB97  86 AE              STX   FAC1_2            ; save high byte as FAC1 mantissa2
06627    DB99  A2 90              LDX   #$90              ; set exponent to 16d bits
06628    DB9B  38                 SEC                     ; set integer is +ve flag
06629    DB9C  20 1A DA           JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
06630    DB9F  A0 00              LDY   #$00              ; clear index
06631    DBA1  98                 TYA                     ; clear A
06632    DBA2  20 B5 DB           JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
06633    DBA5  4C DA C9           JMP   LAB_18C3          ; print null terminated string from memory and return
06634    
06635    ; convert FAC1 to ASCII string result in (AY)
06636    ; not any more, moved scratchpad to page 0
06637    
06638    LAB_296E
06639    DBA8  A0 01              LDY   #$01              ; set index = 1
06640    DBAA  A9 20              LDA   #$20              ; character = " " (assume +ve)
06641    DBAC  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
06642    DBAE  10 02              BPL   LAB_2978          ; branch if +ve
06643    
06644    DBB0  A9 2D              LDA   #$2D              ; else character = "-"
06645    LAB_2978
06646    DBB2  99 EF 00           STA   Decss,Y           ; save leading character (" " or "-")
06647    LAB_297B
06648    DBB5  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
06649    DBB7  84 BA              STY   Sendl             ; save index
06650    DBB9  C8                 INY                     ; increment index
06651    DBBA  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
06652    DBBC  D0 05              BNE   LAB_2989          ; branch if FAC1<>0
06653    
06654                                  ; exponent was $00 so FAC1 is 0
06655    DBBE  A9 30              LDA   #'0'              ; set character = "0"
06656    DBC0  4C C1 DC           JMP   LAB_2A89          ; save last character, [EOT] and exit
06657    
06658                                  ; FAC1 is some non zero value
06659    LAB_2989
06660    DBC3  A9 00              LDA   #$00              ; clear (number exponent count)
06661    DBC5  E0 81              CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
06662    
06663    DBC7  B0 09              BCS   LAB_299A          ; branch if FAC1=>1
06664    
06665                                  ; FAC1<1
06666    DBC9  A9 A2              LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
06667    DBCB  A0 E2              LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
06668    DBCD  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06669    DBD0  A9 FA              LDA   #$FA              ; set number exponent count (-6)
06670    LAB_299A
06671    DBD2  85 A8              STA   numexp            ; save number exponent count
06672    LAB_299C
06673    DBD4  A9 9E              LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
06674    DBD6  A0 E2              LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
06675    DBD8  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
06676    DBDB  F0 1E              BEQ   LAB_29C3          ; exit if FAC1 = (AY)
06677    
06678    DBDD  10 12              BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
06679    
06680                                  ; FAC1 < (AY)
06681    LAB_29A7
06682    DBDF  A9 9A              LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
06683    DBE1  A0 E2              LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
06684    DBE3  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
06685    DBE6  F0 02              BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
06686    
06687    DBE8  10 0E              BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
06688    
06689                                  ; FAC1 <= (AY)
06690    LAB_29B2
06691    DBEA  20 EA D8           JSR   LAB_269E          ; multiply by 10
06692    DBED  C6 A8              DEC   numexp            ; decrement number exponent count
06693    DBEF  D0 EE              BNE   LAB_29A7          ; go test again (branch always)
06694    
06695    LAB_29B9
06696    DBF1  20 03 D9           JSR   LAB_26B9          ; divide by 10
06697    DBF4  E6 A8              INC   numexp            ; increment number exponent count
06698    DBF6  D0 DC              BNE   LAB_299C          ; go test again (branch always)
06699    
06700    ; now we have just the digits to do
06701    
06702    LAB_29C0
06703    DBF8  20 CD D6           JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
06704    LAB_29C3
06705    DBFB  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
06706    DBFE  A2 01              LDX   #$01              ; set default digits before dp = 1
06707    DC00  A5 A8              LDA   numexp            ; get number exponent count
06708    DC02  18                 CLC                     ; clear carry for add
06709    DC03  69 07              ADC   #$07              ; up to 6 digits before point
06710    DC05  30 09              BMI   LAB_29D8          ; if -ve then 1 digit before dp
06711    
06712    DC07  C9 08              CMP   #$08              ; A>=8 if n>=1E6
06713    DC09  B0 06              BCS   LAB_29D9          ; branch if >= $08
06714    
06715                                  ; carry is clear
06716    DC0B  69 FF              ADC   #$FF              ; take 1 from digit count
06717    DC0D  AA                 TAX                     ; copy to A
06718    DC0E  A9 02              LDA   #$02              ;.set exponent adjust
06719    LAB_29D8
06720    DC10  38                 SEC                     ; set carry for subtract
06721    LAB_29D9
06722    DC11  E9 02              SBC   #$02              ; -2
06723    DC13  85 A9              STA   expcnt            ;.save exponent adjust
06724    DC15  86 A8              STX   numexp            ; save digits before dp count
06725    DC17  8A                 TXA                     ; copy to A
06726    DC18  F0 02              BEQ   LAB_29E4          ; branch if no digits before dp
06727    
06728    DC1A  10 13              BPL   LAB_29F7          ; branch if digits before dp
06729    
06730    LAB_29E4
06731    DC1C  A4 BA              LDY   Sendl             ; get output string index
06732    DC1E  A9 2E              LDA   #$2E              ; character "."
06733    DC20  C8                 INY                     ; increment index
06734    DC21  99 EF 00           STA   Decss,Y           ; save to output string
06735    DC24  8A                 TXA                     ;.
06736    DC25  F0 06              BEQ   LAB_29F5          ;.
06737    
06738    DC27  A9 30              LDA   #'0'              ; character "0"
06739    DC29  C8                 INY                     ; increment index
06740    DC2A  99 EF 00           STA   Decss,Y           ; save to output string
06741    LAB_29F5
06742    DC2D  84 BA              STY   Sendl             ; save output string index
06743    LAB_29F7
06744    DC2F  A0 00              LDY   #$00              ; clear index (point to 100,000)
06745    DC31  A2 80              LDX   #$80              ; 
06746    LAB_29FB
06747    DC33  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
06748    DC35  18                 CLC                     ; clear carry for add
06749    DC36  79 18 E3           ADC   LAB_2A9C,Y        ; add -ve LSB
06750    DC39  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
06751    DC3B  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
06752    DC3D  79 17 E3           ADC   LAB_2A9B,Y        ; add -ve NMSB
06753    DC40  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
06754    DC42  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
06755    DC44  79 16 E3           ADC   LAB_2A9A,Y        ; add -ve MSB
06756    DC47  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06757    DC49  E8                 INX                     ; 
06758    DC4A  B0 04              BCS   LAB_2A18          ; 
06759    
06760    DC4C  10 E5              BPL   LAB_29FB          ; not -ve so try again
06761    
06762    DC4E  30 02              BMI   LAB_2A1A          ; 
06763    
06764    LAB_2A18
06765    DC50  30 E1              BMI   LAB_29FB          ; 
06766    
06767    LAB_2A1A
06768    DC52  8A                 TXA                     ; 
06769    DC53  90 04              BCC   LAB_2A21          ; 
06770    
06771    DC55  49 FF              EOR   #$FF              ; 
06772    DC57  69 0A              ADC   #$0A              ; 
06773    LAB_2A21
06774    DC59  69 2F              ADC   #'0'-1            ; add "0"-1 to result
06775    DC5B  C8                 INY                     ; increment index ..
06776    DC5C  C8                 INY                     ; .. to next less ..
06777    DC5D  C8                 INY                     ; .. power of ten
06778    DC5E  84 95              STY   Cvaral            ; save as current var address low byte
06779    DC60  A4 BA              LDY   Sendl             ; get output string index
06780    DC62  C8                 INY                     ; increment output string index
06781    DC63  AA                 TAX                     ; copy character to X
06782    DC64  29 7F              AND   #$7F              ; mask out top bit
06783    DC66  99 EF 00           STA   Decss,Y           ; save to output string
06784    DC69  C6 A8              DEC   numexp            ; decrement # of characters before the dp
06785    DC6B  D0 06              BNE   LAB_2A3B          ; branch if still characters to do
06786    
06787                                  ; else output the point
06788    DC6D  A9 2E              LDA   #$2E              ; character "."
06789    DC6F  C8                 INY                     ; increment output string index
06790    DC70  99 EF 00           STA   Decss,Y           ; save to output string
06791    LAB_2A3B
06792    DC73  84 BA              STY   Sendl             ; save output string index
06793    DC75  A4 95              LDY   Cvaral            ; get current var address low byte
06794    DC77  8A                 TXA                     ; get character back
06795    DC78  49 FF              EOR   #$FF              ; 
06796    DC7A  29 80              AND   #$80              ; 
06797    DC7C  AA                 TAX                     ; 
06798    DC7D  C0 12              CPY   #$12              ; compare index with max
06799    DC7F  D0 B2              BNE   LAB_29FB          ; loop if not max
06800    
06801                                  ; now remove trailing zeroes
06802    DC81  A4 BA              LDY   Sendl             ; get output string index
06803    LAB_2A4B
06804    DC83  B9 EF 00           LDA   Decss,Y           ; get character from output string
06805    DC86  88                 DEY                     ; decrement output string index
06806    DC87  C9 30              CMP   #'0'              ; compare with "0"
06807    DC89  F0 F8              BEQ   LAB_2A4B          ; loop until non "0" character found
06808    
06809    DC8B  C9 2E              CMP   #'.'              ; compare with "."
06810    DC8D  F0 01              BEQ   LAB_2A58          ; branch if was dp
06811    
06812                                  ; restore last character
06813    DC8F  C8                 INY                     ; increment output string index
06814    LAB_2A58
06815    DC90  A9 2B              LDA   #$2B              ; character "+"
06816    DC92  A6 A9              LDX   expcnt            ; get exponent count
06817    DC94  F0 2E              BEQ   LAB_2A8C          ; if zero go set null terminator and exit
06818    
06819                                  ; exponent isn't zero so write exponent
06820    DC96  10 08              BPL   LAB_2A68          ; branch if exponent count +ve
06821    
06822    DC98  A9 00              LDA   #$00              ; clear A
06823    DC9A  38                 SEC                     ; set carry for subtract
06824    DC9B  E5 A9              SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
06825    DC9D  AA                 TAX                     ; copy exponent count to X
06826    DC9E  A9 2D              LDA   #'-'              ; character "-"
06827    LAB_2A68
06828    DCA0  99 F1 00           STA   Decss+2,Y         ; save to output string
06829    DCA3  A9 45              LDA   #$45              ; character "E"
06830    DCA5  99 F0 00           STA   Decss+1,Y         ; save exponent sign to output string
06831    DCA8  8A                 TXA                     ; get exponent count back
06832    DCA9  A2 2F              LDX   #'0'-1            ; one less than "0" character
06833    DCAB  38                 SEC                     ; set carry for subtract
06834    LAB_2A74
06835    DCAC  E8                 INX                     ; increment 10's character
06836    DCAD  E9 0A              SBC   #$0A              ;.subtract 10 from exponent count
06837    DCAF  B0 FB              BCS   LAB_2A74          ; loop while still >= 0
06838    
06839    DCB1  69 3A              ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
06840    DCB3  99 F3 00           STA   Decss+4,Y         ; save to output string
06841    DCB6  8A                 TXA                     ; copy 10's character
06842    DCB7  99 F2 00           STA   Decss+3,Y         ; save to output string
06843    DCBA  A9 00              LDA   #$00              ; set null terminator
06844    DCBC  99 F4 00           STA   Decss+5,Y         ; save to output string
06845    DCBF  F0 08              BEQ   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
06846    
06847                                  ; save last character, [EOT] and exit
06848    LAB_2A89
06849    DCC1  99 EF 00           STA   Decss,Y           ; save last character to output string
06850    
06851                                  ; set null terminator and exit
06852    LAB_2A8C
06853    DCC4  A9 00              LDA   #$00              ; set null terminator
06854    DCC6  99 F0 00           STA   Decss+1,Y         ; save after last character
06855    
06856                                  ; set string pointer (AY) and exit
06857    LAB_2A91
06858    DCC9  A9 F0              LDA   #<Decssp1         ; set result string low pointer
06859    DCCB  A0 00              LDY   #>Decssp1         ; set result string high pointer
06860    DCCD  60                 RTS
06861    
06862    ; perform power function
06863    
06864    LAB_POWER
06865    DCCE  F0 42              BEQ   LAB_EXP           ; go do  EXP()
06866    
06867    DCD0  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
06868    DCD2  D0 03              BNE   LAB_2ABF          ; branch if FAC2<>0
06869    
06870    DCD4  4C 65 D7           JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
06871    
06872    LAB_2ABF
06873    DCD7  A2 9C              LDX   #<func_l          ; set destination pointer low byte
06874    DCD9  A0 00              LDY   #>func_l          ; set destination pointer high byte
06875    DCDB  20 BA D9           JSR   LAB_2778          ; pack FAC1 into (XY)
06876    DCDE  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
06877    DCE0  10 0F              BPL   LAB_2AD9          ; branch if FAC2>0
06878    
06879                                  ; else FAC2 is -ve and can only be raised to an
06880                                  ; integer power which gives an x +j0 result
06881    DCE2  20 94 DA           JSR   LAB_INT           ; perform INT
06882    DCE5  A9 9C              LDA   #<func_l          ; set source pointer low byte
06883    DCE7  A0 00              LDY   #>func_l          ; set source pointer high byte
06884    DCE9  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
06885    DCEC  D0 03              BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
06886                                  ; this will leave FAC1 -ve and cause a Function Call
06887                                  ; error when LOG() is called
06888    
06889    DCEE  98                 TYA                     ; clear sign b7
06890    DCEF  A4 5B              LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
06891                                  ; for possible later negation, b0
06892    LAB_2AD9
06893    DCF1  20 D8 D6           JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
06894    DCF4  98                 TYA                     ; copy sign back ..
06895    DCF5  48                 PHA                     ; .. and save it
06896    DCF6  20 0E D8           JSR   LAB_LOG           ; do LOG(n)
06897    DCF9  A9 9C              LDA   #<garb_l          ; set pointer low byte
06898    DCFB  A0 00              LDY   #>garb_l          ; set pointer high byte
06899    DCFD  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
06900    DD00  20 12 DD           JSR   LAB_EXP           ; go do EXP(n)
06901    DD03  68                 PLA                     ; pull sign from stack
06902    DD04  4A                 LSR                     ; b0 is to be tested, shift to Cb
06903    DD05  90 0A              BCC   LAB_2AF9          ; if no bit then exit
06904    
06905                                  ; Perform negation
06906    ; do - FAC1
06907    
06908    LAB_GTHAN
06909    DD07  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06910    DD09  F0 06              BEQ   LAB_2AF9          ; exit if FAC1_e = $00
06911    
06912    DD0B  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06913    DD0D  49 FF              EOR   #$FF              ; complement it
06914    DD0F  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
06915    LAB_2AF9
06916    DD11  60                 RTS
06917    
06918    ; perform EXP()   (x^e)
06919    
06920    LAB_EXP
06921    DD12  A9 A6              LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
06922    DD14  A0 E2              LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
06923    DD16  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06924    DD19  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
06925    DD1B  69 50              ADC   #$50              ; +$50/$100
06926    DD1D  90 03              BCC   LAB_2B2B          ; skip rounding if no carry
06927    
06928    DD1F  20 F4 D9           JSR   LAB_27C2          ; round FAC1 (no check)
06929    LAB_2B2B
06930    DD22  85 A3              STA   FAC2_r            ; save FAC2 rounding byte
06931    DD24  20 E0 D9           JSR   LAB_27AE          ; copy FAC1 to FAC2
06932    DD27  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06933    DD29  C9 88              CMP   #$88              ; compare with EXP limit (256d)
06934    DD2B  90 03              BCC   LAB_2B39          ; branch if less
06935    
06936    LAB_2B36
06937    DD2D  20 E1 D8           JSR   LAB_2690          ; handle overflow and underflow
06938    LAB_2B39
06939    DD30  20 94 DA           JSR   LAB_INT           ; perform INT
06940    DD33  A5 5B              LDA   Temp3             ; get mantissa 3 from INT() function
06941    DD35  18                 CLC                     ; clear carry for add
06942    DD36  69 81              ADC   #$81              ; normalise +1
06943    DD38  F0 F3              BEQ   LAB_2B36          ; if $00 go handle overflow
06944    
06945    DD3A  38                 SEC                     ; set carry for subtract
06946    DD3B  E9 01              SBC   #$01              ; now correct for exponent
06947    DD3D  48                 PHA                     ; save FAC2 exponent
06948    
06949                                  ; swap FAC1 and FAC2
06950    DD3E  A2 04              LDX   #$04              ; 4 bytes to do
06951    LAB_2B49
06952    DD40  B5 B3              LDA   FAC2_e,X          ; get FAC2,X
06953    DD42  B4 AC              LDY   FAC1_e,X          ; get FAC1,X
06954    DD44  95 AC              STA   FAC1_e,X          ; save FAC1,X
06955    DD46  94 B3              STY   FAC2_e,X          ; save FAC2,X
06956    DD48  CA                 DEX                     ; decrement count/index
06957    DD49  10 F5              BPL   LAB_2B49          ; loop if not all done
06958    
06959    DD4B  A5 A3              LDA   FAC2_r            ; get FAC2 rounding byte
06960    DD4D  85 B9              STA   FAC1_r            ; save as FAC1 rounding byte
06961    DD4F  20 B9 D6           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
06962    DD52  20 07 DD           JSR   LAB_GTHAN         ; do - FAC1
06963    DD55  A9 AA              LDA   #<LAB_2AFE        ; set counter pointer low byte
06964    DD57  A0 E2              LDY   #>LAB_2AFE        ; set counter pointer high byte
06965    DD59  20 7A DD           JSR   LAB_2B84          ; go do series evaluation
06966    DD5C  A9 00              LDA   #$00              ; clear A
06967    DD5E  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
06968    DD60  68                 PLA                     ;.get saved FAC2 exponent
06969    DD61  4C C6 D8           JMP   LAB_2675          ; test and adjust accumulators and return
06970    
06971    ; ^2 then series evaluation
06972    
06973    LAB_2B6E
06974    DD64  85 BA              STA   Cptrl             ; save count pointer low byte
06975    DD66  84 BB              STY   Cptrh             ; save count pointer high byte
06976    DD68  20 B0 D9           JSR   LAB_276E          ; pack FAC1 into Adatal
06977    DD6B  A9 A4              LDA   #<Adatal          ; set pointer low byte (Y already $00)
06978    DD6D  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06979    DD70  20 7E DD           JSR   LAB_2B88          ; go do series evaluation
06980    DD73  A9 A4              LDA   #<Adatal          ; pointer to original # low byte
06981    DD75  A0 00              LDY   #>Adatal          ; pointer to original # high byte
06982    DD77  4C 4C D8           JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
06983    
06984    ; series evaluation
06985    
06986    LAB_2B84
06987    DD7A  85 BA              STA   Cptrl             ; save count pointer low byte
06988    DD7C  84 BB              STY   Cptrh             ; save count pointer high byte
06989    LAB_2B88
06990    DD7E  A2 A8              LDX   #<numexp          ; set pointer low byte
06991    DD80  20 B2 D9           JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
06992    DD83  B1 BA              LDA   (Cptrl),Y         ; get constants count
06993    DD85  85 B1              STA   numcon            ; save constants count
06994    DD87  A4 BA              LDY   Cptrl             ; get count pointer low byte
06995    DD89  C8                 INY                     ; increment it (now constants pointer)
06996    DD8A  98                 TYA                     ; copy it
06997    DD8B  D0 02              BNE   LAB_2B97          ; skip next if no overflow
06998    
06999    DD8D  E6 BB              INC   Cptrh             ; else increment high byte
07000    LAB_2B97
07001    DD8F  85 BA              STA   Cptrl             ; save low byte
07002    DD91  A4 BB              LDY   Cptrh             ; get high byte
07003    LAB_2B9B
07004    DD93  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
07005    DD96  A5 BA              LDA   Cptrl             ; get constants pointer low byte
07006    DD98  A4 BB              LDY   Cptrh             ; get constants pointer high byte
07007    DD9A  18                 CLC                     ; clear carry for add
07008    DD9B  69 04              ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
07009    DD9D  90 01              BCC   LAB_2BA8          ; skip next if no overflow
07010    
07011    DD9F  C8                 INY                     ; increment high byte
07012    LAB_2BA8
07013    DDA0  85 BA              STA   Cptrl             ; save pointer low byte
07014    DDA2  84 BB              STY   Cptrh             ; save pointer high byte
07015    DDA4  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
07016    DDA7  A9 A8              LDA   #<numexp          ; set pointer low byte to partial @ numexp
07017    DDA9  A0 00              LDY   #>numexp          ; set pointer high byte to partial @ numexp
07018    DDAB  C6 B1              DEC   numcon            ; decrement constants count
07019    DDAD  D0 E4              BNE   LAB_2B9B          ; loop until all done
07020    
07021    DDAF  60                 RTS
07022    
07023    ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
07024    ; to get 19th next number in sequence after seed n. This version of the PRNG uses
07025    ; the Galois method and a sample of 65536 bytes produced gives the following values.
07026    
07027    ; Entropy = 7.997442 bits per byte
07028    ; Optimum compression would reduce these 65536 bytes by 0 percent
07029    
07030    ; Chi square distribution for 65536 samples is 232.01, and
07031    ; randomly would exceed this value 75.00 percent of the time
07032    
07033    ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
07034    ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
07035    ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
07036    
07037    LAB_RND
07038    DDB0  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07039    DDB2  F0 07              BEQ   NextPRN           ; do next random # if zero
07040    
07041                                  ; else get seed into random number store
07042    DDB4  A2 D8              LDX   #Rbyte4           ; set PRNG pointer low byte
07043    DDB6  A0 00              LDY   #$00              ; set PRNG pointer high byte
07044    DDB8  20 BA D9           JSR   LAB_2778          ; pack FAC1 into (XY)
07045    NextPRN
07046    DDBB  A2 AF              LDX   #$AF              ; set EOR byte
07047    DDBD  A0 13              LDY   #$13              ; do this nineteen times
07048    LoopPRN
07049    DDBF  06 D9              ASL   Rbyte1            ; shift PRNG most significant byte
07050    DDC1  26 DA              ROL   Rbyte2            ; shift PRNG middle byte
07051    DDC3  26 DB              ROL   Rbyte3            ; shift PRNG least significant byte
07052    DDC5  26 D8              ROL   Rbyte4            ; shift PRNG extra byte
07053    DDC7  90 05              BCC   Ninc1             ; branch if bit 32 clear
07054    
07055    DDC9  8A                 TXA                     ; set EOR byte
07056    DDCA  45 D9              EOR   Rbyte1            ; EOR PRNG extra byte
07057    DDCC  85 D9              STA   Rbyte1            ; save new PRNG extra byte
07058    Ninc1
07059    DDCE  88                 DEY                     ; decrement loop count
07060    DDCF  D0 EE              BNE   LoopPRN           ; loop if not all done
07061    
07062    DDD1  A2 02              LDX   #$02              ; three bytes to copy
07063    CopyPRNG
07064    DDD3  B5 D9              LDA   Rbyte1,X          ; get PRNG byte
07065    DDD5  95 AD              STA   FAC1_1,X          ; save FAC1 byte
07066    DDD7  CA                 DEX
07067    DDD8  10 F9              BPL   CopyPRNG          ; loop if not complete
07068    
07069    DDDA  A9 80              LDA   #$80              ; set the exponent
07070    DDDC  85 AC              STA   FAC1_e            ; save FAC1 exponent
07071    
07072    DDDE  0A                 ASL                     ; clear A
07073    DDDF  85 B0              STA   FAC1_s            ; save FAC1 sign
07074    
07075    DDE1  4C 47 D7           JMP   LAB_24D5          ; normalise FAC1 and return
07076    
07077    ; perform COS()
07078    
07079    LAB_COS
07080    DDE4  A9 C7              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
07081    DDE6  A0 E2              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
07082    DDE8  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
07083    
07084    ; perform SIN()
07085    
07086    LAB_SIN
07087    DDEB  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
07088    DDEE  A9 DC              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
07089    DDF0  A0 E2              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
07090    DDF2  A6 B7              LDX   FAC2_s            ; get FAC2 sign (b7)
07091    DDF4  20 0C D9           JSR   LAB_26C2          ; divide by (AY) (X=sign)
07092    DDF7  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
07093    DDFA  20 94 DA           JSR   LAB_INT           ; perform INT
07094    DDFD  A9 00              LDA   #$00              ; clear byte
07095    DDFF  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
07096    DE01  20 B9 D6           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
07097    DE04  A9 0E              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
07098    DE06  A0 E3              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
07099    DE08  20 B6 D6           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
07100    DE0B  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
07101    DE0D  48                 PHA                     ; save FAC1 sign
07102    DE0E  10 0D              BPL   LAB_2C35          ; branch if +ve
07103    
07104                                  ; FAC1 sign was -ve
07105    DE10  20 CD D6           JSR   LAB_244E          ; add 0.5 to FAC1
07106    DE13  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
07107    DE15  30 09              BMI   LAB_2C38          ; branch if -ve
07108    
07109    DE17  A5 63              LDA   Cflag             ; get comparison evaluation flag
07110    DE19  49 FF              EOR   #$FF              ; toggle flag
07111    DE1B  85 63              STA   Cflag             ; save comparison evaluation flag
07112    LAB_2C35
07113    DE1D  20 07 DD           JSR   LAB_GTHAN         ; do - FAC1
07114    LAB_2C38
07115    DE20  A9 0E              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
07116    DE22  A0 E3              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
07117    DE24  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
07118    DE27  68                 PLA                     ; restore FAC1 sign
07119    DE28  10 03              BPL   LAB_2C45          ; branch if was +ve
07120    
07121                                  ; else correct FAC1
07122    DE2A  20 07 DD           JSR   LAB_GTHAN         ; do - FAC1
07123    LAB_2C45
07124    DE2D  A9 CB              LDA   #<LAB_2C84        ; set pointer low byte to counter
07125    DE2F  A0 E2              LDY   #>LAB_2C84        ; set pointer high byte to counter
07126    DE31  4C 64 DD           JMP   LAB_2B6E          ; ^2 then series evaluation and return
07127    
07128    ; perform TAN()
07129    
07130    LAB_TAN
07131    DE34  20 B0 D9           JSR   LAB_276E          ; pack FAC1 into Adatal
07132    DE37  A9 00              LDA   #$00              ; clear byte
07133    DE39  85 63              STA   Cflag             ; clear comparison evaluation flag
07134    DE3B  20 EB DD           JSR   LAB_SIN           ; go do SIN(n)
07135    DE3E  A2 9C              LDX   #<func_l          ; set sin(n) pointer low byte
07136    DE40  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
07137    DE42  20 BA D9           JSR   LAB_2778          ; pack FAC1 into (XY)
07138    DE45  A9 A4              LDA   #<Adatal          ; set n pointer low addr
07139    DE47  A0 00              LDY   #>Adatal          ; set n pointer high addr
07140    DE49  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
07141    DE4C  A9 00              LDA   #$00              ; clear byte
07142    DE4E  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
07143    DE50  A5 63              LDA   Cflag             ; get comparison evaluation flag
07144    DE52  20 5C DE           JSR   LAB_2C74          ; save flag and go do series evaluation
07145    
07146    DE55  A9 9C              LDA   #<func_l          ; set sin(n) pointer low byte
07147    DE57  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
07148    DE59  4C 14 D9           JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
07149    
07150    LAB_2C74
07151    DE5C  48                 PHA                     ; save comparison evaluation flag
07152    DE5D  4C 1D DE           JMP   LAB_2C35          ; go do series evaluation
07153    
07154    ; perform USR()
07155    
07156    LAB_USR
07157    DE60  20 0A 00           JSR   Usrjmp            ; call user code
07158    DE63  4C F5 CC           JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
07159    
07160    ; perform ATN()
07161    
07162    LAB_ATN
07163    DE66  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
07164    DE68  48                 PHA                     ; save sign
07165    DE69  10 03              BPL   LAB_2CA1          ; branch if +ve
07166    
07167    DE6B  20 07 DD           JSR   LAB_GTHAN         ; else do - FAC1
07168    LAB_2CA1
07169    DE6E  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07170    DE70  48                 PHA                     ; push exponent
07171    DE71  C9 81              CMP   #$81              ; compare with 1
07172    DE73  90 07              BCC   LAB_2CAF          ; branch if FAC1<1
07173    
07174    DE75  A9 01              LDA   #<LAB_259C        ; set 1 pointer low byte
07175    DE77  A0 E3              LDY   #>LAB_259C        ; set 1 pointer high byte
07176    DE79  20 14 D9           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
07177    LAB_2CAF
07178    DE7C  A9 E0              LDA   #<LAB_2CC9        ; set pointer low byte to counter
07179    DE7E  A0 E2              LDY   #>LAB_2CC9        ; set pointer high byte to counter
07180    DE80  20 64 DD           JSR   LAB_2B6E          ; ^2 then series evaluation
07181    DE83  68                 PLA                     ; restore old FAC1 exponent
07182    DE84  C9 81              CMP   #$81              ; compare with 1
07183    DE86  90 07              BCC   LAB_2CC2          ; branch if FAC1<1
07184    
07185    DE88  A9 C7              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
07186    DE8A  A0 E2              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
07187    DE8C  20 B6 D6           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
07188    LAB_2CC2
07189    DE8F  68                 PLA                     ; restore FAC1 sign
07190    DE90  10 16              BPL   LAB_2D04          ; exit if was +ve
07191    
07192    DE92  4C 07 DD           JMP   LAB_GTHAN         ; else do - FAC1 and return
07193    
07194    ; perform BITSET
07195    
07196    LAB_BITSET
07197    DE95  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
07198    DE98  E0 08              CPX   #$08              ; only 0 to 7 are allowed
07199    DE9A  B0 20              BCS   FCError           ; branch if > 7
07200    
07201    DE9C  A9 00              LDA   #$00              ; clear A
07202    DE9E  38                 SEC                     ; set the carry
07203    S_Bits
07204    DE9F  2A                 ROL                     ; shift bit
07205    DEA0  CA                 DEX                     ; decrement bit number
07206    DEA1  10 FC              BPL   S_Bits            ; loop if still +ve
07207    
07208    DEA3  E8                 INX                     ; make X = $00
07209    DEA4  01 11              ORA   (Itempl,X)        ; or with byte via temporary integer (addr)
07210    DEA6  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
07211    LAB_2D04
07212    DEA8  60                 RTS
07213    
07214    ; perform BITCLR
07215    
07216    LAB_BITCLR
07217    DEA9  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
07218    DEAC  E0 08              CPX   #$08              ; only 0 to 7 are allowed
07219    DEAE  B0 0C              BCS   FCError           ; branch if > 7
07220    
07221    DEB0  A9 FF              LDA   #$FF              ; set A
07222    S_Bitc
07223    DEB2  2A                 ROL                     ; shift bit
07224    DEB3  CA                 DEX                     ; decrement bit number
07225    DEB4  10 FC              BPL   S_Bitc            ; loop if still +ve
07226    
07227    DEB6  E8                 INX                     ; make X = $00
07228    DEB7  21 11              AND   (Itempl,X)        ; and with byte via temporary integer (addr)
07229    DEB9  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
07230    DEBB  60                 RTS
07231    
07232    FCError
07233    DEBC  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
07234    
07235    ; perform BITTST()
07236    
07237    LAB_BTST
07238    DEBF  20 BC 00           JSR   LAB_IGBY          ; increment BASIC pointer
07239    DEC2  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
07240    DEC5  E0 08              CPX   #$08              ; only 0 to 7 are allowed
07241    DEC7  B0 F3              BCS   FCError           ; branch if > 7
07242    
07243    DEC9  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
07244    DECC  C9 29              CMP   #')'              ; is next character ")"
07245    DECE  F0 03              BEQ   TST_OK            ; if ")" go do rest of function
07246    
07247    DED0  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
07248    
07249    TST_OK
07250    DED3  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
07251    DED6  A9 00              LDA   #$00              ; clear A
07252    DED8  38                 SEC                     ; set the carry
07253    T_Bits
07254    DED9  2A                 ROL                     ; shift bit
07255    DEDA  CA                 DEX                     ; decrement bit number
07256    DEDB  10 FC              BPL   T_Bits            ; loop if still +ve
07257    
07258    DEDD  E8                 INX                     ; make X = $00
07259    DEDE  21 11              AND   (Itempl,X)        ; AND with byte via temporary integer (addr)
07260    DEE0  F0 02              BEQ   LAB_NOTT          ; branch if zero (already correct)
07261    
07262    DEE2  A9 FF              LDA   #$FF              ; set for -1 result
07263    LAB_NOTT
07264    DEE4  4C 0D DA           JMP   LAB_27DB          ; go do SGN tail
07265    
07266    ; perform BIN$()
07267    
07268    LAB_BINS
07269    DEE7  E0 19              CPX   #$19              ; max + 1
07270    DEE9  B0 48              BCS   BinFErr           ; exit if too big ( > or = )
07271    
07272    DEEB  86 78              STX   TempB             ; save # of characters ($00 = leading zero remove)
07273    DEED  A9 18              LDA   #$18              ; need A byte long space
07274    DEEF  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long
07275    DEF2  A0 17              LDY   #$17              ; set index
07276    DEF4  A2 18              LDX   #$18              ; character count
07277    NextB1
07278    DEF6  46 11              LSR   nums_1            ; shift highest byte
07279    DEF8  66 12              ROR   nums_2            ; shift middle byte
07280    DEFA  66 13              ROR   nums_3            ; shift lowest byte bit 0 to carry
07281    DEFC  8A                 TXA                     ; load with "0"/2
07282    DEFD  2A                 ROL                     ; shift in carry
07283    DEFE  91 AD              STA   (str_pl),Y        ; save to temp string + index
07284    DF00  88                 DEY                     ; decrement index
07285    DF01  10 F3              BPL   NextB1            ; loop if not done
07286    
07287    DF03  A5 78              LDA   TempB             ; get # of characters
07288    DF05  F0 0A              BEQ   EndBHS            ; branch if truncate
07289    
07290    DF07  AA                 TAX                     ; copy length to X
07291    DF08  38                 SEC                     ; set carry for add !
07292    DF09  49 FF              EOR   #$FF              ; 1's complement
07293    DF0B  69 18              ADC   #$18              ; add 24d
07294    DF0D  F0 1C              BEQ   GoPr2             ; if zero print whole string
07295    
07296    DF0F  D0 0F              BNE   GoPr1             ; else go make output string
07297          
07298    ; this is the exit code and is also used by HEX$()
07299    ; truncate string to remove leading "0"s
07300    
07301    EndBHS
07302    DF11  A8                 TAY                     ; clear index (A=0, X=length here)
07303    NextB2
07304    DF12  B1 AD              LDA   (str_pl),Y        ; get character from string
07305    DF14  C9 30              CMP   #'0'              ; compare with "0"
07306    DF16  D0 07              BNE   GoPr              ; if not "0" then go print string from here
07307    
07308    DF18  CA                 DEX                     ; decrement character count
07309    DF19  F0 03              BEQ   GoPr3             ; if zero then end of string so go print it
07310    
07311    DF1B  C8                 INY                     ; else increment index
07312    DF1C  10 F4              BPL   NextB2            ; loop always
07313    
07314    ; make fixed length output string - ignore overflows!
07315    
07316    GoPr3
07317    DF1E  E8                 INX                     ; need at least 1 character
07318    GoPr
07319    DF1F  98                 TYA                     ; copy result
07320    GoPr1
07321    DF20  18                 CLC                     ; clear carry for add
07322    DF21  65 AD              ADC   str_pl            ; add low address
07323    DF23  85 AD              STA   str_pl            ; save low address
07324    DF25  A9 00              LDA   #$00              ; do high byte
07325    DF27  65 AE              ADC   str_ph            ; add high address
07326    DF29  85 AE              STA   str_ph            ; save high address
07327    GoPr2
07328    DF2B  86 AC              STX   str_ln            ; X holds string length
07329    DF2D  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
07330    DF30  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put address
07331                                  ; and length on descriptor stack and update stack pointers
07332    
07333    BinFErr
07334    DF33  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
07335    
07336    ; perform HEX$()
07337    
07338    LAB_HEXS
07339    DF36  E0 07              CPX   #$07              ; max + 1
07340    DF38  B0 F9              BCS   BinFErr           ; exit if too big ( > or = )
07341    
07342    DF3A  86 78              STX   TempB             ; save # of characters
07343    
07344    DF3C  A9 06              LDA   #$06              ; need 6 bytes for string
07345    DF3E  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long
07346    DF41  A0 05              LDY   #$05              ; set string index
07347    
07348    ; *** disable decimal mode patch - comment next line ***
07349    ;      SED                     ; need decimal mode for nibble convert
07350    DF43  A5 13              LDA   nums_3            ; get lowest byte
07351    DF45  20 62 DF           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
07352    DF48  A5 12              LDA   nums_2            ; get middle byte
07353    DF4A  20 62 DF           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
07354    DF4D  A5 11              LDA   nums_1            ; get highest byte
07355    DF4F  20 62 DF           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
07356    ; *** disable decimal mode patch - comment next line ***
07357    ;      CLD                     ; back to binary
07358    
07359    DF52  A2 06              LDX   #$06              ; character count
07360    DF54  A5 78              LDA   TempB             ; get # of characters
07361    DF56  F0 B9              BEQ   EndBHS            ; branch if truncate
07362    
07363    DF58  AA                 TAX                     ; copy length to X
07364    DF59  38                 SEC                     ; set carry for add !
07365    DF5A  49 FF              EOR   #$FF              ; 1's complement
07366    DF5C  69 06              ADC   #$06              ; add 6d
07367    DF5E  F0 CB              BEQ   GoPr2             ; if zero print whole string
07368    
07369    DF60  D0 BE              BNE   GoPr1             ; else go make output string (branch always)
07370    
07371    ; convert A to ASCII hex byte and output .. note set decimal mode before calling
07372    
07373    LAB_A2HX
07374    DF62  AA                 TAX                     ; save byte
07375    DF63  29 0F              AND   #$0F              ; mask off top bits
07376    DF65  20 6D DF           JSR   LAB_AL2X          ; convert low nibble to ASCII and output
07377    DF68  8A                 TXA                     ; get byte back
07378    DF69  4A                 LSR                     ; /2  shift high nibble to low nibble
07379    DF6A  4A                 LSR                     ; /4
07380    DF6B  4A                 LSR                     ; /8
07381    DF6C  4A                 LSR                     ; /16
07382    LAB_AL2X
07383    DF6D  C9 0A              CMP   #$0A              ; set carry for +1 if >9
07384    ; *** begin disable decimal mode patch ***
07385    ; *** insert
07386    DF6F  90 02              BCC   LAB_AL20          ; skip adjust if <= 9
07387    DF71  69 06              ADC   #$06              ; adjust for A to F
07388    LAB_AL20
07389    ; *** end   disable decimal mode patch ***
07390    DF73  69 30              ADC   #'0'              ; add ASCII "0"
07391    DF75  91 AD              STA   (str_pl),Y        ; save to temp string
07392    DF77  88                 DEY                     ; decrement counter
07393    DF78  60                 RTS
07394    
07395    LAB_NLTO
07396    DF79  85 AC              STA   FAC1_e            ; save FAC1 exponent
07397    DF7B  A9 00              LDA   #$00              ; clear sign compare
07398    LAB_MLTE
07399    DF7D  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
07400    DF7F  8A                 TXA                     ; restore character
07401    DF80  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
07402    
07403    ; gets here if the first character was "$" for hex
07404    ; get hex number
07405    
07406    LAB_CHEX
07407    DF83  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
07408    DF86  90 0A              BCC   LAB_ISHN          ; branch if numeric character
07409    
07410    DF88  09 20              ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
07411    DF8A  E9 61              SBC   #'a'              ; subtract "a" (carry set here)
07412    DF8C  C9 06              CMP   #$06              ; compare normalised with $06 (max+1)
07413    DF8E  B0 2A              BCS   LAB_EXCH          ; exit if >"f" or <"0"
07414    
07415    DF90  69 0A              ADC   #$0A              ; convert to nibble
07416    LAB_ISHN
07417    DF92  29 0F              AND   #$0F              ; convert to binary
07418    DF94  AA                 TAX                     ; save nibble
07419    DF95  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07420    DF97  F0 E4              BEQ   LAB_MLTE          ; skip multiply if zero
07421    
07422    DF99  69 04              ADC   #$04              ; add four to exponent (*16 - carry clear here)
07423    DF9B  90 DC              BCC   LAB_NLTO          ; if no overflow do evaluate digit
07424    
07425    LAB_MLTO
07426    DF9D  4C D6 D7           JMP   LAB_2564          ; do overflow error and warm start
07427    
07428    LAB_NXCH
07429    DFA0  AA                 TAX                     ; save bit
07430    DFA1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07431    DFA3  F0 06              BEQ   LAB_MLBT          ; skip multiply if zero
07432    
07433    DFA5  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*2)
07434    DFA7  F0 F4              BEQ   LAB_MLTO          ; do overflow error if = $00
07435    
07436    DFA9  A9 00              LDA   #$00              ; clear sign compare
07437    LAB_MLBT
07438    DFAB  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
07439    DFAD  8A                 TXA                     ; restore bit
07440    DFAE  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
07441    
07442    ; gets here if the first character was  "%" for binary
07443    ; get binary number
07444    
07445    LAB_CBIN
07446    DFB1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
07447    DFB4  49 30              EOR   #'0'              ; convert "0" to 0 etc.
07448    DFB6  C9 02              CMP   #$02              ; compare with max+1
07449    DFB8  90 E6              BCC   LAB_NXCH          ; branch exit if < 2
07450    
07451    LAB_EXCH
07452    DFBA  4C 3D DB           JMP   LAB_28F6          ; evaluate -ve flag and return
07453    
07454    ; ctrl-c check routine. includes limited "life" byte save for INGET routine
07455    ; now also the code that checks to see if an interrupt has occurred
07456    
07457    CTRLC
07458    DFBD  AD 00 02           LDA   ccflag            ; get [CTRL-C] check flag
07459    DFC0  D0 18              BNE   LAB_FBA2          ; exit if inhibited
07460    
07461    DFC2  20 FF E1           JSR   V_INPT            ; scan input device
07462    DFC5  90 0B              BCC   LAB_FBA0          ; exit if buffer empty
07463    
07464    DFC7  8D 01 02           STA   ccbyte            ; save received byte
07465    DFCA  A2 20              LDX   #$20              ; "life" timer for bytes
07466    DFCC  8E 02 02           STX   ccnull            ; set countdown
07467    DFCF  4C 1F C6           JMP   LAB_1636          ; return to BASIC
07468    
07469    LAB_FBA0
07470    DFD2  AE 02 02           LDX   ccnull            ; get countdown byte
07471    DFD5  F0 03              BEQ   LAB_FBA2          ; exit if finished
07472    
07473    DFD7  CE 02 02           DEC   ccnull            ; else decrement countdown
07474    LAB_FBA2
07475    DFDA  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
07476    DFDC  20 E5 DF           JSR   LAB_CKIN          ; go check interrupt
07477    DFDF  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
07478    DFE1  20 E5 DF           JSR   LAB_CKIN          ; go check interrupt
07479    LAB_CRTS
07480    DFE4  60                 RTS
07481    
07482    ; check whichever interrupt is indexed by X
07483    
07484    LAB_CKIN
07485    DFE5  B5 00              LDA   PLUS_0,X          ; get interrupt flag byte
07486    DFE7  10 FB              BPL   LAB_CRTS          ; branch if interrupt not enabled
07487    
07488    ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
07489    ; automatically enable the interrupt when we exit
07490    
07491    DFE9  0A                 ASL                     ; move happened bit to setup bit
07492    DFEA  29 40              AND   #$40              ; mask happened bits
07493    DFEC  F0 F6              BEQ   LAB_CRTS          ; if no interrupt then exit
07494    
07495    DFEE  95 00              STA   PLUS_0,X          ; save interrupt flag byte
07496    
07497    DFF0  8A                 TXA                     ; copy index ..
07498    DFF1  A8                 TAY                     ; .. to Y
07499    
07500    DFF2  68                 PLA                     ; dump return address low byte, call from CTRL-C
07501    DFF3  68                 PLA                     ; dump return address high byte
07502    
07503    DFF4  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
07504    DFF6  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
07505    DFF9  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
07506    DFFB  48                 PHA                     ; push on stack
07507    DFFC  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
07508    DFFE  48                 PHA                     ; push on stack
07509    DFFF  A5 88              LDA   Clineh            ; get current line high byte
07510    E001  48                 PHA                     ; push on stack
07511    E002  A5 87              LDA   Clinel            ; get current line low byte
07512    E004  48                 PHA                     ; push on stack
07513    E005  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
07514    E007  48                 PHA                     ; push on stack
07515    
07516    E008  B9 01 00           LDA   PLUS_1,Y          ; get interrupt code pointer low byte
07517    E00B  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
07518    E00D  B9 02 00           LDA   PLUS_2,Y          ; get interrupt code pointer high byte
07519    E010  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
07520    
07521    E012  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
07522                                  ; can't RTS, we used the stack! the RTS from the ctrl-c
07523                                  ; check will be taken when the RETIRQ/RETNMI/RETURN is
07524                                  ; executed at the end of the subroutine
07525    
07526    ; get byte from input device, no waiting
07527    ; returns with carry set if byte in A
07528    
07529    INGET
07530    E015  20 FF E1           JSR   V_INPT            ; call scan input device
07531    E018  B0 09              BCS   LAB_FB95          ; if byte go reset timer
07532    
07533    E01A  AD 02 02           LDA   ccnull            ; get countdown
07534    E01D  F0 09              BEQ   LAB_FB96          ; exit if empty
07535    
07536    E01F  AD 01 02           LDA   ccbyte            ; get last received byte
07537    E022  38                 SEC                     ; flag we got a byte
07538    LAB_FB95
07539    E023  A2 00              LDX   #$00              ; clear X
07540    E025  8E 02 02           STX   ccnull            ; clear timer because we got a byte
07541    LAB_FB96
07542    E028  60                 RTS
07543    
07544    ; these routines only enable the interrupts if the set-up flag is set
07545    ; if not they have no effect
07546    
07547    ; perform IRQ {ON|OFF|CLEAR}
07548    
07549    LAB_IRQ
07550    E029  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
07551          .byte $2C               ; make next line BIT abs.
07552    
07553    ; perform NMI {ON|OFF|CLEAR}
07554    
07555    LAB_NMI
07556    E02C  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
07557    E02E  C9 93              CMP   #TK_ON            ; compare with token for ON
07558    E030  F0 11              BEQ   LAB_INON          ; go turn on interrupt
07559    
07560    E032  C9 BF              CMP   #TK_OFF           ; compare with token for OFF
07561    E034  F0 07              BEQ   LAB_IOFF          ; go turn off interrupt
07562    
07563    E036  49 A2              EOR   #TK_CLEAR         ; compare with token for CLEAR, A = $00 if = TK_CLEAR
07564    E038  F0 0E              BEQ   LAB_INEX          ; go clear interrupt flags and return
07565    
07566    E03A  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
07567    
07568    LAB_IOFF
07569    E03D  A9 7F              LDA   #$7F              ; clear A
07570    E03F  35 00              AND   PLUS_0,X          ; AND with interrupt setup flag
07571    E041  10 05              BPL   LAB_INEX          ; go clear interrupt enabled flag and return
07572    
07573    LAB_INON
07574    E043  B5 00              LDA   PLUS_0,X          ; get interrupt setup flag
07575    E045  0A                 ASL                     ; Shift bit to enabled flag
07576    E046  15 00              ORA   PLUS_0,X          ; OR with flag byte
07577    LAB_INEX
07578    E048  95 00              STA   PLUS_0,X          ; save interrupt flag byte
07579    E04A  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer and return
07580    
07581    ; these routines set up the pointers and flags for the interrupt routines
07582    ; note that the interrupts are also enabled by these commands
07583    
07584    ; perform ON IRQ
07585    
07586    LAB_SIRQ
07587    E04D  58                 CLI                     ; enable interrupts
07588    E04E  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
07589          .byte $2C               ; make next line BIT abs.
07590    
07591    ; perform ON NMI
07592    
07593    LAB_SNMI
07594    E051  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
07595    
07596    E053  86 78              STX   TempB             ; save interrupt pointer
07597    E055  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (past token)
07598    E058  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
07599    E05B  A5 79              LDA   Smeml             ; get start of mem low byte
07600    E05D  A6 7A              LDX   Smemh             ; get start of mem high byte
07601    E05F  20 31 C4           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
07602    E062  B0 03              BCS   LAB_LFND          ; if carry set go set-up interrupt
07603    
07604    E064  4C 76 C7           JMP   LAB_16F7          ; else go do "Undefined statement" error and warm start
07605    
07606    LAB_LFND
07607    E067  A6 78              LDX   TempB             ; get interrupt pointer
07608    E069  A5 AA              LDA   Baslnl            ; get pointer low byte
07609    E06B  E9 01              SBC   #$01              ; -1 (carry already set for subtract)
07610    E06D  95 01              STA   PLUS_1,X          ; save as interrupt pointer low byte
07611    E06F  A5 AB              LDA   Baslnh            ; get pointer high byte
07612    E071  E9 00              SBC   #$00              ; subtract carry
07613    E073  95 02              STA   PLUS_2,X          ; save as interrupt pointer high byte
07614    
07615    E075  A9 C0              LDA   #$C0              ; set interrupt enabled/setup bits
07616    E077  95 00              STA   PLUS_0,X          ; set interrupt flags
07617    LAB_IRTS
07618    E079  60                 RTS
07619    
07620    ; return from IRQ service, restores the enabled flag.
07621    
07622    ; perform RETIRQ
07623    
07624    LAB_RETIRQ
07625    E07A  D0 FD              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
07626    
07627    E07C  A5 DF              LDA   IrqBase           ; get interrupt flags
07628    E07E  0A                 ASL                     ; copy setup to enabled (b7)
07629    E07F  05 DF              ORA   IrqBase           ; OR in setup flag
07630    E081  85 DF              STA   IrqBase           ; save enabled flag
07631    E083  4C 7D C7           JMP   LAB_16E8          ; go do rest of RETURN
07632    
07633    ; return from NMI service, restores the enabled flag.
07634    
07635    ; perform RETNMI
07636    
07637    LAB_RETNMI
07638    E086  D0 F1              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
07639    
07640    E088  A5 DC              LDA   NmiBase           ; get set-up flag
07641    E08A  0A                 ASL                     ; copy setup to enabled (b7)
07642    E08B  05 DC              ORA   NmiBase           ; OR in setup flag
07643    E08D  85 DC              STA   NmiBase           ; save enabled flag
07644    E08F  4C 7D C7           JMP   LAB_16E8          ; go do rest of RETURN
07645    
07646    ; MAX() MIN() pre process
07647    
07648    LAB_MMPP
07649    E092  20 EF CB           JSR   LAB_EVEZ          ; process expression
07650    E095  4C D6 CB           JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
07651    
07652    ; perform MAX()
07653    
07654    LAB_MAX
07655    E098  20 C6 E0           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
07656                                  ; pull FAC2 and compare with FAC1
07657    E09B  10 FB              BPL   LAB_MAX           ; branch if no swap to do
07658    
07659    E09D  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
07660    E09F  09 80              ORA   #$80              ; set top bit (clear sign from compare)
07661    E0A1  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
07662    E0A3  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1
07663    E0A6  F0 F0              BEQ   LAB_MAX           ; go do next (branch always)
07664    
07665    ; perform MIN()
07666    
07667    LAB_MIN
07668    E0A8  20 C6 E0           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
07669                                  ; pull FAC2 and compare with FAC1
07670    E0AB  30 FB              BMI   LAB_MIN           ; branch if no swap to do
07671    
07672    E0AD  F0 F9              BEQ   LAB_MIN           ; branch if no swap to do
07673    
07674    E0AF  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
07675    E0B1  09 80              ORA   #$80              ; set top bit (clear sign from compare)
07676    E0B3  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
07677    E0B5  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1
07678    E0B8  F0 EE              BEQ   LAB_MIN           ; go do next (branch always)
07679    
07680    ; exit routine. don't bother returning to the loop code
07681    ; check for correct exit, else so syntax error
07682    
07683    LAB_MMEC
07684    E0BA  C9 29              CMP   #')'              ; is it end of function?
07685    E0BC  D0 05              BNE   LAB_MMSE          ; if not do MAX MIN syntax error
07686    
07687    E0BE  68                 PLA                     ; dump return address low byte
07688    E0BF  68                 PLA                     ; dump return address high byte
07689    E0C0  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
07690    
07691    LAB_MMSE
07692    E0C3  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
07693    
07694    ; check for next, evaluate and return or exit
07695    ; this is the routine that does most of the work
07696    
07697    LAB_PHFA
07698    E0C6  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
07699    E0C9  C9 2C              CMP   #','              ; is there more ?
07700    E0CB  D0 ED              BNE   LAB_MMEC          ; if not go do end check
07701    
07702                                  ; push FAC1
07703    E0CD  20 EC D9           JSR   LAB_27BA          ; round FAC1
07704    E0D0  A5 B0              LDA   FAC1_s            ; get FAC1 sign
07705    E0D2  09 7F              ORA   #$7F              ; set all non sign bits
07706    E0D4  25 AD              AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
07707    E0D6  48                 PHA                     ; push on stack
07708    E0D7  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
07709    E0D9  48                 PHA                     ; push on stack
07710    E0DA  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
07711    E0DC  48                 PHA                     ; push on stack
07712    E0DD  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07713    E0DF  48                 PHA                     ; push on stack
07714    
07715    E0E0  20 BC 00           JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
07716    E0E3  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
07717                                  ; else do type mismatch
07718    
07719                                  ; pop FAC2 (MAX/MIN expression so far)
07720    E0E6  68                 PLA                     ; pop exponent
07721    E0E7  85 B3              STA   FAC2_e            ; save FAC2 exponent
07722    E0E9  68                 PLA                     ; pop mantissa3
07723    E0EA  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
07724    E0EC  68                 PLA                     ; pop mantissa1
07725    E0ED  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
07726    E0EF  68                 PLA                     ; pop sign/mantissa1
07727    E0F0  85 B4              STA   FAC2_1            ; save FAC2 sign/mantissa1
07728    E0F2  85 B7              STA   FAC2_s            ; save FAC2 sign
07729    
07730                                  ; compare FAC1 with (packed) FAC2
07731    E0F4  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
07732    E0F6  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
07733    E0F8  4C 2A DA           JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
07734                                  ; returns A=$00 if FAC1 = (AY)
07735                                  ; returns A=$01 if FAC1 > (AY)
07736                                  ; returns A=$FF if FAC1 < (AY)
07737    
07738    ; perform WIDTH
07739    
07740    LAB_WDTH
07741    E0FB  C9 2C              CMP   #','              ; is next byte ","
07742    E0FD  F0 1B              BEQ   LAB_TBSZ          ; if so do tab size
07743    
07744    E0FF  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
07745    E102  8A                 TXA                     ; copy width to A
07746    E103  F0 0A              BEQ   LAB_NSTT          ; branch if set for infinite line
07747    
07748    E105  E0 10              CPX   #$10              ; else make min width = 16d
07749    E107  90 45              BCC   TabErr            ; if less do function call error and exit
07750    
07751    ; this next compare ensures that we can't exit WIDTH via an error leaving the
07752    ; tab size greater than the line length.
07753    
07754    E109  E4 64              CPX   TabSiz            ; compare with tab size
07755    E10B  B0 02              BCS   LAB_NSTT          ; branch if >= tab size
07756    
07757    E10D  86 64              STX   TabSiz            ; else make tab size = terminal width
07758    LAB_NSTT
07759    E10F  86 0F              STX   TWidth            ; set the terminal width
07760    E111  20 C2 00           JSR   LAB_GBYT          ; get BASIC byte back
07761    E114  F0 1A              BEQ   WExit             ; exit if no following
07762    
07763    E116  C9 2C              CMP   #','              ; else is it ","
07764    E118  D0 A9              BNE   LAB_MMSE          ; if not do syntax error
07765    
07766    LAB_TBSZ
07767    E11A  20 A3 D5           JSR   LAB_SGBY          ; scan and get byte parameter
07768    E11D  8A                 TXA                     ; copy TAB size
07769    E11E  30 2E              BMI   TabErr            ; if >127 do function call error and exit
07770    
07771    E120  E0 01              CPX   #$01              ; compare with min-1
07772    E122  90 2A              BCC   TabErr            ; if <=1 do function call error and exit
07773    
07774    E124  A5 0F              LDA   TWidth            ; set flags for width
07775    E126  F0 06              BEQ   LAB_SVTB          ; skip check if infinite line
07776    
07777    E128  E4 0F              CPX   TWidth            ; compare TAB with width
07778    E12A  F0 02              BEQ   LAB_SVTB          ; ok if =
07779    
07780    E12C  B0 20              BCS   TabErr            ; branch if too big
07781    
07782    LAB_SVTB
07783    E12E  86 64              STX   TabSiz            ; save TAB size
07784    
07785    ; calculate tab column limit from TAB size. The Iclim is set to the last tab
07786    ; position on a line that still has at least one whole tab width between it
07787    ; and the end of the line.
07788    
07789    WExit
07790    E130  A5 0F              LDA   TWidth            ; get width
07791    E132  F0 06              BEQ   LAB_SULP          ; branch if infinite line
07792    
07793    E134  C5 64              CMP   TabSiz            ; compare with tab size
07794    E136  B0 03              BCS   LAB_WDLP          ; branch if >= tab size
07795    
07796    E138  85 64              STA   TabSiz            ; else make tab size = terminal width
07797    LAB_SULP
07798    E13A  38                 SEC                     ; set carry for subtract
07799    LAB_WDLP
07800    E13B  E5 64              SBC   TabSiz            ; subtract tab size
07801    E13D  B0 FC              BCS   LAB_WDLP          ; loop while no borrow
07802    
07803    E13F  65 64              ADC   TabSiz            ; add tab size back
07804    E141  18                 CLC                     ; clear carry for add
07805    E142  65 64              ADC   TabSiz            ; add tab size back again
07806    E144  85 10              STA   Iclim             ; save for now
07807    E146  A5 0F              LDA   TWidth            ; get width back
07808    E148  38                 SEC                     ; set carry for subtract
07809    E149  E5 10              SBC   Iclim             ; subtract remainder
07810    E14B  85 10              STA   Iclim             ; save tab column limit
07811    LAB_NOSQ
07812    E14D  60                 RTS
07813    
07814    TabErr
07815    E14E  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
07816    
07817    ; perform SQR()
07818    
07819    LAB_SQR
07820    E151  A5 B0              LDA   FAC1_s            ; get FAC1 sign
07821    E153  30 F9              BMI   TabErr            ; if -ve do function call error
07822    
07823    E155  A5 AC              LDA   FAC1_e            ; get exponent
07824    E157  F0 F4              BEQ   LAB_NOSQ          ; if zero just return
07825    
07826                                  ; else do root
07827    E159  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
07828    E15C  A9 00              LDA   #$00              ; clear A
07829    
07830    E15E  85 77              STA   FACt_3            ; clear remainder
07831    E160  85 76              STA   FACt_2            ; ..
07832    E162  85 75              STA   FACt_1            ; ..
07833    E164  85 78              STA   TempB             ; ..
07834    
07835    E166  85 AF              STA   FAC1_3            ; clear root
07836    E168  85 AE              STA   FAC1_2            ; ..
07837    E16A  85 AD              STA   FAC1_1            ; ..
07838    
07839    E16C  A2 18              LDX   #$18              ; 24 pairs of bits to do
07840    E16E  A5 B3              LDA   FAC2_e            ; get exponent
07841    E170  4A                 LSR                     ; check odd/even
07842    E171  B0 0E              BCS   LAB_SQE2          ; if odd only 1 shift first time
07843    
07844    LAB_SQE1
07845    E173  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
07846    E175  26 B5              ROL   FAC2_2            ; ..
07847    E177  26 B4              ROL   FAC2_1            ; ..
07848    E179  26 77              ROL   FACt_3            ; .. into remainder
07849    E17B  26 76              ROL   FACt_2            ; ..
07850    E17D  26 75              ROL   FACt_1            ; ..
07851    E17F  26 78              ROL   TempB             ; .. never overflows
07852    LAB_SQE2
07853    E181  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
07854    E183  26 B5              ROL   FAC2_2            ; ..
07855    E185  26 B4              ROL   FAC2_1            ; ..
07856    E187  26 77              ROL   FACt_3            ; .. into remainder
07857    E189  26 76              ROL   FACt_2            ; ..
07858    E18B  26 75              ROL   FACt_1            ; ..
07859    E18D  26 78              ROL   TempB             ; .. never overflows
07860    
07861    E18F  06 AF              ASL   FAC1_3            ; root = root * 2
07862    E191  26 AE              ROL   FAC1_2            ; ..
07863    E193  26 AD              ROL   FAC1_1            ; .. never overflows
07864    
07865    E195  A5 AF              LDA   FAC1_3            ; get root low byte
07866    E197  2A                 ROL                     ; *2
07867    E198  85 5B              STA   Temp3             ; save partial low byte
07868    E19A  A5 AE              LDA   FAC1_2            ; get root low mid byte
07869    E19C  2A                 ROL                     ; *2
07870    E19D  85 5C              STA   Temp3+1           ; save partial low mid byte
07871    E19F  A5 AD              LDA   FAC1_1            ; get root high mid byte
07872    E1A1  2A                 ROL                     ; *2
07873    E1A2  85 5D              STA   Temp3+2           ; save partial high mid byte
07874    E1A4  A9 00              LDA   #$00              ; get root high byte (always $00)
07875    E1A6  2A                 ROL                     ; *2
07876    E1A7  85 5E              STA   Temp3+3           ; save partial high byte
07877    
07878                                  ; carry clear for subtract +1
07879    E1A9  A5 77              LDA   FACt_3            ; get remainder low byte
07880    E1AB  E5 5B              SBC   Temp3             ; subtract partial low byte
07881    E1AD  85 5B              STA   Temp3             ; save partial low byte
07882    
07883    E1AF  A5 76              LDA   FACt_2            ; get remainder low mid byte
07884    E1B1  E5 5C              SBC   Temp3+1           ; subtract partial low mid byte
07885    E1B3  85 5C              STA   Temp3+1           ; save partial low mid byte
07886    
07887    E1B5  A5 75              LDA   FACt_1            ; get remainder high mid byte
07888    E1B7  E5 5D              SBC   Temp3+2           ; subtract partial high mid byte
07889    E1B9  A8                 TAY                     ; copy partial high mid byte
07890    
07891    E1BA  A5 78              LDA   TempB             ; get remainder high byte
07892    E1BC  E5 5E              SBC   Temp3+3           ; subtract partial high byte
07893    E1BE  90 0E              BCC   LAB_SQNS          ; skip sub if remainder smaller
07894    
07895    E1C0  85 78              STA   TempB             ; save remainder high byte
07896    
07897    E1C2  84 75              STY   FACt_1            ; save remainder high mid byte
07898    
07899    E1C4  A5 5C              LDA   Temp3+1           ; get remainder low mid byte
07900    E1C6  85 76              STA   FACt_2            ; save remainder low mid byte
07901    
07902    E1C8  A5 5B              LDA   Temp3             ; get partial low byte
07903    E1CA  85 77              STA   FACt_3            ; save remainder low byte
07904    
07905    E1CC  E6 AF              INC   FAC1_3            ; increment root low byte (never any rollover)
07906    LAB_SQNS
07907    E1CE  CA                 DEX                     ; decrement bit pair count
07908    E1CF  D0 A2              BNE   LAB_SQE1          ; loop if not all done
07909    
07910    E1D1  38                 SEC                     ; set carry for subtract
07911    E1D2  A5 B3              LDA   FAC2_e            ; get exponent
07912    E1D4  E9 80              SBC   #$80              ; normalise
07913    E1D6  6A                 ROR                     ; /2 and re-bias to $80
07914    E1D7  69 00              ADC   #$00              ; add bit zero back in (allow for half shift)
07915    E1D9  85 AC              STA   FAC1_e            ; save it
07916    E1DB  4C 47 D7           JMP   LAB_24D5          ; normalise FAC1 and return
07917    
07918    ; perform VARPTR()
07919    
07920    LAB_VARPTR
07921    E1DE  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
07922    E1E1  20 BE CE           JSR   LAB_GVAR          ; get var address
07923    E1E4  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
07924    E1E7  A4 95              LDY   Cvaral            ; get var address low byte
07925    E1E9  A5 96              LDA   Cvarah            ; get var address high byte
07926    E1EB  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
07927    
07928    ; perform PI
07929    
07930    LAB_PI
07931    E1EE  A9 DC              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
07932    E1F0  A0 E2              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
07933    E1F2  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
07934    E1F5  C6 AC              DEC   FAC1_e            ; make result = PI
07935    E1F7  60                 RTS
07936    
07937    ; perform TWOPI
07938    
07939    LAB_TWOPI
07940    E1F8  A9 DC              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
07941    E1FA  A0 E2              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
07942    E1FC  4C 90 D9           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
07943    
07944    ; system dependant i/o vectors
07945    ; these are in RAM and are set by the monitor at start-up
07946    
07947    V_INPT
07948    E1FF  6C 05 02           JMP   (VEC_IN)          ; non halting scan input device
07949    V_OUTP
07950    E202  6C 07 02           JMP   (VEC_OUT)         ; send byte to output device
07951    V_LOAD
07952    E205  6C 09 02           JMP   (VEC_LD)          ; load tape file
07953    V_SAVE
07954    E208  6C 0B 02           JMP   (VEC_SV)          ; save tape file
07955    V_VERIFY
07956    E20B  6C 0D 02           JMP   (VEC_VERIFY)      ; verify tape file
07957    V_CAT 
07958    E20E  6C 0F 02           JMP   (VEC_CAT)         ; catalogue tape files
07959    
07960    ; The rest are tables messages and code for RAM
07961    
07962    ; the rest of the code is tables and BASIC start-up code
07963    
07964    PG2_TABS
07965          .byte $00               ; ctrl-c flag           -     $00 = enabled
07966          .byte $00               ; ctrl-c byte           -     GET needs this
07967          .byte $00               ; ctrl-c byte timeout   -     GET needs this
07968          .word CTRLC             ; ctrl c check vector
07969    ;     .word xxxx              ; non halting key input -     monitor to set this
07970    ;     .word xxxx              ; output vector         -     monitor to set this
07971    ;     .word xxxx              ; load vector           -     monitor to set this
07972    ;     .word xxxx              ; save vector           -     monitor to set this
07973    PG2_TABE
07974    
07975    ; character get subroutine for zero page
07976    
07977    ; For a 1.8432MHz 6502 including the JSR and RTS
07978    ; fastest (>=":") =  29 cycles =  15.7uS
07979    ; slowest (<":")  =  40 cycles =  21.7uS
07980    ; space skip      = +21 cycles = +11.4uS
07981    ; inc across page =  +4 cycles =  +2.2uS
07982    
07983    ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
07984    ; block is copied to it's destination, any non zero page address will do at assembly
07985    ; time, to assemble a three byte instruction.
07986    
07987    ; page 0 initialisation table from $BC
07988    ; increment and scan memory
07989    
07990    LAB_2CEE
07991    E216  E6 C3              INC   Bpntrl            ; increment BASIC execute pointer low byte
07992    E218  D0 02              BNE   LAB_2CF4          ; branch if no carry
07993                                  ; else
07994    E21A  E6 C4              INC   Bpntrh            ; increment BASIC execute pointer high byte
07995    
07996    ; page 0 initialisation table from $C2
07997    ; scan memory
07998    
07999    LAB_2CF4
08000    E21C  AD FF FF           LDA   $FFFF             ; get byte to scan (addr set by call routine)
08001    E21F  C9 B6              CMP   #TK_ELSE          ; compare with the token for ELSE
08002    E221  F0 0E              BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
08003    
08004    E223  C9 3A              CMP   #':'              ; compare with ":"
08005    E225  B0 0A              BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
08006    
08007    E227  C9 20              CMP   #' '              ; compare with " "
08008    E229  F0 EB              BEQ   LAB_2CEE          ; if " " go do next
08009    
08010    E22B  38                 SEC                     ; set carry for SBC
08011    E22C  E9 30              SBC   #'0'              ; subtract "0"
08012    E22E  38                 SEC                     ; set carry for SBC
08013    E22F  E9 D0              SBC   #$D0              ; subtract -"0"
08014                                  ; clear carry if byte = "0"-"9"
08015    LAB_2D05
08016    E231  60                 RTS
08017    
08018    ; page zero initialisation table $00-$12 inclusive
08019    
08020    StrTab
08021          .byte $4C               ; JMP opcode
08022          .word LAB_COLD          ; initial warm start vector (cold start)
08023    
08024          .byte $00               ; these bytes are not used by BASIC
08025          .word $0000             ; 
08026          .word $0000             ; 
08027          .word $0000             ; 
08028    
08029          .byte $4C               ; JMP opcode
08030          .word LAB_FCER          ; initial user function vector ("Function call" error)
08031          .byte $00               ; default NULL count
08032          .byte $00               ; clear terminal position
08033          .byte $00               ; default terminal width byte
08034          .byte $F2               ; default limit for TAB = 14
08035          .word Ram_base          ; start of user RAM
08036    EndTab
08037    
08038    LAB_MSZM
08039          .byte $0D,$0A,"Memory size ",$00
08040    
08041    LAB_SMSG
08042          .byte " Bytes free",$0D,$0A,$0A
08043          .byte "Enhanced BASIC 2.22p5 EL3",$0A,$00
08044    
08045    ; numeric constants and series
08046    
08047                                  ; constants and series for LOG(n)
08048    LAB_25A0
08049          .byte $02               ; counter
08050          .byte $80,$19,$56,$62   ; 0.59898
08051          .byte $80,$76,$22,$F3   ; 0.96147
08052    ;##   .byte $80,$76,$22,$F1   ; 0.96147
08053          .byte $82,$38,$AA,$40   ; 2.88539
08054    ;##   .byte $82,$38,$AA,$45   ; 2.88539
08055    
08056    LAB_25AD
08057          .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
08058    LAB_25B1
08059          .byte $81,$35,$04,$F3   ; 1.41421   root 2
08060    LAB_25B5
08061          .byte $80,$80,$00,$00   ; -0.5
08062    LAB_25B9
08063          .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
08064    
08065                                  ; numeric PRINT constants
08066    LAB_2947
08067          .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
08068    LAB_294B
08069          .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
08070    LAB_294F
08071          .byte $94,$74,$24,$00   ; 1000000
08072    
08073                                  ; EXP(n) constants and series
08074    LAB_2AFA
08075          .byte $81,$38,$AA,$3B   ; 1.4427    (1/LOG base 2 e)
08076    LAB_2AFE
08077          .byte $06               ; counter
08078          .byte $74,$63,$90,$8C   ; 2.17023e-4
08079          .byte $77,$23,$0C,$AB   ; 0.00124
08080          .byte $7A,$1E,$94,$00   ; 0.00968
08081          .byte $7C,$63,$42,$80   ; 0.05548
08082          .byte $7E,$75,$FE,$D0   ; 0.24023
08083          .byte $80,$31,$72,$15   ; 0.69315
08084          .byte $81,$00,$00,$00   ; 1.00000
08085    
08086    ;##   .byte $07               ; counter
08087    ;##   .byte $74,$94,$2E,$40   ; -1/7! (-1/5040)
08088    ;##   .byte $77,$2E,$4F,$70   ;  1/6! ( 1/720)
08089    ;##   .byte $7A,$88,$02,$6E   ; -1/5! (-1/120)
08090    ;##   .byte $7C,$2A,$A0,$E6   ;  1/4! ( 1/24)
08091    ;##   .byte $7E,$AA,$AA,$50   ; -1/3! (-1/6)
08092    ;##   .byte $7F,$7F,$FF,$FF   ;  1/2! ( 1/2)
08093    ;##   .byte $81,$80,$00,$00   ; -1/1! (-1/1)
08094    ;##   .byte $81,$00,$00,$00   ;  1/0! ( 1/1)
08095    
08096                                  ; trigonometric constants and series
08097    LAB_2C78
08098          .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
08099    LAB_2C84
08100          .byte $04               ; counter
08101          .byte $86,$1E,$D7,$FB   ; 39.7109
08102    ;##   .byte $86,$1E,$D7,$BA   ; 39.7109
08103          .byte $87,$99,$26,$65   ;-76.575
08104    ;##   .byte $87,$99,$26,$64   ;-76.575
08105          .byte $87,$23,$34,$58   ; 81.6022
08106          .byte $86,$A5,$5D,$E1   ;-41.3417
08107    ;##   .byte $86,$A5,$5D,$E0   ;-41.3417
08108    LAB_2C7C
08109          .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
08110    ;##   .byte $83,$49,$0F,$DA   ; 6.28319 (2*pi) as floating #
08111    
08112    LAB_2CC9
08113          .byte $08               ; counter
08114          .byte $78,$3A,$C5,$37   ; 0.00285
08115          .byte $7B,$83,$A2,$5C   ;-0.0160686
08116          .byte $7C,$2E,$DD,$4D   ; 0.0426915
08117          .byte $7D,$99,$B0,$1E   ;-0.0750429
08118          .byte $7D,$59,$ED,$24   ; 0.106409
08119          .byte $7E,$91,$72,$00   ;-0.142036
08120          .byte $7E,$4C,$B9,$73   ; 0.199926
08121          .byte $7F,$AA,$AA,$53   ;-0.333331
08122    
08123    ;##   .byte $08               ; counter
08124    ;##   .byte $78,$3B,$D7,$4A   ; 1/17
08125    ;##   .byte $7B,$84,$6E,$02   ;-1/15
08126    ;##   .byte $7C,$2F,$C1,$FE   ; 1/13
08127    ;##   .byte $7D,$9A,$31,$74   ;-1/11
08128    ;##   .byte $7D,$5A,$3D,$84   ; 1/9
08129    ;##   .byte $7E,$91,$7F,$C8   ;-1/7
08130    ;##   .byte $7E,$4C,$BB,$E4   ; 1/5
08131    ;##   .byte $7F,$AA,$AA,$6C   ;-1/3
08132    
08133      E302             LAB_1D96    = *+1             ; $00,$00 used for undefined variables
08134    LAB_259C
08135          .byte $81,$00,$00,$00   ; 1.000000, used for INC
08136    LAB_2AFD
08137          .byte $81,$80,$00,$00   ; -1.00000, used for DEC. must be on the same page as +1.00
08138    
08139                                  ; misc constants
08140    LAB_1DF7
08141          .byte $90               ;-32768 (uses first three bytes from 0.5)
08142    LAB_2A96
08143          .byte $80,$00,$00,$00   ; 0.5
08144    LAB_2C80
08145          .byte $7F,$00,$00,$00   ; 0.25
08146    LAB_26B5
08147          .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
08148    
08149    ; This table is used in converting numbers to ASCII.
08150    
08151    LAB_2A9A
08152      E317             LAB_2A9B = LAB_2A9A+1
08153      E318             LAB_2A9C = LAB_2A9B+1
08154          .byte $FE,$79,$60       ; -100000
08155          .byte $00,$27,$10       ; 10000
08156          .byte $FF,$FC,$18       ; -1000
08157          .byte $00,$00,$64       ; 100
08158          .byte $FF,$FF,$F6       ; -10
08159          .byte $00,$00,$01       ; 1
08160    
08161    LAB_CTBL
08162          .word LAB_END-1         ; END
08163          .word LAB_FOR-1         ; FOR
08164          .word LAB_NEXT-1        ; NEXT
08165          .word LAB_DATA-1        ; DATA
08166          .word LAB_INPUT-1       ; INPUT
08167          .word LAB_DIM-1         ; DIM
08168          .word LAB_READ-1        ; READ
08169          .word LAB_LET-1         ; LET
08170          .word LAB_DEC-1         ; DEC             new command
08171          .word LAB_GOTO-1        ; GOTO
08172          .word LAB_RUN-1         ; RUN
08173          .word LAB_IF-1          ; IF
08174          .word LAB_RESTORE-1     ; RESTORE         modified command
08175          .word LAB_GOSUB-1       ; GOSUB
08176          .word LAB_RETIRQ-1      ; RETIRQ          new command
08177          .word LAB_RETNMI-1      ; RETNMI          new command
08178          .word LAB_RETURN-1      ; RETURN
08179          .word LAB_REM-1         ; REM
08180          .word LAB_STOP-1        ; STOP
08181          .word LAB_ON-1          ; ON              modified command
08182          .word LAB_NULL-1        ; NULL            modified command
08183          .word LAB_INC-1         ; INC             new command
08184          .word LAB_WAIT-1        ; WAIT
08185          .word V_LOAD-1          ; LOAD
08186          .word V_SAVE-1          ; SAVE
08187          .word LAB_DEF-1         ; DEF
08188          .word LAB_POKE-1        ; POKE
08189          .word LAB_DOKE-1        ; DOKE            new command
08190          .word LAB_CALL-1        ; CALL            new command
08191          .word LAB_DO-1          ; DO              new command
08192          .word LAB_LOOP-1        ; LOOP            new command
08193          .word LAB_PRINT-1       ; PRINT
08194          .word LAB_CONT-1        ; CONT
08195          .word LAB_LIST-1        ; LIST
08196          .word LAB_CLEAR-1       ; CLEAR
08197          .word LAB_NEW-1         ; NEW
08198          .word LAB_WDTH-1        ; WIDTH           new command
08199          .word LAB_GET-1         ; GET             new command
08200          .word LAB_SWAP-1        ; SWAP            new command
08201          .word LAB_BITSET-1      ; BITSET          new command
08202          .word LAB_BITCLR-1      ; BITCLR          new command
08203          .word LAB_IRQ-1         ; IRQ             new command
08204          .word LAB_NMI-1         ; NMI             new command
08205          .word V_VERIFY-1        ; VERIFY          new command
08206          .word V_CAT-1           ; CAT             new command
08207          .word MON_CLS-1         ; CLS             new command
08208          .word XTRA_LOCATE_F-1   ; LOCATE          new command
08209          .word XTRA_PLOT_F-1     ; PLOT            new command
08210          .word AY_SOUND-1        ; SOUND           new command
08211          .word AY_ENVELOPE-1     ; ENVELOPE        new command
08212          .word I2C_Start_BAS-1   ; I2C_START       new command
08213          .word I2C_Stop_BAS-1    ; I2C_STOP        new command
08214          .word I2C_Init-1        ; I2C_INIT        new command
08215          
08216    
08217    ; function pre process routine table
08218    
08219    LAB_FTPL
08220      E393             LAB_FTPM    = LAB_FTPL+$01
08221          .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
08222          .word LAB_PPFN-1        ; INT(n)          "
08223          .word LAB_PPFN-1        ; ABS(n)          "
08224          .word LAB_EVEZ-1        ; USR(x)    process any expression
08225          .word LAB_1BF7-1        ; FRE(x)          "
08226          .word LAB_1BF7-1        ; POS(x)          "
08227          .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
08228          .word LAB_PPFN-1        ; RND(n)          "
08229          .word LAB_PPFN-1        ; LOG(n)          "
08230          .word LAB_PPFN-1        ; EXP(n)          "
08231          .word LAB_PPFN-1        ; COS(n)          "
08232          .word LAB_PPFN-1        ; SIN(n)          "
08233          .word LAB_PPFN-1        ; TAN(n)          "
08234          .word LAB_PPFN-1        ; ATN(n)          "
08235          .word LAB_PPFN-1        ; PEEK(n)         "
08236          .word LAB_PPFN-1        ; DEEK(n)         "
08237          .word $0000             ; SADD()    none
08238          .word LAB_PPFS-1        ; LEN($)    process string expression in ()
08239          .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
08240          .word LAB_PPFS-1        ; VAL($)    process string expression in ()
08241          .word LAB_PPFS-1        ; ASC($)          "
08242          .word LAB_PPFS-1        ; UCASE$($)       "
08243          .word LAB_PPFS-1        ; LCASE$($)       "
08244          .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
08245          .word LAB_BHSS-1        ; HEX$(n)         "
08246          .word LAB_BHSS-1        ; BIN$(n)         "
08247          .word $0000             ; BITTST()  none
08248          .word LAB_MMPP-1        ; MAX()     process numeric expression
08249          .word LAB_MMPP-1        ; MIN()           "
08250          .word LAB_PPBI-1        ; PI        advance pointer
08251          .word LAB_PPBI-1        ; TWOPI           "
08252          .word $0000             ; VARPTR()  none
08253          .word LAB_LRMS-1        ; LEFT$()   process string expression
08254          .word LAB_LRMS-1        ; RIGHT$()        "
08255          .word LAB_LRMS-1        ; MID$()          "
08256          .word LAB_PPFN-1        ; I2C_OUT() process numeric expression in ()
08257          .word LAB_PPFN-1        ; I2C_IN()        "
08258    
08259    ; action addresses for functions
08260    
08261    LAB_FTBL
08262      E3DD             LAB_FTBM    = LAB_FTBL+$01
08263          .word LAB_SGN-1         ; SGN()
08264          .word LAB_INT-1         ; INT()
08265          .word LAB_ABS-1         ; ABS()
08266          .word LAB_USR-1         ; USR()
08267          .word LAB_FRE-1         ; FRE()
08268          .word LAB_POS-1         ; POS()
08269          .word LAB_SQR-1         ; SQR()
08270          .word LAB_RND-1         ; RND()           modified function
08271          .word LAB_LOG-1         ; LOG()
08272          .word LAB_EXP-1         ; EXP()
08273          .word LAB_COS-1         ; COS()
08274          .word LAB_SIN-1         ; SIN()
08275          .word LAB_TAN-1         ; TAN()
08276          .word LAB_ATN-1         ; ATN()
08277          .word LAB_PEEK-1        ; PEEK()
08278          .word LAB_DEEK-1        ; DEEK()          new function
08279          .word LAB_SADD-1        ; SADD()          new function
08280          .word LAB_LENS-1        ; LEN()
08281          .word LAB_STRS-1        ; STR$()
08282          .word LAB_VAL-1         ; VAL()
08283          .word LAB_ASC-1         ; ASC()
08284          .word LAB_UCASE-1       ; UCASE$()        new function
08285          .word LAB_LCASE-1       ; LCASE$()        new function
08286          .word LAB_CHRS-1        ; CHR$()
08287          .word LAB_HEXS-1        ; HEX$()          new function
08288          .word LAB_BINS-1        ; BIN$()          new function
08289          .word LAB_BTST-1        ; BITTST()        new function
08290          .word LAB_MAX-1         ; MAX()           new function
08291          .word LAB_MIN-1         ; MIN()           new function
08292          .word LAB_PI-1          ; PI              new function
08293          .word LAB_TWOPI-1       ; TWOPI           new function
08294          .word LAB_VARPTR-1      ; VARPTR()        new function
08295          .word LAB_LEFT-1        ; LEFT$()
08296          .word LAB_RIGHT-1       ; RIGHT$()
08297          .word LAB_MIDS-1        ; MID$()
08298          .word I2C_Out_BAS-1     ; I2C_OUT()       new function
08299          .word I2C_In_BAS-1      ; I2C_IN()        new function
08300          
08301    
08302    ; hierarchy and action addresses for operator
08303    
08304    LAB_OPPT
08305          .byte $79               ; +
08306          .word LAB_ADD-1
08307          .byte $79               ; -
08308          .word LAB_SUBTRACT-1
08309          .byte $7B               ; *
08310          .word LAB_MULTIPLY-1
08311          .byte $7B               ; /
08312          .word LAB_DIVIDE-1
08313          .byte $7F               ; ^
08314          .word LAB_POWER-1
08315          .byte $50               ; AND
08316          .word LAB_AND-1
08317          .byte $46               ; EOR             new operator
08318          .word LAB_EOR-1
08319          .byte $46               ; OR
08320          .word LAB_OR-1
08321          .byte $56               ; >>              new operator
08322          .word LAB_RSHIFT-1
08323          .byte $56               ; <<              new operator
08324          .word LAB_LSHIFT-1
08325          .byte $7D               ; >
08326          .word LAB_GTHAN-1
08327          .byte $5A               ; =
08328          .word LAB_EQUAL-1
08329          .byte $64               ; <
08330          .word LAB_LTHAN-1
08331    
08332    ; keywords start with ..
08333    ; this is the first character table and must be in alphabetic order
08334    
08335    TAB_1STC
08336          .byte "*"
08337          .byte "+"
08338          .byte "-"
08339          .byte "/"
08340          .byte "<"
08341          .byte "="
08342          .byte ">"
08343          .byte "?"
08344          .byte "A"
08345          .byte "B"
08346          .byte "C"
08347          .byte "D"
08348          .byte "E"
08349          .byte "F"
08350          .byte "G"
08351          .byte "H"
08352          .byte "I"
08353          .byte "L"
08354          .byte "M"
08355          .byte "N"
08356          .byte "O"
08357          .byte "P"
08358          .byte "R"
08359          .byte "S"
08360          .byte "T"
08361          .byte "U"
08362          .byte "V"
08363          .byte "W"
08364          .byte "^"
08365          .byte $00               ; table terminator
08366    
08367    ; pointers to keyword tables
08368    
08369    TAB_CHRT
08370          .word TAB_STAR          ; table for "*"
08371          .word TAB_PLUS          ; table for "+"
08372          .word TAB_MNUS          ; table for "-"
08373          .word TAB_SLAS          ; table for "/"
08374          .word TAB_LESS          ; table for "<"
08375          .word TAB_EQUL          ; table for "="
08376          .word TAB_MORE          ; table for ">"
08377          .word TAB_QEST          ; table for "?"
08378          .word TAB_ASCA          ; table for "A"
08379          .word TAB_ASCB          ; table for "B"
08380          .word TAB_ASCC          ; table for "C"
08381          .word TAB_ASCD          ; table for "D"
08382          .word TAB_ASCE          ; table for "E"
08383          .word TAB_ASCF          ; table for "F"
08384          .word TAB_ASCG          ; table for "G"
08385          .word TAB_ASCH          ; table for "H"
08386          .word TAB_ASCI          ; table for "I"
08387          .word TAB_ASCL          ; table for "L"
08388          .word TAB_ASCM          ; table for "M"
08389          .word TAB_ASCN          ; table for "N"
08390          .word TAB_ASCO          ; table for "O"
08391          .word TAB_ASCP          ; table for "P"
08392          .word TAB_ASCR          ; table for "R"
08393          .word TAB_ASCS          ; table for "S"
08394          .word TAB_ASCT          ; table for "T"
08395          .word TAB_ASCU          ; table for "U"
08396          .word TAB_ASCV          ; table for "V"
08397          .word TAB_ASCW          ; table for "W"
08398          .word TAB_POWR          ; table for "^"
08399    
08400    
08401    ; FINDME LBB
08402    ; tables for each start character, note if a longer keyword with the same start
08403    ; letters as a shorter one exists then it must come first, else the list is in
08404    ; alphabetical order as follows ..
08405    
08406    ; [keyword,token
08407    ; [keyword,token]]
08408    ; end marker (#$00)
08409    
08410    TAB_STAR
08411          .byte TK_MUL,$00              ; *
08412    TAB_PLUS
08413          .byte TK_PLUS,$00             ; +
08414    TAB_MNUS
08415          .byte TK_MINUS,$00            ; -
08416    TAB_SLAS
08417          .byte TK_DIV,$00              ; /
08418    TAB_LESS
08419    LBB_LSHIFT
08420          .byte "<",TK_LSHIFT           ; <<  note - "<<" must come before "<"
08421          .byte TK_LT                   ; <
08422          .byte $00
08423    TAB_EQUL
08424          .byte TK_EQUAL,$00            ; =
08425    TAB_MORE
08426    LBB_RSHIFT
08427          .byte ">",TK_RSHIFT           ; >>  note - ">>" must come before ">"
08428          .byte TK_GT                   ; >
08429          .byte $00
08430    TAB_QEST
08431          .byte TK_PRINT,$00            ; ?
08432    TAB_ASCA
08433    LBB_ABS
08434          .byte "BS(",TK_ABS            ; ABS(
08435    LBB_AND
08436          .byte "ND",TK_AND             ; AND
08437    LBB_ASC
08438          .byte "SC(",TK_ASC            ; ASC(
08439    LBB_ATN
08440          .byte "TN(",TK_ATN            ; ATN(
08441          .byte $00
08442    TAB_ASCB
08443    LBB_BINS
08444          .byte "IN$(",TK_BINS          ; BIN$(
08445    LBB_BITCLR
08446          .byte "ITCLR",TK_BITCLR       ; BITCLR
08447    LBB_BITSET
08448          .byte "ITSET",TK_BITSET       ; BITSET
08449    LBB_BITTST
08450          .byte "ITTST(",TK_BITTST
08451                                        ; BITTST(
08452          .byte $00
08453    TAB_ASCC
08454    LBB_CAT
08455          .byte "AT",TK_CAT             ; CAT
08456    LBB_CALL
08457          .byte "ALL",TK_CALL           ; CALL
08458    LBB_CHRS
08459          .byte "HR$(",TK_CHRS          ; CHR$(
08460    LBB_CLS
08461          .byte "LS",TK_CLS             ; CLS
08462    LBB_CLEAR
08463          .byte "LEAR",TK_CLEAR         ; CLEAR
08464    LBB_CONT
08465          .byte "ONT",TK_CONT           ; CONT
08466    LBB_COS
08467          .byte "OS(",TK_COS            ; COS(
08468          .byte $00
08469    TAB_ASCD
08470    LBB_DATA
08471          .byte "ATA",TK_DATA           ; DATA
08472    LBB_DEC
08473          .byte "EC",TK_DEC             ; DEC
08474    LBB_DEEK
08475          .byte "EEK(",TK_DEEK          ; DEEK(
08476    LBB_DEF
08477          .byte "EF",TK_DEF             ; DEF
08478    LBB_DIM
08479          .byte "IM",TK_DIM             ; DIM
08480    LBB_DOKE
08481          .byte "OKE",TK_DOKE           ; DOKE note - "DOKE" must come before "DO"
08482    LBB_DO
08483          .byte "O",TK_DO               ; DO
08484          .byte $00
08485    TAB_ASCE
08486    LBB_ELSE
08487          .byte "LSE",TK_ELSE           ; ELSE
08488    LBB_END
08489          .byte "ND",TK_END             ; END
08490    LBB_ENVELOPE
08491          .byte "NVELOPE", TK_ENVELOPE  ; ENVELOPE
08492    LBB_EOR
08493          .byte "OR",TK_EOR             ; EOR
08494    LBB_EXP
08495          .byte "XP(",TK_EXP            ; EXP(
08496          .byte $00
08497    TAB_ASCF
08498    LBB_FN
08499          .byte "N",TK_FN               ; FN
08500    LBB_FOR
08501          .byte "OR",TK_FOR             ; FOR
08502    LBB_FRE
08503          .byte "RE(",TK_FRE            ; FRE(
08504          .byte $00
08505    TAB_ASCG
08506    LBB_GET
08507          .byte "ET",TK_GET             ; GET
08508    LBB_GOSUB
08509          .byte "OSUB",TK_GOSUB         ; GOSUB
08510    LBB_GOTO
08511          .byte "OTO",TK_GOTO           ; GOTO
08512          .byte $00
08513    TAB_ASCH
08514    LBB_HEXS
08515          .byte "EX$(",TK_HEXS          ; HEX$(
08516          .byte $00
08517    TAB_ASCI
08518    LBB_IF
08519          .byte "F",TK_IF               ; IF
08520    LBB_INC
08521          .byte "NC",TK_INC             ; INC
08522    LBB_INPUT
08523          .byte "NPUT",TK_INPUT         ; INPUT
08524    LBB_INT
08525          .byte "NT(",TK_INT            ; INT(
08526    LBB_IRQ
08527          .byte "RQ",TK_IRQ             ; IRQ
08528    LBB_I2C_INIT
08529          .byte "2C_INIT",TK_I2C_INIT   ; I2C_INIT
08530    LBB_I2C_IN
08531          .byte "2C_IN(",TK_I2C_IN      ; I2C_IN(
08532    LBB_I2C_OUT
08533          .byte "2C_OUT(",TK_I2C_OUT    ; I2C_OUT(
08534    LBB_I2C_START
08535          .byte "2C_START",TK_I2C_START ; I2C_START
08536    LBB_I2C_STOP
08537          .byte "2C_STOP",TK_I2C_STOP   ; I2C STOP
08538    
08539          .byte $00
08540    TAB_ASCL
08541    LBB_LCASES
08542          .byte "CASE$(",TK_LCASES
08543                                        ; LCASE$(
08544    LBB_LEFTS
08545          .byte "EFT$(",TK_LEFTS        ; LEFT$(
08546    LBB_LEN
08547          .byte "EN(",TK_LEN            ; LEN(
08548    LBB_LET
08549          .byte "ET",TK_LET             ; LET
08550    LBB_LIST
08551          .byte "IST",TK_LIST           ; LIST
08552    LBB_LOAD
08553          .byte "OAD",TK_LOAD           ; LOAD      
08554    LBB_LOCATE
08555          .byte "OCATE",TK_LOCATE       ; LOCATE
08556          
08557    LBB_LOG
08558          .byte "OG(",TK_LOG            ; LOG(
08559    LBB_LOOP
08560          .byte "OOP",TK_LOOP           ; LOOP
08561          .byte $00
08562    TAB_ASCM
08563    LBB_MAX
08564          .byte "AX(",TK_MAX            ; MAX(
08565    LBB_MIDS
08566          .byte "ID$(",TK_MIDS          ; MID$(
08567    LBB_MIN
08568          .byte "IN(",TK_MIN            ; MIN(
08569          .byte $00
08570    TAB_ASCN
08571    LBB_NEW
08572          .byte "EW",TK_NEW             ; NEW
08573    LBB_NEXT
08574          .byte "EXT",TK_NEXT           ; NEXT
08575    LBB_NMI
08576          .byte "MI",TK_NMI             ; NMI
08577    LBB_NOT
08578          .byte "OT",TK_NOT             ; NOT
08579    LBB_NULL
08580          .byte "ULL",TK_NULL           ; NULL
08581          .byte $00
08582    TAB_ASCO
08583    LBB_OFF
08584          .byte "FF",TK_OFF             ; OFF
08585    LBB_ON
08586          .byte "N",TK_ON               ; ON
08587    LBB_OR
08588          .byte "R",TK_OR               ; OR
08589          .byte $00
08590    TAB_ASCP
08591    LBB_PEEK
08592          .byte "EEK(",TK_PEEK          ; PEEK(
08593    LBB_PI
08594          .byte "I",TK_PI               ; PI
08595    
08596    LBB_PLOT
08597          .byte "LOT",TK_PLOT           ; PLOT      
08598          
08599    LBB_POKE
08600          .byte "OKE",TK_POKE           ; POKE
08601    LBB_POS
08602          .byte "OS(",TK_POS            ; POS(
08603    LBB_PRINT
08604          .byte "RINT",TK_PRINT         ; PRINT
08605          .byte $00
08606    TAB_ASCR
08607    LBB_READ
08608          .byte "EAD",TK_READ           ; READ
08609    LBB_REM
08610          .byte "EM",TK_REM             ; REM
08611    LBB_RESTORE
08612          .byte "ESTORE",TK_RESTORE
08613                                        ; RESTORE
08614    LBB_RETIRQ
08615          .byte "ETIRQ",TK_RETIRQ       ; RETIRQ
08616    LBB_RETNMI
08617          .byte "ETNMI",TK_RETNMI       ; RETNMI
08618    LBB_RETURN
08619          .byte "ETURN",TK_RETURN       ; RETURN
08620    LBB_RIGHTS
08621          .byte "IGHT$(",TK_RIGHTS
08622                                        ; RIGHT$(
08623    LBB_RND
08624          .byte "ND(",TK_RND            ; RND(
08625    LBB_RUN
08626          .byte "UN",TK_RUN             ; RUN
08627          .byte $00
08628    TAB_ASCS
08629    LBB_SADD
08630          .byte "ADD(",TK_SADD          ; SADD(
08631    LBB_SAVE
08632          .byte "AVE",TK_SAVE           ; SAVE
08633    LBB_SGN
08634          .byte "GN(",TK_SGN            ; SGN(
08635    LBB_SIN
08636          .byte "IN(",TK_SIN            ; SIN(
08637    LBB_SOUND
08638          .byte "OUND",TK_SOUND         ; SOUND
08639    LBB_SPC
08640          .byte "PC(",TK_SPC            ; SPC(
08641    LBB_SQR
08642          .byte "QR(",TK_SQR            ; SQR(
08643    LBB_STEP
08644          .byte "TEP",TK_STEP           ; STEP
08645    LBB_STOP
08646          .byte "TOP",TK_STOP           ; STOP
08647    LBB_STRS
08648          .byte "TR$(",TK_STRS          ; STR$(
08649    LBB_SWAP
08650          .byte "WAP",TK_SWAP           ; SWAP
08651          .byte $00
08652    TAB_ASCT
08653    LBB_TAB
08654          .byte "AB(",TK_TAB            ; TAB(
08655    LBB_TAN
08656          .byte "AN(",TK_TAN            ; TAN(
08657    LBB_THEN
08658          .byte "HEN",TK_THEN           ; THEN
08659    LBB_TO
08660          .byte "O",TK_TO               ; TO
08661    LBB_TWOPI
08662          .byte "WOPI",TK_TWOPI         ; TWOPI
08663          .byte $00
08664    TAB_ASCU
08665    LBB_UCASES
08666          .byte "CASE$(",TK_UCASES
08667                                        ; UCASE$(
08668    LBB_UNTIL
08669          .byte "NTIL",TK_UNTIL         ; UNTIL
08670    LBB_USR
08671          .byte "SR(",TK_USR            ; USR(
08672          .byte $00
08673    TAB_ASCV
08674    LBB_VAL
08675          .BYTE "AL(",TK_VAL            ; VAL(
08676    LBB_VPTR
08677          .byte "ARPTR(",TK_VPTR        ; VARPTR(
08678    LBB_VERIFY
08679          .BYTE "ERIFY",TK_VERIFY       ; VERIFY
08680          .byte $00
08681    TAB_ASCW
08682    LBB_WAIT
08683          .byte "AIT",TK_WAIT           ; WAIT
08684    LBB_WHILE
08685          .byte "HILE",TK_WHILE         ; WHILE
08686    LBB_WIDTH
08687          .byte "IDTH",TK_WIDTH        ; WIDTH
08688          .byte $00
08689    TAB_POWR
08690          .byte TK_POWER,$00           ; ^
08691    
08692    ; new decode table for LIST
08693    ; Table is ..
08694    ; byte - keyword length, keyword first character
08695    ; word - pointer to rest of keyword from dictionary
08696    
08697    ; note if length is 1 then the pointer is ignored
08698    
08699    LAB_KEYT
08700          .byte 3,'E'
08701          .word LBB_END           ; END
08702          .byte 3,'F'
08703          .word LBB_FOR           ; FOR
08704          .byte 4,'N'
08705          .word LBB_NEXT          ; NEXT
08706          .byte 4,'D'
08707          .word LBB_DATA          ; DATA
08708          .byte 5,'I'
08709          .word LBB_INPUT         ; INPUT
08710          .byte 3,'D'
08711          .word LBB_DIM           ; DIM
08712          .byte 4,'R'
08713          .word LBB_READ          ; READ
08714          .byte 3,'L'
08715          .word LBB_LET           ; LET
08716          .byte 3,'D'
08717          .word LBB_DEC           ; DEC
08718          .byte 4,'G'
08719          .word LBB_GOTO          ; GOTO
08720          .byte 3,'R'
08721          .word LBB_RUN           ; RUN
08722          .byte 2,'I'
08723          .word LBB_IF            ; IF
08724          .byte 7,'R'
08725          .word LBB_RESTORE       ; RESTORE
08726          .byte 5,'G'
08727          .word LBB_GOSUB         ; GOSUB
08728          .byte 6,'R'
08729          .word LBB_RETIRQ        ; RETIRQ
08730          .byte 6,'R'
08731          .word LBB_RETNMI        ; RETNMI
08732          .byte 6,'R'
08733          .word LBB_RETURN        ; RETURN
08734          .byte 3,'R'
08735          .word LBB_REM           ; REM
08736          .byte 4,'S'
08737          .word LBB_STOP          ; STOP
08738          .byte 2,'O'
08739          .word LBB_ON            ; ON
08740          .byte 4,'N'
08741          .word LBB_NULL          ; NULL
08742          .byte 3,'I'
08743          .word LBB_INC           ; INC
08744          .byte 4,'W'
08745          .word LBB_WAIT          ; WAIT
08746          .byte 4,'L'
08747          .word LBB_LOAD          ; LOAD
08748          .byte 4,'S'
08749          .word LBB_SAVE          ; SAVE
08750          .byte 3,'D'
08751          .word LBB_DEF           ; DEF
08752          .byte 4,'P'
08753          .word LBB_POKE          ; POKE
08754          .byte 4,'D'
08755          .word LBB_DOKE          ; DOKE
08756          .byte 4,'C'
08757          .word LBB_CALL          ; CALL
08758          .byte 2,'D'
08759          .word LBB_DO            ; DO
08760          .byte 4,'L'
08761          .word LBB_LOOP          ; LOOP
08762          .byte 5,'P'
08763          .word LBB_PRINT         ; PRINT
08764          .byte 4,'C'
08765          .word LBB_CONT          ; CONT
08766          .byte 4,'L'
08767          .word LBB_LIST          ; LIST
08768          .byte 5,'C'
08769          .word LBB_CLEAR         ; CLEAR
08770          .byte 3,'N'
08771          .word LBB_NEW           ; NEW
08772          .byte 5,'W'
08773          .word LBB_WIDTH         ; WIDTH
08774          .byte 3,'G'
08775          .word LBB_GET           ; GET
08776          .byte 4,'S'
08777          .word LBB_SWAP          ; SWAP
08778          .byte 6,'B'
08779          .word LBB_BITSET        ; BITSET
08780          .byte 6,'B'
08781          .word LBB_BITCLR        ; BITCLR
08782          .byte 3,'I'
08783          .word LBB_IRQ           ; IRQ
08784          .byte 3,'N'
08785          .word LBB_NMI           ; NMI
08786          .byte 6,'V'
08787          .word LBB_VERIFY        ; VERIFY
08788          .byte 3,'C'
08789          .word LBB_CAT           ; CAT
08790          .byte 3,'C'
08791          .word LBB_CLS           ; CLS
08792          .byte 6,'L'
08793          .word LBB_LOCATE        ; LOCATE
08794          .byte 4,'P'
08795          .word LBB_PLOT          ; PLOT
08796          .byte 5,'S'
08797          .word LBB_SOUND         ; SOUND
08798          .byte 8,'E'
08799          .word LBB_ENVELOPE      ; ENVELOPE
08800          .byte 9,'I'
08801          .word LBB_I2C_START     ; I2C_START
08802          .byte 8,'I'
08803          .word LBB_I2C_STOP      ; I2C_STOP
08804          .byte 8,'I'
08805          .word LBB_I2C_INIT      ; I2C_INIT
08806    
08807    
08808    ; secondary commands (can't start a statement)
08809    
08810          .byte 4,'T'
08811          .word LBB_TAB           ; TAB
08812          .byte 4,'E'
08813          .word LBB_ELSE          ; ELSE
08814          .byte 2,'T'
08815          .word LBB_TO            ; TO
08816          .byte 2,'F'
08817          .word LBB_FN            ; FN
08818          .byte 4,'S'
08819          .word LBB_SPC           ; SPC
08820          .byte 4,'T'
08821          .word LBB_THEN          ; THEN
08822          .byte 3,'N'
08823          .word LBB_NOT           ; NOT
08824          .byte 4,'S'
08825          .word LBB_STEP          ; STEP
08826          .byte 5,'U'
08827          .word LBB_UNTIL         ; UNTIL
08828          .byte 5,'W'
08829          .word LBB_WHILE         ; WHILE
08830          .byte 3,'O'
08831          .word LBB_OFF           ; OFF
08832    
08833    ; operators
08834    
08835          .byte 1,'+'
08836          .word $0000             ; +
08837          .byte 1,'-'
08838          .word $0000             ; -
08839          .byte 1,'*'
08840          .word $0000             ; *
08841          .byte 1,'/'
08842          .word $0000             ; /
08843          .byte 1,'^'
08844          .word $0000             ; ^
08845          .byte 3,'A'
08846          .word LBB_AND           ; AND
08847          .byte 3,'E'
08848          .word LBB_EOR           ; EOR
08849          .byte 2,'O'
08850          .word LBB_OR            ; OR
08851          .byte 2,'>'
08852          .word LBB_RSHIFT        ; >>
08853          .byte 2,'<'
08854          .word LBB_LSHIFT        ; <<
08855          .byte 1,'>'
08856          .word $0000             ; >
08857          .byte 1,'='
08858          .word $0000             ; =
08859          .byte 1,'<'
08860          .word $0000             ; <
08861    
08862    ; functions
08863    
08864          .byte 4,'S'             ;
08865          .word LBB_SGN           ; SGN
08866          .byte 4,'I'             ;
08867          .word LBB_INT           ; INT
08868          .byte 4,'A'             ;
08869          .word LBB_ABS           ; ABS
08870          .byte 4,'U'             ;
08871          .word LBB_USR           ; USR
08872          .byte 4,'F'             ;
08873          .word LBB_FRE           ; FRE
08874          .byte 4,'P'             ;
08875          .word LBB_POS           ; POS
08876          .byte 4,'S'             ;
08877          .word LBB_SQR           ; SQR
08878          .byte 4,'R'             ;
08879          .word LBB_RND           ; RND
08880          .byte 4,'L'             ;
08881          .word LBB_LOG           ; LOG
08882          .byte 4,'E'             ;
08883          .word LBB_EXP           ; EXP
08884          .byte 4,'C'             ;
08885          .word LBB_COS           ; COS
08886          .byte 4,'S'             ;
08887          .word LBB_SIN           ; SIN
08888          .byte 4,'T'             ;
08889          .word LBB_TAN           ; TAN
08890          .byte 4,'A'             ;
08891          .word LBB_ATN           ; ATN
08892          .byte 5,'P'             ;
08893          .word LBB_PEEK          ; PEEK
08894          .byte 5,'D'             ;
08895          .word LBB_DEEK          ; DEEK
08896          .byte 5,'S'             ;
08897          .word LBB_SADD          ; SADD
08898          .byte 4,'L'             ;
08899          .word LBB_LEN           ; LEN
08900          .byte 5,'S'             ;
08901          .word LBB_STRS          ; STR$
08902          .byte 4,'V'             ;
08903          .word LBB_VAL           ; VAL
08904          .byte 4,'A'             ;
08905          .word LBB_ASC           ; ASC
08906          .byte 7,'U'             ;
08907          .word LBB_UCASES        ; UCASE$
08908          .byte 7,'L'             ;
08909          .word LBB_LCASES        ; LCASE$
08910          .byte 5,'C'             ;
08911          .word LBB_CHRS          ; CHR$
08912          .byte 5,'H'             ;
08913          .word LBB_HEXS          ; HEX$
08914          .byte 5,'B'             ;
08915          .word LBB_BINS          ; BIN$
08916          .byte 7,'B'             ;
08917          .word LBB_BITTST        ; BITTST
08918          .byte 4,'M'             ;
08919          .word LBB_MAX           ; MAX
08920          .byte 4,'M'             ;
08921          .word LBB_MIN           ; MIN
08922          .byte 2,'P'             ;
08923          .word LBB_PI            ; PI
08924          .byte 5,'T'             ;
08925          .word LBB_TWOPI         ; TWOPI
08926          .byte 7,'V'             ;
08927          .word LBB_VPTR          ; VARPTR
08928          .byte 6,'L'             ;
08929          .word LBB_LEFTS         ; LEFT$
08930          .byte 7,'R'             ;
08931          .word LBB_RIGHTS        ; RIGHT$
08932          .byte 5,'M'             ;
08933          .word LBB_MIDS          ; MID$
08934          .byte 8,'I'
08935          .word LBB_I2C_OUT       ; I2C_OUT
08936          .byte 7,'I'
08937          .word LBB_I2C_IN        ; I2C_IN
08938          
08939    
08940    ; BASIC messages, mostly error messages
08941    
08942    LAB_BAER
08943          .word ERR_NF            ;$00 NEXT without FOR
08944          .word ERR_SN            ;$02 syntax
08945          .word ERR_RG            ;$04 RETURN without GOSUB
08946          .word ERR_OD            ;$06 out of data
08947          .word ERR_FC            ;$08 function call
08948          .word ERR_OV            ;$0A overflow
08949          .word ERR_OM            ;$0C out of memory
08950          .word ERR_US            ;$0E undefined statement
08951          .word ERR_BS            ;$10 array bounds
08952          .word ERR_DD            ;$12 double dimension array
08953          .word ERR_D0            ;$14 divide by 0
08954          .word ERR_ID            ;$16 illegal direct
08955          .word ERR_TM            ;$18 type mismatch
08956          .word ERR_LS            ;$1A long string
08957          .word ERR_ST            ;$1C string too complex
08958          .word ERR_CN            ;$1E continue error
08959          .word ERR_UF            ;$20 undefined function
08960          .word ERR_LD            ;$22 LOOP without DO
08961          .word ERR_BF            ;$24 Filename too long
08962    
08963    ; I may implement these two errors to force definition of variables and
08964    ; dimensioning of arrays before use.
08965    
08966    ;     .word ERR_UV            ;$26 undefined variable
08967    
08968    ; the above error has been tested and works (see code and comments below LAB_1D8B)
08969    
08970    ;     .word ERR_UA            ;$28 undimensioned array
08971    
08972    ERR_NF      .byte "NEXT without FOR",$00
08973    ERR_SN      .byte "Syntax",$00
08974    ERR_RG      .byte "RETURN without GOSUB",$00
08975    ERR_OD      .byte "Out of DATA",$00
08976    ERR_FC      .byte "Function call",$00
08977    ERR_OV      .byte "Overflow",$00
08978    ERR_OM      .byte "Out of memory",$00
08979    ERR_US      .byte "Undefined statement",$00
08980    ERR_BS      .byte "Array bounds",$00
08981    ERR_DD      .byte "Double dimension",$00
08982    ERR_D0      .byte "Divide by zero",$00
08983    ERR_ID      .byte "Illegal direct",$00
08984    ERR_TM      .byte "Type mismatch",$00
08985    ERR_LS      .byte "String too long",$00
08986    ERR_ST      .byte "String too complex",$00
08987    ERR_CN      .byte "Can't continue",$00
08988    ERR_UF      .byte "Undefined function",$00
08989    ERR_LD      .byte "LOOP without DO",$00
08990    ERR_BF      .byte "Filename too long",$00
08991    
08992    ;ERR_UV     .byte "Undefined variable",$00
08993    
08994    ; the above error has been tested and works (see code and comments below LAB_1D8B)
08995    
08996    ;ERR_UA     .byte "Undimensioned array",$00
08997    
08998    LAB_BMSG    .byte $0D,$0A,"Break",$00
08999    LAB_EMSG    .byte " Error",$00
09000    LAB_LMSG    .byte " in line ",$00
09001    LAB_RMSG    .byte $0D,$0A,"Ready",$0D,$0A,$00
09002    
09003    LAB_IMSG    .byte " Extra ignored",$0D,$0A,$00
09004    LAB_REDO    .byte " Redo from start",$0D,$0A,$00
09005    
09006    AA_end_basic
09007    AA_end_basic
09008    ; put the IRQ and MNI code in RAM so that it can be changed
09009    
09010    ; IRQ_vec	= VEC_SV+2              	; Previous IRQ code vector
09011      F9EC             IRQ_vec		= IRQH_ProcessIRQs		; IRQ code vector
09012      F9F6             NMI_vec		= IRQ_vec+$0A           	; NMI code vector
09013    
09014    
09015    ; OS System variables live here
09016    
09017      05E0             MON_sysvars_base  	= $5E0			; base address of the reserved base memory
09018      05E0             os_outsel		= MON_sysvars_base	; output selection variable
09019      05E1             os_infilt		= os_outsel+1		; Filter switches for character input filtering.
09020      05E2             os_insel		= os_infilt+1		; Input source for BASIC inputs.
09021      05E2             ToE_mon_vars_end	= os_insel
09022    
09023    
09024      00E7             TOE_MemptrLo  = $E7				; General purpose memory pointer low byte
09025      00E8             TOE_MemptrHi  = $E8				; General purpose memory pointer high byte
09026    
09027    
09028    ; OS Bit Definitions
09029    
09030      0001             ACIA1_out_sw	= @00000001
09031      0002             ANSI_out_sw	= @00000010
09032      0004             TPB_out_sw	= @00000100
09033      0008             ACIA2_out_sw	= @00001000
09034      0010             TAPE_out_sw	= @00010000
09035      0001             OS_input_ACIA1  = @00000001
09036      0008             OS_input_ACIA2  = @00001000
09037      0010             OS_input_TAPE   = @00010000
09038    
09039    
09040    ; OS Constants
09041    
09042      3000             MON_CR_Delay_C  = $3000
09043    
09044    
09045    ; now the code. This sets up the vectors, interrupt code,
09046    ; and waits for the user to select [C]old or [W]arm start.
09047    ;
09048    ; Also, during the running phase, the extra OS features are hosted here.
09049    
09050      .ROM_AREA $C100,$FFFF
09051      
09052    EC00                 *= $EC00                              ; Give ourselves room for the OS. Formerly F000
09053      .INCLUDE "ACIA.asm"
09054    ; Jennifer's 6551 ACIA Library
09055    ;
09056    
09057    ; This is the configuration section for the ACIA.
09058    ;
09059    ; Make changes to setup here.
09060    ;
09061      001E             ACIA_CTRL_IDLE   = ACIA_WL8 | ACIA_RCS_BRG | ACIA_9600 | ACIA_TIC_10
09062      001E             ACIA_CTRL_LISTEN = ACIA_WL8 | ACIA_RCS_BRG | ACIA_9600 | ACIA_TIC_00 
09063      008B             ACIA_CMD_SETUP   = ACIA_PMC_DIS | ACIA_PME_DIS | ACIA_REM_OFF | ACIA_TIC_10 | ACIA_INT_DIS | ACIA_DTR_RDY
09064    
09065    ; ACIA1 Registers
09066    
09067      C010             ACIA1_base     = $C010                 ; Change as needed later.
09068      C010             ACIA1_tx       = ACIA1_base
09069      C010             ACIA1_rx       = ACIA1_base
09070      C011             ACIA1_sts      = ACIA1_base + 1
09071      C012             ACIA1_cmd      = ACIA1_base + 2
09072      C013             ACIA1_ctrl     = ACIA1_base + 3
09073    
09074    
09075    ; ACIA2 Registers
09076    
09077      C014             ACIA2_base     = $C014                 ; Change as needed later.
09078      C014             ACIA2_tx       = ACIA2_base
09079      C014             ACIA2_rx       = ACIA2_base
09080      C015             ACIA2_sts      = ACIA2_base + 1
09081      C016             ACIA2_cmd      = ACIA2_base + 2
09082      C017             ACIA2_ctrl     = ACIA2_base + 3
09083    
09084    
09085    
09086    ; ACIA Speeds
09087    
09088      0000             ACIA_16x            = @0000
09089      0001             ACIA_50             = @0001
09090      0002             ACIA_75             = @0010
09091      0003             ACIA_109p92         = @0011
09092      0004             ACIA_134p51         = @0100
09093      0005             ACIA_150            = @0101
09094      0006             ACIA_300            = @0110
09095      0007             ACIA_600            = @0111
09096      0008             ACIA_1200           = @1000
09097      0009             ACIA_1800           = @1001
09098      000A             ACIA_2400           = @1010
09099      000B             ACIA_3600           = @1011
09100      000C             ACIA_4800           = @1100
09101      000D             ACIA_7200           = @1101
09102      000E             ACIA_9600           = @1110
09103      000F             ACIA_19200          = @1111
09104    
09105    
09106    ; ACIA Word lengths
09107    
09108      0000             ACIA_WL8            = @00000000
09109      0020             ACIA_WL7            = @00100000
09110      0040             ACIA_WL6            = @01000000
09111      0060             ACIA_WL5            = @01100000
09112    
09113    
09114    ; ACIA Command bits
09115    
09116      0000             ACIA_PMC_ODD        = @00000000        ; Parity Mode Control bits
09117      0040             ACIA_PMC_EVN        = @01000000
09118      0080             ACIA_PMC_DIS        = @10000000
09119    
09120      0000             ACIA_PME_DIS        = @00000000        ; Parity Mode Enable bit
09121      0020             ACIA_PME_ENA        = @00100000
09122    
09123      0000             ACIA_REM_OFF        = @00000000        ; Receiver Echo Mode bit
09124      0010             ACIA_REM_ON         = @00010000
09125    
09126      0000             ACIA_TIC_00         = @00000000        ; RTSB High, Transmit Int disabled
09127      0004             ACIA_TIC_01         = @00000100        ; RTSB Low, Transmit Int enabled
09128      0008             ACIA_TIC_10         = @00001000        ; RTSB Low, Transmit Int disabled
09129      000C             ACIA_TIC_11         = @00001100        ; RTSB Low, Transmit Int disabled & Transmit break on TxD
09130      0002             ACIA_INT_DIS        = @00000010
09131      0000             ACIA_INT_ENA        = @00000000
09132      0000             ACIA_DTR_NRDY       = @00000000
09133      0001             ACIA_DTR_RDY        = @00000001
09134    
09135    
09136    ; ACIA Clock Source
09137    
09138      0000             ACIA_RCS_EXT	    = @00000000
09139      0010             ACIA_RCS_BRG	    = @00010000
09140    
09141    
09142    ; Status Flags
09143    
09144      0001             ACIA_PER	    = @00000001
09145      0002             ACIA_FER	    = @00000010
09146      0004             ACIA_OVR	    = @00000100
09147      0008             ACIA_RBF	    = @00001000
09148      0010             ACIA_TXE	    = @00010000
09149      0020             ACIA_DCD	    = @00100000
09150      0040             ACIA_DSR	    = @01000000
09151      0080             ACIA_INT	    = @10000000
09152    
09153    
09154    ; Filter Switch
09155    
09156      0001             LF_filt_sw1	    = @00000001
09157      0002             LF_filt_sw2	    = @00000010
09158    
09159    ; Baud rate registers
09160      05E3             ACIA_vars_base  = ToE_mon_vars_end + 1
09161      05E3             ACIA1_cfg_cmd   = ACIA_vars_base
09162      05E4             ACIA1_cfg_ctrl  = ACIA1_cfg_cmd   + 1
09163      05E5             ACIA2_cfg_cmd   = ACIA1_cfg_ctrl  + 1
09164      05E6             ACIA2_cfg_ctrl  = ACIA2_cfg_cmd   + 1
09165      05E6             ACIA_vars_end   = ACIA2_cfg_ctrl
09166    
09167    
09168    
09169    ; Tower of Eightness Specific serial routines.
09170    
09171    INI_ACIA_SYS
09172    EC00  A9 1E          LDA #ACIA_CTRL_LISTEN
09173    EC02  8D E4 05       STA ACIA1_cfg_ctrl
09174    EC05  8D E6 05       STA ACIA2_cfg_ctrl
09175    EC08  A9 8B          LDA #ACIA_CMD_SETUP
09176    EC0A  8D E3 05       STA ACIA1_cfg_cmd
09177    EC0D  8D E5 05       STA ACIA2_cfg_cmd
09178    EC10  20 17 EC       JSR INI_ACIA1
09179    EC13  20 26 EC       JSR INI_ACIA2
09180    EC16  60             RTS
09181    
09182    	
09183    INI_ACIA1                               ; As required for a 6551 ACIA
09184    EC17  AD E3 05       LDA ACIA1_cfg_cmd
09185    EC1A  8D 12 C0       STA ACIA1_cmd                         ; Set the command reg for specified baud rate
09186    EC1D  AD E4 05       LDA ACIA1_cfg_ctrl
09187    EC20  8D 13 C0       STA ACIA1_ctrl                        ; Set the control reg for correct operation
09188    EC23  20 54 EC       JSR ACIA1in                           ; Swallow the first byte (experimental fix) 
09189      
09190      
09191    INI_ACIA2                               ; As required for a 6551 ACIA
09192    EC26  AD E5 05       LDA ACIA2_cfg_cmd
09193    EC29  8D 16 C0       STA ACIA2_cmd                         ; Set the command reg for specified baud rate
09194    EC2C  AD E6 05       LDA ACIA2_cfg_ctrl
09195    EC2F  8D 17 C0       STA ACIA2_ctrl                        ; Set the control reg for correct operation
09196    EC32  20 69 EC       JSR ACIA2in                           ; Swallow the first byte (experimental fix)
09197    EC35  60             RTS
09198    
09199    
09200    ; byte out to 6551 ACIA1
09201    
09202    ACIA1out
09203    EC36  08             PHP                                   ; Save registers as we aren't allowed to change them
09204    EC37  48             PHA
09205    	
09206    EC38  8D 10 C0       STA ACIA1_tx                          ; write to ACIA TX buffer
09207    EC3B  A9 10          LDA #ACIA_TXE
09208    
09209    ACIA1_wr_wait
09210    EC3D  2C 11 C0       BIT ACIA1_sts
09211    EC40  F0 FB          BEQ ACIA1_wr_wait                     ; Wait until written.
09212    	
09213    EC42  68             PLA                                   ; Restore registers. We're all good.
09214    EC43  28             PLP
09215    	
09216    EC44  60             RTS                                   ; Done... Hopefully.
09217      
09218      
09219      
09220    ; byte out to 6551 ACIA2
09221    
09222    ACIA2out
09223    EC45  08             PHP                                   ; Save registers as we aren't allowed to change them
09224    EC46  48             PHA
09225    	
09226    EC47  8D 14 C0       STA ACIA2_tx                          ; write to ACIA TX buffer
09227    EC4A  A9 10          LDA #ACIA_TXE
09228    
09229    ACIA2_wr_wait
09230    EC4C  2C 15 C0       BIT ACIA2_sts
09231    EC4F  F0 FB          BEQ ACIA2_wr_wait                     ; Wait until written.
09232    	
09233    EC51  68             PLA                                   ; Restore registers. We're all good.
09234    EC52  28             PLP
09235    	
09236    EC53  60             RTS                                   ; Done... Hopefully.
09237    
09238    
09239    ; byte in from 6551 ACIA 1
09240    
09241    ACIA1in
09242    EC54  A9 08          LDA #ACIA_RBF
09243    EC56  2C 11 C0       BIT ACIA1_sts				; do we have a byte?
09244    EC59  F0 2A          BEQ LAB_nobyw				; branch if no byte waiting
09245    
09246    EC5B  AD 10 C0       LDA ACIA1_rx				; Get byte sent.
09247    EC5E  38             SEC					; flag byte received
09248      
09249    EC5F  48             PHA
09250    EC60  A9 01          LDA #LF_filt_sw1
09251    EC62  2C E1 05       BIT os_infilt
09252    EC65  F0 17          BEQ filter_inp
09253    EC67  68             PLA
09254    EC68  60             RTS
09255    
09256    
09257    ; byte in from 6551 ACIA 2
09258      
09259    ACIA2in
09260    EC69  A9 08          LDA #ACIA_RBF
09261    EC6B  2C 15 C0       BIT ACIA2_sts				; do we have a byte?
09262    EC6E  F0 15          BEQ LAB_nobyw				; branch if no byte waiting
09263    
09264    EC70  AD 14 C0       LDA ACIA2_rx				; Get byte sent.
09265    EC73  38             SEC					; flag byte received
09266      
09267    EC74  48             PHA
09268    EC75  A9 02          LDA #LF_filt_sw2
09269    EC77  2C E1 05       BIT os_infilt
09270    EC7A  F0 02          BEQ filter_inp
09271    EC7C  68             PLA
09272    EC7D  60             RTS
09273    
09274    ; Byte filter feature.  Applicable to both ACIAs.
09275    
09276    
09277    filter_inp  
09278    EC7E  68             PLA
09279    EC7F  C9 0A          CMP #$A
09280    EC81  F0 02          BEQ LAB_nobyw
09281    EC83  38             SEC
09282    EC84  60             RTS
09283      
09284    LAB_nobyw
09285    EC85  A9 00          LDA #0
09286    EC87  18             CLC
09287    EC88  60             RTS                             ; flag no byte received
09288      RTS                             ; flag no byte received
09289      .INCLUDE "ANSICARD.asm"
09290    ; Duncan's ANSI Video card library
09291    ;
09292    ; This card is based on a 6522 VIA chip.
09293    
09294    
09295    ; Register addresses
09296    
09297      C000             ANSI_base	= $C000
09298      C000             ANSI_reg_b	= ANSI_base
09299      C001             ANSI_reg_a	= ANSI_base+1
09300      C002             ANSI_ddr_b	= ANSI_base+2
09301      C003             ANSI_ddr_a	= ANSI_base+3
09302    
09303    ; Control Bits
09304    
09305      0040             ANSI_AVAIL	= @01000000
09306      0080             ANSI_ACK	= @10000000
09307    
09308    
09309    ; Memory allocations
09310    
09311      05F0             ANSI_area	= $5F0
09312      05F0             ANSI_LastACK	= ANSI_area
09313      05F1             ANSI_LastAVL	= ANSI_area+1
09314    
09315    
09316    ; Initialisation Routine
09317    
09318    ANSI_INIT
09319    EC89  A9 0C          LDA #12
09320    EC8B  8D 00 C0       STA ANSI_reg_b
09321    EC8E  A9 40          LDA #ANSI_AVAIL
09322    EC90  8D 03 C0       STA ANSI_ddr_a
09323    EC93  A9 FF          LDA #$FF
09324    EC95  8D 02 C0       STA ANSI_ddr_b
09325    EC98  AD 01 C0       LDA ANSI_reg_a
09326    EC9B  25 80          AND ANSI_ACK
09327    EC9D  8D F0 05       STA ANSI_LastACK
09328    ECA0  0A             ASL
09329    ECA1  8D F1 05       STA ANSI_LastAVL
09330    ECA4  0D F0 05       ORA ANSI_LastACK
09331    ECA7  8D 01 C0       STA ANSI_reg_a
09332    ECAA  60             RTS
09333      
09334    
09335    ; ANSI Write.
09336    ; *================================*
09337    ; *                                *
09338    ; *  ENTRY: A=char                 *
09339    ; *  EXIT: As found                *
09340    ; *                                *
09341    ; **********************************
09342    
09343    ANSI_write
09344    
09345    ECAB  08             PHP			; Save Register States
09346    ECAC  48             PHA
09347      
09348    ECAD  20 C1 EC       JSR ANSI_wait		; Wait until AVAIL and ACK agree
09349      
09350    ECB0  8D 00 C0       STA ANSI_reg_b	; Write the char to output
09351    ECB3  AD F1 05       LDA ANSI_LastAVL	; Flip and re-write avail bit to tell
09352    ECB6  49 40          EOR #ANSI_AVAIL	; the ANSI processor of new data
09353    ECB8  8D 01 C0       STA ANSI_reg_a
09354    ECBB  8D F1 05       STA ANSI_LastAVL
09355      
09356    ECBE  68             PLA
09357    ECBF  28             PLP
09358    ECC0  60             RTS
09359      
09360    ANSI_wait
09361    ECC1  48             PHA
09362      
09363    ANSI_w_loop
09364    ECC2  AD 01 C0       LDA ANSI_reg_a	; Check ACK against AVAIL
09365    ECC5  29 80          AND #ANSI_ACK
09366    ECC7  4A             LSR
09367    ECC8  CD F1 05       CMP ANSI_LastAVL
09368    ECCB  D0 F5          BNE ANSI_w_loop	; Until they match
09369      
09370    ECCD  68             PLA
09371    ECCE  60             RTS
09372     
09373    
09374    
09375      .INCLUDE "TPBCARD.asm"
09376    ; Duncan's TPB Card driver
09377    ;
09378    ; This card is based on a 6522 VIA chip.
09379    
09380    
09381    ; Register addresses
09382    
09383      C020             TPB_base        = $C020
09384      C020             TPB_reg_b       = TPB_base
09385      C021             TPB_reg_a       = TPB_base+1
09386      C022             TPB_ddr_b       = TPB_base+2
09387      C023             TPB_ddr_a       = TPB_base+3
09388      C02C             TPB_pcr         = TPB_base+$C
09389      C02D             TPB_ifr         = TPB_base+$D
09390    
09391    
09392    ; LPT Control Bits
09393    
09394      0002             TPB_LPT_stb_b   = @00000010
09395      0001             TPB_LPT_ack_b   = @00000001
09396      0002             TPB_ACK_CA1_b   = @00000010
09397      0001             TPB_CA1_pe_b    = @00000001
09398    
09399    
09400    ; TPB Bus Control Bits
09401    
09402      0010             TPB_BUS_clkout  = @00010000       ; Clock line output (Port B, out)
09403      0040             TPB_BUS_clkin   = @01000000       ; Clock line readback (Port B, in)
09404      0020             TPB_BUS_datout  = @00100000       ; Data line output (Port B, out)
09405      0080             TPB_BUS_datin   = @10000000       ; Data line readback (Port B, in)
09406      0008             TPB_BUS_select  = @00001000       ; TPB bus select (Port B, out) signals bus selection.
09407      0004             TPB_BUS_atnin   = @00000100       ; ATN signal readback (Port B, in) indicates a peripheral needs attention or select signal
09408      0001             TPB_BUS_atnout  = @00000001       ; ATN signal output.  When used, tells a device that the data is a select signal.
09409    
09410    
09411    ; TPB Configuration parameters
09412    
09413      00FF             TPB_BUS_lim_c   = 255             ; Number of samples before giving up on device
09414      000F             TPB_BUS_dev_max = 15              ; Highest device address permitted, host being 0.
09415    
09416    ; *****************************************************************************
09417    ; *                           TABLE 1: BLOCK TYPES                            *
09418    ; *                           --------------------                            *
09419    ; * 1.  Command Block (Always the same size 4 bytes at current).              *
09420    ; * 2.  Response Block (Same size as the command block).                      *
09421    ; * 3.  Data Block.  Upto 65535 bytes. It is not reccomended to go that big,  *
09422    ; *     you would touch registers that way!                                   *
09423    ; * 4.  Broadcast Block (4 bytes long).                                       *
09424    ; *                                                                           *
09425    ; *****************************************************************************
09426    
09427      0001             TPB_BLK_cmd        = 1
09428      0002             TPB_BLK_rsp        = 2
09429      0003             TPB_BLK_dat        = 3
09430      0004             TPB_BLK_brd        = 4
09431    
09432    
09433    ; *****************************************************************************
09434    ; *                                                                           *
09435    ; *                          TABLE 2: DEVICE TYPES                            *
09436    ; *                          ---------------------                            *
09437    ; * 1.  DEVType_BlkStorage.  Block storage device.                            *
09438    ; * 2.  DEVType_IOStream.    Input/Output Stream device.                      *
09439    ; * 15. DEVType_User.        User defined device.  Must use own code.         *
09440    ; *                                                                           *
09441    ; *                                                                           *
09442    ; *                                                                           *
09443    ; *                                                                           *
09444    ; *****************************************************************************
09445    
09446      0001             DEVType_blkstorage = 1
09447      0002             DEVType_IOstream   = 2
09448      000F             DEVType_User       = 15
09449    
09450    
09451    ; Memory allocations
09452    
09453      05F2             TPB_worksp         = $5F2                 ; Start of TPB card memory allocation
09454      05F2             TPB_curr_dev       = TPB_worksp           ; Currently selected TPB devce ID
09455      05F3             TPB_dev_type       = TPB_worksp+1         ; Device class of selected device
09456      05F4             TPB_last_rd        = TPB_worksp+2         ; last byte read from TPB device
09457      05F5             TPB_BUS_status     = TPB_worksp+3         ; Status word from TPB engine (subject to change)
09458      05F6             TPB_BUS_tries      = TPB_worksp+4         ; Bus device counter.  This ensures fewer hangs.
09459      05F7             TPB_BUS_lim        = TPB_worksp+5         ; Bus countdown timer limit. (Reload value).
09460      05F8             TPB_BUS_blk_lenlo  = TPB_worksp+6         ; Length of block in or out
09461      05F9             TPB_BUS_blk_lenhi  = TPB_worksp+7         ; Length of block in or out
09462      05F8             TPB_BUS_blk_len    = TPB_BUS_blk_lenlo    ; Convenience pointer to TPB_BUS_blk_lenlo
09463      05FA             TPB_BUS_blk_stlo   = TPB_worksp+8         ; Start address low byte of block
09464      05FB             TPB_BUS_blk_sthi   = TPB_worksp+9         ; Start address high byte of block
09465      05FA             TPB_BUS_blk_st     = TPB_BUS_blk_stlo     ; Convenience pointer to TPB_BUS_BLK_stlo
09466      05FC             TPB_BUS_blk_type   = TPB_worksp+$A        ; Type of block transfer. See table 1
09467      00E2             TPB_Temp1          = $E2                  ; Temporary memory location 1
09468      00E3             TPB_Temp2          = $E3                  ; Temporary memory location 2
09469      00E4             TPB_Temp3          = $E4                  ; Temporary memory location 3
09470    
09471    ; 3 spaces remain between the system variables and the buffer block.
09472    ; This means we end up with $5FD to $5FF unused.
09473    
09474    ; Last TPB workspace allocation @ $5FC before buffers.
09475    
09476    
09477    ; TPB Command Codes
09478    
09479      0000             PRESENCE           = 0                  ; Check for device presence by ID   <DONE>
09480      0001             ATN_CHK            = 1                  ; Check if device is asserting ATN   <DONE>
09481      0002             REQ_DEV_TYPE       = 2                  ; Request device type-code.
09482      0003             CTRL_BLK_WR        = 3                  ; Write to control block
09483      0004             CTRL_BLK_RD        = 4                  ; Read from control block
09484      0005             BUFF_BLK_WR        = 5                  ; Write to device buffer
09485      0006             BUFF_BLK_RD        = 6                  ; Read from device buffer
09486      0007             BUFF_PROCESS       = 7                  ; Process buffer contents
09487      0008             STREAM_OUT         = 8                  ; Stream out (each char requires an ACK or NACK after)
09488      0009             STREAM_IN          = 9                  ; Stream in (for each char in, you must send an ACK or NACK)
09489    
09490    
09491    ; ACK and NACK codes
09492    
09493      00F1             TPB_ACK            = $F1                ; Acknowledge code (Continuance signal)
09494      00F5             TPB_NACK           = $F5                ; Not Acknoledge code. (Terminator)
09495    
09496    
09497      0600             TPB_BUS_RAMBASE    = $600
09498      0600             TPB_Dev_table      = TPB_BUS_RAMBASE                     ; Start of the TPB bus device table.
09499      0610             TPB_BUS_IO_buff    = TPB_Dev_table + TPB_BUS_dev_max + 1 ; Page of buffer for TPB transfers
09500      0700             TPB_BUFFER         = $700                                ; Block transfers go here. Max 1 page.
09501    
09502    
09503    ; Control Block Structure and Location.
09504    
09505      0610             TPB_ctrl_blk       = TPB_BUS_IO_buff
09506      0610             DEV_ID             = TPB_ctrl_blk
09507      0611             DEV_BLK_TYPE       = TPB_ctrl_blk + 1
09508      0612             DEV_CMD_RSP        = TPB_ctrl_blk + 2
09509      0613             CHECKSUM           = TPB_ctrl_blk + 3
09510    
09511    ; Initialisation Routine
09512    
09513      0002             TPB_PbInitial   = TPB_LPT_stb_b
09514      003B             TPB_PbOutputs   = TPB_LPT_stb_b | TPB_BUS_clkout | TPB_BUS_datout | TPB_BUS_atnout | TPB_BUS_select
09515    
09516    
09517    TPB_INIT
09518    ;  This first part initialises the on-card 6522 VIA pins for both features.
09519    
09520    ECCF  A9 00          LDA #0                          ; Set our registers to defaults
09521    ECD1  8D 21 C0       STA TPB_reg_a
09522    ECD4  A9 02          LDA #TPB_PbInitial
09523    ECD6  8D 20 C0       STA TPB_reg_b
09524      
09525    ECD9  A9 FF          LDA #$FF
09526    ECDB  8D 23 C0       STA TPB_ddr_a                   ; Setup port a as outputs to our LPT
09527    ECDE  A9 3B          LDA #TPB_PbOutputs
09528    ECE0  8D 22 C0       STA TPB_ddr_b                   ; Setup port B for both LPT and TPB initial state.
09529    ECE3  A9 01          LDA #TPB_CA1_pe_b               ; Configure for positive edge interrupt trigger.
09530    ECE5  8D 2C C0       STA TPB_pcr                     ; on CA1
09531      
09532      ;  This second part initialises the Tower Peripheral Bus engine.
09533      
09534    ECE8  A9 00          LDA #0
09535    ECEA  8D F5 05       STA TPB_BUS_status              ; Set the bus to listening.
09536    
09537    ECED  A9 FF          LDA #TPB_BUS_lim_c
09538    ECEF  8D F7 05       STA TPB_BUS_lim                 ; Set the bus response tries limit (variable for latency)
09539    ECF2  60             RTS
09540    
09541    
09542    ; TPB Write to remote device control block
09543    ; *******************************************************
09544    ; *                                                     *
09545    ; *  ENTRY:                                             *
09546    ; *  EXIT:                                              *
09547    ; *         Affects, A,X,Y,P.                           *
09548    ; *         C = 0: Fail                                 *
09549    ; *         C = 1: Success.                             *
09550    ; *                                                     *
09551    ; *******************************************************
09552    
09553    TPB_Ctrl_Blk_Wr
09554    ECF3  AD F2 05       LDA TPB_curr_dev                ; Setup Command Block
09555    ECF6  8D 10 06       STA DEV_ID
09556    ECF9  A9 01          LDA #TPB_BLK_cmd
09557    ECFB  8D 11 06       STA DEV_BLK_TYPE
09558    ECFE  A9 03          LDA #CTRL_BLK_WR
09559    ED00  8D 12 06       STA DEV_CMD_RSP
09560    ED03  20 49 EE       JSR TPB_calc_ctrl_csum
09561    
09562    ED06  20 B8 ED       JSR TPB_Tx_CMD                  ; Issue write to remote control block command.
09563        
09564    ED09  20 D0 ED       JSR TPB_WaitATN                 ; Wait for Attention signal
09565    ED0C  90 19          BCC CBW_Fail                    ; If no device then quit with carry clear.
09566      
09567    ED0E  A9 00          LDA #<TPB_BUFFER                ; Setup for device control block transmit.
09568    ED10  8D FA 05       STA TPB_BUS_blk_stlo
09569    ED13  A9 07          LDA #>TPB_BUFFER
09570    ED15  8D FB 05       STA TPB_BUS_blk_sthi
09571    ED18  A9 10          LDA #16                         ; Control blocks are 16 bytes in length
09572    ED1A  8D F8 05       STA TPB_BUS_blk_lenlo           ; at present.  I may change this...
09573    ED1D  A9 00          LDA #0
09574    ED1F  8D F9 05       STA TPB_BUS_blk_lenhi
09575      
09576    ED22  20 F4 EE       JSR TPB_tx_block                ; Transmit the control block.
09577      
09578    ED25  38             SEC                             ; Exit signalling success.
09579    ED26  60             RTS
09580      
09581    CBW_Fail  
09582    ED27  18             CLC                             ; Exit signalling fail.
09583    ED28  60             RTS
09584      
09585      
09586      ; TPB Read from remote device control block
09587    ; *******************************************************
09588    ; *                                                     *
09589    ; *  ENTRY:                                             *
09590    ; *  EXIT:                                              *
09591    ; *         Affects, A,X,Y,P.                           *
09592    ; *         C = 0: Fail                                 *
09593    ; *         C = 1: Success.                             *
09594    ; *                                                     *
09595    ; *******************************************************
09596    
09597    TPB_Ctrl_Blk_Rd
09598    ED29  AD F2 05       LDA TPB_curr_dev                ; Setup Command Block
09599    ED2C  8D 10 06       STA DEV_ID
09600    ED2F  A9 01          LDA #TPB_BLK_cmd
09601    ED31  8D 11 06       STA DEV_BLK_TYPE
09602    ED34  A9 04          LDA #CTRL_BLK_RD
09603    ED36  8D 12 06       STA DEV_CMD_RSP
09604    ED39  20 49 EE       JSR TPB_calc_ctrl_csum
09605    
09606    ED3C  20 B8 ED       JSR TPB_Tx_CMD                  ; Issue write to remote control block command.
09607     
09608    ED3F  20 D0 ED       JSR TPB_WaitATN                 ; Wait for Attention signal
09609    ED42  90 1A          BCC CBR_Fail                    ; If no device then quit with carry clear.
09610      
09611    ED44  A9 00          LDA #<TPB_BUFFER                ; Setup for device control block receive.
09612    ED46  8D FA 05       STA TPB_BUS_blk_stlo
09613    ED49  A9 07          LDA #>TPB_BUFFER
09614    ED4B  8D FB 05       STA TPB_BUS_blk_sthi
09615    ED4E  A9 10          LDA #16                         ; Control blocks are 16 bytes in length
09616    ED50  8D F8 05       STA TPB_BUS_blk_lenlo           ; at present.  I may change this...
09617    ED53  A9 00          LDA #0
09618    ED55  8D F9 05       STA TPB_BUS_blk_lenhi
09619      
09620    ED58  20 38 EF       JSR TPB_rx_block                ; Receive the control block.
09621    ED5B  90 01          BCC CBR_Fail
09622        
09623    ED5D  60             RTS                             ; Exit successfully.
09624      
09625    CBR_Fail  
09626    ED5E  18             CLC                             ; Exit signalling fail.
09627    ED5F  60             RTS
09628      
09629      
09630      
09631    
09632    ; TPB Request device type code
09633    ; *******************************************************
09634    ; *                                                     *
09635    ; *  ENTRY: A=Device ID                                 *
09636    ; *  EXIT:  A=Device Type                               *
09637    ; *         Affects, A,X,Y,P.                           *
09638    ; *         C = 0: Fail                                 *
09639    ; *         C = 1: Success.                             *
09640    ; *                                                     *
09641    ; *******************************************************
09642      
09643    TPB_Req_Dev_Type
09644    ED60  8D 10 06       STA DEV_ID                      ; Setup Command Block
09645    ED63  A9 01          LDA #TPB_BLK_cmd
09646    ED65  8D 11 06       STA DEV_BLK_TYPE
09647    ED68  A9 02          LDA #REQ_DEV_TYPE
09648    ED6A  8D 12 06       STA DEV_CMD_RSP
09649    ED6D  20 49 EE       JSR TPB_calc_ctrl_csum
09650      
09651    ED70  20 B8 ED       JSR TPB_Tx_CMD                  ; Issue Req_Dev_Type command
09652        
09653    ED73  20 D0 ED       JSR TPB_WaitATN                 ; Wait for Attention signal
09654    ED76  90 34          BCC DevType_Fail                ; If no device then quit with carry clear.
09655    
09656    ED78  A9 10          LDA #<TPB_ctrl_blk              ; Setup for device reply to the control block
09657    ED7A  8D FA 05       STA TPB_BUS_blk_stlo
09658    ED7D  A9 06          LDA #>TPB_ctrl_blk
09659    ED7F  8D FB 05       STA TPB_BUS_blk_sthi
09660    ED82  A9 04          LDA #4
09661    ED84  8D F8 05       STA TPB_BUS_blk_lenlo
09662    ED87  A9 00          LDA #0
09663    ED89  8D F9 05       STA TPB_BUS_blk_lenhi
09664      
09665    ED8C  20 38 EF       JSR TPB_rx_block                ; Get our reply block.
09666    ED8F  90 1B          BCC DevType_Fail                ; Error if TPB_rx_block fails.
09667      
09668    ED91  18             CLC                            ; Calculate Checksum
09669    ED92  AD 10 06       LDA DEV_ID
09670    ED95  6D 11 06       ADC DEV_BLK_TYPE
09671    ED98  6D 12 06       ADC DEV_CMD_RSP
09672      
09673    ED9B  CD 13 06       CMP CHECKSUM                   ; Compare with received checksum
09674    ED9E  D0 0C          BNE DevType_Fail               ; Signal appropriately with the carry bit.
09675      
09676    EDA0  AD 11 06       LDA DEV_BLK_TYPE               ; Check for the appropriate response.
09677    EDA3  C9 02          CMP #TPB_BLK_rsp
09678    EDA5  D0 05          BNE DevType_Fail               ; ...and fail if incorrect.
09679      
09680    EDA7  AD 12 06       LDA DEV_CMD_RSP                ; Reply with device type.
09681      
09682    EDAA  38             SEC
09683    EDAB  60             RTS
09684    
09685    DevType_Fail
09686    EDAC  18             CLC                            ; General failiure exit point.
09687    EDAD  60             RTS
09688      
09689      
09690    ; TPB Check ATN state.
09691    ; *******************************************************
09692    ; *                                                     *
09693    ; *  ENTRY:                                             *
09694    ; *  EXIT: A, P, carry is set when asserted, otherwise  *
09695    ; *           cleared.                                  *
09696    ; *                                                     *
09697    ; *******************************************************
09698    
09699    
09700    TPB_Check_ATN
09701    EDAE  AD 20 C0       LDA TPB_reg_b                   ; Check if ATN is asserted
09702    EDB1  29 04          AND #TPB_BUS_atnin
09703    EDB3  38             SEC
09704    EDB4  F0 01          BEQ ATN_asserted                ; Skip clearing C if ATN is asserted.
09705    EDB6  18             CLC                             ; Carry is cleared as ATN isn't asserted.
09706    ATN_asserted
09707    EDB7  60             RTS 
09708                       
09709    
09710    ; TPB Transmit Command
09711    ; ****************************************************
09712    ; *                                                  *
09713    ; *  ENTRY:                                          *
09714    ; *  EXIT:  A, X, Y, P affected                      *
09715    ; *                                                  *
09716    ; ****************************************************
09717    
09718    
09719    TPB_Tx_CMD
09720    EDB8  A9 10          LDA #<DEV_ID                   ; Setup pointers and transmit control block.
09721    EDBA  8D FA 05       STA TPB_BUS_blk_stlo
09722    EDBD  A9 06          LDA #>DEV_ID
09723    EDBF  8D FB 05       STA TPB_BUS_blk_sthi
09724    EDC2  A9 04          LDA #4
09725    EDC4  8D F8 05       STA TPB_BUS_blk_lenlo
09726    EDC7  A9 00          LDA #0
09727    EDC9  8D F9 05       STA TPB_BUS_blk_lenhi
09728      
09729    EDCC  20 F4 EE       JSR TPB_tx_block
09730      
09731    EDCF  60             RTS
09732    
09733    
09734    ; TPB Attention Signal handler with wait.
09735    ; ****************************************************
09736    ; *                                                  *
09737    ; *  ENTRY:                                          *
09738    ; *  EXIT:  A,X,P                                    *
09739    ; *         C=0 ATN line not asserted or timeout.    *
09740    ; *         C=1 ATN line asserted                    *
09741    ; *                                                  *
09742    ; ****************************************************
09743    
09744    TPB_WaitATN
09745    EDD0  A2 FF          LDX #TPB_BUS_lim_c                ; Set number of tries
09746      
09747    TPB_WaitATN_try
09748    EDD2  20 BF EF       JSR TPB_delay                     ; Wait and check
09749    EDD5  20 AE ED       JSR TPB_Check_ATN
09750    EDD8  B0 04          BCS FinWaitATN
09751    EDDA  CA             DEX                               ; Reduce counter and try again
09752    EDDB  D0 F5          BNE TPB_WaitATN_try
09753    EDDD  18             CLC  
09754    FinWaitATN
09755    EDDE  60             RTS
09756    
09757    
09758    ; TPB DEVICE_PRESENCE handler (Currently broken)
09759    ; ****************************************************
09760    ; *                                                  *
09761    ; *  ENTRY: A=ID                                     *
09762    ; *  EXIT:  TPB_BUS_IO_buff = reply block            *
09763    ; *         C=0 (No device or block fail),           *
09764    ; *         C=1 Success.                             *
09765    ; *                                                  *
09766    ; ****************************************************
09767    
09768    
09769    ; Setup Command Block 
09770    
09771    TPB_Dev_Presence
09772      ; Command Setup
09773    EDDF  8D 10 06       STA DEV_ID                     ; Store device ID
09774    EDE2  A9 01          LDA #TPB_BLK_cmd
09775    EDE4  8D 11 06       STA DEV_BLK_TYPE
09776    EDE7  A9 00          LDA #PRESENCE                  ; Command: PRESENCE check.
09777    EDE9  8D 12 06       STA DEV_CMD_RSP  
09778    EDEC  20 49 EE       JSR TPB_calc_ctrl_csum         ; Calculate checksum
09779      ; Command Issue
09780    EDEF  20 B8 ED       JSR TPB_Tx_CMD                 ; Transmit Command
09781      ; Process Outcome
09782    EDF2  20 D0 ED       JSR TPB_WaitATN                ; Wait for Attention signal
09783    EDF5  90 2A          BCC PRESENCE_NoRESP            ; If no device then skip RESP fetch
09784    
09785    EDF7  A9 10          LDA #<DEV_ID                   ; Setup pointers for RESP block.
09786    EDF9  8D FA 05       STA TPB_BUS_blk_stlo
09787    EDFC  A9 06          LDA #>DEV_ID
09788    EDFE  8D FB 05       STA TPB_BUS_blk_sthi
09789    EE01  A9 04          LDA #4
09790    EE03  8D F8 05       STA TPB_BUS_blk_lenlo
09791    EE06  A9 00          LDA #0
09792    EE08  8D F9 05       STA TPB_BUS_blk_lenhi
09793      
09794    EE0B  20 38 EF       JSR TPB_rx_block               ; Get RESPonse block
09795      
09796    EE0E  90 11          BCC PRESENCE_NoRESP            ; If failed or no response fall through.
09797      
09798    EE10  18             CLC                            ; Calculate Checksum
09799    EE11  AD 10 06       LDA DEV_ID
09800    EE14  6D 11 06       ADC DEV_BLK_TYPE
09801    EE17  6D 12 06       ADC DEV_CMD_RSP
09802      
09803    EE1A  CD 13 06       CMP CHECKSUM                   ; Compare with received checksum
09804    EE1D  D0 02          BNE PRESENCE_NoRESP            ; Signal appropriately with the carry bit.
09805    EE1F  38             SEC
09806    EE20  60             RTS                            ; Return with positive response
09807      
09808    PRESENCE_NoRESP
09809    EE21  18             CLC
09810    EE22  60             RTS                            ; ...Else return negative.
09811    
09812    
09813    ; TPB Attention handler (Needs work, do not use)
09814    ; ****************************************************
09815    ; *                                                  *
09816    ; *  ENTRY:                                          *
09817    ; *  EXIT:                                           *
09818    ; *                                                  *
09819    ; *                                                  *
09820    ; *                                                  *
09821    ; ****************************************************
09822    
09823    TPB_ATN_handler
09824      
09825    EE23  A0 00          LDY #0
09826    ATN_next                          ; Work our way through the device table
09827    EE25  B9 00 06       LDA TPB_Dev_table,Y           
09828      
09829    EE28  F0 1E          BEQ TPB_EOT                     ; Check for end of table marker (0).
09830                                      ; Initialise our control block for attention check
09831    EE2A  8D 10 06       STA DEV_ID                      ; Store device ID.
09832    EE2D  98             TYA
09833    EE2E  48             PHA                             ; Stack our table pointer for later.
09834    EE2F  A9 01          LDA #TPB_BLK_cmd
09835    EE31  8D 11 06       STA DEV_BLK_TYPE
09836    EE34  A9 01          LDA #ATN_CHK
09837    EE36  8D 12 06       STA DEV_CMD_RSP
09838      
09839    EE39  20 49 EE       JSR TPB_calc_ctrl_csum
09840      
09841    EE3C  20 B8 ED       JSR TPB_Tx_CMD                  ; Transmit Command
09842      
09843    EE3F  20 F4 EE       JSR TPB_tx_block
09844      
09845      ;JSR TPB_ctrl_rd
09846      
09847    EE42  68             PLA                             ; Get our id table pointer back.
09848    EE43  A8             TAY
09849    EE44  C8             INY                             ; Advance to next table entry  
09850    EE45  4C 25 EE       JMP ATN_next
09851    TPB_EOT
09852    EE48  60             RTS
09853      
09854    TPB_calc_ctrl_csum
09855    EE49  18             CLC
09856    EE4A  A9 00          LDA #0                          ; Calculate and store checksum for block.
09857    EE4C  6D 10 06       ADC DEV_ID
09858    EE4F  6D 11 06       ADC DEV_BLK_TYPE
09859    EE52  6D 12 06       ADC DEV_CMD_RSP
09860    EE55  8D 13 06       STA CHECKSUM
09861    EE58  60             RTS
09862     
09863     
09864    ; TPB transmit byte
09865    ; *================================*
09866    ; *                                *
09867    ; *  ENTRY: A=byte                 *
09868    ; *  EXIT: Affects X, P            *
09869    ; *                                *
09870    ; *================================*
09871    
09872    TPB_tx_byte
09873    EE59  A2 0A          LDX #10                   ; 1 start bit, 8 data bits and 1 stop bit.
09874    EE5B  38             SEC                       ; We want a start bit.
09875    EE5C  48             PHA
09876    TPB_bit_out  
09877    EE5D  90 0F          BCC TPB_out_zero          ; Determine whether a 1 or 0 to be sent.
09878      
09879    ; output 1 on TPB data
09880    EE5F  AD 20 C0       LDA TPB_reg_b
09881    EE62  09 20          ORA #TPB_BUS_datout
09882    EE64  8D 20 C0       STA TPB_reg_b
09883    EE67  EA             NOP                       ; This NOP compensates for the branch timing.
09884    EE68  20 7C EE       JSR TPB_pulseclk
09885      
09886    EE6B  4C 93 EE       JMP TPB_shiftbit
09887       
09888    ; output 0 on TPB data  
09889    TPB_out_zero
09890    EE6E  AD 20 C0       LDA TPB_reg_b
09891    EE71  29 DF          AND #~TPB_BUS_datout
09892    EE73  8D 20 C0       STA TPB_reg_b
09893    EE76  20 7C EE       JSR TPB_pulseclk 
09894      
09895    EE79  4C 93 EE       JMP TPB_shiftbit
09896    
09897    
09898    ; Clock line Pulse function
09899    ; **********************************
09900    ; *                                *
09901    ; *   ENTRY: None                  *
09902    ; *   EXIT: A,P Affected           *
09903    ; *   USES: TPB_delay              *
09904    ; *                                *
09905    ; **********************************
09906    
09907    TPB_pulseclk  
09908    EE7C  AD 20 C0       LDA TPB_reg_b
09909    EE7F  09 10          ORA #TPB_BUS_clkout       ; Set the clock line output
09910    EE81  8D 20 C0       STA TPB_reg_b
09911      
09912    EE84  20 BF EF       JSR TPB_delay
09913    
09914    EE87  AD 20 C0       LDA TPB_reg_b
09915    EE8A  29 EF          AND #~TPB_BUS_clkout      ; Clear the clock line output
09916    EE8C  8D 20 C0       STA TPB_reg_b
09917      
09918    EE8F  20 BF EF       JSR TPB_delay
09919    EE92  60             RTS
09920    
09921          
09922    TPB_shiftbit  
09923    EE93  CA             DEX
09924    EE94  F0 06          BEQ TPB_wr_done
09925    EE96  68             PLA
09926    EE97  0A             ASL
09927    EE98  48             PHA
09928    EE99  4C 5D EE       JMP TPB_bit_out
09929      
09930    TPB_wr_done
09931    EE9C  68             PLA
09932    EE9D  60             RTS
09933    
09934    
09935    ; TPB recieve byte
09936    ; *======================================*
09937    ; *                                      *
09938    ; *  ENTRY:                              *
09939    ; *  EXIT: Affects A,X,Y,P               *
09940    ; *        A = byte                      *
09941    ; *        C = 1 Sucess, 0 Fail          *
09942    ; *                                      *
09943    ; *======================================*
09944    
09945    TPB_rx_byte                       ; Read one byte
09946    EE9E  A9 00          LDA #0                          ; This is our starting value
09947    EEA0  85 E4          STA TPB_Temp3                   ; Keep it safe in Temp3
09948      
09949    EEA2  AD 20 C0       LDA TPB_reg_b                   ; Signal start bit required.
09950    EEA5  09 10          ORA #TPB_BUS_clkout             ; Set the clock line output
09951    EEA7  8D 20 C0       STA TPB_reg_b
09952      
09953    EEAA  18             CLC
09954    EEAB  A0 FF          LDY #TPB_BUS_lim_c              ; Load our limit (preventing bus hangs)
09955    TPB_chk_databit
09956    EEAD  20 BF EF       JSR TPB_delay                   ; Small delay.  This may change later.
09957    EEB0  AD 20 C0       LDA TPB_reg_b
09958    EEB3  29 80          AND #TPB_BUS_datin
09959    EEB5  F0 12          BEQ TPB_sbit_asserted
09960      
09961    EEB7  88             DEY                             ; Check for timeout & branch if still waiting.
09962    EEB8  D0 F3          BNE TPB_chk_databit
09963      
09964    TPB_rx_fail
09965    EEBA  AD 20 C0       LDA TPB_reg_b                   ; Clear clock line output
09966    EEBD  29 EF          AND #~TPB_BUS_clkout
09967    EEBF  8D 20 C0       STA TPB_reg_b
09968    EEC2  20 BF EF       JSR TPB_delay                   ; ...and include a small delay
09969    
09970    EEC5  A9 00          LDA #0                          ; We timed out so let's signal that
09971    EEC7  18             CLC
09972    EEC8  60             RTS
09973      
09974    TPB_sbit_asserted
09975    EEC9  AD 20 C0       LDA TPB_reg_b                   ; Clear clock line output
09976    EECC  29 EF          AND #~TPB_BUS_clkout
09977    EECE  8D 20 C0       STA TPB_reg_b
09978    EED1  20 BF EF       JSR TPB_delay                   ; ...and include a small delay
09979      
09980    
09981    EED4  A2 08          LDX #8                          ; Receive and store 8 bits.
09982    TPB_rcv_nextbit  
09983    EED6  20 E7 EE       JSR TPB_Takebit
09984    EED9  26 E4          ROL TPB_Temp3                   ; Push our sampled bit into our output.
09985    
09986    EEDB  CA             DEX
09987    EEDC  D0 F8          BNE TPB_rcv_nextbit
09988      
09989    EEDE  20 E7 EE       JSR TPB_Takebit                 ; Receive the stop bit.  
09990    EEE1  B0 D7          BCS TPB_rx_fail
09991      
09992    EEE3  A5 E4          LDA TPB_Temp3                   ; Retrieve our finished byte
09993    EEE5  38             SEC                             ; and signal that we were successful
09994    EEE6  60             RTS
09995      
09996    TPB_Takebit  
09997    EEE7  20 7C EE       JSR TPB_pulseclk                ; Sample the bus and set or clear carry as required.
09998    EEEA  AD 20 C0       LDA TPB_reg_b
09999    EEED  29 80          AND #TPB_BUS_datin
10000    EEEF  18             CLC
10001    EEF0  D0 01          BNE TPB_skip_setbit
10002    EEF2  38             SEC
10003    TPB_skip_setbit
10004    EEF3  60             RTS
10005      
10006    
10007    ; TPB transmit block
10008    ; *==================================================*
10009    ; *                                                  *
10010    ; *  ENTRY: TPB_BUS_blk_lenlo = length of block (LO) *
10011    ; *         TPB_BUS_blk_lenhi = length of block (HI) *
10012    ; *                                                  *
10013    ; *         TPB_BUS_blk_st  = start of block         *
10014    ; *                                                  *
10015    ; *  EXIT:  TPB_BUS_blk_len = unchanged              *
10016    ; *         TPB_BUS_blk_st  = st+len                 *
10017    ; *         A,X,Y,P affected.                        *
10018    ; *                                                  *
10019    ; *                                                  *
10020    ; *==================================================*
10021    
10022    TPB_tx_block
10023    EEF4  AD FA 05       LDA TPB_BUS_blk_stlo             ; Copy block address to temp1/2
10024    EEF7  85 E2          STA TPB_Temp1
10025    EEF9  AD FB 05       LDA TPB_BUS_blk_sthi
10026    EEFC  85 E3          STA TPB_Temp2
10027      
10028    TPB_BUS_tx_next                    ; Transmitter inside loop
10029    EEFE  AD F8 05       LDA TPB_BUS_blk_lenlo            ; Finish when TPB_blk_len(lo and hi) = 0
10030    EF01  0D F9 05       ORA TPB_BUS_blk_lenhi
10031    EF04  F0 31          BEQ TPB_tx_block_done
10032      
10033    EF06  A0 00          LDY #0                           ; Get and transmit byte.
10034    EF08  B1 E2          LDA (TPB_Temp1),Y
10035    EF0A  20 59 EE       JSR TPB_tx_byte
10036    
10037    EF0D  AD F8 05       LDA TPB_BUS_blk_lenlo            ; Decrement our length counter
10038    EF10  38             SEC
10039    EF11  E9 01          SBC #1
10040    EF13  8D F8 05       STA TPB_BUS_blk_lenlo
10041    EF16  AD F9 05       LDA TPB_BUS_blk_lenhi
10042    EF19  E9 00          SBC #0
10043    EF1B  8D F9 05       STA TPB_BUS_blk_lenhi
10044      
10045    EF1E  18             CLC                              ; Increment TPB_BUS_blk_len copy in TPB_Temp1/2
10046    EF1F  A5 E2          LDA TPB_Temp1
10047    EF21  69 01          ADC #1
10048    EF23  85 E2          STA TPB_Temp1
10049    EF25  A5 E3          LDA TPB_Temp2
10050    EF27  69 00          ADC #0
10051    EF29  85 E3          STA TPB_Temp2
10052      
10053    EF2B  20 BF EF       JSR TPB_delay                    ; Add a little delay between bytes.
10054    EF2E  20 BF EF       JSR TPB_delay                    ; thereby allowing the receiver to do something useful.
10055    EF31  20 BF EF       JSR TPB_delay
10056      
10057    EF34  4C FE EE       JMP TPB_BUS_tx_next
10058      
10059    TPB_tx_block_done
10060    EF37  60             RTS
10061     
10062    
10063    ; TPB receive block
10064    ; *==================================================*
10065    ; *                                                  *
10066    ; *  ENTRY: TPB_BUS_blk_lenlo = length of block (LO) *
10067    ; *         TPB_BUS_blk_lenhi = length of block (HI) *
10068    ; *                                                  *
10069    ; *         TPB_BUS_blk_st  = start of block         *
10070    ; *                                                  *
10071    ; *  EXIT:  TPB_BUS_blk_len = unchanged              *
10072    ; *         TPB_BUS_blk_st  = st+len                 *
10073    ; *         Temp1, Temp2 Corrupted                   *
10074    ; *         A,X,Y,P all affected.                    *
10075    ; *         C=0 Fail, C=1 Success                    *
10076    ; *                                                  *
10077    ; *==================================================*
10078     
10079    TPB_rx_block
10080    EF38  AD FA 05       LDA TPB_BUS_blk_stlo             ; Copy block address to temp1/2
10081    EF3B  85 E2          STA TPB_Temp1
10082    EF3D  AD FB 05       LDA TPB_BUS_blk_sthi
10083    EF40  85 E3          STA TPB_Temp2
10084      
10085    TPB_BUS_rx_next
10086    EF42  AD F8 05       LDA TPB_BUS_blk_lenlo            ; While block length > 0.
10087    EF45  0D F9 05       ORA TPB_BUS_blk_lenhi
10088    EF48  F0 2B          BEQ TPB_rx_block_done
10089      
10090    EF4A  20 9E EE       JSR TPB_rx_byte                  ; Get byte.
10091      
10092    EF4D  B0 01          BCS TPB_rx_continue              ; Continue unless TPB_rx_byte signals failiure.
10093    EF4F  60             RTS
10094      
10095    TPB_rx_continue
10096    EF50  A0 00          LDY #0                           
10097    EF52  91 E2          STA (TPB_Temp1),Y                ; Store our successfully received byte.
10098      
10099    EF54  AD F8 05       LDA TPB_BUS_blk_lenlo            ; Decrement our length counter
10100    EF57  38             SEC
10101    EF58  E9 01          SBC #1
10102    EF5A  8D F8 05       STA TPB_BUS_blk_lenlo
10103    EF5D  AD F9 05       LDA TPB_BUS_blk_lenhi
10104    EF60  E9 00          SBC #0
10105    EF62  8D F9 05       STA TPB_BUS_blk_lenhi
10106      
10107    EF65  18             CLC                              ; Increment TPB_BUS_blk_len copy in TPB_Temp1/2
10108    EF66  A5 E2          LDA TPB_Temp1
10109    EF68  69 01          ADC #1
10110    EF6A  85 E2          STA TPB_Temp1
10111    EF6C  A5 E3          LDA TPB_Temp2
10112    EF6E  69 00          ADC #0
10113    EF70  85 E3          STA TPB_Temp2
10114      
10115    EF72  4C 42 EF       JMP TPB_BUS_rx_next
10116      
10117    TPB_rx_block_done
10118    EF75  38             SEC
10119    EF76  60             RTS
10120      
10121      
10122    ; TPB Device Select
10123    ; *==================================================*
10124    ; *                                                  *
10125    ; *   ENTRY:   A = Device to select                  *
10126    ; *   EXIT:    None                                  *
10127    ; *   AFFECTS: A,X,Y,P                               *
10128    ; *                                                  *
10129    ; *                                                  *
10130    ; *==================================================*
10131    
10132    TPB_dev_select
10133    EF77  A8             TAY                       ; Save our device ID
10134      
10135      
10136    EF78  A9 08          LDA #TPB_BUS_select       ; Assert SELECT signal
10137    EF7A  8D 20 C0       STA TPB_reg_b
10138    
10139    EF7D  A2 00          LDX #$0                   ; Give device time to act
10140    ATN_Resp_Dwell
10141    EF7F  CA             DEX
10142    EF80  EA             NOP
10143    EF81  EA             NOP
10144    EF82  D0 FB          BNE ATN_Resp_Dwell
10145      
10146    EF84  98             TYA                       ; Get our ID from Y
10147    EF85  20 59 EE       JSR TPB_tx_byte           ; Transmit our device ID
10148      
10149    EF88  A9 F7          LDA #~TPB_BUS_select      ; Deassert SELECT
10150    EF8A  8D 20 C0       STA TPB_reg_b
10151      
10152    EF8D  8C F2 05       STY TPB_curr_dev          ; Update current dev variable
10153      
10154    EF90  60             RTS
10155      
10156    
10157    
10158        
10159    FINDME:
10160    
10161    ; TPB LPT Write.
10162    ; *================================*
10163    ; *                                *
10164    ; *  ENTRY: A=char                 *
10165    ; *  EXIT: As found                *
10166    ; *                                *
10167    ; **********************************
10168    
10169    TPB_LPT_write
10170    
10171    EF91  08             PHP                             ; Save Register States
10172    EF92  48             PHA
10173      
10174    EF93  20 B5 EF       JSR STB_ack_wait                ; Wait until Ack=1
10175      
10176    EF96  20 BF EF       JSR TPB_delay
10177      
10178    EF99  8D 21 C0       STA TPB_reg_a                   ; Write the char to output
10179      
10180    EF9C  20 BF EF       JSR TPB_delay
10181      
10182    EF9F  AD 20 C0       LDA TPB_reg_b                   ; Set the strobe bit low (Active)
10183    EFA2  29 FD          AND #~TPB_LPT_stb_b             ; and only the strobe bit.
10184    EFA4  8D 20 C0       STA TPB_reg_b
10185      
10186    EFA7  20 BF EF       JSR TPB_delay
10187      
10188    EFAA  AD 20 C0       LDA TPB_reg_b                   ; Now we return the strobe bit to it's
10189    EFAD  09 02          ORA #TPB_LPT_stb_b              ; 'idle' state.
10190    EFAF  8D 20 C0       STA TPB_reg_b
10191      
10192    EFB2  68             PLA
10193    EFB3  28             PLP
10194    EFB4  60             RTS  
10195      
10196    STB_ack_wait
10197    EFB5  48             PHA
10198      
10199    TPB_w_loop
10200    EFB6  AD 2D C0       LDA TPB_ifr                     ; Check IFR for interrupt flag on CB1 set
10201    EFB9  29 02          AND #TPB_ACK_CA1_b
10202    EFBB  F0 F9          BEQ TPB_w_loop                  ; Until they match
10203      
10204    EFBD  68             PLA
10205    EFBE  60             RTS
10206     
10207     
10208    ; Delay routine for TPB, there are better ways but this will do for now.
10209      
10210    TPB_delay
10211    EFBF  48             PHA
10212      
10213    EFC0  A9 06          LDA #6
10214    EFC2  38             SEC
10215      
10216    TPB_delay_loop
10217    EFC3  E9 01          SBC #1
10218    EFC5  D0 FC          BNE TPB_delay_loop
10219      
10220    EFC7  68             PLA
10221    EFC8  60             RTS
10222    
10223    ; *****************************************************************
10224    ;
10225    ;                       END OF TPBCARD.asm
10226    ;
10227    ; *****************************************************************
10228    ; *****************************************************************
10229      .INCLUDE "TAPE_IO.asm"
10230    ; Tape Interface Functions for ToE Tape and Joystick interface.
10231    
10232    ; Compatible with versions 1 and 1.1 of the interface as of 30/12/2020
10233    
10234    
10235    ; Tape interface bitfield definitions
10236    
10237      0080             TAPE_out		= @10000000			; This is the bit to toggle for tape writing.
10238      0040             TAPE_in			= @01000000			; This is the bit to sample for tape reading.
10239      003F             JOYSTICK_bits		= @00111111			; These bits are used by the joystick interface.
10240      0001             JOYSTICK_sel		= @00000001			; 0 selects Joystick 0, 1 selects joystick 2. Easy.
10241    
10242      0001             TAPE_Stat_overrun	= @00000001			; Stop bit was a one!
10243      0002             TAPE_Stat_par_err	= @00000010			; Parity error.  It remains to be seen if this gets implemented.
10244      0004             TAPE_Stat_RXFull	= @00000100			; Byte received
10245      0008             TAPE_Stat_Escape	= @00001000			; Indication that the escape key has been pressed
10246    
10247      0001             TAPE_BlockIn_Complete	= @00000001
10248      0002             TAPE_BlockIn_Escape	= @00000010
10249      0004             TAPE_BlockIn_Error	= @00000100
10250    
10251      0001             TAPE_Verify_Good	= @00000001
10252      0002             TAPE_Verify_Escape	= @00000010
10253      0004             TAPE_Verify_Error	= @00000100
10254    
10255    ; Tape interface port addresses
10256    
10257      C040             TAPE_IOBASE		= $C040				; Base address for our tape port.  This is normally set to whatever the GPIO card is.
10258      C040             TAPE_IOP		= TAPE_IOBASE			; We are currently using PORT B on the user port card for IO.
10259      C042             TAPE_DDRB		= TAPE_IOBASE + 2
10260    
10261    
10262    ; Tape system storage zeropage addresses
10263      00E4             TAPE_temp		= $E4				; Let's use one of the zero page addresses
10264      00E5             TAPE_BlockLo		= $E5
10265      00E6             TAPE_BlockHi		= $E6
10266    
10267    ; Tape timing values.
10268    
10269    ; Please note that all this is subject to changes as and when needed because I'm in uncharted territory
10270    ; and don't quite know what I'm doing yet.
10271    
10272    
10273      0008             C_TAPE_Phasetime	= 8				; How long to wait between phases.  Bigger is slower
10274      0014             C_TAPE_Sample_Offset	= 20				; How far is the middle of the bit. Note: timing errors will cause this to stretch
10275      0036             C_TAPE_Bitlength	= 54				; How many passes for a full bit
10276      0008             C_TAPE_bitcycles	= 8				; Number of cycles to a bit
10277      000A             C_TAPE_BitsPerFrame	= 10				; Total number of bits per frame including start and stop bits.
10278      00AA             C_TAPE_LeaderByte	= $AA				; Leader byte
10279      0055             C_TAPE_EndOfLeaderByte  = $55				; End of leader signal byte
10280      AFC8             C_TAPE_Interblock_pause = 45000				; How long between blocks to wait before starting the next one.
10281    
10282      0064             TAPE_Leader_Bytes	= 100				; Set leader length in bits.
10283    
10284    ; File type constants
10285    
10286      0000             C_TAPE_FType_BASIC	= 0				; BASIC program
10287      0001             C_TAPE_FType_BINARY	= 1				; Binary Data
10288      0002             C_TAPE_FType_TEXT	= 2				; Pure text.  NOTE: Good for merging snippets of code.
10289    
10290    
10291    ; System variables for tape routines.
10292    
10293    
10294    ; +================================+
10295    ; !                                !
10296    ; ! TAPE SPACE FROM $900 TO $AFF   !
10297    ; !                                !
10298    ; !                                !
10299    ; !                                !
10300    ; +================================+
10301    
10302      0900             TAPE_RAM_Start			= $900				; Base address of the tape filing system main memory
10303    
10304      0900             V_TAPE_BlockSize		= TAPE_RAM_Start		; 2 Byte address for block size
10305      0902             TAPE_temp2			= TAPE_RAM_Start + 2		; Second temporary store for tape functions.
10306      0903             TAPE_temp3			= TAPE_RAM_Start + 3		; Third temporary store for tape functions.
10307      0904             TAPE_temp4			= TAPE_RAM_Start + 4		; Fourth temporary store for tape functions.
10308      0905             TAPE_LineUptime			= TAPE_RAM_Start + 5		; How many passes of the superloop the line has been up.
10309      0906             TAPE_Demod_Status		= TAPE_RAM_Start + 6		; Demodulated bit status.
10310      0907             TAPE_Demod_Last			= TAPE_RAM_Start + 7		; Our previous demod status.  Used for edge detection etc.
10311      0908             TAPE_StartDet			= TAPE_RAM_Start + 8		; Start bit detected is 1, 0 otherwise
10312      0909             TAPE_RX_Status			= TAPE_RAM_Start + 9		; Receive engine status bitfield.
10313      090A             TAPE_BitsToDecode		= TAPE_RAM_Start + 10		; Bit countdown counter when decoding
10314      090B             TAPE_ByteReceived		= TAPE_RAM_Start + 11		; Last byte received
10315      090C             TAPE_Sample_Position		= TAPE_RAM_Start + 12		; Countdown timer for bit engine sample synchronization
10316      090D             TAPE_BlockIn_Status		= TAPE_RAM_Start + 13		; Status register for the F_TAPE_BlockIn function.
10317    
10318      090E             TAPE_Header_Buffer		= TAPE_BlockIn_Status + 1	; This is where the tape header data starts
10319      090E             TAPE_HeaderID			= TAPE_Header_Buffer		; Just stores 'HEAD'.  Used to identify headers from other stuff.
10320      0912             TAPE_FileType			= TAPE_HeaderID + 4		; This is the file type ID goes. 0 is for BASIC, otherwise ignored by LOAD.
10321      0913             TAPE_FileSizeLo			= TAPE_FileType + 1		; Low byte of the file size
10322      0914             TAPE_FileSizeHi			= TAPE_FileSizeLo + 1		; High byte of the file size
10323      0915             TAPE_LoadAddrLo			= TAPE_FileSizeHi + 1		; Low byte of the file load address
10324      0916             TAPE_LoadAddrHi			= TAPE_LoadAddrLo + 1		; High byte of the file load address
10325      0917             TAPE_FileName			= TAPE_LoadAddrHi + 1		; Null terminated filename field 17 bytes long.
10326      0928             TAPE_ChecksumLo			= TAPE_FileName + C_TAPE_Fname_BufferSize	; Checksum Low byte
10327      0929             TAPE_ChecksumHi			= TAPE_ChecksumLo + 1		; Checksum High byte
10328      0929             TAPE_Header_End			= TAPE_ChecksumHi		; End of header space
10329    
10330      092A             TAPE_CS_AccLo			= TAPE_Header_End + 1		; Tape checksum Accumulator low byte
10331      092B             TAPE_CS_AccHi			= TAPE_CS_AccLo + 1		; Tape checksum Accumulator high byte
10332    
10333      092C             V_TAPE_Phasetime		= TAPE_CS_AccHi + 1		; Tape phasetime variable
10334      092D             V_TAPE_Sample_Offset		= V_TAPE_Phasetime + 1		; Sample offset variable
10335      092E             V_TAPE_Bitlength		= V_TAPE_Sample_Offset + 1	; How long a bit is in passes variable
10336      092F             V_TAPE_bitcycles		= V_TAPE_Bitlength + 1		; Number of cycles to a bit variable
10337    
10338      0930             V_TAPE_Verify_Status		= V_TAPE_bitcycles + 1		; Status register for the F_TAPE_Verify function.
10339      0931             V_TAPE_Fname_Buffer		= V_TAPE_Verify_Status + 1	; Filename Buffer for null terminated filename.
10340      0943             V_TAPE_LOADSAVE_Type		= V_TAPE_Fname_Buffer + 18	; LOAD or SAVE type being currently handled.
10341      0944             V_TAPE_Address_Buff		= V_TAPE_LOADSAVE_Type + 1	; Address for LOAD and SAVE operations.
10342      0946             V_TAPE_Size_Buff		= V_TAPE_Address_Buff + 2
10343    
10344    ; Some more handy constants
10345    
10346      0011             C_TAPE_Fname_BufferSize		= 17
10347      0942             C_TAPE_Fname_BuffEnd		= V_TAPE_Fname_Buffer + C_TAPE_Fname_BufferSize 
10348      001C             C_TAPE_HeaderSize		= TAPE_Header_End - TAPE_Header_Buffer + 1
10349    
10350    
10351    
10352    
10353    
10354    ; Next is $947.
10355    
10356    ; +-------------------------------------------------------------------------------------------+
10357    ; +                                                                                           +
10358    ; +                              TAPE FILING SYSTEM MESSAGE STRINGS.                          +
10359    ; +                                                                                           +
10360    ; +-------------------------------------------------------------------------------------------+
10361    
10362    
10363    TMSG_init_msg						; Filing System initialisation string.
10364     
10365      .BYTE $0C,1,$18,$03,$0D,$0A
10366      .BYTE "TowerTAPE Filing System",$0D,$0A
10367      .BYTE "V2.37",$0D,$0A,$0D,$0A,$00
10368      
10369    
10370    TMSG_Ready
10371    
10372      .BYTE "Ready",$D,$A,0
10373      
10374      
10375    TMSG_Saving
10376    
10377      .BYTE $D,$A
10378      .BYTE "Saving ",0
10379      
10380      
10381    TMSG_Searching
10382    
10383      .BYTE $D,$A
10384      .BYTE "Searching...",$D,$A,$A,0
10385    
10386    
10387    TMSG_Found
10388      .BYTE "Found ",0 
10389    
10390    TMSG_Loading
10391    
10392      .BYTE $D,$A
10393      .BYTE "Loading...",$D,$A,0
10394      
10395    TMSG_Verifying
10396    
10397      .BYTE $D,$A
10398      .BYTE "Verifying...",$D,$A,0
10399      
10400    TMSG_Verified
10401    
10402      .BYTE $D,$A
10403      .BYTE "Verified OK.",$D,$A,0
10404      
10405    TMSG_VerifyError
10406    
10407      .BYTE $D,$A
10408      .BYTE "Verify Error.",$D,$A,0
10409    
10410    TMSG_TapeError
10411    
10412      .BYTE $D,$A
10413      .BYTE "Tape loading Error.",$D,$A,0
10414      
10415      
10416    TMSG_HeaderError  
10417    
10418      .BYTE $D,$A
10419      .BYTE "Header error. Retrying.",$D,$A,0
10420      
10421    TMSG_TypeBASIC
10422    
10423      .BYTE "BASIC:  ",0
10424      
10425    TMSG_TypeBINARY
10426    
10427      .BYTE "Binary: ",0
10428      
10429    TMSG_TypeTEXT
10430    
10431      .BYTE "Text:   ",0
10432      
10433    TMSG_TypeOTHER
10434      .BYTE "Other:  ",0
10435      
10436    
10437    
10438    ; +-------------------------------------------------------------------------------------------------+
10439    ; +                                                                                                 +
10440    ; +                        Functions for tape loading and saving start here.                        +
10441    ; +                        =================================================                        +
10442    ; +                                                                                                 +
10443    ; +                                                                                                 +
10444    ; +-------------------------------------------------------------------------------------------------+
10445    
10446    
10447    ;*****************************************************************************************
10448    ;**                                                                                     **
10449    ;**                                                                                     **
10450    ;**                HOUSEKEEPING AND INITIALISATION FUNCTIONS GO HERE.                   **
10451    ;**                                                                                     **
10452    ;**                                                                                     **
10453    ;*****************************************************************************************
10454    
10455    F_TAPE_Init
10456    F0B8  A9 81          LDA #TAPE_out | JOYSTICK_sel				; Setup tape and joystick 6522 DDR Bits.
10457    F0BA  8D 42 C0       STA TAPE_DDRB
10458    
10459    F0BD  A0 00          LDY #0						; Setup our index to the start of the string
10460      
10461    L_TAPE_init_msg  
10462    F0BF  B9 C9 EF       LDA TMSG_init_msg,Y					; Get the character
10463    F0C2  F0 07          BEQ TAPE_msg_done					; Break out of the loop when we're done.
10464      
10465    F0C4  20 02 E2       JSR V_OUTP						; output character
10466      
10467    F0C7  C8             INY							; Do the next character
10468    F0C8  4C BF F0       JMP L_TAPE_init_msg
10469    
10470    TAPE_msg_done  
10471    F0CB  60             RTS
10472        
10473    
10474      
10475    
10476    
10477    ;*****************************************************************************************
10478    ;**                                                                                     **
10479    ;**                                                                                     **
10480    ;**          Helper and high level functions for tape loading and saving.               **
10481    ;**                                                                                     **
10482    ;**                                                                                     **
10483    ;*****************************************************************************************
10484    
10485    
10486    ; Compares the filename in the buffer to the one in the header and returns C=1 on equality, otherwise C=0
10487    ;
10488    
10489    F_TAPE_CompareFileNames
10490    F0CC  A0 00          LDY #0						; Setup our index
10491      
10492    F0CE  AD 31 09       LDA V_TAPE_Fname_Buffer				; Short circuit to match on null filename specified.
10493    F0D1  C9 00          CMP #0
10494    F0D3  F0 10          BEQ TAPE_CompareByte_Match_B
10495      
10496    TAPE_CompareByte_L
10497    F0D5  B9 31 09       LDA V_TAPE_Fname_Buffer,Y				; Get our byte to compare
10498    
10499    F0D8  D9 17 09       CMP TAPE_FileName,Y					; Branch on mismatch.
10500    F0DB  D0 0A          BNE TAPE_CompareMismatch_B
10501      
10502    F0DD  98             TYA							; Decrement index and branch when done
10503    F0DE  C8             INY
10504    F0DF  C9 10          CMP #16
10505    F0E1  F0 02          BEQ TAPE_CompareByte_Match_B
10506    F0E3  80 F0          BRA TAPE_CompareByte_L
10507      
10508    TAPE_CompareByte_Match_B				; Signal match and exit
10509    F0E5  38             SEC
10510    F0E6  60             RTS 
10511      
10512    TAPE_CompareMismatch_B
10513    F0E7  18             CLC							; Signal mismatch and exit
10514    F0E8  60             RTS
10515    
10516    ; Just prints 'Found ', followed by the filename.  That's all.
10517    
10518    F_TAPE_PrintFound
10519    F0E9  A9 16          LDA #<TMSG_Found					; Print 'Found '
10520    F0EB  85 E7          STA TOE_MemptrLo
10521    F0ED  A9 F0          LDA #>TMSG_Found 
10522    F0EF  85 E8          STA TOE_MemptrHi
10523    F0F1  20 60 FF       JSR TOE_PrintStr_vec
10524      
10525    
10526    F0F4  AD 12 09       LDA TAPE_FileType					; Check and print BASIC if necessary.
10527    F0F7  C9 00          CMP #C_TAPE_FType_BASIC
10528    F0F9  D0 0D          BNE TAPE_Skip_RepBASIC_B
10529      
10530    F0FB  A9 94          LDA #<TMSG_TypeBASIC
10531    F0FD  85 E7          STA TOE_MemptrLo
10532    F0FF  A9 F0          LDA #>TMSG_TypeBASIC
10533    F101  85 E8          STA TOE_MemptrHi
10534    F103  20 60 FF       JSR TOE_PrintStr_vec
10535      
10536    F106  80 33          BRA TAPE_DoPrintFname_B
10537       
10538    TAPE_Skip_RepBASIC_B
10539    
10540    F108  AD 12 09       LDA TAPE_FileType					; Check and print BINARY if necessary.
10541    F10B  C9 01          CMP #C_TAPE_FType_BINARY
10542    F10D  D0 0D          BNE TAPE_Skip_RepBinary_B
10543      
10544    F10F  A9 9D          LDA #<TMSG_TypeBINARY
10545    F111  85 E7          STA TOE_MemptrLo
10546    F113  A9 F0          LDA #>TMSG_TypeBINARY
10547    F115  85 E8          STA TOE_MemptrHi
10548    F117  20 60 FF       JSR TOE_PrintStr_vec
10549      
10550    F11A  80 1F          BRA TAPE_DoPrintFname_B
10551      
10552    TAPE_Skip_RepBinary_B
10553    
10554    F11C  AD 12 09       LDA TAPE_FileType					; Check and print TEXT if necessary.
10555    F11F  C9 02          CMP #C_TAPE_FType_TEXT
10556    F121  D0 0D          BNE TAPE_Skip_RepText_B
10557      
10558    F123  A9 A6          LDA #<TMSG_TypeTEXT
10559    F125  85 E7          STA TOE_MemptrLo
10560    F127  A9 F0          LDA #>TMSG_TypeTEXT
10561    F129  85 E8          STA TOE_MemptrHi
10562    F12B  20 60 FF       JSR TOE_PrintStr_vec
10563    
10564    F12E  80 0B          BRA TAPE_DoPrintFname_B
10565      
10566    TAPE_Skip_RepText_B
10567    
10568    F130  A9 AF          LDA #<TMSG_TypeOTHER
10569    F132  85 E7          STA TOE_MemptrLo
10570    F134  A9 F0          LDA #>TMSG_TypeOTHER
10571    F136  85 E8          STA TOE_MemptrHi
10572    F138  20 60 FF       JSR TOE_PrintStr_vec
10573    
10574    TAPE_DoPrintFname_B
10575    F13B  20 F7 F1       JSR F_TAPE_PrintFname_in_Header			; Print our filename.
10576    F13E  20 99 C9       JSR   LAB_CRLF					; print CR/LF. 
10577    F141  60             RTS
10578    
10579    
10580    F_TAPE_PrintStart
10581    F142  AD 16 09       LDA TAPE_LoadAddrHi
10582    F145  20 AC FE       JSR MON_PrintHexByte
10583    F148  AD 15 09       LDA TAPE_LoadAddrLo
10584    F14B  20 AC FE       JSR MON_PrintHexByte
10585    F14E  60             RTS
10586    
10587    F_TAPE_PrintSize
10588    F14F  AD 14 09       LDA TAPE_FileSizeHi
10589    F152  20 AC FE       JSR MON_PrintHexByte
10590    F155  AD 13 09       LDA TAPE_FileSizeLo
10591    F158  20 AC FE       JSR MON_PrintHexByte
10592    F15B  60             RTS
10593      
10594    
10595      
10596      
10597    
10598    ; Write HEAD to the header ID field.  Yes, it's primitive but it really is the easiest way.
10599    ;  
10600    F_TAPE_WriteHeaderID
10601    F15C  A9 48          LDA #'H'
10602    F15E  8D 0E 09       STA TAPE_HeaderID
10603    F161  A9 45          LDA #'E'
10604    F163  8D 0F 09       STA TAPE_HeaderID + 1
10605    F166  A9 41          LDA #'A'
10606    F168  8D 10 09       STA TAPE_HeaderID + 2
10607    F16B  A9 44          LDA #'D'
10608    F16D  8D 11 09       STA TAPE_HeaderID + 3
10609    F170  60             RTS
10610    
10611    
10612    ; Check to see if our header block IS a header block.
10613    ;
10614    F_TAPE_CheckHeaderID
10615    F171  AD 0E 09       LDA TAPE_HeaderID
10616    F174  C9 48          CMP #'H'
10617    F176  D0 17          BNE TAPE_NotAHeader_B
10618      
10619    F178  AD 0F 09       LDA TAPE_HeaderID + 1
10620    F17B  C9 45          CMP #'E'
10621    F17D  D0 10          BNE TAPE_NotAHeader_B
10622      
10623    F17F  AD 10 09       LDA TAPE_HeaderID + 2
10624    F182  C9 41          CMP #'A'
10625    F184  D0 09          BNE TAPE_NotAHeader_B
10626      
10627    F186  AD 11 09       LDA TAPE_HeaderID + 3
10628    F189  C9 44          CMP #'D'
10629    F18B  D0 02          BNE TAPE_NotAHeader_B
10630      
10631    F18D  38             SEC					; Is a confirmed header
10632    F18E  60             RTS
10633      
10634    TAPE_NotAHeader_B  
10635    F18F  18             CLC					; Is not a header or is a bad header.
10636    F190  60             RTS
10637      
10638    
10639    ; Fill out V_TAPE_Fname_buffer with filename.
10640    ; TOE_MemptrLo and Hi contain the address bytes for the source.  A contains the length.
10641    ; This function also null terminates the string.
10642    
10643    F_TAPE_Fill_Fname
10644    F191  A0 00          LDY #0						; Clear our index so we point to the start of the string.
10645      
10646    F193  C9 00          CMP #0						; Handle null string swiftly
10647    F195  F0 0B          BEQ TAPE_Fill_Null_L
10648      
10649    F197  AA             TAX							; Set up our byte counter
10650      
10651    TAPE_Fill_Fname_L					; Fill_Fname loop start
10652    F198  B1 E7          LDA (TOE_MemptrLo),Y					; Get our byte
10653    F19A  99 31 09       STA V_TAPE_Fname_Buffer,Y				; Save our byte in our buffer.
10654    
10655    F19D  C8             INY							; Increment our index
10656    F19E  CA             DEX							; Decrement our counter
10657    F19F  8A             TXA
10658    F1A0  D0 F6          BNE TAPE_Fill_Fname_L					; Repeat while counter not zero
10659    
10660    TAPE_Fill_Null_L					; At this point, we're putting the null characters in
10661    F1A2  A9 00          LDA #0
10662      
10663    F1A4  99 31 09       STA V_TAPE_Fname_Buffer,Y
10664    F1A7  98             TYA
10665    F1A8  C8             INY
10666    F1A9  C9 10          CMP #C_TAPE_Fname_BufferSize-1
10667    F1AB  D0 F5          BNE TAPE_Fill_Null_L
10668      
10669    F1AD  60             RTS							; End of F_TAPE_Fill_Fname routine.
10670      
10671      
10672    ; Copies V_TAPE_Fname_Buffer to the header
10673      
10674    F_TAPE_Fname_Buf_to_Header
10675    F1AE  A0 00          LDY #0						; Set our index
10676    
10677    TAPE_Fname_Buf_to_Header_L
10678    
10679    F1B0  B9 31 09       LDA V_TAPE_Fname_Buffer,Y				; Get our first byte
10680    F1B3  99 17 09       STA TAPE_FileName,Y					; And transfer it to the header.
10681      
10682    F1B6  C8             INY							; Increment and repeat until done.
10683    F1B7  C9 00          CMP #0
10684    F1B9  D0 F5          BNE TAPE_Fname_Buf_to_Header_L
10685      
10686    TAPE_Fname_BlankRest_B					; Fill out rest of header with zero's for checksum purposes.
10687    F1BB  A9 00          LDA #0
10688    F1BD  99 17 09       STA TAPE_FileName,Y
10689    F1C0  98             TYA
10690    F1C1  C9 11          CMP #C_TAPE_Fname_BufferSize
10691    F1C3  F0 03          BEQ TAPE_Done_BlankRest_B
10692    F1C5  C8             INY
10693    F1C6  80 F3          BRA TAPE_Fname_BlankRest_B
10694      
10695    TAPE_Done_BlankRest_B
10696    F1C8  60             RTS							; Done
10697    
10698    
10699    ; Get filename from command line into buffer.  Also handle errors.  This may not be the final thing.
10700    
10701    F_TAPE_GetName
10702    F1C9  20 E7 CB       JSR LAB_EVEX						; evaluate string
10703    F1CC  20 55 D4       JSR LAB_EVST						; test it is a string
10704    F1CF  8D 02 09       STA TAPE_temp2					; Store our string length for later
10705      
10706    F1D2  A5 5F          LDA Dtypef						; Find out if it is a string and error if it isn't.  $FF=Str, $0=Numeric
10707    F1D4  F0 10          BEQ TAPE_SYN_ERR
10708      
10709    F1D6  AD 02 09       LDA TAPE_temp2					; Recover our string length
10710    F1D9  38             SEC
10711    F1DA  E9 11          SBC #17
10712    F1DC  30 0E          BMI TAPE_NameToBuffer_B
10713    F1DE  80 00          BRA TAPE_LEN_ERR
10714    
10715    TAPE_LEN_ERR  
10716    F1E0  A2 24          LDX #$24 ;ERR_BF					; Issue a Bad filename Error
10717    F1E2  20 3F C2       JSR LAB_XERR
10718    F1E5  60             RTS							; Does LAB_XERR really return??
10719      
10720    TAPE_SYN_ERR
10721    ; Syntax Error output
10722    F1E6  A2 02          LDX #$2 ;ERR_SN					; Issue a Syntax Error.  
10723    F1E8  20 3F C2       JSR LAB_XERR
10724    F1EB  60             RTS							; Does LAB_XERR really return??							
10725    
10726    TAPE_NameToBuffer_B
10727    
10728    F1EC  86 E7          STX TOE_MemptrLo					; Copy our String to the 
10729    F1EE  84 E8          STY TOE_MemptrHi					; TOE_Memptr contains starting location
10730    F1F0  AD 02 09       LDA TAPE_temp2					; and A contains size.
10731    F1F3  20 91 F1       JSR F_TAPE_Fill_Fname
10732    F1F6  60             RTS
10733    
10734    
10735    ; Print Filename in header
10736    
10737    F_TAPE_PrintFname_in_Header
10738    
10739    F1F7  20 42 F1       JSR F_TAPE_PrintStart
10740    F1FA  A9 20          LDA #' '
10741    F1FC  20 02 E2       JSR V_OUTP
10742    F1FF  20 4F F1       JSR F_TAPE_PrintSize
10743    F202  A9 20          LDA #' '
10744    F204  20 02 E2       JSR V_OUTP
10745      
10746    F207  A9 22          LDA #34
10747    F209  20 02 E2       JSR V_OUTP
10748    F20C  A9 17          LDA #<TAPE_FileName				; Print our Filename in the header space
10749    F20E  85 E7          STA TOE_MemptrLo
10750    F210  A9 09          LDA #>TAPE_FileName 
10751    F212  85 E8          STA TOE_MemptrHi
10752    F214  20 60 FF       JSR TOE_PrintStr_vec
10753    F217  A9 22          LDA #34
10754    F219  20 02 E2       JSR V_OUTP
10755    
10756      
10757    F21C  60             RTS
10758      
10759    
10760    ; Saves A BASIC program or binary block.  Meant to be called from within BASIC
10761    ;
10762    
10763    F_TAPE_SAVE_BASIC
10764    
10765    F21D  20 C9 F1       JSR F_TAPE_GetName					; Get the filename from the command stream
10766    F220  20 AE F1       JSR F_TAPE_Fname_Buf_to_Header			; and put it in the header.
10767      
10768    F223  20 5C F1       JSR F_TAPE_WriteHeaderID				; Include the Header ID 'HEAD'
10769    
10770    F226  A9 00          LDA #C_TAPE_FType_BASIC				; Initially set the type to BASIC.  Depending on following params, this may get changed.
10771    F228  8D 43 09       STA V_TAPE_LOADSAVE_Type
10772      
10773    F22B  A9 00          LDA #<Ram_base					; Store the BASIC load address to our buffer too.
10774    F22D  8D 44 09       STA V_TAPE_Address_Buff				; This also might get changed.
10775    F230  A9 0C          LDA #>Ram_base
10776    F232  8D 45 09       STA V_TAPE_Address_Buff + 1
10777      
10778    F235  20 99 F5       JSR F_TAPE_GetBASIC_Size				; Find out how big our BASIC program is.
10779      
10780    F238  AD 00 09       LDA V_TAPE_BlockSize					; Transfer it to the size buffer.
10781    F23B  8D 46 09       STA V_TAPE_Size_Buff
10782    F23E  AD 01 09       LDA V_TAPE_BlockSize + 1
10783    F241  8D 47 09       STA V_TAPE_Size_Buff + 1
10784      
10785      
10786      
10787    F244  20 C2 00       JSR LAB_GBYT						; Find out if we have extra parameters or not,
10788      							; firstly checking if we have a null.
10789    F247  F0 2B          BEQ B_TAPE_SAVE_BASIC					; If we have null, we can continue as SAVEing BASIC otherwise it's binary.
10790      
10791    ; Experimental code goes here.
10792    
10793    
10794    ; End experimental code.  
10795      
10796    
10797    ; BINARY case.
10798    
10799    B_TAPE_SAVE_BINARY
10800    F249  20 D3 CB       JSR LAB_EVNM						; evaluate expression and check is numeric,
10801    							; else do type mismatch
10802    F24C  20 04 D6       JSR LAB_F2FX						; save integer part of FAC1 in temporary integer
10803    
10804    F24F  20 04 CD       JSR LAB_1C01						; scan for "," , else do syntax error then warm start
10805          							
10806    F252  A5 11          LDA Itempl						; save our specified base address
10807    F254  8D 44 09       STA V_TAPE_Address_Buff
10808    F257  A5 12          LDA   Itemph
10809    F259  8D 45 09       STA V_TAPE_Address_Buff + 1
10810      
10811    F25C  20 D3 CB       JSR LAB_EVNM						; Get and store our binary file size
10812      							; If this parameter is missing you will get a Syntax Error.
10813    F25F  20 04 D6       JSR LAB_F2FX						; save integer part of FAC1 in temporary integer
10814      
10815    F262  20 C2 00       JSR LAB_GBYT						; FINDME:- Loose the comma ready for the next paramter.
10816      							; This may not be necessary or right.
10817      
10818    F265  A5 11          LDA Itempl						; Replace the size in the buffer with the one from BASIC
10819    F267  8D 46 09       STA V_TAPE_Size_Buff
10820    F26A  A5 12          LDA Itemph
10821    F26C  8D 47 09       STA V_TAPE_Size_Buff + 1
10822      
10823    F26F  A9 01          LDA #C_TAPE_FType_BINARY				; Set the type to BINARY
10824    F271  8D 43 09       STA V_TAPE_LOADSAVE_Type
10825      
10826      ; NOTE:- By this point, the address and size buffers should contain correct parameters alongside the file type info.
10827      
10828      
10829    ; Now do the SAVE
10830    
10831    ; By this point the Address and size are stored in their relevant buffers.
10832    
10833    B_TAPE_SAVE_BASIC
10834    
10835    F274  A9 FA          LDA #<TMSG_Saving					; Tell the user that we are saving.
10836    F276  85 E7          STA TOE_MemptrLo
10837    F278  A9 EF          LDA #>TMSG_Saving
10838    F27A  85 E8          STA TOE_MemptrHi
10839    F27C  20 60 FF       JSR TOE_PrintStr_vec
10840    
10841    ; Provide the necessary parameters for the F_TAPE_CalcChecksum to work
10842      
10843    F27F  AD 46 09       LDA V_TAPE_Size_Buff					; Save our program size to the header and to V_TAPE_BlockSize
10844    F282  8D 13 09       STA TAPE_FileSizeLo
10845    F285  8D 00 09       STA V_TAPE_BlockSize
10846    F288  AD 47 09       LDA V_TAPE_Size_Buff + 1
10847    F28B  8D 14 09       STA TAPE_FileSizeHi  
10848    F28E  8D 01 09       STA V_TAPE_BlockSize + 1
10849      
10850    F291  AD 44 09       LDA V_TAPE_Address_Buff				; Get our starting pointer for calculating our checksum loaded.
10851    F294  85 E5          STA TAPE_BlockLo
10852    F296  AD 45 09       LDA V_TAPE_Address_Buff + 1
10853    F299  85 E6          STA TAPE_BlockHi
10854      
10855    F29B  20 5E F5       JSR F_TAPE_CalcChecksum				; Get our checksum value
10856    
10857    F29E  AD 2A 09       LDA TAPE_CS_AccLo					; Store our calculated Checksum in the header structure.
10858    F2A1  8D 28 09       STA TAPE_ChecksumLo
10859    F2A4  AD 2B 09       LDA TAPE_CS_AccHi
10860    F2A7  8D 29 09       STA TAPE_ChecksumHi
10861      
10862    F2AA  AD 44 09       LDA V_TAPE_Address_Buff				; Include the LOAD address in the header.  It remains to be seen how we establish
10863    F2AD  8D 15 09       STA TAPE_LoadAddrLo					; Load to SAVE'd address implied by the header.
10864    F2B0  AD 45 09       LDA V_TAPE_Address_Buff + 1
10865    F2B3  8D 16 09       STA TAPE_LoadAddrHi
10866      
10867    F2B6  AD 43 09       LDA V_TAPE_LOADSAVE_Type				; Setup the file type in the header too.
10868    F2B9  8D 12 09       STA TAPE_FileType
10869    
10870    F2BC  20 F7 F1       JSR F_TAPE_PrintFname_in_Header			; Print our "Filename".  
10871      
10872      ; Setup for F_TAPE_BlockOut to write the header to tape and then write it out.
10873      
10874    F2BF  A9 0E          LDA #<TAPE_Header_Buffer				; Setup our block pointer to the start of the header
10875    F2C1  85 E5          STA TAPE_BlockLo
10876    F2C3  A9 09          LDA #>TAPE_Header_Buffer
10877    F2C5  85 E6          STA TAPE_BlockHi
10878      
10879    F2C7  A9 1C          LDA #<C_TAPE_HeaderSize				; Load our blocksize with the size of our header buffer
10880    F2C9  8D 00 09       STA V_TAPE_BlockSize
10881    F2CC  A9 00          LDA #>C_TAPE_HeaderSize
10882    F2CE  8D 01 09       STA V_TAPE_BlockSize + 1
10883      
10884    F2D1  20 29 F6       JSR F_TAPE_BlockOut					; Write our block to tape
10885      
10886      
10887      ; Include a decent pause between the header and the main block.
10888      
10889    F2D4  A2 C8          LDX #<C_TAPE_Interblock_pause				; Wait a little before writing the actual program data block.
10890    F2D6  A0 AF          LDY #>C_TAPE_Interblock_pause
10891    F2D8  20 4B F5       JSR F_TAPE_Pause
10892      
10893      
10894    F2DB  AD 15 09       LDA TAPE_LoadAddrLo					; Transfer our start address to our Block pointer
10895    F2DE  85 E5          STA TAPE_BlockLo
10896    F2E0  AD 16 09       LDA TAPE_LoadAddrHi
10897    F2E3  85 E6          STA TAPE_BlockHi
10898      
10899    F2E5  AD 13 09       LDA TAPE_FileSizeLo					; Setup our blocksize counter
10900    F2E8  8D 00 09       STA V_TAPE_BlockSize
10901    F2EB  AD 14 09       LDA TAPE_FileSizeHi
10902    F2EE  8D 01 09       STA V_TAPE_BlockSize + 1
10903      
10904    F2F1  20 29 F6       JSR F_TAPE_BlockOut					; Write our file
10905        
10906    F2F4  60             RTS							; We're done for now.
10907      
10908      
10909    
10910    ; Tape VERIFY routine.
10911    ; --------------------
10912    
10913    F_TAPE_VERIFY_BASIC
10914    
10915    F2F5  20 C9 F1       JSR F_TAPE_GetName					; Get the filename string into our buffer
10916    
10917      ; Initial BASIC case.
10918    
10919    F2F8  A9 00          LDA #<Ram_base					; Store the BASIC load address to our buffer too.
10920    F2FA  8D 44 09       STA V_TAPE_Address_Buff				; This also might get changed.
10921    F2FD  A9 0C          LDA #>Ram_base
10922    F2FF  8D 45 09       STA V_TAPE_Address_Buff + 1
10923      
10924    F302  20 99 F5       JSR F_TAPE_GetBASIC_Size				; Get our BASIC size.
10925      
10926    F305  AD 00 09       LDA V_TAPE_BlockSize					; Transfer it to the size buffer.
10927    F308  8D 46 09       STA V_TAPE_Size_Buff
10928    F30B  AD 01 09       LDA V_TAPE_BlockSize + 1
10929    F30E  8D 47 09       STA V_TAPE_Size_Buff + 1
10930      
10931    F311  A9 00          LDA #C_TAPE_FType_BASIC				; Set the type to BASIC
10932    F313  8D 43 09       STA V_TAPE_LOADSAVE_Type
10933    
10934    
10935      ; Identify if we are dealing with binary by it's extra parameters.
10936       
10937    F316  20 C2 00       JSR LAB_GBYT						; Find out if we have extra parameters or not,
10938      							; firstly checking if we have a null.
10939    F319  F0 15          BEQ TAPE_VERIFY_Searching_B				; If we have null, we can continue as SAVEing BASIC otherwise it's binary.
10940      
10941      ; BINARY case.
10942      
10943    F31B  20 D3 CB       JSR LAB_EVNM						; evaluate expression and check is numeric,
10944    							; else do type mismatch
10945    F31E  20 04 D6       JSR LAB_F2FX						; save integer part of FAC1 in temporary integer
10946        							
10947    F321  A5 11          LDA Itempl						; save our specified base address
10948    F323  8D 44 09       STA V_TAPE_Address_Buff
10949    F326  A5 12          LDA Itemph
10950    F328  8D 45 09       STA V_TAPE_Address_Buff + 1
10951      
10952    F32B  A9 01          LDA #C_TAPE_FType_BINARY				; Set the type to BINARY
10953    F32D  8D 43 09       STA V_TAPE_LOADSAVE_Type
10954      
10955      
10956      ; Now go verify!
10957      
10958    TAPE_VERIFY_Searching_B
10959    
10960    F330  A9 04          LDA #<TMSG_Searching					; Tell the user that we are searching.
10961    F332  85 E7          STA TOE_MemptrLo
10962    F334  A9 F0          LDA #>TMSG_Searching
10963    F336  85 E8          STA TOE_MemptrHi
10964    F338  20 60 FF       JSR TOE_PrintStr_vec
10965    
10966    TAPE_VERIFY_Header_B
10967    
10968    F33B  A9 0E          LDA #<TAPE_Header_Buffer				; Point to start of header buffer
10969    F33D  85 E5          STA TAPE_BlockLo
10970    F33F  A9 09          LDA #>TAPE_Header_Buffer
10971    F341  85 E6          STA TAPE_BlockHi
10972      
10973    F343  A9 1C          LDA #<C_TAPE_HeaderSize				; Specify how big our header is.
10974    F345  8D 00 09       STA V_TAPE_BlockSize
10975    F348  A9 00          LDA #>C_TAPE_HeaderSize
10976    F34A  8D 01 09       STA V_TAPE_BlockSize + 1
10977      
10978    F34D  20 07 F7       JSR F_TAPE_BlockIn					; Load the header block.
10979      
10980    F350  C9 02          CMP #TAPE_BlockIn_Escape
10981    F352  D0 03          BNE TAPE_BlockIn_EscNotPressed_B
10982    F354  4C 40 F4       JMP TAPE_BlockIn_EscHandler				; If escaping jump to the escape handler
10983    
10984    TAPE_BlockIn_EscNotPressed_B
10985    
10986    F357  20 71 F1       JSR F_TAPE_CheckHeaderID				; try again if not a valid header
10987    F35A  90 DF          BCC TAPE_VERIFY_Header_B
10988    
10989    F35C  C9 04          CMP #TAPE_Verify_Error
10990    F35E  D0 0E          BNE TAPE_VERIFY_Fname_Check
10991    
10992    F360  A9 78          LDA #<TMSG_HeaderError				; Tell the user of the header error and retry
10993    F362  85 E7          STA TOE_MemptrLo
10994    F364  A9 F0          LDA #>TMSG_HeaderError
10995    F366  85 E8          STA TOE_MemptrHi
10996    F368  20 60 FF       JSR TOE_PrintStr_vec
10997      
10998    F36B  4C 3B F3       JMP TAPE_VERIFY_Header_B				; Keep coming back until the header is read valid or the user presses escape
10999    
11000    
11001    TAPE_VERIFY_Fname_Check
11002    F36E  20 E9 F0       JSR F_TAPE_PrintFound
11003      
11004    F371  20 CC F0       JSR F_TAPE_CompareFileNames
11005    F374  90 C5          BCC TAPE_VERIFY_Header_B
11006      
11007    F376  AD 12 09       LDA TAPE_FileType					; We're only interested in verifying the right type of file.
11008    F379  CD 43 09       CMP V_TAPE_LOADSAVE_Type
11009    F37C  D0 BD          BNE TAPE_VERIFY_Header_B
11010      
11011    TAPE_Verify_Stage
11012    
11013    F37E  AD 13 09       LDA TAPE_FileSizeLo					; Put our file size into V_TAPE_BlockSize.
11014    F381  8D 00 09       STA V_TAPE_BlockSize
11015    F384  AD 14 09       LDA TAPE_FileSizeHi
11016    F387  8D 01 09       STA V_TAPE_BlockSize + 1
11017    
11018    F38A  AD 43 09       LDA V_TAPE_LOADSAVE_Type
11019    F38D  C9 01          CMP #C_TAPE_FType_BINARY
11020      
11021    F38F  F0 0C          BEQ B_TAPE_Verify_SkipBASIC_Sizing
11022    
11023    F391  AD 46 09       LDA V_TAPE_Size_Buff					; Put our measured BASIC size into V_TAPE_BlockSize
11024    F394  8D 00 09       STA V_TAPE_BlockSize
11025    F397  AD 47 09       LDA V_TAPE_Size_Buff + 1
11026    F39A  8D 01 09       STA V_TAPE_BlockSize + 1
11027    
11028    B_TAPE_Verify_SkipBASIC_Sizing
11029    
11030    F39D  AD 13 09       LDA TAPE_FileSizeLo					; Check our file is the same size as our stored program.
11031    F3A0  CD 00 09       CMP V_TAPE_BlockSize
11032    F3A3  D0 37          BNE TAPE_Verify_Error_B
11033    F3A5  AD 14 09       LDA TAPE_FileSizeHi
11034    F3A8  CD 01 09       CMP V_TAPE_BlockSize + 1
11035    F3AB  D0 2F          BNE TAPE_Verify_Error_B
11036       
11037    F3AD  AD 13 09       LDA TAPE_FileSizeLo					; Tell the system how big the file to verify is.
11038    F3B0  8D 00 09       STA V_TAPE_BlockSize
11039    F3B3  AD 14 09       LDA TAPE_FileSizeHi
11040    F3B6  8D 01 09       STA V_TAPE_BlockSize + 1
11041      
11042    F3B9  AD 44 09       LDA V_TAPE_Address_Buff				; Tell the system where to start verifying the data,
11043    F3BC  85 E5          STA TAPE_BlockLo					; this should point to Ram_base for BASIC or as specified for binary.
11044    F3BE  AD 45 09       LDA V_TAPE_Address_Buff + 1
11045    F3C1  85 E6          STA TAPE_BlockHi
11046      
11047    F3C3  A9 2C          LDA #<TMSG_Verifying					; Tell the user that we are verifying.
11048    F3C5  85 E7          STA TOE_MemptrLo
11049    F3C7  A9 F0          LDA #>TMSG_Verifying
11050    F3C9  85 E8          STA TOE_MemptrHi
11051    F3CB  20 60 FF       JSR TOE_PrintStr_vec 
11052        
11053    F3CE  20 60 F7       JSR F_TAPE_VerifyBlock				; Verify the data in memory against the block on tape.
11054    
11055    F3D1  AD 30 09       LDA V_TAPE_Verify_Status				; Check our status
11056    F3D4  C9 02          CMP #TAPE_Verify_Escape
11057    F3D6  F0 68          BEQ TAPE_BlockIn_EscHandler				; If escaping jump to the escape handler
11058      
11059    F3D8  C9 04          CMP #TAPE_Verify_Error				; Check if verify passed or not.
11060    F3DA  D0 0C          BNE TAPE_Verify_OK
11061      
11062    TAPE_Verify_Error_B  
11063    F3DC  A9 4E          LDA #<TMSG_VerifyError				; Inform the user of the verification error.
11064    F3DE  85 E7          STA TOE_MemptrLo
11065    F3E0  A9 F0          LDA #>TMSG_VerifyError
11066    F3E2  85 E8          STA TOE_MemptrHi
11067    F3E4  20 60 FF       JSR TOE_PrintStr_vec
11068    F3E7  60             RTS
11069      
11070    TAPE_Verify_OK
11071    F3E8  A9 3D          LDA #<TMSG_Verified					; Inform the user of verification success.
11072    F3EA  85 E7          STA TOE_MemptrLo
11073    F3EC  A9 F0          LDA #>TMSG_Verified
11074    F3EE  85 E8          STA TOE_MemptrHi
11075    F3F0  20 60 FF       JSR TOE_PrintStr_vec
11076    
11077    TAPE_Verify_Done  
11078    F3F3  60             RTS
11079      
11080    F_TAPE_CAT
11081    
11082    F3F4  A9 04          LDA #<TMSG_Searching					; Tell the user that we are searching.
11083    F3F6  85 E7          STA TOE_MemptrLo
11084    F3F8  A9 F0          LDA #>TMSG_Searching
11085    F3FA  85 E8          STA TOE_MemptrHi
11086    F3FC  20 60 FF       JSR TOE_PrintStr_vec
11087    
11088    TAPE_CAT_Header_B
11089    
11090    F3FF  A9 0E          LDA #<TAPE_Header_Buffer				; Point to start of header buffer
11091    F401  85 E5          STA TAPE_BlockLo
11092    F403  A9 09          LDA #>TAPE_Header_Buffer
11093    F405  85 E6          STA TAPE_BlockHi
11094      
11095    F407  A9 1C          LDA #<C_TAPE_HeaderSize				; Specify how big our header is.
11096    F409  8D 00 09       STA V_TAPE_BlockSize
11097    F40C  A9 00          LDA #>C_TAPE_HeaderSize
11098    F40E  8D 01 09       STA V_TAPE_BlockSize + 1
11099      
11100    F411  20 07 F7       JSR F_TAPE_BlockIn
11101    F414  C9 02          CMP #TAPE_BlockIn_Escape
11102    F416  F0 1B          BEQ TAPE_CAT_Exit_B
11103      
11104    F418  20 71 F1       JSR F_TAPE_CheckHeaderID				; try again if not a valid header
11105    F41B  90 E2          BCC TAPE_CAT_Header_B
11106    
11107    F41D  C9 04          CMP #TAPE_BlockIn_Error
11108    F41F  D0 0D          BNE TAPE_CAT_Fname_Report
11109      
11110    F421  A9 78          LDA #<TMSG_HeaderError				; Tell the user of the header error and retry
11111    F423  85 E7          STA TOE_MemptrLo
11112    F425  A9 F0          LDA #>TMSG_HeaderError
11113    F427  85 E8          STA TOE_MemptrHi
11114    F429  20 60 FF       JSR TOE_PrintStr_vec
11115      
11116    F42C  80 D1          BRA TAPE_CAT_Header_B
11117      
11118    
11119    TAPE_CAT_Fname_Report
11120    F42E  20 E9 F0       JSR F_TAPE_PrintFound					; Tell the user what we found.
11121    F431  80 CC          BRA TAPE_CAT_Header_B
11122      
11123    TAPE_CAT_Exit_B
11124    F433  60             RTS
11125    
11126    
11127    
11128    
11129    
11130    ; Tape Reporting routines.
11131    ; ------------------------
11132    
11133    TAPE_BlockIn_LoadErr
11134    F434  A9 60          LDA #<TMSG_TapeError					; Tell the user that we are have encountered an error.
11135    F436  85 E7          STA TOE_MemptrLo
11136    F438  A9 F0          LDA #>TMSG_TapeError
11137    F43A  85 E8          STA TOE_MemptrHi
11138    F43C  20 60 FF       JSR TOE_PrintStr_vec
11139    F43F  60             RTS
11140      
11141    TAPE_BlockIn_EscHandler
11142    F440  A9 AA          LDA #<LAB_BMSG					; Tell the user that we are have pressed Escape.
11143    F442  85 E7          STA TOE_MemptrLo
11144    F444  A9 E9          LDA #>LAB_BMSG
11145    F446  85 E8          STA TOE_MemptrHi
11146    F448  20 60 FF       JSR TOE_PrintStr_vec
11147    F44B  60             RTS
11148      
11149      
11150    ;To BASIC 'LOAD' entry point.
11151      
11152    F_TAPE_LOAD_BASIC
11153    
11154    F44C  20 C9 F1       JSR F_TAPE_GetName					; Get the filename string into our buffer
11155      
11156    F44F  A9 00          LDA #C_TAPE_FType_BASIC				; Initially set the type to BASIC
11157    F451  8D 43 09       STA V_TAPE_LOADSAVE_Type
11158      
11159    F454  A9 00          LDA #<Ram_base					; Store the BASIC load address to our buffer too.
11160    F456  8D 44 09       STA V_TAPE_Address_Buff
11161    F459  A9 0C          LDA #>Ram_base
11162    F45B  8D 45 09       STA V_TAPE_Address_Buff + 1
11163    
11164    
11165    F45E  20 C2 00       JSR LAB_GBYT						; Find out if we have extra parameters or not.						; Firstly checking if we have a null.
11166    F461  F0 15          BEQ TAPE_LOAD_Header_B				; Since we have nothing, we can continue as LOADing BASIC
11167      
11168    
11169    ; Handle BINARY case.
11170      
11171    F463  20 D3 CB       JSR LAB_EVNM						; evaluate expression and check is numeric,
11172    							; else do type mismatch
11173    F466  20 04 D6       JSR LAB_F2FX						; save integer part of FAC1 in temporary integer
11174    
11175    ; These next two lines are not needed for LOADs to memory, only SAVEs from memory.
11176    
11177    							; scan for "," and get byte, else do Syntax error then warm start
11178    
11179          							; JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
11180          							
11181    
11182    ; Setup for a binary LOAD
11183          							
11184    F469  A5 11          LDA Itempl						; save our specified base address
11185    F46B  8D 44 09       STA V_TAPE_Address_Buff
11186    F46E  A5 12          LDA Itemph
11187    F470  8D 45 09       STA V_TAPE_Address_Buff + 1
11188      
11189    F473  A9 01          LDA #C_TAPE_FType_BINARY				; Set the type to BINARY
11190    F475  8D 43 09       STA V_TAPE_LOADSAVE_Type
11191    
11192    
11193    ; Handle the Header
11194    
11195    TAPE_LOAD_Header_B  
11196    
11197    F478  A9 04          LDA #<TMSG_Searching					; Tell the user that we are searching.
11198    F47A  85 E7          STA TOE_MemptrLo
11199    F47C  A9 F0          LDA #>TMSG_Searching
11200    F47E  85 E8          STA TOE_MemptrHi
11201    F480  20 60 FF       JSR TOE_PrintStr_vec
11202    
11203    TAPE_LOAD_Header_Silent_B
11204    
11205    F483  A9 0E          LDA #<TAPE_Header_Buffer				; Point to start of header buffer
11206    F485  85 E5          STA TAPE_BlockLo
11207    F487  A9 09          LDA #>TAPE_Header_Buffer
11208    F489  85 E6          STA TAPE_BlockHi
11209      
11210    F48B  A9 1C          LDA #<C_TAPE_HeaderSize				; Specify how big our header is.
11211    F48D  8D 00 09       STA V_TAPE_BlockSize
11212    F490  A9 00          LDA #>C_TAPE_HeaderSize
11213    F492  8D 01 09       STA V_TAPE_BlockSize + 1
11214    
11215    F495  20 07 F7       JSR F_TAPE_BlockIn					; Load the header block.
11216      
11217    F498  AD 0D 09       LDA TAPE_BlockIn_Status				; Branch on non load conditions
11218    F49B  C9 02          CMP #TAPE_BlockIn_Escape
11219    F49D  F0 A1          BEQ TAPE_BlockIn_EscHandler				; If escaping jump to the escape handler
11220      
11221    F49F  20 71 F1       JSR F_TAPE_CheckHeaderID				; try again if not a valid header
11222    F4A2  90 DF          BCC TAPE_LOAD_Header_Silent_B
11223    
11224    F4A4  C9 04          CMP #TAPE_BlockIn_Error
11225    F4A6  D0 0E          BNE TAPE_BASLOAD_Fname_Check
11226    
11227    F4A8  A9 78          LDA #<TMSG_HeaderError				; Tell the user of the header error and retry
11228    F4AA  85 E7          STA TOE_MemptrLo
11229    F4AC  A9 F0          LDA #>TMSG_HeaderError
11230    F4AE  85 E8          STA TOE_MemptrHi
11231    F4B0  20 60 FF       JSR TOE_PrintStr_vec
11232    F4B3  4C 78 F4       JMP TAPE_LOAD_Header_B
11233      
11234    
11235    TAPE_BASLOAD_Fname_Check
11236    F4B6  20 E9 F0       JSR F_TAPE_PrintFound					; Tell the user what we found.
11237      
11238    F4B9  20 CC F0       JSR F_TAPE_CompareFileNames				; Check if our file is the right name
11239    F4BC  90 BA          BCC TAPE_LOAD_Header_B
11240      
11241    F4BE  AD 12 09       LDA TAPE_FileType					; We're only interested in loading the appropriate file type.
11242    F4C1  CD 43 09       CMP V_TAPE_LOADSAVE_Type
11243    F4C4  D0 B2          BNE TAPE_LOAD_Header_B
11244    
11245    TAPE_BASIC_Load_Stage
11246    F4C6  AD 13 09       LDA TAPE_FileSizeLo					; Tell the system how big the file to load is.
11247    F4C9  8D 00 09       STA V_TAPE_BlockSize
11248    F4CC  AD 14 09       LDA TAPE_FileSizeHi
11249    F4CF  8D 01 09       STA V_TAPE_BlockSize + 1
11250      
11251    F4D2  AD 44 09       LDA V_TAPE_Address_Buff				; Tell the system where to load to. This should point to Ram_base for BASIC
11252    F4D5  85 E5          STA TAPE_BlockLo
11253    F4D7  AD 45 09       LDA V_TAPE_Address_Buff + 1
11254    F4DA  85 E6          STA TAPE_BlockHi
11255      
11256    F4DC  A9 1D          LDA #<TMSG_Loading					; Tell the user that we are loading.
11257    F4DE  85 E7          STA TOE_MemptrLo
11258    F4E0  A9 F0          LDA #>TMSG_Loading
11259    F4E2  85 E8          STA TOE_MemptrHi
11260    F4E4  20 60 FF       JSR TOE_PrintStr_vec
11261      
11262    F4E7  20 07 F7       JSR F_TAPE_BlockIn					; Load the code block that follows
11263      
11264    F4EA  AD 0D 09       LDA TAPE_BlockIn_Status				; Branch on non load conditions
11265    F4ED  C9 02          CMP #TAPE_BlockIn_Escape
11266    F4EF  D0 03          BNE TAPE_Skip_EscHandler_B
11267    F4F1  4C 40 F4       JMP TAPE_BlockIn_EscHandler				; If escaping jump to the escape handler
11268      
11269    TAPE_Skip_EscHandler_B  
11270    
11271    F4F4  C9 01          CMP #TAPE_BlockIn_Complete
11272    F4F6  F0 03          BEQ TAPE_BASIC_LoadingDone
11273    
11274    F4F8  4C 34 F4       JMP TAPE_BlockIn_LoadErr
11275      
11276    TAPE_BASIC_LoadingDone  
11277    F4FB  AD 44 09       LDA V_TAPE_Address_Buff				; Setup our pointer to the start of our LOADed memory
11278    F4FE  85 E5          STA TAPE_BlockLo
11279    F500  AD 45 09       LDA V_TAPE_Address_Buff + 1
11280    F503  85 E6          STA TAPE_BlockHi
11281    
11282    F505  20 5E F5       JSR F_TAPE_CalcChecksum				; Get our checksum value into TAPE_CS_Acc_Lo and Hi
11283      
11284    F508  AD 28 09       LDA TAPE_ChecksumLo					; First we check the low byte.
11285    F50B  CD 2A 09       CMP TAPE_CS_AccLo
11286    F50E  D0 2E          BNE TAPE_CS_Fail
11287      
11288    F510  AD 29 09       LDA TAPE_ChecksumHi					; And then if necessary, we check the high byte.
11289    F513  CD 2B 09       CMP TAPE_CS_AccHi
11290    F516  D0 26          BNE TAPE_CS_Fail
11291    
11292    TAPE_BASICload_exit
11293    
11294    F518  AD 43 09       LDA V_TAPE_LOADSAVE_Type
11295    F51B  C9 00          CMP #C_TAPE_FType_BASIC
11296    F51D  F0 01          BEQ B_Setup_NEWBASIC_Prog
11297    F51F  60             RTS
11298      
11299    B_Setup_NEWBASIC_Prog
11300    
11301    F520  A9 F2          LDA #<TMSG_Ready					; Tell the user that we are saving.
11302    F522  85 E7          STA TOE_MemptrLo
11303    F524  A9 EF          LDA #>TMSG_Ready
11304    F526  85 E8          STA TOE_MemptrHi
11305    F528  20 60 FF       JSR TOE_PrintStr_vec
11306        
11307    F52B  A5 E5          LDA TAPE_BlockLo					; Return the system to a useable state
11308    F52D  85 7B          STA Svarl
11309    F52F  85 7D          STA Sarryl
11310    F531  85 7F          STA Earryl
11311    F533  A5 E6          LDA TAPE_BlockHi
11312    F535  85 7C          STA Svarh
11313    F537  85 7E          STA Sarryh
11314    F539  85 80          STA Earryh
11315    F53B  4C 17 C3       JMP LAB_1319						; Tidy up system.
11316      
11317    TAPE_CS_Fail
11318    F53E  A9 60          LDA #<TMSG_TapeError					; Inform the user of their loading error.
11319    F540  85 E7          STA TOE_MemptrLo
11320    F542  A9 F0          LDA #>TMSG_TapeError
11321    F544  85 E8          STA TOE_MemptrHi
11322    F546  20 60 FF       JSR TOE_PrintStr_vec
11323    F549  80 CD          BRA TAPE_BASICload_exit
11324      
11325      
11326    F_TAPE_Pause
11327    
11328    F54B  EA             NOP
11329    F54C  EA             NOP
11330    F54D  EA             NOP
11331    F54E  EA             NOP
11332    F54F  EA             NOP
11333    F550  EA             NOP
11334    F551  EA             NOP
11335    F552  EA             NOP
11336      
11337    F553  CA             DEX
11338    F554  E0 FF          CPX #$FF
11339    F556  D0 F3          BNE F_TAPE_Pause
11340      
11341    F558  88             DEY
11342    F559  C0 00          CPY #0
11343    F55B  D0 EE          BNE F_TAPE_Pause
11344      
11345    F55D  60             RTS
11346    
11347    
11348    F_TAPE_CalcChecksum
11349    
11350    F55E  AE 00 09       LDX V_TAPE_BlockSize					; Set up our block counter
11351    F561  AC 01 09       LDY V_TAPE_BlockSize + 1
11352        
11353    F564  A9 00          LDA #0						; Clear the checksum accumulator
11354    F566  8D 2A 09       STA TAPE_CS_AccLo
11355    F569  8D 2B 09       STA TAPE_CS_AccHi
11356    
11357    L_TAPE_CS_NEXT  
11358    F56C  AD 2A 09       LDA TAPE_CS_AccLo					; Add our byte to the checksum
11359    F56F  18             CLC
11360    F570  72 E5          ADC (TAPE_BlockLo)
11361    F572  8D 2A 09       STA TAPE_CS_AccLo
11362    F575  AD 2B 09       LDA TAPE_CS_AccHi
11363    F578  69 00          ADC #0
11364    F57A  8D 2B 09       STA TAPE_CS_AccHi
11365      
11366    F57D  A5 E5          LDA TAPE_BlockLo					; Advance our pointer.
11367    F57F  18             CLC
11368    F580  69 01          ADC #1
11369    F582  85 E5          STA TAPE_BlockLo
11370    F584  A5 E6          LDA TAPE_BlockHi
11371    F586  69 00          ADC #0
11372    F588  85 E6          STA TAPE_BlockHi
11373      
11374    F58A  CA             DEX							; Repeat until 0
11375    F58B  E0 FF          CPX #$FF
11376    F58D  D0 01          BNE CS_No_Y_update  
11377    F58F  88             DEY
11378    CS_No_Y_update
11379    F590  C0 00          CPY #0
11380    F592  D0 D8          BNE L_TAPE_CS_NEXT
11381    F594  E0 00          CPX #0
11382    F596  D0 D4          BNE L_TAPE_CS_NEXT
11383      
11384    F598  60             RTS
11385    
11386    
11387    ; Calculate the size of the BASIC program and store it in V_TAPE_BlockSize
11388    
11389    F_TAPE_GetBASIC_Size
11390    
11391    F599  38             SEC
11392    F59A  A5 7B          LDA Svarl
11393    F59C  E9 00          SBC #<Ram_base
11394    F59E  8D 00 09       STA V_TAPE_BlockSize
11395    F5A1  A5 7C          LDA Svarh
11396    F5A3  E9 0C          SBC #>Ram_base
11397    F5A5  8D 01 09       STA V_TAPE_BlockSize + 1
11398      
11399    F5A8  60             RTS
11400    
11401    
11402    ;*****************************************************************************************
11403    ;**                                                                                     **
11404    ;**                Timing and Synchronization functions go here.                        **
11405    ;**                ---------------------------------------------                        **
11406    ;**                                                                                     **
11407    ;*****************************************************************************************
11408    
11409    
11410    ; Wait for 50uS.  Note that JSR's cost 6 cycles
11411    
11412    F_TAPE_Phasetime_pause
11413    ; Each pass takes 10 cycles unless across a page boundary then it's 11 for an error of 10%!!
11414    
11415    ; Also, we need to make up the loss of 12 Cycles in calling it and in theory also the variable loading
11416    ; at the time of the call.
11417    
11418    ; First we disregard 20 cycles, then we burn them at 10 cycles a pass.
11419    
11420    F5A9  A2 08          LDX #C_TAPE_Phasetime					; 2 Cycles
11421    F5AB  CA             DEX							; 2 Cycles saving 10
11422    F5AC  CA             DEX							; 2 Cycles saving 10
11423    F5AD  EA             NOP							; 2 Cycles
11424    F5AE  EA             NOP							; 2 Cycles
11425    F5AF  EA             NOP							; 2 Cycles
11426    F5B0  EA             NOP							; 2 Cycles
11427      
11428    TAPE_Phasetime_loop
11429    F5B1  CA             DEX							; 2 Cycles
11430    F5B2  EA             NOP							; 2 Cycles
11431    F5B3  EA             NOP							; 2 Cycles
11432    F5B4  EA             NOP							; 2 Cycles
11433    F5B5  D0 FA          BNE TAPE_Phasetime_loop				; 2 Cycles unless across pages.
11434      
11435    F5B7  60             RTS							; 6 Cycles
11436      
11437      
11438      
11439      
11440    ;*****************************************************************************************
11441    ;**                                                                                     **
11442    ;**             Output Generating Functions.  Spoiler, It's all bitbashed!              **
11443    ;**             ----------------------------------------------------------              **
11444    ;**                                                                                     **
11445    ;*****************************************************************************************
11446      
11447        
11448    ;===============================================================================================
11449    ; TAPE Bit pulse generator  Takes the Z bit into consideration.
11450    
11451    
11452    F_TAPE_BitGen
11453    
11454    F5B8  A0 08          LDY #C_TAPE_bitcycles					; Setup bitcycles loop
11455      
11456    TAPE_bitcycles_loop
11457    F5BA  48             PHA
11458    F5BB  C9 00          CMP #0
11459    F5BD  F0 05          BEQ TAPE_No_Pulse
11460      
11461    
11462    F5BF  A9 80          LDA #TAPE_out						; Set high phase
11463    F5C1  8D 40 C0       STA TAPE_IOP
11464    TAPE_No_Pulse
11465    F5C4  20 A9 F5       JSR F_TAPE_Phasetime_pause				; Wait hightone time which is eight times phase time.
11466    F5C7  20 A9 F5       JSR F_TAPE_Phasetime_pause				; This is so that the same loop can be used to capture the data for serial input
11467    F5CA  20 A9 F5       JSR F_TAPE_Phasetime_pause
11468    F5CD  20 A9 F5       JSR F_TAPE_Phasetime_pause
11469    F5D0  20 A9 F5       JSR F_TAPE_Phasetime_pause
11470    F5D3  20 A9 F5       JSR F_TAPE_Phasetime_pause
11471    F5D6  20 A9 F5       JSR F_TAPE_Phasetime_pause
11472    F5D9  20 A9 F5       JSR F_TAPE_Phasetime_pause
11473      
11474    
11475      
11476    
11477    F5DC  A9 00          LDA #0
11478    F5DE  8D 40 C0       STA TAPE_IOP						; Set low phase
11479    F5E1  20 A9 F5       JSR F_TAPE_Phasetime_pause				; Wait hightone time
11480    F5E4  20 A9 F5       JSR F_TAPE_Phasetime_pause
11481    F5E7  20 A9 F5       JSR F_TAPE_Phasetime_pause
11482    F5EA  20 A9 F5       JSR F_TAPE_Phasetime_pause
11483    F5ED  20 A9 F5       JSR F_TAPE_Phasetime_pause
11484    F5F0  20 A9 F5       JSR F_TAPE_Phasetime_pause
11485    F5F3  20 A9 F5       JSR F_TAPE_Phasetime_pause
11486    F5F6  20 A9 F5       JSR F_TAPE_Phasetime_pause
11487      
11488    F5F9  68             PLA
11489    F5FA  88             DEY
11490    F5FB  D0 BD          BNE TAPE_bitcycles_loop
11491    
11492    F5FD  60             RTS
11493      
11494      
11495    ;===============================================================================================  
11496    ; Tape byte output routine LSb first.  Accumulator holds the current byte.
11497    
11498    F_TAPE_ByteOut
11499    F5FE  08             PHP								; Save and disable IRQ status.
11500    F5FF  78             SEI
11501      
11502    F600  48             PHA								; Generate start bit.
11503    F601  A9 01          LDA #1
11504    F603  20 B8 F5       JSR F_TAPE_BitGen
11505    F606  68             PLA
11506    
11507    F607  A2 08          LDX #8							; Set our bit counter for 8 bits.
11508      
11509    TAPE_Nextbit
11510    F609  48             PHA								; Save the byte for later use.
11511    F60A  DA             PHX								; Save our counter
11512      
11513    F60B  29 01          AND #1							; Keep just the bit of interest.
11514    F60D  20 B8 F5       JSR F_TAPE_BitGen						; Output our bit.
11515    
11516    F610  FA             PLX								; Recover our counter
11517    F611  68             PLA								; Recover our working byte out
11518      
11519    F612  4A             LSR								; Move on to the next bit
11520    F613  CA             DEX								; Decrement our counter
11521      
11522    F614  D0 F3          BNE TAPE_Nextbit						; Keep going until completed.
11523      
11524    F616  48             PHA								; Generate stop bit
11525    F617  A9 00          LDA #0
11526    F619  20 B8 F5       JSR F_TAPE_BitGen
11527    F61C  A9 00          LDA #0							; Generate first guard bit
11528    F61E  20 B8 F5       JSR F_TAPE_BitGen
11529    F621  A9 00          LDA #0							; Generate second guard bit
11530    F623  20 B8 F5       JSR F_TAPE_BitGen
11531    ;  LDA #0							; Generate third guard bit!
11532    ;  JSR F_TAPE_BitGen
11533    ;  LDA #0							; Generate fourth guard bit!
11534    ;  JSR F_TAPE_BitGen
11535    
11536    ; FINDME GUARDBITS
11537    F626  68             PLA
11538      
11539    F627  28             PLP								; Restore IRQ status
11540      
11541    F628  60             RTS
11542    
11543    
11544    ;===============================================================================================  
11545    ; Block output routine
11546    ;
11547    ; This requires the starting address and number of bytes output to operate.
11548    ; X contains the low byte of the count, Y contains the high byte and a two byte zero page variable
11549    ; holds the starting address, which is incremented as used.
11550    
11551    F_TAPE_BlockOut
11552    
11553    F629  20 59 F6       JSR F_TAPE_Leader						; Generate block leader
11554    
11555    F62C  AE 00 09       LDX V_TAPE_BlockSize						; Get the low byte of BlockStart
11556    F62F  AC 01 09       LDY V_TAPE_BlockSize+1					; Get the high byte of BlockStart
11557      
11558    L_TAPE_BlockOut
11559      
11560    F632  B2 E5          LDA (TAPE_BlockLo)						; Get the byte to output to tape
11561      
11562    F634  DA             PHX
11563    F635  5A             PHY
11564    F636  20 FE F5       JSR F_TAPE_ByteOut						; Transmit the byte.
11565    F639  7A             PLY
11566    F63A  FA             PLX
11567    
11568    
11569      
11570    F63B  A5 E5          LDA TAPE_BlockLo						; Increment our byte pointer
11571    F63D  18             CLC
11572    F63E  69 01          ADC #1
11573    F640  85 E5          STA TAPE_BlockLo
11574    F642  A5 E6          LDA TAPE_BlockHi
11575    F644  69 00          ADC #0
11576    F646  85 E6          STA TAPE_BlockHi  
11577    
11578      
11579    TAPE_BlockOut_CheckZero_B
11580    F648  C0 00          CPY #0
11581    F64A  D0 05          BNE B_TAPE_BlockOut_Decrement
11582    F64C  E0 00          CPX #0
11583    F64E  D0 01          BNE B_TAPE_BlockOut_Decrement
11584    
11585    F650  60             RTS
11586    
11587    B_TAPE_BlockOut_Decrement
11588    F651  CA             DEX
11589    F652  E0 FF          CPX #$FF
11590    F654  D0 DC          BNE L_TAPE_BlockOut
11591    F656  88             DEY
11592    F657  80 D9          BRA L_TAPE_BlockOut
11593    
11594      
11595    
11596    ;===============================================================================================  
11597    ; Tape leader_tone  
11598    
11599    F_TAPE_Leader
11600    F659  A2 64          LDX #TAPE_Leader_Bytes				; Put the leader cycles low byte into X
11601    
11602    TAPE_leader_lp
11603    F65B  DA             PHX							; Save our cycle counter for later
11604      
11605    F65C  A9 AA          LDA #C_TAPE_LeaderByte
11606    F65E  20 FE F5       JSR F_TAPE_ByteOut					; Send leader byte
11607    
11608    
11609    F661  FA             PLX							; Retrieve our counter
11610    
11611    F662  CA             DEX							; Decrement our counter
11612    F663  D0 F6          BNE TAPE_leader_lp					; and loopback as necessary
11613    F665  A9 55          LDA #C_TAPE_EndOfLeaderByte
11614    F667  20 FE F5       JSR F_TAPE_ByteOut					; Send Terminating byte
11615    
11616    F66A  60             RTS
11617    
11618    
11619    ;*****************************************************************************************
11620    ;**                                                                                     **
11621    ;**              Input Generating Functions.  Spoiler, It's all bitbashed!              **
11622    ;**              ---------------------------------------------------------              **
11623    ;**                                                                                     **
11624    ;*****************************************************************************************
11625    
11626    
11627    ;===============================================================================================  
11628    ; Tape line status sampler, temporarily flipped  
11629    
11630    
11631    F_TAPE_Sample_Tapeline
11632    F66B  AD 40 C0       LDA TAPE_IOP						; Get sample
11633    F66E  29 40          AND #TAPE_in
11634      
11635    F670  F0 02          BEQ TAPE_line_low					; Set or clear carry as needed.
11636    F672  38             SEC
11637    F673  60             RTS
11638      
11639    TAPE_line_low
11640    F674  18             CLC
11641    F675  60             RTS
11642    
11643    
11644    ;===============================================================================================
11645    ; Pulse Decoding engine.  This is where deserialisation happens.
11646    
11647    TAPE_PulseDecoder
11648    F676  AD 08 09       LDA TAPE_StartDet					; If the start bit has been detected
11649    F679  D0 1A          BNE TAPE_SamplePos_Check				; Seek rising edge and end otherwise
11650      
11651    F67B  AD 06 09       LDA TAPE_Demod_Status					; Detect rising edge
11652    F67E  F0 14          BEQ TAPE_NotRising
11653    F680  AD 07 09       LDA TAPE_Demod_Last
11654    F683  D0 0F          BNE TAPE_NotRising
11655    
11656    F685  A9 01          LDA #1						; Store rising edge signal
11657    F687  8D 08 09       STA TAPE_StartDet
11658    F68A  A9 14          LDA #C_TAPE_Sample_Offset				; Start the counter for mid-bit
11659    F68C  8D 0C 09       STA TAPE_Sample_Position
11660    F68F  A9 0A          LDA #C_TAPE_BitsPerFrame
11661    F691  8D 0A 09       STA TAPE_BitsToDecode
11662    
11663    TAPE_NotRising
11664    F694  60             RTS
11665    
11666    TAPE_SamplePos_Check
11667    F695  A9 00          LDA #0						; Are we at the bit sample position
11668    F697  CD 0C 09       CMP TAPE_Sample_Position
11669    F69A  F0 04          BEQ TAPE_AtStartBit
11670      
11671    F69C  CE 0C 09       DEC TAPE_Sample_Position				; Decrement sample position end.
11672    F69F  60             RTS
11673      
11674    TAPE_AtStartBit						; At start bit?
11675    F6A0  AD 0A 09       LDA TAPE_BitsToDecode
11676    F6A3  C9 0A          CMP #C_TAPE_BitsPerFrame
11677    F6A5  D0 17          BNE TAPE_AtStopBit
11678      
11679    F6A7  AD 06 09       LDA TAPE_Demod_Status					; Branch on start bit state.
11680    F6AA  D0 09          BNE TAPE_AdjustCountersStart
11681      
11682    F6AC  A9 00          LDA #0						; Path of invalid start bit.
11683    F6AE  8D 08 09       STA TAPE_StartDet					; Clear start condition
11684    F6B1  8D 09 09       STA TAPE_RX_Status					; and status register.
11685    F6B4  60             RTS
11686      
11687    TAPE_AdjustCountersStart
11688    F6B5  A9 36          LDA #C_TAPE_Bitlength					; Start the counter for the next bit to sample
11689    F6B7  8D 0C 09       STA TAPE_Sample_Position
11690    F6BA  CE 0A 09       DEC TAPE_BitsToDecode
11691    F6BD  60             RTS
11692      
11693    TAPE_AtStopBit						; Stop bit?
11694    F6BE  AD 0A 09       LDA TAPE_BitsToDecode
11695    F6C1  C9 01          CMP #1
11696    F6C3  D0 1B          BNE TAPE_AtDataBit
11697    
11698    F6C5  AD 06 09       LDA TAPE_Demod_Status
11699    F6C8  D0 0B          BNE TAPE_Overrun
11700      
11701    F6CA  A9 00          LDA #0						; Clear Start detect bit
11702    F6CC  8D 08 09       STA TAPE_StartDet
11703    F6CF  A9 04          LDA #TAPE_Stat_RXFull					; Indicate byte received
11704    F6D1  8D 09 09       STA TAPE_RX_Status
11705    F6D4  60             RTS
11706      
11707    TAPE_Overrun
11708    F6D5  A9 00          LDA #0						; Clear Start detect bit
11709    F6D7  8D 08 09       STA TAPE_StartDet
11710    F6DA  A9 01          LDA #TAPE_Stat_overrun				; Indicate byte received
11711    F6DC  8D 09 09       STA TAPE_RX_Status
11712    F6DF  60             RTS
11713    
11714    TAPE_AtDataBit
11715    F6E0  AD 06 09       LDA TAPE_Demod_Status					; Shift our bit into the byte received LSb when not a stop bit
11716    F6E3  6A             ROR
11717    F6E4  6E 0B 09       ROR TAPE_ByteReceived
11718      
11719    
11720    F6E7  CE 0A 09       DEC TAPE_BitsToDecode					; Adjust counters accordingly
11721    F6EA  A9 36          LDA #C_TAPE_Bitlength
11722    F6EC  8D 0C 09       STA TAPE_Sample_Position
11723     
11724    F6EF  60             RTS
11725      
11726      
11727    
11728    
11729    ;*****************************************************************************************
11730    ;**                                                                                     **
11731    ;**           Tape Input Functions.  These are all hand calibrated so take care.        **
11732    ;**           ------------------------------------------------------------------        **
11733    ;**                                                                                     **
11734    ;*****************************************************************************************
11735    
11736    
11737    
11738    
11739    
11740    F_TAPE_FindStart
11741    F6F0  20 BB F7       JSR F_TAPE_GetByte
11742    F6F3  AD 09 09       LDA TAPE_RX_Status
11743      
11744    F6F6  C9 08          CMP #TAPE_Stat_Escape						; Break on Escape condition
11745    F6F8  D0 01          BNE TAPE_LeaderNoBreak
11746      
11747    F6FA  60             RTS
11748      
11749    TAPE_LeaderNoBreak
11750    F6FB  C9 01          CMP #TAPE_Stat_overrun
11751    F6FD  F0 F1          BEQ F_TAPE_FindStart
11752      
11753    F6FF  AD 0B 09       LDA TAPE_ByteReceived
11754    F702  C9 55          CMP #C_TAPE_EndOfLeaderByte					; Keep trying until end of leader byte is received
11755    F704  D0 EA          BNE F_TAPE_FindStart
11756      
11757    F706  60             RTS
11758    
11759    
11760    
11761    
11762    ;===============================================================================================  
11763    ; Block read routine
11764    ;
11765    ; This requires the starting address and number of bytes output to operate.
11766    ; X contains the low byte of the count, Y contains the high byte and a two byte zero page variable
11767    ; holds the starting address, which is incremented as used.
11768    
11769    F_TAPE_BlockIn
11770    
11771    F707  20 F0 F6       JSR F_TAPE_FindStart						; Follow the leader signal
11772      
11773    F70A  AD 09 09       LDA TAPE_RX_Status
11774    F70D  C9 08          CMP #TAPE_Stat_Escape
11775    F70F  F0 1D          BEQ TAPE_BlockIn_Sig_Escape
11776      
11777    F711  AE 00 09       LDX V_TAPE_BlockSize						; Get the low byte of BlockStart
11778    F714  AC 01 09       LDY V_TAPE_BlockSize+1					; Get the high byte of BlockStart
11779      
11780    F717  A9 00          LDA #0							; Initialise BlockIn's status register
11781    F719  8D 0D 09       STA TAPE_BlockIn_Status
11782      
11783    L_TAPE_BlockIn
11784    
11785    F71C  DA             PHX								; Get a byte from the tape interface
11786    F71D  5A             PHY
11787    F71E  20 BB F7       JSR F_TAPE_GetByte
11788    F721  7A             PLY
11789    F722  FA             PLX
11790      
11791    F723  AD 09 09       LDA TAPE_RX_Status						; failing gracefully upon bad events.
11792    F726  C9 04          CMP #TAPE_Stat_RXFull
11793    F728  F0 10          BEQ TAPE_BlockIn_Store
11794      
11795    F72A  C9 08          CMP #TAPE_Stat_Escape
11796    F72C  D0 06          BNE TAPE_BlockIn_CheckError
11797      
11798    TAPE_BlockIn_Sig_Escape  
11799    F72E  A9 02          LDA #TAPE_BlockIn_Escape
11800    F730  8D 0D 09       STA TAPE_BlockIn_Status
11801    F733  60             RTS								; Escape
11802      
11803    TAPE_BlockIn_CheckError  
11804    F734  A9 04          LDA #TAPE_BlockIn_Error
11805    F736  8D 0D 09       STA TAPE_BlockIn_Status
11806    F739  60             RTS								; Failed  
11807      
11808    TAPE_BlockIn_Store
11809    F73A  AD 0B 09       LDA TAPE_ByteReceived						; Store our received byte to our current pointer address.
11810    F73D  92 E5          STA (TAPE_BlockLo)
11811    
11812    F73F  A5 E5          LDA TAPE_BlockLo						; Increment our byte pointer
11813    F741  18             CLC
11814    F742  69 01          ADC #1
11815    F744  85 E5          STA TAPE_BlockLo
11816    F746  A5 E6          LDA TAPE_BlockHi
11817    F748  69 00          ADC #0
11818    F74A  85 E6          STA TAPE_BlockHi
11819    
11820    TAPE_BlockIn_DecCounter
11821    F74C  CA             DEX
11822    F74D  E0 FF          CPX #$FF
11823    F74F  D0 01          BNE TAPE_CheckBlockInCounterZero_B
11824    F751  88             DEY
11825    
11826    TAPE_CheckBlockInCounterZero_B  
11827    F752  C0 00          CPY #0
11828    F754  D0 C6          BNE L_TAPE_BlockIn
11829    F756  E0 00          CPX #0
11830    F758  D0 C2          BNE L_TAPE_BlockIn
11831    
11832    TAPE_BlockIn_Finish
11833    F75A  A9 01          LDA #TAPE_BlockIn_Complete					; Indicate tast completion
11834    F75C  8D 0D 09       STA TAPE_BlockIn_Status
11835    F75F  60             RTS
11836       
11837      
11838    F_TAPE_VerifyBlock
11839    
11840    F760  20 F0 F6       JSR F_TAPE_FindStart						; Follow the leader signal
11841      
11842    F763  AD 09 09       LDA TAPE_RX_Status
11843    F766  C9 08          CMP #TAPE_Stat_Escape
11844    F768  F0 1D          BEQ TAPE_Verify_Sig_Escape
11845      
11846    F76A  AE 00 09       LDX V_TAPE_BlockSize						; Get the low byte of BlockStart
11847    F76D  AC 01 09       LDY V_TAPE_BlockSize+1					; Get the high byte of BlockStart
11848      
11849    F770  A9 01          LDA #TAPE_Verify_Good						; Initialise Verify's status register
11850    F772  8D 30 09       STA V_TAPE_Verify_Status
11851      
11852    L_TAPE_BlockVerify
11853    
11854    F775  DA             PHX								; Get a byte from the tape interface
11855    F776  5A             PHY
11856    F777  20 BB F7       JSR F_TAPE_GetByte
11857    F77A  7A             PLY
11858    F77B  FA             PLX
11859      
11860    F77C  AD 09 09       LDA TAPE_RX_Status						; did we capture a good byte?
11861    F77F  C9 04          CMP #TAPE_Stat_RXFull
11862    F781  F0 10          BEQ TAPE_Verify_Check
11863      
11864    F783  C9 08          CMP #TAPE_Stat_Escape						; Did we press escape?
11865    F785  D0 06          BNE TAPE_Verify_CheckError
11866      
11867    TAPE_Verify_Sig_Escape  
11868    F787  A9 02          LDA #TAPE_Verify_Escape					; Signal that we pressed escape and return.
11869    F789  8D 30 09       STA V_TAPE_Verify_Status
11870    F78C  60             RTS
11871      
11872    TAPE_Verify_CheckError						; Signal the encountered error and return.
11873    F78D  A9 04          LDA #TAPE_Verify_Error
11874    F78F  8D 30 09       STA V_TAPE_Verify_Status
11875    F792  60             RTS  
11876      
11877    TAPE_Verify_Check
11878    F793  AD 0B 09       LDA TAPE_ByteReceived						; Compare our fectched byte with the one in BASIC memory.
11879    F796  D2 E5          CMP (TAPE_BlockLo)
11880    F798  D0 F3          BNE TAPE_Verify_CheckError					; Signal inconsistency as an error.
11881      
11882    F79A  A5 E5          LDA TAPE_BlockLo						; Increment our byte pointer
11883    F79C  18             CLC
11884    F79D  69 01          ADC #1
11885    F79F  85 E5          STA TAPE_BlockLo
11886    F7A1  A5 E6          LDA TAPE_BlockHi
11887    F7A3  69 00          ADC #0
11888    F7A5  85 E6          STA TAPE_BlockHi
11889    
11890    TAPE_Verify_DecCounter
11891    F7A7  CA             DEX
11892    F7A8  E0 FF          CPX #$FF
11893    F7AA  D0 01          BNE TAPE_CheckCounterZero_B
11894    F7AC  88             DEY
11895      
11896    TAPE_CheckCounterZero_B
11897    F7AD  C0 00          CPY #0							; Check to see if we have done yet.
11898    F7AF  D0 C4          BNE L_TAPE_BlockVerify
11899    F7B1  E0 00          CPX #0
11900    F7B3  D0 C0          BNE L_TAPE_BlockVerify
11901      
11902    TAPE_Verify_Finish
11903    F7B5  A9 01          LDA #TAPE_Verify_Good						; Indicate test completion
11904    F7B7  8D 30 09       STA V_TAPE_Verify_Status
11905    F7BA  60             RTS
11906    
11907    
11908    ;===============================================================================================
11909    ; Byte Reader.
11910    
11911    F_TAPE_GetByte
11912    
11913    ; First some initial housekeeping
11914    
11915    F7BB  08             PHP							; Save and disable IRQ status
11916    F7BC  78             SEI
11917    
11918    F7BD  A9 00          LDA #0
11919    F7BF  8D 06 09       STA TAPE_Demod_Status					; Start our bit demod with zero.
11920    F7C2  8D 07 09       STA TAPE_Demod_Last					; Set our initial demod status too.
11921    F7C5  8D 05 09       STA TAPE_LineUptime					; Set our initial uptime counter to zero.
11922    F7C8  8D 09 09       STA TAPE_RX_Status					; Clear our Status register
11923      
11924    TAPE_pulselatch
11925      
11926    F7CB  AD 09 09       LDA TAPE_RX_Status
11927    F7CE  D0 0A          BNE TAPE_ByteCaptured					; Check status for received byte.
11928      
11929    F7D0  20 54 EC       JSR ACIA1in						; Just in case the user needs to get out of this loop
11930    F7D3  90 07          BCC TAPE_ContLoop					; Caught in a landsliiiide, no escape TO re-al-ih-teeeee!
11931    F7D5  A9 08          LDA #TAPE_Stat_Escape
11932    F7D7  8D 09 09       STA TAPE_RX_Status
11933      
11934    
11935    TAPE_ByteCaptured
11936    F7DA  28             PLP							; Restore IRQ status
11937      
11938    F7DB  60             RTS							; Done
11939    
11940    
11941    ; Services that use the pulse decoded go here.
11942    
11943    TAPE_ContLoop
11944    F7DC  20 76 F6       JSR TAPE_PulseDecoder					; We gotta do something with these pulses right...?
11945    
11946    F7DF  AD 06 09       LDA TAPE_Demod_Status					; Update some variables
11947    F7E2  8D 07 09       STA TAPE_Demod_Last
11948    
11949    ; =-=-=-=-=-=-=-=-----------------=-=-=-=-=-=-=-=---------=-=-=-=-=-=-=-=-
11950    ;
11951    ; The actual pulse demodulation code starts here
11952    ;
11953    ; =-=-=-=-=-=-=-=-----------------=-=-=-=-=-=-=-=---------=-=-=-=-=-=-=-=-
11954      
11955    F7E5  20 A9 F5       JSR F_TAPE_Phasetime_pause				; and delay for our respective looptime
11956      
11957    F7E8  20 6B F6       JSR F_TAPE_Sample_Tapeline				; Update status
11958    F7EB  90 0A          BCC TAPE_DontSet
11959      
11960    F7ED  A9 01          LDA #1
11961    F7EF  8D 06 09       STA TAPE_Demod_Status					; Set our line status to up
11962    F7F2  A9 0A          LDA #10						; THIS WAS WORKING AT 7
11963    F7F4  8D 05 09       STA TAPE_LineUptime					; Reset our latch counter
11964      
11965    TAPE_DontSet
11966    F7F7  AD 05 09       LDA TAPE_LineUptime
11967    F7FA  F0 06          BEQ TAPE_AtMinimum
11968      
11969    F7FC  CE 05 09       DEC TAPE_LineUptime
11970    F7FF  4C CB F7       JMP TAPE_pulselatch
11971        
11972    TAPE_AtMinimum
11973    F802  A9 00          LDA #0						; Clear our line status
11974    F804  8D 06 09       STA TAPE_Demod_Status
11975    F807  4C CB F7       JMP TAPE_pulselatch
11976    
11977    
11978      .INCLUDE "AY_DRIVER.asm"
11979    ; AY-3-891x Register Driver
11980    ;
11981    ; By Duncan Gunn.
11982    
11983    
11984    ; AY_6522 Registers
11985    
11986      C0E0             AY_6522_Base	 	=	$C0E0
11987      C0E0             AY_6522_ORB		=	AY_6522_Base
11988      C0E1             AY_6522_ORA		=	AY_6522_Base + $01
11989      C0E2             AY_6522_DDRB		=	AY_6522_Base + $02
11990      C0E3             AY_6522_DDRA		=	AY_6522_Base + $03
11991      C0E4             AY_6522_T1C_L		=	AY_6522_Base + $04
11992      C0E5             AY_6522_T1C_H		=	AY_6522_Base + $05
11993      C0E6             AY_6522_L1L_L		=	AY_6522_Base + $06
11994      C0E7             AY_6522_L1L_H		=	AY_6522_Base + $07
11995      C0E8             AY_6522_T2C_L		=	AY_6522_Base + $08
11996      C0E9             AY_6522_T2C_H		=	AY_6522_Base + $09
11997      C0EA             AY_6522_SR		=	AY_6522_Base + $0A
11998      C0EB             AY_6522_ACR		=	AY_6522_Base + $0B
11999      C0EC             AY_6522_PCR		=	AY_6522_Base + $0C
12000      C0ED             AY_6522_IFR		=	AY_6522_Base + $0D
12001      C0EE             AY_6522_IER		=	AY_6522_Base + $0E
12002      C0EF             AY_6522_ORA_IRA		=	AY_6522_Base + $0F
12003    
12004    
12005    ; AY_6522 HW Mappings.
12006    
12007      C0E0             AY_DATAPORT		=	AY_6522_ORB
12008      C0E2             AY_DDR_DATA		=	AY_6522_DDRB
12009    
12010      C0E1             AY_CTRLPORT		=	AY_6522_ORA
12011      C0E3             AY_DDR_CTRL		=	AY_6522_DDRA
12012    
12013      0001             AY_CTRL_bit_BC1		= 	@00000001
12014      0002             AY_CTRL_bit_BDIR	=	@00000010
12015    
12016      0003             AY_CTRL_dir		=	AY_CTRL_bit_BC1 | AY_CTRL_bit_BDIR	; Set relevant port bits as outputs
12017      00FF             AY_DATA_out		=	$FF
12018      0000             AY_DATA_in		=	$0
12019    
12020    
12021    
12022    ; AY Registers
12023    
12024      0000             AY_CH_A_TP_FINE		= $0
12025      0001             AY_CH_A_TP_COARSE	= $1	; Bottom four bits only
12026      0002             AY_CH_B_TP_FINE		= $2
12027      0003             AY_CH_B_TP_COARSE	= $3	; Bottom four bits only
12028      0004             AY_CH_C_TP_FINE		= $4
12029      0005             AY_CH_C_TP_COARSE	= $5
12030      0006             AY_NOISE_PERIOD		= $6	; Bottom five bits only
12031      0007             AY_NOT_ENABLE		= $7	; Bitfield: See table 1 below
12032      0008             AY_CH_A_AMP		= $8	; M (Bit 5) when set uses the Envelope gen, otherwise B3-B0 sets the volume
12033      0009             AY_CH_B_AMP		= $9	; See channel A
12034      000A             AY_CH_C_AMP		= $A	; See channel A
12035      000B             AY_ENV_P_FINE		= $B	
12036      000C             AY_ENV_P_COARSE		= $C
12037      000D             AY_ENV_SH_CYC		= $D	; See table 2 below
12038      000E             AY_PORTA_REG		= $E	; Not implemented for the AY-3-8912
12039      000F             AY_PORTB_REG		= $F	; Not implemented for the AY-3-8912
12040    
12041    
12042    ; Table 1.  AY_NOT_ENABLE bitfield.
12043    ;
12044    ; +---------+-----------+-----------+
12045    ; | IN/nOUT |   nNOISE  |   nTONE   |
12046    ; +----+----+---+---+---+---+---+---+
12047    ; |IOB |IOA | C | B | A | C | B | A |
12048    ; +----+----+---+---+---+---+---+---+
12049    
12050      0080             AY_bit_nIOB		= @10000000
12051      0040             AY_bit_nIOA		= @01000000
12052      0020             AY_bit_nNOISE_C		= @00100000
12053      0010             AY_bit_nNOISE_B		= @00010000
12054      0008             AY_bit_nNOISE_A		= @00001000
12055      0004             AY_bit_nTONE_C		= @00000100
12056      0002             AY_bit_nTONE_B		= @00000010
12057      0001             AY_bit_nTONE_A		= @00000001
12058      00FF             AY_AllOff		= @11111111
12059    
12060    
12061    ; Table 2.  Envelope shape/cycle bitfield.
12062    ;
12063    ; +--------+--------+--------+--------+--------+--------+--------+--------+
12064    ; |   B7   |   B6   |   B5   |   B4   |   B3   |   B2   |   B1   |   B0   |
12065    ; +--------+--------+--------+--------+--------+--------+--------+--------+
12066    ; |          B7-B4 Not used.          | Cont   | Attack | Alt    | Hold   |
12067    ; +--------+--------+--------+--------+--------+--------+--------+--------+
12068    ;
12069    ; CONTinue causes the pattern to cycle when set.
12070    ; Setting Attack makes the envelope counter count up, but when cleared causes a count down instead.
12071    ; Setting ALTernate causes the counter to reverse direction at the end of each cycle.
12072    ; Setting HOLD limits the envelope generator to one cycle
12073    
12074      0008             AY_bit_CONT		= @00001000
12075      0004             AY_bit_ATTACK		= @00000100
12076      0002             AY_bit_ALT		= @00000010
12077      0001             AY_bit_HOLD		= @00000001
12078    
12079    
12080    ; AY control modes
12081    
12082      0000             AY_INACK		= 0
12083      0001             AY_READ			= AY_CTRL_bit_BC1
12084      0002             AY_WRITE		= AY_CTRL_bit_BDIR
12085      0003             AY_LAT_ADDR		= AY_CTRL_bit_BC1 | AY_CTRL_bit_BDIR
12086    
12087    
12088    ; AY Soundcard memory allocations.
12089    
12090      0A00             AY_Memstart		= $A00
12091      0A00             AY_Reg			= AY_Memstart
12092      0A01             AY_Data			= AY_Reg             + 1		; 16-bit reg for purposes of including double register accesses.
12093      0A03             AY_Mask			= AY_Data            + 2
12094      0A04             AY_Channel		= AY_Mask            + 1
12095      0A05             AY_Period		= AY_Channel         + 1
12096      0A07             AY_Volume		= AY_Period          + 2
12097      0A08             AY_Envelope_Period	= AY_Volume          + 1
12098      0A0A             AY_Envelope_Mode 	= AY_Envelope_Period + 2
12099    
12100    
12101    
12102    ; AY_Initialisation routine.
12103    
12104    AY_Init
12105    F80A  A9 00          LDA #0
12106    F80C  8D E1 C0       STA AY_CTRLPORT	; Let's make our control port inactive first.
12107    F80F  A9 03          LDA #AY_CTRL_dir
12108    F811  8D E3 C0       STA AY_DDR_CTRL  
12109    
12110    F814  A2 0F          LDX #$F		; Clear all the registers
12111    AY_Init_Loop
12112    
12113    F816  A9 00          LDA #0
12114    F818  20 9F F8       JSR AY_wr_to_reg
12115    F81B  CA             DEX
12116    F81C  D0 F8          BNE AY_Init_Loop
12117    
12118    F81E  A9 07          LDA #AY_NOT_ENABLE
12119    F820  20 9F F8       JSR AY_wr_to_reg
12120    
12121    F823  A9 FF          LDA #AY_AllOff	; Set all our enable bits to disabled. Blissful quiet!
12122    F825  8D 03 0A       STA AY_Mask
12123    F828  A2 07          LDX #AY_NOT_ENABLE
12124    F82A  20 9F F8       JSR AY_wr_to_reg
12125        
12126    F82D  60             RTS
12127    
12128    
12129    ; Channel enable function (VERIFIED)
12130    
12131    AY_EnableCh
12132    F82E  29 07          AND #7		; Get our channel selection, this includes noise.
12133      
12134    F830  AA             TAX			; Put our shift counter in X
12135    F831  A9 01          LDA #1		; and set our enable bit to 1
12136      
12137    F833  18             CLC
12138    AY_Enable_L		; Loop while X > 0
12139    F834  E0 00          CPX #0
12140    F836  F0 04          BEQ AY_Enable_B	; including 0 times for channel A (0)
12141      
12142    F838  CA             DEX			; Moving the 0
12143    F839  0A             ASL
12144    F83A  80 F8          BRA AY_Enable_L
12145    
12146    AY_Enable_B
12147    F83C  49 FF          EOR #$FF		; Make sure our enable bit is 0
12148    F83E  2D 03 0A       AND AY_Mask
12149    F841  8D 03 0A       STA AY_Mask
12150      
12151    F844  A2 07          LDX #AY_NOT_ENABLE
12152    F846  20 9F F8       JSR AY_wr_to_reg
12153    F849  60             RTS
12154      
12155      
12156    ; Channel disable function (VERIFIED)
12157    
12158    AY_DisableCh
12159    F84A  29 07          AND #7		; Get our channel selection, this includes noise.
12160      
12161    F84C  AA             TAX			; Put our shift counter in X
12162    F84D  A9 01          LDA #1		; and set our enable bit to 1
12163      
12164    F84F  18             CLC
12165    AY_Disable_L		; Loop while X > 0
12166    F850  E0 00          CPX #0
12167    F852  F0 04          BEQ AY_Disable_B	; including 0 times for channel A (0)
12168      
12169    F854  CA             DEX			; Moving the 0
12170    F855  0A             ASL
12171    F856  80 F8          BRA AY_Disable_L
12172    
12173    AY_Disable_B
12174    F858  0D 03 0A       ORA AY_Mask
12175    F85B  8D 03 0A       STA AY_Mask
12176      
12177    F85E  A2 07          LDX #AY_NOT_ENABLE
12178    F860  20 9F F8       JSR AY_wr_to_reg
12179    F863  60             RTS
12180    
12181    
12182    
12183    ; AY register read-write primitives
12184    ;
12185    
12186    ; Writes the register address to the AY
12187    ;
12188    ; Takes A as the register parameter. Corrupts A
12189    AY_wr_reg
12190    F864  8D E0 C0       STA AY_DATAPORT	; Place our register value on the AY bus
12191      
12192    F867  A9 FF          LDA #AY_DATA_out
12193    F869  8D E2 C0       STA AY_DDR_DATA	; And ensure the bus is an output.
12194      
12195    F86C  A9 03          LDA #AY_LAT_ADDR	; Latch our data to the AY
12196    F86E  8D E1 C0       STA AY_CTRLPORT
12197      ;NOP
12198      ;NOP
12199    F871  A9 00          LDA #AY_INACK		; And ensure out bus goes inactive again.
12200    F873  8D E1 C0       STA AY_CTRLPORT
12201    F876  60             RTS
12202    
12203    ; Writes data to the currently selected register
12204    ;
12205    ; Takes A as the register parameter. Corrupts A
12206    AY_wr_data
12207    F877  8D E0 C0       STA AY_DATAPORT	; Place our data on the AY bus
12208    
12209    F87A  A9 FF          LDA #AY_DATA_out
12210    F87C  8D E2 C0       STA AY_DDR_DATA
12211        
12212    F87F  A9 02          LDA #AY_WRITE
12213    F881  8D E1 C0       STA AY_CTRLPORT
12214    
12215    F884  A9 00          LDA #AY_INACK		; And ensure the bus is an output.
12216    F886  8D E1 C0       STA AY_CTRLPORT
12217    F889  60             RTS
12218    
12219    ; Read register		; Corrupts Y, returns the result in A.
12220    AY_rd_data
12221    F88A  A9 00          LDA #AY_DATA_in	; Make our bus an input so that the AY can drive it.
12222    F88C  8D E2 C0       STA AY_DDR_DATA
12223      
12224    F88F  A9 01          LDA #AY_READ		; Set our AY to output it's register contents
12225    F891  8D E1 C0       STA AY_CTRLPORT
12226      
12227    F894  AD E0 C0       LDA AY_DATAPORT	; Grab those contents and put them in Y
12228    F897  A8             TAY
12229      
12230    F898  A9 00          LDA #AY_INACK		; Put our AY but back inactive.
12231    F89A  8D E1 C0       STA AY_CTRLPORT
12232      
12233    F89D  98             TYA			; Put our result back into A
12234      
12235    F89E  60             RTS			; Were finished.
12236      
12237      
12238    ; The 'All in one' function.
12239    ;
12240    AY_wr_to_reg
12241    F89F  48             PHA
12242    F8A0  8A             TXA
12243      
12244    F8A1  20 64 F8       JSR AY_wr_reg
12245    F8A4  68             PLA
12246    F8A5  20 77 F8       JSR AY_wr_data
12247    F8A8  60             RTS
12248      
12249    
12250    ; For the users of BASIC, here's the easier read/write functions. 
12251    
12252    AY_Userwrite
12253    F8A9  AD 01 0A       LDA AY_Data
12254    F8AC  AE 00 0A       LDX AY_Reg
12255    F8AF  20 9F F8       JSR AY_wr_to_reg
12256    F8B2  60             RTS
12257      
12258    AY_Userread
12259    F8B3  AD 00 0A       LDA AY_Reg		; Select our register of interest.
12260    F8B6  20 64 F8       JSR AY_wr_reg
12261      
12262    F8B9  20 8A F8       JSR AY_rd_data	; Get the contents of the register of interest.
12263    F8BC  8D 01 0A       STA AY_Data
12264    F8BF  60             RTS
12265      
12266    AY_Userwrite_16
12267    F8C0  AD 01 0A       LDA AY_Data
12268    F8C3  AE 00 0A       LDX AY_Reg
12269    F8C6  20 9F F8       JSR AY_wr_to_reg
12270    F8C9  E8             INX
12271    F8CA  AD 02 0A       LDA AY_Data + 1
12272    F8CD  20 9F F8       JSR AY_wr_to_reg
12273    F8D0  60             RTS
12274      
12275    AY_Userread_16
12276    F8D1  AD 00 0A       LDA AY_Reg		; Select our register of interest.
12277    F8D4  20 64 F8       JSR AY_wr_reg
12278      
12279    F8D7  20 8A F8       JSR AY_rd_data	; Get the contents of the register of interest.
12280    F8DA  8D 01 0A       STA AY_Data
12281    F8DD  AD 00 0A       LDA AY_Reg		; Select our register of interest.
12282    
12283    F8E0  38             SEC
12284    F8E1  69 00          ADC #0
12285      
12286    F8E3  20 64 F8       JSR AY_wr_reg
12287      
12288    F8E6  20 8A F8       JSR AY_rd_data	; Get the contents of the register of interest.
12289    F8E9  8D 02 0A       STA AY_Data + 1
12290    F8EC  60             RTS
12291      
12292    
12293    ; *********************************************************************
12294    ;
12295    ;                       BASIC Extension commands
12296    ;
12297    ; *********************************************************************
12298    
12299    ; Sound command for BASIC
12300    ;
12301    ; Format: SOUND channel,period,vol
12302    
12303    AY_SOUND
12304    
12305    ; Get channel.
12306    
12307    F8ED  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12308    						; else do type mismatch
12309    F8F0  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12310      
12311    F8F3  A5 11          LDA Itempl					; Get our channel parameter.
12312    F8F5  8D 04 0A       STA AY_Channel				; And save them for the future.
12313    
12314    F8F8  20 04 CD       JSR LAB_1C01					; scan for "," , else do syntax error then warm start
12315      
12316    F8FB  AD 04 0A       LDA AY_Channel				; Mug trap channel for over range values.
12317    F8FE  89 F8          BIT #@11111000
12318    F900  D0 59          BNE AY_Parameter_FCER_B
12319    F902  38             SEC
12320    F903  E9 06          SBC #6
12321    F905  10 54          BPL AY_Parameter_FCER_B
12322        
12323    
12324    ; Get period.
12325    
12326    F907  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12327    						; else do type mismatch
12328    F90A  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12329      
12330    F90D  A5 11          LDA Itempl
12331    F90F  8D 05 0A       STA AY_Period
12332    F912  A5 12          LDA Itemph
12333    F914  8D 06 0A       STA AY_Period + 1
12334      
12335    F917  20 04 CD       JSR LAB_1C01					; scan for "," , else do syntax error then warm start  
12336      
12337      
12338    ; Get volume
12339      
12340    F91A  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12341    						; else do type mismatch
12342    F91D  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12343      
12344    F920  A5 11          LDA Itempl
12345    F922  8D 07 0A       STA AY_Volume
12346      
12347      
12348    ; Enact upon sound parameters
12349      
12350    F925  AD 04 0A       LDA AY_Channel				; Set our period
12351    F928  29 07          AND #7
12352    F92A  18             CLC
12353    F92B  0A             ASL
12354    F92C  AA             TAX
12355      
12356    F92D  AD 05 0A       LDA AY_Period
12357    F930  20 9F F8       JSR AY_wr_to_reg
12358    F933  E8             INX
12359    F934  AD 06 0A       LDA AY_Period + 1
12360    F937  20 9F F8       JSR AY_wr_to_reg
12361      
12362    F93A  AD 04 0A       LDA AY_Channel				; Set our volume
12363    F93D  29 07          AND #7
12364    F93F  18             CLC
12365    F940  69 08          ADC #8
12366    F942  AA             TAX
12367    F943  AD 07 0A       LDA AY_Volume
12368    F946  20 9F F8       JSR AY_wr_to_reg
12369      
12370    F949  AD 04 0A       LDA AY_Channel
12371    F94C  AE 07 0A       LDX AY_Volume
12372    F94F  E0 00          CPX #0
12373    F951  D0 04          BNE AY_EnableCh_B
12374    F953  20 4A F8       JSR AY_DisableCh
12375      
12376    F956  60             RTS
12377      
12378    AY_EnableCh_B
12379    F957  20 2E F8       JSR AY_EnableCh
12380    F95A  60             RTS
12381     
12382    AY_Parameter_FCER_B
12383    F95B  4C 3D D0       JMP LAB_FCER  
12384        
12385    
12386    ; ENVELOPE command.
12387    ;
12388    ; Format ENVELOPE period, mode  
12389    
12390    
12391    AY_ENVELOPE
12392    
12393    ; Get period.
12394    
12395    F95E  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12396    						; else do type mismatch
12397    F961  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12398      
12399    F964  A5 11          LDA Itempl
12400    F966  8D 08 0A       STA AY_Envelope_Period
12401    F969  A5 12          LDA Itemph
12402    F96B  8D 09 0A       STA AY_Envelope_Period + 1
12403      
12404    F96E  20 04 CD       JSR LAB_1C01					; scan for "," , else do syntax error then warm start
12405    
12406    ; Get mode
12407      
12408    F971  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12409    						; else do type mismatch
12410    F974  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12411      
12412    F977  A5 11          LDA Itempl
12413    F979  8D 0A 0A       STA AY_Envelope_Mode
12414      
12415    F97C  A2 0B          LDX #AY_ENV_P_FINE
12416    F97E  AD 08 0A       LDA AY_Envelope_Period
12417    F981  20 9F F8       JSR AY_wr_to_reg
12418    F984  E8             INX
12419    F985  AD 09 0A       LDA AY_Envelope_Period + 1
12420    F988  20 9F F8       JSR AY_wr_to_reg
12421      
12422    F98B  AD 0A 0A       LDA AY_Envelope_Mode
12423    F98E  A2 0D          LDX #AY_ENV_SH_CYC
12424    F990  20 9F F8       JSR AY_wr_to_reg
12425    F993  60             RTS
12426      .INCLUDE "IRQ_Handler.asm"
12427    ; IRQ Manager.
12428    ;
12429    ; Interrupt request handling and masking on per device basis.
12430    
12431    
12432    ; System constants
12433    
12434      0000             IRQH_Version_C		= 0					; Version 0 (Pre-release)
12435    
12436    
12437    ; IRQ Handler command codes
12438    ;
12439      0000             IRQH_Service_CMD	= 0					; Request IRQ Service
12440      0001             IRQH_Shutdown_CMD	= 1					; Shutdown IRQ gracefully
12441      0002             IRQH_Reset_CMD		= 2					; Reset the IRQ handler.
12442    
12443    
12444    ; IRQ Memory table
12445    ;
12446      0A20             IRQH_Table_Base		= $A20 					; Beginning of IRQ Handler Memory.
12447      0A20             IRQH_CallList		= IRQH_Table_Base			; All sixteen bytes for eight addresses.
12448      0A30             IRQH_CallReg		= IRQH_CallList + 16			; Two bytes containing an address being transferred.
12449      0A32             IRQH_ClaimsList		= IRQH_CallReg + 2			; Byte with list of calls that returned and IRQ Claim
12450      0A33             IRQH_MaskByte		= IRQH_ClaimsList + 1			; Byte containing IRQ Table entry mask bits. IRQ entry LSb is IRQ entry 0.
12451      0A34             IRQH_WorkingMask	= IRQH_MaskByte + 1			; Walking bit for masking and setting purposes.
12452      0A35             IRQH_CurrentEntry	= IRQH_WorkingMask + 1			; Pointer for IRQ Table entries.
12453      0A36             IRQH_CMD_Table		= IRQH_CurrentEntry + 1			; Table of IRQ handler commands with parameter space.  16 bytes.
12454    
12455      0016             IRQH_zero_range_C	= IRQH_CurrentEntry+17-IRQH_CallReg	; Amount to zero after IRQH_CallList.
12456    
12457    ; Table current size is 21 bytes.
12458    
12459    
12460    ; IRQ Handler Initialisation Call
12461    
12462    IRQH_Handler_Init_F
12463    F994  78             SEI						; Disable IRQ's so we don't break anything already happening.
12464      
12465    F995  A9 BC          LDA #<IRQH_Null_F				; Put the null IRQ Function address into IRQ_CallReg
12466    F997  8D 30 0A       STA IRQH_CallReg
12467    F99A  A9 F9          LDA #>IRQH_Null_F
12468    F99C  8D 31 0A       STA IRQH_CallReg + 1
12469      
12470    F99F  A9 07          LDA #7					; Point at the last table entry
12471    F9A1  A8             TAY
12472    
12473    IRQH_FillTable_L
12474    F9A2  20 C8 F9       JSR IRQH_SetIRQ_F				; Iterate copy to whole table
12475      
12476    F9A5  98             TYA
12477    F9A6  38             SEC
12478    F9A7  E9 01          SBC #1
12479    F9A9  A8             TAY
12480      
12481    F9AA  B0 F6          BCS IRQH_FillTable_L
12482      
12483    F9AC  A9 00          LDA #0					; Clear rest of the IRQ Handler's structure.
12484    F9AE  A2 00          LDX #0
12485      
12486    IRQH_FillRemaining_L
12487    F9B0  A9 00          LDA #0
12488    F9B2  9D 30 0A       STA IRQH_CallReg,X
12489    F9B5  E8             INX
12490      
12491    F9B6  8A             TXA						; Stop when the table is full.
12492    F9B7  C9 16          CMP #IRQH_zero_range_C
12493    F9B9  D0 F5          BNE IRQH_FillRemaining_L
12494      
12495    F9BB  60             RTS						; Return to caller.
12496      
12497      
12498    ; IRQ Null function
12499    
12500    IRQH_Null_F
12501    F9BC  AD 34 0A       LDA IRQH_WorkingMask				; Get our Working position
12502      
12503    F9BF  49 FF          EOR #$FF					; Unset our Claim bit.
12504    F9C1  2D 32 0A       AND IRQH_ClaimsList
12505    F9C4  8D 32 0A       STA IRQH_ClaimsList
12506      
12507    F9C7  60             RTS
12508      
12509    
12510    ; Function to atomically add an IRQ to the IRQ Table.
12511    
12512    IRQH_SetIRQ_F
12513    
12514    F9C8  08             PHP						; Assure atomic
12515    F9C9  78             SEI
12516      
12517    F9CA  0A             ASL						; Multiply our pointer by two as the table uses words not bytes.
12518      
12519    F9CB  AA             TAX						; Transfer our table reference to index X
12520      
12521    F9CC  AD 30 0A       LDA IRQH_CallReg				; Get our call low-byte
12522    F9CF  9D 20 0A       STA IRQH_CallList,X				; Store our low byte
12523      
12524    F9D2  AD 31 0A       LDA IRQH_CallReg + 1				; Get our call high-byte
12525    F9D5  E8             INX
12526    F9D6  9D 20 0A       STA IRQH_CallList,X				; Store our high byte.
12527      
12528    F9D9  28             PLP						; End atomic operation
12529    F9DA  60             RTS
12530      
12531      
12532    ; Function to atomically clear an IRQ from the table
12533    
12534    IRQH_ClrIRQ_F
12535    F9DB  08             PHP						; Assure atomic
12536    F9DC  78             SEI
12537    
12538    F9DD  0A             ASL						; Multiply our pointer by two
12539    F9DE  AA             TAX						; and place it in X
12540    
12541    F9DF  A9 BC          LDA #<IRQH_Null_F				; Transfer our Null function address to the table
12542    F9E1  9D 20 0A       STA IRQH_CallList,X
12543    F9E4  A9 F9          LDA #>IRQH_Null_F
12544    F9E6  E8             INX
12545    F9E7  9D 20 0A       STA IRQH_CallList,X
12546      
12547    F9EA  28             PLP						; End atomic operation
12548    F9EB  60             RTS
12549      
12550      
12551    ; IRQ Handler function.
12552    
12553    IRQH_ProcessIRQs
12554    F9EC  48             PHA						; Save processor registers
12555    F9ED  DA             PHX
12556    F9EE  5A             PHY
12557      
12558    F9EF  D8             CLD						; We have no idea what mode the processor was in when this was called so let's clear it.
12559      
12560    F9F0  AD 33 0A       LDA IRQH_MaskByte				; Get IRQ mask
12561    F9F3  F0 29          BEQ IRQH_FinishIRQs_B				; and quit early if all disabled.
12562      
12563    F9F5  A9 01          LDA #1					; Put 1 into our working mask
12564    F9F7  8D 34 0A       STA IRQH_WorkingMask				
12565    
12566    F9FA  A2 00          LDX #0					; Start with X at table entry 0
12567      
12568    IRQH_CheckCall_B  
12569    F9FC  AD 33 0A       LDA IRQH_MaskByte				; Check if we need to call that table entry or not
12570    F9FF  2D 34 0A       AND IRQH_WorkingMask
12571    FA02  F0 0A          BEQ IRQH_SkipCall_B
12572      
12573    
12574    FA04  A9 FA          LDA #>IRQH_Return_B				; Place our return address-1 on the stack for the ensuing RTS (which adds 1)
12575    FA06  48             PHA
12576    FA07  A9 0D          LDA #<IRQH_Return_B
12577    FA09  48             PHA
12578      
12579    FA0A  7C 20 0A       JMP (IRQH_CallList,X)				; Make the call, including the table offset
12580      
12581    IRQH_Return_B					; Since the 65C02 won't JSR to our chosen address, this is the return address
12582    FA0D  EA             NOP						; non executed packer.  It's cheaper than the arithmetic approach.
12583    
12584    IRQH_SkipCall_B
12585    FA0E  EE 35 0A       INC IRQH_CurrentEntry				; Advance to the next table entry
12586    FA11  E8             INX
12587    FA12  E8             INX
12588      
12589    FA13  8A             TXA						; Have we processed them all?
12590    FA14  C9 10          CMP #16					; If so, we shall go to the finish-line.
12591    FA16  F0 06          BEQ IRQH_FinishIRQs_B
12592      
12593    FA18  18             CLC						; Move our working mask to the next IRQ
12594    FA19  2E 34 0A       ROL IRQH_WorkingMask
12595      
12596    FA1C  80 DE          BRA IRQH_CheckCall_B				; Check the next call.
12597      
12598    IRQH_FinishIRQs_B
12599    FA1E  7A             PLY						; Retrieve processor registers
12600    FA1F  FA             PLX
12601    FA20  68             PLA
12602      
12603    FA21  40             RTI
12604      
12605      
12606    ; Function to return table base address and version number.
12607    ; Used for keeping programs compatible over generational changes.
12608    
12609    IRQH_SystemReport_F
12610    
12611    FA22  A9 00          LDA #IRQH_Version_C
12612    FA24  A2 20          LDX #<IRQH_Table_Base
12613    FA26  A0 0A          LDY #>IRQH_Table_Base
12614    FA28  60             RTS
12615      .INCLUDE "COUNTDOWN_IRQ.asm"
12616    ; Countdown IRQ.
12617    
12618    ; Adds a system countdown timer.  This is to be driven from the timer on the GPIO card.
12619    
12620    
12621    ; Variables
12622    
12623      0A46             CTR_V			= IRQH_CMD_Table+16		; This is our counter variable base address.
12624      0A48             CTR_LOAD_VAL_V		= CTR_V + 2			; This is the interval between counts in PHI2 ticks
12625    
12626    
12627    ; Constants
12628    
12629      9C3F             TIM_DELAY_C		= 39999		; This is the value we are going to use to set the timer. 10ms @4MHz
12630    
12631    
12632    ; Hardware constants
12633    
12634      C044             TIM_T1L			= TAPE_IOBASE + 4
12635      C045             TIM_T1H			= TAPE_IOBASE + 5
12636    
12637      C04B             TIM_ACR			= TAPE_IOBASE + $B
12638      C04D             TIM_IFR			= TAPE_IOBASE + $D
12639      C04E             TIM_IER			= TAPE_IOBASE + $E
12640    
12641      0080             IFR_IRQ_FLAG		= @10000000
12642      0040             IFR_TIM1_FLAG		= @01000000
12643    
12644    
12645    INIT_COUNTDOWN_IRQ
12646      
12647    FA29  08             PHP					; Add our interrupt guard
12648    FA2A  78             SEI
12649      
12650    FA2B  0D 33 0A       ORA IRQH_MaskByte			; Mark our IRQ as active.
12651    FA2E  8D 33 0A       STA IRQH_MaskByte
12652      
12653    FA31  A9 3F          LDA #<TIM_DELAY_C			; Load timer value to our variable
12654    FA33  8D 48 0A       STA CTR_LOAD_VAL_V
12655    FA36  A9 9C          LDA #>TIM_DELAY_C
12656    FA38  8D 49 0A       STA CTR_LOAD_VAL_V + 1
12657      
12658    FA3B  AD 4B C0       LDA TIM_ACR
12659    FA3E  09 40          ORA #@01000000			; Load Auxilliary Control Register with continuous interrupts on T1 with latching
12660    FA40  8D 4B C0       STA TIM_ACR
12661      
12662    FA43  AD 4E C0       LDA TIM_IER				; Start our interrupts running
12663    FA46  09 C0          ORA #@11000000
12664    FA48  8D 4E C0       STA TIM_IER
12665      
12666    FA4B  20 A2 FA       JSR TIM_Update_T1_F
12667      
12668    FA4E  28             PLP					; Restore our IRQ status
12669    
12670    FA4F  60             RTS
12671      
12672      
12673    
12674    COUNTDOWN_IRQ
12675    
12676    FA50  BD 36 0A       LDA IRQH_CMD_Table,X			; Process command shutdown command when asked.
12677    FA53  C9 01          CMP #IRQH_Shutdown_CMD
12678    FA55  F0 2F          BEQ COUNTDOWN_IRQ_SHUTDOWN
12679      
12680    FA57  AD 4D C0       LDA TIM_IFR				; Check whether this is our interrupt to claim
12681    FA5A  29 C0          AND #IFR_IRQ_FLAG | IFR_TIM1_FLAG
12682    FA5C  C9 C0          CMP #IFR_IRQ_FLAG | IFR_TIM1_FLAG
12683      
12684    FA5E  D0 25          BNE TIM_NOT_OUR_IRQ_B			; Branch politely if it isn't ours.
12685      
12686    FA60  AD 46 0A       LDA CTR_V				; When we reach zero, shutdown.
12687    FA63  0D 47 0A       ORA CTR_V + 1
12688    FA66  F0 1E          BEQ COUNTDOWN_IRQ_SHUTDOWN
12689    
12690    FA68  38             SEC					; Update our countdown counter.
12691    FA69  AD 46 0A       LDA CTR_V
12692    FA6C  E9 01          SBC #1
12693    FA6E  8D 46 0A       STA CTR_V
12694    FA71  AD 47 0A       LDA CTR_V + 1
12695    FA74  E9 00          SBC #0
12696    FA76  8D 47 0A       STA CTR_V + 1
12697      
12698    FA79  AD 44 C0       LDA TIM_T1L				; Read to this register to clear the interrupt.
12699      
12700    FA7C  AD 34 0A       LDA IRQH_WorkingMask			; Set our claims bit.
12701    FA7F  0D 32 0A       ORA IRQH_ClaimsList
12702    FA82  8D 32 0A       STA IRQH_ClaimsList
12703    
12704    TIM_NOT_OUR_IRQ_B
12705    FA85  60             RTS					; IRQ Handler done
12706    
12707        
12708    COUNTDOWN_IRQ_SHUTDOWN
12709    
12710    FA86  AD 44 C0       LDA TIM_T1L				; Read this register to clear the interrupt
12711    
12712    FA89  AD 4B C0       LDA TIM_ACR				; Disable Timer 1
12713    FA8C  29 3F          AND #@00111111			; only affecting our specific hardware
12714    FA8E  8D 4B C0       STA TIM_ACR
12715      
12716    FA91  A9 40          LDA #IFR_TIM1_FLAG			; Disable Our interrupt
12717    FA93  8D 4E C0       STA TIM_IER
12718      
12719    FA96  AD 34 0A       LDA IRQH_WorkingMask			; Unset our IRQ from the handler
12720    FA99  49 FF          EOR #$FF
12721    FA9B  2D 33 0A       AND IRQH_MaskByte
12722    FA9E  8D 33 0A       STA IRQH_MaskByte
12723        
12724    FAA1  60             RTS					; IRQ Handler done.
12725      
12726      
12727      
12728    TIM_Update_T1_F
12729    
12730    FAA2  08             PHP					; Save IRQ state and disable interrupts
12731    FAA3  78             SEI
12732      
12733    FAA4  AD 48 0A       LDA CTR_LOAD_VAL_V			; Load timer
12734    FAA7  8D 44 C0       STA TIM_T1L
12735    FAAA  AD 49 0A       LDA CTR_LOAD_VAL_V + 1
12736    FAAD  8D 45 C0       STA TIM_T1H				; Count commences from here (if running)
12737      
12738    FAB0  28             PLP					; Restore IRQ status
12739      
12740    FAB1  60             RTS
12741      .INCLUDE "XTRA_BASIC.asm"             ; Extra's for EhBASIC.
12742    ; Extra functions for EhBASIC
12743    
12744    
12745    ; Variables for use in Extra functions.
12746    
12747      0A10             V_XTRA_BASE   = $A10
12748    
12749      0A10             V_XTRA_PlotMode  = V_XTRA_BASE
12750      0A11             V_XTRA_Xcoord    = V_XTRA_PlotMode + 1
12751      0A12             V_XTRA_Ycoord    = V_XTRA_Xcoord   + 1
12752    
12753    
12754    ; Function to set the cursor location.
12755    
12756    XTRA_LOCATE_F
12757    
12758    FAB2  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12759    						; else do type mismatch
12760    FAB5  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12761      
12762    FAB8  A9 0E          LDA #14					; Set our column
12763    FABA  20 02 E2       JSR V_OUTP  
12764    FABD  A5 11          LDA   Itempl
12765    FABF  20 02 E2       jsr V_OUTP
12766      
12767    FAC2  20 04 CD       JSR   LAB_1C01				; scan for "," , else do syntax error then warm start
12768     
12769    FAC5  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12770    						; else do type mismatch
12771    FAC8  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12772      
12773    FACB  A9 0F          LDA #15					; Set our row
12774    FACD  20 02 E2       JSR V_OUTP  
12775    FAD0  A5 11          LDA   Itempl
12776    FAD2  20 02 E2       jsr V_OUTP
12777      
12778    FAD5  60             RTS
12779    
12780    
12781    ; Function to PLOT or UNPLOT a pixel
12782      
12783    XTRA_PLOT_F
12784    
12785    FAD6  A9 05          LDA #5					; Start with plot mode
12786    FAD8  8D 10 0A       STA V_XTRA_PlotMode
12787      
12788    FADB  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12789    						; else do type mismatch
12790    FADE  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12791      
12792    FAE1  A5 11          LDA Itempl					; Get our plot/unplot value
12793    
12794    FAE3  89 01          BIT #1
12795    FAE5  D0 05          BNE XTRA_NOT_Plotting_B
12796      
12797    FAE7  A9 06          LDA #6					; Set for unplot mode.
12798    FAE9  8D 10 0A       STA V_XTRA_PlotMode
12799     
12800    XTRA_NOT_Plotting_B
12801      
12802      
12803    FAEC  20 04 CD       JSR   LAB_1C01				; scan for "," , else do syntax error then warm start
12804     
12805    FAEF  20 D3 CB       JSR   LAB_EVNM				; evaluate expression and check is numeric,
12806    						; else do type mismatch
12807    FAF2  20 04 D6       JSR   LAB_F2FX				; save integer part of FAC1 in temporary integer
12808      
12809    FAF5  A5 11          LDA Itempl					; Save our X coordinate
12810    FAF7  8D 11 0A       STA V_XTRA_Xcoord
12811      
12812    FAFA  20 04 CD       JSR   LAB_1C01				; scan for "," , else do syntax error then warm start
12813     
12814    FAFD  20 D3 CB       JSR   LAB_EVNM				; evaluate expression and check is numeric,
12815    						; else do type mismatch
12816    FB00  20 04 D6       JSR   LAB_F2FX				; save integer part of FAC1 in temporary integer
12817      
12818    FB03  A5 11          LDA Itempl					; Save our Y coordinate
12819    FB05  8D 12 0A       STA V_XTRA_Ycoord
12820    
12821    ; Function to actually PLOT/UNPLOT.
12822    XTRA_SystemPlot_F
12823    FB08  AD 10 0A       LDA V_XTRA_PlotMode				; Write our plot command
12824    FB0B  20 02 E2       JSR V_OUTP
12825        
12826    FB0E  AD 11 0A       LDA V_XTRA_Xcoord				; Write our X co-ordinate
12827    FB11  20 02 E2       jsr V_OUTP
12828      
12829    FB14  AD 12 0A       LDA V_XTRA_Ycoord				; Write our Y co-ordinate
12830    FB17  20 02 E2       JSR V_OUTP
12831      
12832    FB1A  60             RTS
12833    
12834    
12835    ; BASIC CommandS for SPI.
12836    
12837    I2C_Start_BAS
12838    FB1B  4C D2 FB       JMP I2C_Start
12839    
12840    I2C_Stop_BAS
12841    FB1E  4C DD FB       JMP I2C_Stop
12842      
12843    I2C_Out_BAS					; This is a *function* as it returns ACK/NAK
12844    
12845    FB21  20 04 D6       JSR   LAB_F2FX                                ; save integer part of FAC1 in temporary integer
12846    FB24  A6 11          LDX Itempl
12847      
12848    FB26  8E D1 05       STX I2C_Byte					; Place it in the I2C Engine for transmission
12849    FB29  20 E8 FB       JSR I2C_Out					; Send it
12850      
12851    FB2C  AD D0 05       LDA I2C_Status				; Get our relevant status bits
12852    FB2F  29 03          AND #I2C_STA_NAK | I2C_STA_Timeout
12853      
12854    
12855    FB31  A8             TAY						; Copy status byte to Y
12856    FB32  4C 7A D1       JMP   LAB_1FD0                                ; convert Y to byte in FAC1 and return
12857    
12858    
12859    I2C_In_BAS					; This is a *function* as it returns ACK/NAK
12860    
12861    FB35  20 04 D6       JSR   LAB_F2FX                                ; save integer part of FAC1 in temporary integer
12862      
12863    FB38  AD D0 05       LDA I2C_Status				; Transfer our ACK/NAK to the status register.
12864    FB3B  29 FE          AND #~I2C_STA_NAK
12865    FB3D  8D D0 05       STA I2C_Status
12866    FB40  A5 11          LDA Itempl
12867    FB42  29 01          AND #I2C_STA_NAK
12868    FB44  0D D0 05       ORA I2C_Status
12869    FB47  8D D0 05       STA I2C_Status
12870      
12871    FB4A  20 38 FC       JSR I2C_In					; Get our byte
12872      
12873    FB4D  AD D1 05       LDA I2C_Byte
12874      
12875    
12876    FB50  A8             TAY						; Copy status byte to Y
12877    FB51  4C 7A D1       JMP   LAB_1FD0                                ; convert Y to byte in FAC1 and return
12878      JMP   LAB_1FD0                                ; convert Y to byte in FAC1 and return
12879      .INCLUDE "I2C_Lib.asm"		; I2C Support
12880    ; I2C (Inter Integrated Circuit) Bus Engine.
12881    ;
12882    
12883    ; Special considerations for this I2C implementation.
12884    ; ---------------------------------------------------
12885    ;
12886    ; 1) I2C is a MSb first protocol.
12887    ; 2) We are not implementing a slave mode here.
12888    ; 3) Multi-master support will *maybe* be added later. Will it be practical?
12889    ; 4) We ain't gonna be particularly fast, that's for sure.
12890    
12891    
12892    ; Pin Bit spec
12893    ;
12894      0001             I2C_SDA_Pin	= @00000001
12895      0002             I2C_SCL_Pin	= @00000010
12896    
12897    
12898    ; Useful addresses
12899    ;
12900      C043             I2C_DDR		= $C043
12901      C041             I2C_PORT	= $C041
12902    
12903      05D0             I2C_Base	= $5D0				; NOT the Final location.
12904      05D0             I2C_Status	= I2C_Base
12905      05D1             I2C_Byte	= I2C_Status+1
12906      05D2             I2C_Timeout_V	= I2C_Byte + 1			; Timeout counter variable.
12907    
12908    
12909    ; I2C State machine bitfield
12910    ;
12911      0001             I2C_STA_NAK	= @00000001
12912      0002             I2C_STA_Timeout	= @00000010
12913      0004             I2C_STA_Rd_nWr	= @00000100
12914      0008             I2C_STA_Master	= @00001000
12915    
12916    
12917    ; I2C handy constants
12918    ;
12919      04FF             I2C_Timeout_C	= $4FF				; Attempts to make before timeout
12920      0001             I2C_Float	= 1
12921      0000             I2C_Assert	= 0				; Note that any non zero vslue will float, which we will exploit.
12922    
12923    
12924    
12925    ; ----------------------------------------------
12926    ; ********  I2C Pin driving functions.  ********
12927    ; ----------------------------------------------
12928    ;
12929    
12930    I2C_SetSDA
12931    FB54  D0 09          BNE I2C_SDA_Float
12932      
12933    ; Asserting case
12934    FB56  A9 01          LDA #I2C_SDA_Pin
12935    FB58  0D 43 C0       ORA I2C_DDR
12936    FB5B  8D 43 C0       STA I2C_DDR
12937    FB5E  60             RTS
12938      
12939    ; Floating case
12940    I2C_SDA_Float
12941    FB5F  A9 FE          LDA #~I2C_SDA_Pin
12942    FB61  2D 43 C0       AND I2C_DDR
12943    FB64  8D 43 C0       STA I2C_DDR
12944    FB67  60             RTS  
12945    
12946    
12947    
12948    I2C_SetSCL
12949    FB68  D0 09          BNE I2C_SCL_Float
12950      
12951    ; Asserting case
12952    FB6A  A9 02          LDA #I2C_SCL_Pin
12953    FB6C  0D 43 C0       ORA I2C_DDR
12954    FB6F  8D 43 C0       STA I2C_DDR
12955    FB72  60             RTS
12956      
12957    ; Floating case
12958    I2C_SCL_Float
12959    FB73  A9 FD          LDA #~I2C_SCL_Pin
12960    FB75  2D 43 C0       AND I2C_DDR
12961    FB78  8D 43 C0       STA I2C_DDR
12962    FB7B  60             RTS
12963    
12964    
12965    
12966    ; ---------------------------------------------
12967    ; ********    Pin reading functions    ********
12968    ; ---------------------------------------------
12969    ;
12970    
12971    
12972    ; Wait for SCL Release and return when done or timed out.
12973    ;
12974    ; This is done to support clock-stretching, which is not very useful at these speeds but... who knows!?
12975    ;
12976    I2C_WaitSCL_Release
12977    FB7C  DA             PHX
12978    FB7D  5A             PHY
12979    FB7E  A2 D2          LDX #<I2C_Timeout_V			; Setup our timeout attempt counter low
12980    FB80  A0 05          LDY #>I2C_Timeout_V			; ...and high.
12981      
12982    
12983    FB82  A9 02          LDA #I2C_SCL_Pin			; Check if SCL has been released
12984      
12985    I2C_WaitSCL_retry_L
12986    FB84  2C 41 C0       BIT I2C_PORT
12987    FB87  D0 11          BNE I2C_SCL_Freed			; Are you free, Are you free!?
12988      
12989    FB89  CA             DEX
12990    FB8A  D0 F8          BNE I2C_WaitSCL_retry_L		; Repeat until we reach 0 or the line is freed
12991    FB8C  88             DEY
12992    FB8D  D0 F5          BNE I2C_WaitSCL_retry_L
12993      
12994    FB8F  AD D0 05       LDA I2C_Status			; Update status bit to reflect line timeout.
12995    FB92  09 02          ORA #I2C_STA_Timeout
12996    FB94  8D D0 05       STA I2C_Status
12997    FB97  7A             PLY
12998    FB98  FA             PLX
12999    FB99  60             RTS
13000    
13001    I2C_SCL_Freed
13002    FB9A  AD D0 05       LDA I2C_Status			; Update status bit to reflect line freed.
13003    FB9D  29 FD          AND #~I2C_STA_Timeout
13004    FB9F  8D D0 05       STA I2C_Status
13005    FBA2  7A             PLY
13006    FBA3  FA             PLX
13007    FBA4  60             RTS
13008      
13009      
13010    I2C_GetSDA
13011    FBA5  AD 41 C0       LDA I2C_PORT
13012    FBA8  29 01          AND #I2C_SDA_Pin
13013    FBAA  60             RTS
13014      
13015    
13016    
13017    ; ---------------------------------------------
13018    ; ********       Bus Functions.        ********
13019    ; ---------------------------------------------
13020    
13021    I2C_Init
13022    
13023    ; Set initial timeout variable
13024    
13025    FBAB  A9 FF          LDA #<I2C_Timeout_C
13026    FBAD  8D D2 05       STA I2C_Timeout_V
13027    FBB0  A9 04          LDA #>I2C_Timeout_C
13028    FBB2  8D D3 05       STA I2C_Timeout_V+1
13029    
13030    
13031    ;  Set initial state of port
13032    
13033    FBB5  A9 01          LDA #I2C_Float
13034    FBB7  20 68 FB       JSR I2C_SetSCL
13035      
13036    FBBA  A9 01          LDA #I2C_Float
13037    FBBC  20 54 FB       JSR I2C_SetSDA
13038        
13039    FBBF  AD 41 C0       LDA I2C_PORT
13040    FBC2  29 FC          AND #~[I2C_SDA_Pin | I2C_SCL_Pin]
13041    FBC4  8D 41 C0       STA I2C_PORT
13042    
13043    
13044    ; Set initial status register value
13045      
13046    FBC7  A9 08          LDA #I2C_STA_Master
13047    FBC9  8D D0 05       STA I2C_Status
13048    
13049    
13050    ; Clear engine state
13051      
13052    FBCC  A9 00          LDA #0
13053    FBCE  8D D1 05       STA I2C_Byte
13054    
13055    FBD1  60             RTS
13056    
13057    
13058    ; I2C Bus commands
13059    
13060    I2C_Start
13061    
13062    FBD2  A9 00          LDA #I2C_Assert
13063    FBD4  20 54 FB       JSR I2C_SetSDA
13064      
13065    FBD7  A9 00          LDA #I2C_Assert
13066    FBD9  20 68 FB       JSR I2C_SetSCL
13067      
13068    FBDC  60             RTS
13069    
13070      
13071    I2C_Stop
13072    
13073    FBDD  A9 01          LDA #I2C_Float
13074    FBDF  20 68 FB       JSR I2C_SetSCL
13075    
13076      ; JSR I2C_WaitSCL_Release ; I don't think we need this line.
13077      
13078    FBE2  A9 01          LDA #I2C_Float
13079    FBE4  20 54 FB       JSR I2C_SetSDA
13080    
13081    
13082    FBE7  60             RTS
13083    
13084      
13085    I2C_Out
13086    FBE8  A0 80          LDY #$80			; Set our bit mask
13087    
13088    
13089    ; ** This part sends out the 8 bit word MSb first. **
13090    
13091    I2C_Out_L
13092    FBEA  A9 00          LDA #I2C_Assert		; Transmit selected bit
13093    FBEC  20 68 FB       JSR I2C_SetSCL		; Clock line low first
13094    
13095    FBEF  98             TYA
13096    FBF0  2D D1 05       AND I2C_Byte			; Set data bit appropriately
13097    FBF3  20 54 FB       JSR I2C_SetSDA
13098      
13099    FBF6  A9 01          LDA #I2C_Float		; Latch it to slave
13100    FBF8  20 68 FB       JSR I2C_SetSCL
13101      
13102    FBFB  98             TYA				; Proceed to next bit until zero
13103    FBFC  6A             ROR
13104    FBFD  A8             TAY
13105    FBFE  D0 EA          BNE I2C_Out_L
13106    
13107    
13108    ; ** This part handles the ACK or NAK appropriately **
13109      
13110    FC00  A9 00          LDA #I2C_Assert		; ACK/NAK clock pulse low
13111    FC02  20 68 FB       JSR I2C_SetSCL
13112      
13113    FC05  A9 01          LDA #I2C_Float		; Float SDA so the slave can pull it for ACK
13114    FC07  20 54 FB       JSR I2C_SetSDA
13115      
13116    FC0A  A9 01          LDA #I2C_Float		; ACK/NAK clock pulse high with stretching
13117    FC0C  20 68 FB       JSR I2C_SetSCL   
13118    FC0F  20 7C FB       JSR I2C_WaitSCL_Release
13119      
13120    FC12  20 A5 FB       JSR I2C_GetSDA		; Read ACK/NAK state
13121      
13122    FC15  F0 0A          BEQ I2C_Out_ACKin		; Set the status word accordingly.
13123      
13124    FC17  A9 01          LDA #I2C_STA_NAK		; Case NAK
13125    FC19  0D D0 05       ORA I2C_Status
13126    FC1C  8D D0 05       STA I2C_Status
13127    FC1F  80 08          BRA I2C_FinishWrite
13128      
13129    I2C_Out_ACKin			; Case ACK
13130    FC21  A9 FE          LDA #~I2C_STA_NAK
13131    FC23  2D D0 05       AND I2C_Status
13132    FC26  8D D0 05       STA I2C_Status
13133      
13134    I2C_FinishWrite
13135    FC29  A9 00          LDA #I2C_Assert		; Finish clock cycle for ACK/NAK
13136    FC2B  20 68 FB       JSR I2C_SetSCL
13137      
13138    FC2E  A9 01          LDA #I2C_Float		; Float SDA or we can't do a repeat start FINDME
13139    FC30  20 54 FB       JSR I2C_SetSDA  
13140    FC33  60             RTS
13141        
13142    I2C_WriteFail  
13143    FC34  20 DD FB       JSR I2C_Stop
13144    FC37  60             RTS
13145      
13146      
13147    I2C_In
13148    
13149    FC38  A9 01          LDA #I2C_Float		; Ensure the SDA line is floating.
13150    FC3A  20 54 FB       JSR I2C_SetSDA
13151      
13152    FC3D  A0 80          LDY #$80			; Setup initial state
13153    FC3F  A9 00          LDA #0
13154    FC41  8D D1 05       STA I2C_Byte
13155    
13156    I2C_In_L
13157    
13158    FC44  A9 00          LDA #I2C_Assert		; Start clock pulse
13159    FC46  20 68 FB       JSR I2C_SetSCL  
13160    FC49  A9 01          LDA #I2C_Float		; Finish clock pulse
13161    FC4B  20 68 FB       JSR I2C_SetSCL  
13162    FC4E  20 A5 FB       JSR I2C_GetSDA		; Get bit
13163    FC51  F0 07          BEQ I2C_In_SkipSet
13164      
13165    FC53  98             TYA				; Set relevant bit of I2C_Byte to 1
13166    FC54  0D D1 05       ORA I2C_Byte
13167    FC57  8D D1 05       STA I2C_Byte
13168    
13169    I2C_In_SkipSet
13170      
13171    FC5A  98             TYA				; Move walking one across
13172    FC5B  4A             LSR
13173    FC5C  A8             TAY
13174    
13175    FC5D  D0 E5          BNE I2C_In_L			; Keep reading until all bits read
13176      
13177    FC5F  A9 00          LDA #I2C_Assert
13178    FC61  20 68 FB       JSR I2C_SetSCL
13179      
13180    FC64  A9 01          LDA #I2C_STA_NAK		; Check whether to send ACK or NAK
13181    FC66  2C D0 05       BIT I2C_Status
13182    FC69  D0 05          BNE I2C_In_SendNAK
13183      
13184    FC6B  A9 00          LDA #I2C_Assert		; Set for ACK
13185    FC6D  20 54 FB       JSR I2C_SetSDA
13186      
13187    I2C_In_SendNAK
13188    FC70  A9 01          LDA #I2C_Float		; Send ACK/NAK
13189    FC72  20 68 FB       JSR I2C_SetSCL
13190    FC75  A9 00          LDA #I2C_Assert
13191    FC77  20 68 FB       JSR I2C_SetSCL
13192    
13193    FC7A  A9 01          LDA #I2C_Float		; Restore SDA to floating. 
13194    FC7C  20 54 FB       JSR I2C_SetSDA
13195    FC7F  60             RTS
13196      
13197      .INCLUDE "SPI_Lib.asm"
13198    ; SPI Driver by Jennifer Gunn
13199    ;
13200    
13201    ; SPI System variables
13202    ;
13203      0400             SPI_Struct		= $400					; Base address of SPI data structure below.
13204    
13205      0400             SPI_In			= SPI_Struct				; Byte received by the SPI subsystem
13206      0401             SPI_Out			= SPI_In + 1				; Byte to be transmitted by the SPI subsystem
13207      0402             SPI_Mode		= SPI_Out + 1				; SPI mode.  See table 1 below.
13208      0403             SPI_SS_Pin		= SPI_Mode + 1				; Slave select pin.  Must be just one bit in the byte.
13209      0404             SPI_SS_Act		= SPI_SS_Pin + 1			; Active Level of SS pin.
13210      0405             SPI_MOSI_Pin		= SPI_SS_Act+ 1				; Master Out, Slave In pin.  This pin outputs the bits.
13211      0406             SPI_MISO_Pin		= SPI_MOSI_Pin + 1			; Master In, Slave Out pin.  This pin reads the slave bits.
13212      0407             SPI_SCK_Pin		= SPI_MISO_Pin +1			; Serial clock output pin. Without clocks, most of us wouldn't exist!
13213      0408             SPI_Temp		= SPI_SCK_Pin + 1			; Temporary store for internal operations.
13214    
13215    
13216    ; SPI Mode bitfields
13217    ;
13218      0002             SPI_CPOL_bit		= @00000010
13219      0001             SPI_CPHA_bit		= @00000001
13220    
13221    
13222    ; SPI constants.
13223    ;
13224      0000             SPI_CPHA0		= @00000000				; Clock phase 0: Out on previous clock trailing, in after leading edge.
13225      0001             SPI_CPHA1		= @00000001				; Clock phase 1: Out on leading edge, in after trailing.
13226      0000             SPI_CPOL0		= @00000000				; Clock polarity 0: Positive logic.
13227      0002             SPI_CPOL1		= @00000010				; Clock polarity 1: Negative logic.
13228    
13229      0000             SPI_MODE0		= SPI_CPHA0 | SPI_CPOL0			; Official modes for SPI, to help those that would like it.
13230      0001             SPI_MODE1		= SPI_CPHA1 | SPI_CPOL0
13231      0002             SPI_MODE2		= SPI_CPHA0 | SPI_CPOL1
13232      0003             SPI_MODE3		= SPI_CPHA1 | SPI_CPOL1
13233    
13234    
13235      0004             SPI_SCK_Pin_C		= @00000100				; Default SPI clock pin.
13236      0008             SPI_MOSI_Pin_C		= @00001000				; This pin and the following two are chosen so as not to
13237      0010             SPI_MISO_Pin_C		= @00010000				; clash with the I2C engine by default.
13238      0020             SPI_SS_Pin_C		= @00100000				; Default Slave Select pin.
13239      0000             SPI_SS_Pin_Act_C	= 0					; SS pin polarity active low.
13240      C043             SPI_DDRPORT_C		= $C043					; Port A DDR register on first GPIO card.
13241      C041             SPI_IOP_C		= $C041					; ORA on first GPIO card,
13242      0000             SPI_Mode_C		= SPI_MODE0				; Clock phase mode 0, Clock polarity 0. Good for eg: 74HC595.
13243      0001             SPI_SS_Pin_ActLo_C	= 1					; Slave Select Active Low
13244      0000             SPI_SS_Pin_ActHi_C	= 0					; Slave Select Active High
13245    
13246    
13247    
13248    ; Setup SPI port. Do NOT call this until your structure is set up correctly.
13249    ;
13250    SPI_Init_F
13251    FC80  20 AE FC       JSR SPI_SetBusDDR_F
13252    FC83  20 C9 FC       JSR SPI_BusIdle_F
13253      
13254    FC86  60             RTS
13255      
13256    
13257    ; Init the SPI Structure with default values from the above constants.
13258    ;
13259    SPI_Struct_Init_F
13260    FC87  A9 08          LDA #SPI_MOSI_Pin_C
13261    FC89  8D 05 04       STA SPI_MOSI_Pin
13262    FC8C  A9 10          LDA #SPI_MISO_Pin_C
13263    FC8E  8D 06 04       STA SPI_MISO_Pin
13264    FC91  A9 20          LDA #SPI_SS_Pin_C
13265    FC93  8D 03 04       STA SPI_SS_Pin
13266    FC96  A9 04          LDA #SPI_SCK_Pin_C
13267    FC98  8D 07 04       STA SPI_SCK_Pin
13268    FC9B  A9 00          LDA #SPI_Mode_C
13269    FC9D  8D 02 04       STA SPI_Mode
13270    FCA0  A9 01          LDA #SPI_SS_Pin_ActLo_C
13271    FCA2  8D 04 04       STA SPI_SS_Act
13272    FCA5  A9 00          LDA #0
13273    FCA7  8D 00 04       STA SPI_In
13274    FCAA  8D 01 04       STA SPI_Out
13275      
13276    FCAD  60             RTS
13277    
13278    
13279    SPI_SetBusDDR_F
13280    FCAE  AD 43 C0       LDA SPI_DDRPORT_C						; Get current state
13281    
13282    FCB1  0D 05 04       ORA SPI_MOSI_Pin						; Set MOSI, SCK and SS out, but MISO to input
13283    FCB4  0D 03 04       ORA SPI_SS_Pin
13284    FCB7  0D 07 04       ORA SPI_SCK_Pin
13285    FCBA  8D 43 C0       STA SPI_DDRPORT_C
13286      
13287    FCBD  AD 06 04       LDA SPI_MISO_Pin
13288    FCC0  49 FF          EOR #$FF
13289    FCC2  2D 43 C0       AND SPI_DDRPORT_C
13290    FCC5  8D 43 C0       STA SPI_DDRPORT_C						; Store it.  Our pin directions are now set.
13291    
13292    FCC8  60             RTS
13293    
13294    
13295    SPI_BusIdle_F  
13296    FCC9  AD 05 04       LDA SPI_MOSI_Pin						; Put our SPI bus in idle.
13297    FCCC  18             CLC
13298    FCCD  20 D7 FC       JSR SPI_SetPins_F
13299    FCD0  20 05 FD       JSR SPI_Deassert_SS_F
13300    FCD3  20 12 FD       JSR SPI_Deassert_SCK_F
13301    
13302    FCD6  60             RTS
13303    
13304    
13305    ; Sets the state of the pin(s) set in A. If carry then set pin(s), otherwise clear pin(s).
13306    ;
13307    SPI_SetPins_F
13308    FCD7  90 07          BCC SPI_ClrPin_B
13309    
13310    SPI_MOSI_SetPin_B
13311    FCD9  0D 41 C0       ORA SPI_IOP_C
13312    FCDC  8D 41 C0       STA SPI_IOP_C
13313      
13314    FCDF  60             RTS
13315      
13316    SPI_ClrPin_B
13317    FCE0  49 FF          EOR #$FF
13318    FCE2  2D 41 C0       AND SPI_IOP_C
13319    FCE5  8D 41 C0       STA SPI_IOP_C
13320      
13321    FCE8  60             RTS
13322    
13323    
13324    ; *****************************************
13325    ; 
13326    ; Assert Functions
13327    ;
13328    ; *****************************************
13329    ;
13330    SPI_Assert_SS_F
13331    FCE9  18             CLC
13332    FCEA  AD 04 04       LDA SPI_SS_Act
13333    FCED  D0 01          BNE SPI_SS_Assert_Low_B
13334    FCEF  38             SEC
13335      
13336    SPI_SS_Assert_Low_B
13337    FCF0  AD 03 04       LDA SPI_SS_Pin
13338    FCF3  4C D7 FC       JMP SPI_SetPins_F
13339      
13340    
13341    SPI_Assert_SCK_F
13342    FCF6  18             CLC
13343    FCF7  AD 02 04       LDA SPI_Mode
13344    FCFA  89 02          BIT #SPI_CPOL_bit
13345    FCFC  D0 01          BNE SPI_SCK_Neg_B
13346    FCFE  38             SEC
13347      
13348    SPI_SCK_Neg_B
13349    FCFF  AD 07 04       LDA SPI_SCK_Pin
13350    FD02  4C D7 FC       JMP SPI_SetPins_F
13351    
13352    
13353    
13354    ; *****************************************
13355    ; 
13356    ; De-Assert Functions
13357    ;
13358    ; *****************************************
13359    ;
13360    SPI_Deassert_SS_F
13361    FD05  38             SEC
13362    FD06  AD 04 04       LDA SPI_SS_Act
13363    FD09  D0 01          BNE SPI_SS_Deassert_Hi_B
13364    FD0B  18             CLC
13365      
13366    SPI_SS_Deassert_Hi_B
13367    FD0C  AD 03 04       LDA SPI_SS_Pin
13368    FD0F  4C D7 FC       JMP SPI_SetPins_F
13369      
13370    
13371    SPI_Deassert_SCK_F
13372    FD12  38             SEC
13373    FD13  AD 02 04       LDA SPI_Mode
13374    FD16  89 02          BIT #SPI_CPOL_bit
13375    FD18  D0 01          BNE SPI_SCK_Pos_B
13376    FD1A  18             CLC
13377      
13378    SPI_SCK_Pos_B
13379    FD1B  AD 07 04       LDA SPI_SCK_Pin
13380    FD1E  4C D7 FC       JMP SPI_SetPins_F
13381    
13382    
13383    ; *************************
13384    ; 
13385    ;  Bit-Shift I/O Function.
13386    ;
13387    ; *************************
13388    ;
13389    SPI_ShiftIn_MISO_F
13390    FD21  38             SEC
13391    FD22  AD 06 04       LDA SPI_MISO_Pin
13392    FD25  D0 01          BNE SPI_ShiftIn_B
13393      
13394    FD27  18             CLC
13395      
13396    SPI_ShiftIn_B
13397    FD28  2E 00 04       ROL SPI_In
13398      
13399    FD2B  60             RTS
13400    
13401      
13402    SPI_ShiftOut_MOSI_F
13403    FD2C  AD 05 04       LDA SPI_MOSI_Pin
13404    FD2F  2E 08 04       ROL SPI_Temp
13405    FD32  4C D7 FC       JMP SPI_SetPins_F
13406      
13407    
13408    SPI_Xfer_F
13409    FD35  A2 08          LDX #8							; Set up our counter for pushing bits.
13410    
13411    FD37  20 C9 FC       JSR SPI_BusIdle_F
13412    FD3A  20 E9 FC       JSR SPI_Assert_SS_F
13413    
13414    FD3D  AD 01 04       LDA SPI_Out							; Get a working copy of our data to send
13415    FD40  8D 08 04       STA SPI_Temp
13416      
13417    FD43  AD 02 04       LDA SPI_Mode							; Adjust for whatever CPHA setting we have.
13418    FD46  24 01          BIT SPI_CPHA_bit
13419    FD48  D0 13          BNE SPI_xfer_CPHA1
13420    
13421    
13422    SPI_xfer_CPHA0							; This path puts data on the trailing edge of the previous clock,
13423    								; and reads it after the leading edge of the current clock.								
13424    FD4A  20 2C FD       JSR SPI_ShiftOut_MOSI_F
13425    FD4D  20 F6 FC       JSR SPI_Assert_SCK_F
13426    FD50  20 21 FD       JSR SPI_ShiftIn_MISO_F
13427    FD53  20 12 FD       JSR SPI_Deassert_SCK_F
13428    
13429    FD56  CA             DEX
13430    FD57  D0 F1          BNE SPI_xfer_CPHA0
13431      
13432    FD59  20 C9 FC       JSR SPI_BusIdle_F
13433    FD5C  60             RTS
13434    
13435      
13436    SPI_xfer_CPHA1							; This path puts the data out just before the leading edge,
13437    								; and reads it just after the trailing edge.
13438     
13439    FD5D  20 F6 FC       JSR SPI_Assert_SCK_F
13440    FD60  20 2C FD       JSR SPI_ShiftOut_MOSI_F
13441    FD63  20 12 FD       JSR SPI_Deassert_SCK_F
13442    FD66  20 21 FD       JSR SPI_ShiftIn_MISO_F
13443      
13444    FD69  CA             DEX
13445    FD6A  D0 F1          BNE SPI_xfer_CPHA1
13446      
13447    FD6C  20 C9 FC       JSR SPI_BusIdle_F
13448        
13449    FD6F  60             RTS
13450    
13451    
13452    ; reset vector points here
13453    
13454    RES_vec
13455    FD70  78             SEI					; Ensure IRQ's are turned off.
13456    FD71  D8             CLD					; clear decimal mode
13457    FD72  A2 FF          LDX #$FF				; empty stack
13458    FD74  9A             TXS					; set the stack
13459    
13460    ; Set up system timing function
13461    
13462    FD75  20 DB FF       JSR IRQH_Handler_Init_vec		; Initialise the IRQ Handler
13463    
13464    FD78  A9 50          LDA #<COUNTDOWN_IRQ			; Put the test IRQ address into the table at IRQ Location 0
13465    FD7A  8D 30 0A       STA IRQH_CallReg
13466    FD7D  A9 FA          LDA #>COUNTDOWN_IRQ
13467    FD7F  8D 31 0A       STA IRQH_CallReg + 1
13468    FD82  A9 00          LDA #0
13469    FD84  20 DE FF       JSR IRQH_SetIRQ_vec
13470       
13471    FD87  58             CLI					; Enable IRQs globally.
13472    
13473    FD88  20 BF EF       JSR TPB_delay
13474      
13475    FD8B  A9 02          LDA #ANSI_out_sw                    ; Set our default output options for ANSI output mode.
13476    ;  LDA #ACIA1_out_sw                   ; Set our default output options for ACIA output mode.
13477    FD8D  8D E0 05       STA os_outsel                       ; to the ANSI card only.
13478    FD90  A9 01          LDA #LF_filt_sw1
13479    FD92  8D E1 05       STA os_infilt                       ; Switch on $A filtering on the ACIA.
13480      
13481    FD95  A9 01          LDA #OS_input_ACIA1                 ; Specify input source as ACIA1
13482    FD97  8D E2 05       STA os_insel
13483      
13484    FD9A  20 00 EC       JSR INI_ACIA_SYS                    ; Init ACIAs. We currently need ACIA1 for the keyboard at startup.
13485    FD9D  20 90 FF       JSR ANSI_init_vec                   ; Initialise the ANSI text video card.
13486    FDA0  20 96 FF       JSR TPB_init_vec                    ; Init Tower Peripheral Bus
13487    FDA3  20 0A F8       JSR AY_Init                         ; Initialise the AY sound system.
13488      
13489    ; set up vectors and interrupt code, copy them to page 2
13490    
13491    FDA6  A0 EF          LDY #END_CODE-LAB_vec               ; set index/count
13492    LAB_stlp
13493    FDA8  B9 D5 FD       LDA LAB_vec-1,Y                     ; get byte from interrupt code
13494    FDAB  99 04 02       STA VEC_IN-1,Y                      ; save to RAM
13495    FDAE  88             DEY                                 ; decrement index/count
13496    FDAF  D0 F7          BNE LAB_stlp                        ; loop if more to do
13497    
13498      
13499    ; Initialise filing system
13500    
13501    FDB1  20 72 FF       JSR TAPE_init_vec                   ; Initialise TowerTAPE filing system.
13502        
13503    ; now do the signon message
13504    
13505    FDB4  A0 00          LDY #0
13506    LAB_signon
13507    
13508    FDB6  B9 D5 FE       LDA LAB_mess,Y                      ; get byte from sign on message
13509    FDB9  F0 06          BEQ LAB_nokey                       ; exit loop if done
13510    
13511    FDBB  20 02 E2       JSR V_OUTP                          ; output character
13512    FDBE  C8             INY                                 ; increment index
13513    FDBF  D0 F5          BNE LAB_signon                      ; loop, branch always
13514    
13515    LAB_nokey
13516    FDC1  20 FF E1       JSR V_INPT                          ; call scan input device
13517    FDC4  90 FB          BCC LAB_nokey                       ; loop if no key
13518    
13519    FDC6  29 DF          AND #$DF                            ; mask xx0x xxxx, ensure upper case
13520    FDC8  C9 57          CMP #'W'                            ; compare with [W]arm start
13521    FDCA  F0 07          BEQ LAB_dowarm                      ; branch if [W]arm start
13522    
13523    FDCC  C9 43          CMP #'C'                            ; compare with [C]old start.
13524    FDCE  D0 E6          BNE LAB_signon                      ; loop if not [C]old start
13525    
13526    FDD0  4C 00 C1       JMP LAB_COLD                        ; do EhBASIC cold start
13527    
13528    LAB_dowarm
13529    FDD3  4C 00 00       JMP LAB_WARM                        ; do EhBASIC warm start
13530    
13531    
13532    ; EhBASIC vector tables
13533    
13534    LAB_vec
13535      .word RD_char                       ; byte in from Selected source
13536      .word WR_char                       ; byte out to ACIA1
13537      .word TAPE_LOAD_BASIC_vec           ; null load vector for EhBASIC
13538      .word TAPE_SAVE_BASIC_vec           ; save vector for EhBASIC
13539      .word TAPE_VERIFY_BASIC_vec         ; verify vector for EhBASIC
13540      .word TAPE_CAT_vec                  ; cat vector for EhBASIC
13541      
13542    
13543    ; EhBASIC IRQ support
13544    
13545    IRQ_CODE
13546    FDE2  48             PHA                                 ; save A
13547    FDE3  A5 DF          LDA IrqBase                         ; get the IRQ flag byte
13548    FDE5  4A             LSR                                 ; shift the set b7 to b6, and on down ...
13549    FDE6  05 DF          ORA IrqBase                         ; OR the original back in
13550    FDE8  85 DF          STA IrqBase                         ; save the new IRQ flag byte
13551    FDEA  68             PLA                                 ; restore A
13552    FDEB  40             RTI
13553    
13554    
13555    ; EhBASIC NMI support
13556    
13557    NMI_CODE
13558    FDEC  48             PHA                                 ; save A
13559    FDED  A5 DC          LDA NmiBase                         ; get the NMI flag byte
13560    FDEF  4A             LSR                                 ; shift the set b7 to b6, and on down ...
13561    FDF0  05 DC          ORA NmiBase                         ; OR the original back in
13562    FDF2  85 DC          STA NmiBase                         ; save the new NMI flag byte
13563    FDF4  68             PLA                                 ; restore A
13564    FDF5  40             RTI
13565    
13566    
13567    ; ToE input BASIC stream support.
13568    
13569    RD_char
13570    
13571    FDF6  AD E2 05       LDA os_insel                        ; Handle TAPE selected
13572    FDF9  89 10          BIT #OS_input_TAPE
13573    FDFB  F0 0F          BEQ INSEL_Check_ACIA1
13574    
13575    FDFD  20 6F FF       JSR TAPE_ByteIn_vec                 ; Get a byte
13576      
13577    FE00  AD 09 09       LDA TAPE_RX_Status                  ; Check if escape was pressed
13578    FE03  89 08          BIT #TAPE_Stat_Escape
13579    FE05  D0 1B          BNE INSEL_ResetSource
13580      
13581    FE07  AD 0B 09       LDA TAPE_ByteReceived
13582    FE0A  38             SEC
13583    FE0B  60             RTS
13584      
13585    
13586    INSEL_Check_ACIA1
13587    FE0C  AD E2 05       LDA os_insel                        ; Handle ACIA1 selected
13588    FE0F  89 01          BIT #OS_input_ACIA1
13589    FE11  F0 04          BEQ INSEL_Check_ACIA2
13590    FE13  20 54 EC       JSR ACIA1in
13591    FE16  60             RTS
13592    
13593    INSEL_Check_ACIA2
13594    FE17  AD E2 05       LDA os_insel  
13595    FE1A  89 08          BIT #OS_input_ACIA2                 ; Handle ACIA2 selected
13596    FE1C  F0 04          BEQ INSEL_ResetSource
13597    FE1E  20 69 EC       JSR ACIA2in
13598    FE21  60             RTS
13599    
13600    INSEL_ResetSource
13601    FE22  A9 01          LDA #OS_input_ACIA1                 ; Reset source
13602    FE24  8D E2 05       STA os_insel
13603      
13604    FE27  A9 0C          LDA #$C                             ; and send a ^C to interrupt program flow.
13605    FE29  38             SEC
13606    FE2A  60             RTS
13607      
13608    
13609    ; OS output stream management support.
13610    
13611    WR_char
13612    FE2B  08             PHP                                 ; Save our registers in case we need 'em
13613    FE2C  DA             PHX
13614    FE2D  5A             PHY
13615    FE2E  48             PHA
13616    FE2F  48             PHA
13617       
13618    FE30  A9 01          LDA #ACIA1_out_sw
13619    FE32  2C E0 05       BIT os_outsel
13620    FE35  F0 05          BEQ no_ACIA1
13621    FE37  68             PLA
13622    FE38  20 36 EC       JSR ACIA1out                         ; Print to ACIA1
13623    
13624    FE3B  48             PHA
13625    no_ACIA1  
13626    FE3C  A9 08          LDA #ACIA2_out_sw
13627    FE3E  2C E0 05       BIT os_outsel
13628    FE41  F0 05          BEQ no_ACIA2
13629    FE43  68             PLA
13630    FE44  20 45 EC       JSR ACIA2out                         ; Print to ACIA2
13631      
13632    FE47  48             PHA
13633    no_ACIA2
13634    FE48  A9 02          LDA #ANSI_out_sw
13635    FE4A  2C E0 05       BIT os_outsel
13636    FE4D  F0 05          BEQ no_ANSI
13637    FE4F  68             PLA
13638    FE50  20 93 FF       JSR ANSI_write_vec                  ; Print to ANSI video card
13639        
13640    FE53  48             PHA
13641    no_ANSI
13642    FE54  A9 04          LDA #TPB_out_sw
13643    FE56  2C E0 05       BIT os_outsel
13644    FE59  F0 05          BEQ no_TPB_LPT
13645    FE5B  68             PLA
13646    FE5C  20 99 FF       JSR TPB_LPT_write_vec               ; Print to TPB LPT card
13647    
13648    FE5F  48             PHA  
13649    no_TPB_LPT                            ; "Print" to the TAPE interface
13650    FE60  A9 10          LDA #TAPE_out_sw
13651    FE62  2C E0 05       BIT os_outsel
13652    FE65  F0 13          BEQ MON_EndWRITE_B                  ; Dont write to tape unless selected.
13653    FE67  68             PLA
13654    FE68  48             PHA
13655    FE69  C9 0A          CMP #10
13656    FE6B  F0 03          BEQ MON_SkipLFtoTAPE
13657    FE6D  20 69 FF       JSR TAPE_ByteOut_vec
13658    MON_SkipLFtoTAPE  
13659    FE70  68             PLA
13660    FE71  C9 0D          CMP #13                             ; Do a little delay if CR is detected to allow the system to catch up on read.
13661    FE73  D0 03          BNE MON_SkipTapeDelay
13662      
13663    FE75  20 8D FE       JSR MON_Do_CR_Delay
13664      
13665    MON_SkipTapeDelay
13666      
13667    FE78  80 01          BRA MON_EndWRITE_B2
13668    
13669    MON_EndWRITE_B
13670    FE7A  68             PLA                                   ; Clean up stack including restoring P and return.
13671    MON_EndWRITE_B2
13672    FE7B  68             PLA
13673    FE7C  7A             PLY
13674    FE7D  FA             PLX
13675    FE7E  28             PLP
13676    FE7F  60             RTS
13677    
13678      
13679    ; Tower string printing routine.
13680    TOE_PrintStr
13681    FE80  A0 00          LDY #0					; Initialise loop index.
13682    TOE_PrintStr_L
13683    FE82  B1 E7          LDA (TOE_MemptrLo),Y				; Print character.
13684    FE84  F0 06          BEQ TOE_DonePrinting
13685    FE86  20 02 E2       JSR V_OUTP
13686    FE89  C8             INY
13687    FE8A  80 F6          BRA TOE_PrintStr_L
13688    
13689    TOE_DonePrinting
13690    FE8C  60             RTS
13691    
13692    ; Tower CR delay for spooling routine.  
13693    MON_Do_CR_Delay
13694    FE8D  A0 30          LDY #>MON_CR_Delay_C                          ; Get our delay value
13695    FE8F  A2 00          LDX #<MON_CR_Delay_C
13696      
13697    MON_CR_Delay_L                                  ; Iterate our delay on the counter.
13698    FE91  EA             NOP
13699    FE92  EA             NOP
13700    FE93  EA             NOP
13701    FE94  EA             NOP
13702    FE95  CA             DEX
13703    FE96  D0 F9          BNE MON_CR_Delay_L                            ; Keep counting X down until 0
13704    FE98  88             DEY
13705    FE99  D0 F6          BNE MON_CR_Delay_L
13706      
13707    FE9B  60             RTS
13708      
13709      
13710    MON_CLS
13711    FE9C  A9 18          LDA #24					; Clear the screen to bold, 80 columns and text
13712    FE9E  20 02 E2       JSR V_OUTP
13713    FEA1  A9 03          LDA #3
13714    FEA3  20 02 E2       JSR V_OUTP
13715    FEA6  A9 0C          LDA #12
13716    FEA8  20 02 E2       JSR V_OUTP
13717    FEAB  60             RTS
13718      
13719    MON_PrintHexByte
13720    FEAC  AA             TAX						; Save the source for later
13721      
13722    FEAD  6A             ROR						; Get only the top nybble.
13723    FEAE  6A             ROR
13724    FEAF  6A             ROR
13725    FEB0  6A             ROR
13726    FEB1  29 0F          AND #$F
13727      
13728    FEB3  20 BD FE       JSR B_PrintHexDig				; Print high digit
13729    FEB6  8A             TXA
13730      
13731    FEB7  29 0F          AND #$F					; Now print low digit
13732    FEB9  20 BD FE       JSR B_PrintHexDig
13733    FEBC  60             RTS
13734      
13735    B_PrintHexDig
13736    FEBD  A8             TAY
13737    FEBE  B9 C5 FE       LDA MON_HexDigits_T,Y
13738    FEC1  20 02 E2       JSR V_OUTP
13739    FEC4  60             RTS
13740      
13741      
13742    END_CODE
13743    
13744    MON_HexDigits_T  
13745      .byte "0123456789ABCDEF"
13746    
13747    
13748    LAB_mess
13749                                          ; sign on string
13750    
13751      .byte "Tower of Eightness OS 5.1.2023.5T",$0D,$0A,$0D,$0A
13752      .byte $0D,$0A,"65C02 TowerBASIC [C]old/[W]arm ?",$00
13753    
13754    
13755    ; ACIA Vectors
13756    FF42                 *= $FF42
13757    ACIA_INI_SYS_vec
13758    FF42  4C 00 EC       JMP INI_ACIA_SYS         ; FF42
13759    ACIA1_init_vec
13760    FF45  4C 17 EC       JMP INI_ACIA1            ; FF45
13761    ACIA2_init_vec
13762    FF48  4C 17 EC       JMP INI_ACIA1            ; FF48
13763    ACIA1out_vec
13764    FF4B  4C 36 EC       JMP ACIA1out             ; FF4B
13765    ACIA2out_vec
13766    FF4E  4C 45 EC       JMP ACIA2out             ; FF4E
13767    ACIA1in_vec
13768    FF51  4C 54 EC       JMP ACIA1in              ; FF51
13769    ACIA2in_vec
13770    FF54  4C 69 EC       JMP ACIA2in              ; FF54
13771    
13772    ; ToE OS Vectors
13773    FF57                 *= $FF57
13774    SPI_Struct_Init_vec
13775    FF57  4C 87 FC       JMP SPI_Struct_Init_F    ; FF57
13776    SPI_Init_vec
13777    FF5A  4C 80 FC       JMP SPI_Init_F           ; FF5A
13778    SPI_Xfer_vec
13779    FF5D  4C 35 FD       JMP SPI_Xfer_F           ; FF5D
13780    
13781    
13782    FF60                 *= $FF60
13783    ; Stream output vector.  
13784    
13785    TOE_PrintStr_vec
13786    FF60  4C 80 FE       JMP TOE_PrintStr         ; FF60
13787      
13788      
13789    ; TAPE subsystem vectors
13790    
13791    TAPE_Leader_vec
13792    FF63  4C 59 F6       JMP F_TAPE_Leader        ; FF63
13793    TAPE_BlockOut_vec
13794    FF66  4C 29 F6       JMP F_TAPE_BlockOut      ; FF66
13795    TAPE_ByteOut_vec
13796    FF69  4C FE F5       JMP F_TAPE_ByteOut       ; FF69
13797    TAPE_BlockIn_vec
13798    FF6C  4C 07 F7       JMP F_TAPE_BlockIn       ; FF6C
13799    TAPE_ByteIn_vec
13800    FF6F  4C BB F7       JMP F_TAPE_GetByte       ; FF6F
13801    TAPE_init_vec
13802    FF72  4C B8 F0       JMP F_TAPE_Init          ; FF72
13803    TAPE_CAT_vec  
13804    FF75  4C F4 F3       JMP F_TAPE_CAT           ; FF75
13805    TAPE_SAVE_BASIC_vec
13806    FF78  4C 1D F2       JMP F_TAPE_SAVE_BASIC    ; FF78
13807    TAPE_LOAD_BASIC_vec  
13808    FF7B  4C 4C F4       JMP F_TAPE_LOAD_BASIC    ; FF7B
13809    TAPE_VERIFY_BASIC_vec
13810    FF7E  4C F5 F2       JMP F_TAPE_VERIFY_BASIC  ; FF7E
13811    
13812    
13813    ; I2C subsystem vectors
13814    
13815    I2C_Init_vec               ; FF81
13816    FF81  4C AB FB       JMP I2C_Init
13817    I2C_Start_vec              ; FF84
13818    FF84  4C D2 FB       JMP I2C_Start
13819    I2C_Stop_vec               ; FF87
13820    FF87  4C DD FB       JMP I2C_Stop
13821    I2C_Out_vec                ; FF8A
13822    FF8A  4C E8 FB       JMP I2C_Out
13823    I2C_In_vec                 ; FF8D
13824    FF8D  4C 38 FC       JMP I2C_In
13825    ; No gap between this and the next lot.
13826    
13827    ; ANSI Card vectors
13828    
13829    FF90                 *= $FF90
13830    
13831    ANSI_init_vec
13832    FF90  4C 89 EC       JMP ANSI_INIT            ; FF90
13833    ANSI_write_vec
13834    FF93  4C AB EC       JMP ANSI_write           ; FF93
13835      
13836    
13837    ; Tower Peripheral Bus vectors
13838    
13839    TPB_init_vec
13840    FF96  4C CF EC       JMP TPB_INIT             ; FF96
13841    TPB_LPT_write_vec
13842    FF99  4C 91 EF       JMP TPB_LPT_write        ; FF99
13843    TPB_tx_byte_vec
13844    FF9C  4C 59 EE       JMP TPB_tx_byte          ; FF9C
13845    TPB_tx_block_vec
13846    FF9F  4C F4 EE       JMP TPB_tx_block         ; FF9F
13847    TPB_ATN_handler_vec
13848    FFA2  4C 23 EE       JMP TPB_ATN_handler      ; FFA2
13849    TPB_rx_byte_vec  
13850    FFA5  4C 9E EE       JMP TPB_rx_byte          ; FFA5
13851    TPB_rx_block_vec
13852    FFA8  4C 38 EF       JMP TPB_rx_block         ; FFA8
13853    TPB_Dev_Presence_vec
13854    FFAB  4C DF ED       JMP TPB_Dev_Presence     ; FFAB
13855    TPB_Req_Dev_Type_vec
13856    FFAE  4C 60 ED       JMP TPB_Req_Dev_Type     ; FFAE
13857    TPB_dev_select_vec
13858    FFB1  4C 77 EF       JMP TPB_dev_select       ; FFB1
13859    TPB_Ctrl_Blk_Wr_vec
13860    FFB4  4C F3 EC       JMP TPB_Ctrl_Blk_Wr      ; FFB4
13861    TPB_Ctrl_Blk_Rd_vec
13862    FFB7  4C 29 ED       JMP TPB_Ctrl_Blk_Rd      ; FFB7
13863      
13864    
13865    FFCF                 *= $FFCF
13866    ; AY Soundcard vectors.
13867    
13868    AY_Userwrite_16_vec        ; FFCF
13869    FFCF  4C C0 F8       JMP AY_Userwrite_16
13870    AY_Userread_16_vec         ; FFD2
13871    FFD2  4C D1 F8       JMP AY_Userread_16
13872    AY_Userwrite_vec           ; FFD5
13873    FFD5  4C A9 F8       JMP AY_Userwrite
13874    AY_Userread_vec            ; FFD8
13875    FFD8  4C B3 F8       JMP AY_Userread
13876    
13877    
13878    ; IRQ Handler Subsystem vectors
13879      
13880    IRQH_Handler_Init_vec	   ; FFDB
13881    FFDB  4C 94 F9       JMP IRQH_Handler_Init_F
13882    IRQH_SetIRQ_vec		   ; FFDE
13883    FFDE  4C C8 F9       JMP IRQH_SetIRQ_F
13884    IRQH_ClrIRQ_vec		   ; FFE1
13885    FFE1  4C DB F9       JMP IRQH_ClrIRQ_F
13886    IRQH_SystemReport_vec	   ; FFE4
13887    FFE4  4C 22 FA       JMP IRQH_SystemReport_F
13888      
13889    ; Timer System vectors
13890    
13891    INIT_COUNTDOWN_IRQ_vec	   ; FFE7
13892    FFE7  4C 29 FA       JMP INIT_COUNTDOWN_IRQ
13893      
13894    
13895    ; Processor hardware vectors.  These are fixed in hardware and cannot be moved.
13896    
13897    FFFA                 *= $FFFA
13898    
13899      .word NMI_vec                ; NMI vector
13900      .word RES_vec                ; RESET vector
13901      .word IRQ_vec                ; IRQ vector
13902    
13903    
13904    
