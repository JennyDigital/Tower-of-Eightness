00001    ; Tower of Eightness OS
00002    
00003    
00004      .include "basic_ToE.asm"
00005    
00006    ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22p5 EL1
00007    
00008    ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
00009    
00010    ; 2.00      new revision numbers start here
00011    ; 2.01      fixed LCASE$() and UCASE$()
00012    ; 2.02      new get value routine done
00013    ; 2.03      changed RND() to galoise method
00014    ; 2.04      fixed SPC()
00015    ; 2.05      new get value routine fixed
00016    ; 2.06      changed USR() code
00017    ; 2.07      fixed STR$()
00018    ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
00019    ; 2.09      fixed RND()
00020    ; 2.10      integrated missed changes from an earlier version
00021    ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
00022    ; 2.21      fixed IF .. THEN RETURN to not cause error
00023    ; 2.22      fixed RND() breaking the get byte routine
00024    ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
00025    ;              (bugsnquirks.txt notes 2, 4 and 5)
00026    ;              tabs converted to spaces, tabwidth=6
00027    ; 2.22p2    fixed can't continue error on 1st statement after direct mode
00028    ;              changed INPUT to throw "break in line ##" on empty line input
00029    ; 2.22p3    fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
00030    ;              fix provided by github user mgcaret
00031    ; 2.22p4    fixed string compare of equal strings in direct mode returns FALSE
00032    ;              fixed FALSE stored to a variable after a string compare 
00033    ;                 is > 0 and < 1E-16
00034    ;              added additional stack floor protection for background interrupts
00035    ;              fixed conditional LOOP & NEXT cannot find their data strucure on stack
00036    ; 2.22p5    fixes issues reported by users Ruud and dclxvi on the 6502.org forum
00037    ;      5.0     http://forum.6502.org/viewtopic.php?f=5&t=5500
00038    ;              sanity check for RAM top allows values below RAM base
00039    ;      5.1-7   http://forum.6502.org/viewtopic.php?f=5&t=5606
00040    ;              1-7 coresponds to the bug# in the thread
00041    ;      5.1     TO expression with a subtract may evaluate with the sign bit flipped
00042    ;      5.3     call to LAB_1B5B may return to an address -$100 (page not incremented)
00043    ;      5.4     string concatenate followed by MINUS or NOT() crashes EhBASIC
00044    ;      5.5     garbage collection may cause an overlap with temporary strings
00045    ;      5.6     floating point multiply rounding bug
00046    ;      5.7     VAL() may cause string variables to be trashed
00047    
00048    ; Tower of Eightness additions:-
00049    ;
00050    ;      LOCATE command. Moves the text cursor on the ANSI display to x,y coordinate.
00051    ;      CLS command. Clears the ANSI display.
00052    ;      PLOT command. Sets/clears a pixel on the ANSI display.
00053    ;      CAT command. Displays the contents of (at present TowerTAPE only) currently selected file system.
00054    ;      LOAD and SAVE have real functionality.
00055    ;      VERIFY command.  Have you ever lost data?  HAVE YOU!!?  Let's be sure things are right before moving on.
00056    ;      SOUND command. Plays a sound on the AY until stopped.
00057    ;      ENVELOPE command. Defines period and mode of AY volume modulation.
00058    
00059    
00060    ; zero page use ..
00061    
00062    ; the following locations are bulk initialized from StrTab at LAB_GMEM
00063      0000             LAB_WARM          = $00       ; BASIC warm start entry point
00064      0001             Wrmjpl            = LAB_WARM+1; BASIC warm start vector jump low byte
00065      0002             Wrmjph            = LAB_WARM+2; BASIC warm start vector jump high byte
00066    
00067      000A             Usrjmp            = $0A       ; USR function JMP address
00068      000B             Usrjpl            = Usrjmp+1  ; USR function JMP vector low byte
00069      000C             Usrjph            = Usrjmp+2  ; USR function JMP vector high byte
00070      000D             Nullct            = $0D       ; nulls output after each line
00071      000E             TPos              = $0E       ; BASIC terminal position byte
00072      000F             TWidth            = $0F       ; BASIC terminal width byte
00073      0010             Iclim             = $10       ; input column limit
00074      0011             Itempl            = $11       ; temporary integer low byte
00075      0012             Itemph            = Itempl+1  ; temporary integer high byte
00076    ; end bulk initialize from StrTab at LAB_GMEM
00077    
00078      0011             nums_1            = Itempl    ; number to bin/hex string convert MSB
00079      0012             nums_2            = nums_1+1  ; number to bin/hex string convert
00080      0013             nums_3            = nums_1+2  ; number to bin/hex string convert LSB
00081    
00082      005B             Srchc             = $5B       ; search character
00083      005B             Temp3             = Srchc     ; temp byte used in number routines
00084      005C             Scnquo            = $5C       ; scan-between-quotes flag
00085      005C             Asrch             = Scnquo    ; alt search character
00086    
00087      005B             XOAw_l            = Srchc     ; eXclusive OR, OR and AND word low byte
00088      005C             XOAw_h            = Scnquo    ; eXclusive OR, OR and AND word high byte
00089    
00090      005D             Ibptr             = $5D       ; input buffer pointer
00091      005D             Dimcnt            = Ibptr     ; # of dimensions
00092      005D             Tindx             = Ibptr     ; token index
00093    
00094      005E             Defdim            = $5E       ; default DIM flag
00095      005F             Dtypef            = $5F       ; data type flag, $FF=string, $00=numeric
00096      0060             Oquote            = $60       ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
00097      0060             Gclctd            = $60       ; garbage collected flag
00098      0061             Sufnxf            = $61       ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
00099      0062             Imode             = $62       ; input mode flag, $00=INPUT, $80=READ
00100    
00101      0063             Cflag             = $63       ; comparison evaluation flag
00102    
00103      0064             TabSiz            = $64       ; TAB step size (was input flag)
00104    
00105      0065             next_s            = $65       ; next descriptor stack address
00106    
00107                                  ; these two bytes form a word pointer to the item
00108                                  ; currently on top of the descriptor stack
00109      0066             last_sl           = $66       ; last descriptor stack address low byte
00110      0067             last_sh           = $67       ; last descriptor stack address high byte (always $00)
00111    
00112      0068             des_sk            = $68       ; descriptor stack start address (temp strings)
00113    
00114    ;                 = $70       ; End of descriptor stack
00115    
00116      0071             ut1_pl            = $71       ; utility pointer 1 low byte
00117      0072             ut1_ph            = ut1_pl+1  ; utility pointer 1 high byte
00118      0073             ut2_pl            = $73       ; utility pointer 2 low byte
00119      0074             ut2_ph            = ut2_pl+1  ; utility pointer 2 high byte
00120    
00121      0071             Temp_2            = ut1_pl    ; temp byte for block move    
00122    
00123      0075             FACt_1            = $75       ; FAC temp mantissa1
00124      0076             FACt_2            = FACt_1+1  ; FAC temp mantissa2
00125      0077             FACt_3            = FACt_2+1  ; FAC temp mantissa3
00126    
00127      0076             dims_l            = FACt_2    ; array dimension size low byte
00128      0077             dims_h            = FACt_3    ; array dimension size high byte
00129    
00130      0078             TempB             = $78       ; temp page 0 byte
00131    
00132      0079             Smeml             = $79       ; start of mem low byte       (Start-of-Basic)
00133      007A             Smemh             = Smeml+1   ; start of mem high byte      (Start-of-Basic)
00134      007B             Svarl             = $7B       ; start of vars low byte      (Start-of-Variables)
00135      007C             Svarh             = Svarl+1   ; start of vars high byte     (Start-of-Variables)
00136      007D             Sarryl            = $7D       ; var mem end low byte        (Start-of-Arrays)
00137      007E             Sarryh            = Sarryl+1  ; var mem end high byte       (Start-of-Arrays)
00138      007F             Earryl            = $7F       ; array mem end low byte      (End-of-Arrays)
00139      0080             Earryh            = Earryl+1  ; array mem end high byte     (End-of-Arrays)
00140      0081             Sstorl            = $81       ; string storage low byte     (String storage (moving down))
00141      0082             Sstorh            = Sstorl+1  ; string storage high byte    (String storage (moving down))
00142      0083             Sutill            = $83       ; string utility ptr low byte
00143      0084             Sutilh            = Sutill+1  ; string utility ptr high byte
00144      0085             Ememl             = $85       ; end of mem low byte         (Limit-of-memory)
00145      0086             Ememh             = Ememl+1   ; end of mem high byte        (Limit-of-memory)
00146      0087             Clinel            = $87       ; current line low byte       (Basic line number)
00147      0088             Clineh            = Clinel+1  ; current line high byte      (Basic line number)
00148      0089             Blinel            = $89       ; break line low byte         (Previous Basic line number)
00149      008A             Blineh            = Blinel+1  ; break line high byte        (Previous Basic line number)
00150    
00151      008B             Cpntrl            = $8B       ; continue pointer low byte
00152      008C             Cpntrh            = Cpntrl+1  ; continue pointer high byte
00153    
00154      008D             Dlinel            = $8D       ; current DATA line low byte
00155      008E             Dlineh            = Dlinel+1  ; current DATA line high byte
00156    
00157      008F             Dptrl             = $8F       ; DATA pointer low byte
00158      0090             Dptrh             = Dptrl+1   ; DATA pointer high byte
00159    
00160      0091             Rdptrl            = $91       ; read pointer low byte
00161      0092             Rdptrh            = Rdptrl+1  ; read pointer high byte
00162    
00163      0093             Varnm1            = $93       ; current var name 1st byte
00164      0094             Varnm2            = Varnm1+1  ; current var name 2nd byte
00165    
00166      0095             Cvaral            = $95       ; current var address low byte
00167      0096             Cvarah            = Cvaral+1  ; current var address high byte
00168    
00169      0097             Frnxtl            = $97       ; var pointer for FOR/NEXT low byte
00170      0098             Frnxth            = Frnxtl+1  ; var pointer for FOR/NEXT high byte
00171    
00172      0097             Tidx1             = Frnxtl    ; temp line index
00173    
00174      0097             Lvarpl            = Frnxtl    ; let var pointer low byte
00175      0098             Lvarph            = Frnxth    ; let var pointer high byte
00176    
00177      0099             prstk             = $99       ; precedence stacked flag
00178    
00179      009B             comp_f            = $9B       ; compare function flag, bits 0,1 and 2 used
00180                                  ; bit 2 set if >
00181                                  ; bit 1 set if =
00182                                  ; bit 0 set if <
00183    
00184      009C             func_l            = $9C       ; function pointer low byte
00185      009D             func_h            = func_l+1  ; function pointer high byte
00186    
00187      009C             garb_l            = func_l    ; garbage collection working pointer low byte
00188      009D             garb_h            = func_h    ; garbage collection working pointer high byte
00189    
00190      009E             des_2l            = $9E       ; string descriptor_2 pointer low byte
00191      009F             des_2h            = des_2l+1  ; string descriptor_2 pointer high byte
00192    
00193      00A0             g_step            = $A0       ; garbage collect step size
00194    
00195      00A1             Fnxjmp            = $A1       ; jump vector for functions
00196      00A2             Fnxjpl            = Fnxjmp+1  ; functions jump vector low byte
00197      00A3             Fnxjph            = Fnxjmp+2  ; functions jump vector high byte
00198    
00199      00A2             g_indx            = Fnxjpl    ; garbage collect temp index
00200    
00201      00A3             FAC2_r            = $A3       ; FAC2 rounding byte
00202    
00203      00A4             Adatal            = $A4       ; array data pointer low byte
00204      00A5             Adatah            = Adatal+1  ; array data pointer high  byte
00205    
00206      00A4             Nbendl            = Adatal    ; new block end pointer low byte
00207      00A5             Nbendh            = Adatah    ; new block end pointer high  byte
00208    
00209      00A6             Obendl            = $A6       ; old block end pointer low byte
00210      00A7             Obendh            = Obendl+1  ; old block end pointer high  byte
00211    
00212      00A8             numexp            = $A8       ; string to float number exponent count
00213      00A9             expcnt            = $A9       ; string to float exponent count
00214    
00215      00A8             numbit            = numexp    ; bit count for array element calculations
00216    
00217      00AA             numdpf            = $AA       ; string to float decimal point flag
00218      00AB             expneg            = $AB       ; string to float eval exponent -ve flag
00219    
00220      00AA             Astrtl            = numdpf    ; array start pointer low byte
00221      00AB             Astrth            = expneg    ; array start pointer high  byte
00222    
00223      00AA             Histrl            = numdpf    ; highest string low byte
00224      00AB             Histrh            = expneg    ; highest string high  byte
00225    
00226      00AA             Baslnl            = numdpf    ; BASIC search line pointer low byte
00227      00AB             Baslnh            = expneg    ; BASIC search line pointer high  byte
00228    
00229      00AA             Fvar_l            = numdpf    ; find/found variable pointer low byte
00230      00AB             Fvar_h            = expneg    ; find/found variable pointer high  byte
00231    
00232      00AA             Ostrtl            = numdpf    ; old block start pointer low byte
00233      00AB             Ostrth            = expneg    ; old block start pointer high  byte
00234    
00235      00AA             Vrschl            = numdpf    ; variable search pointer low byte
00236      00AB             Vrschh            = expneg    ; variable search pointer high  byte
00237    
00238      00AC             FAC1_e            = $AC       ; FAC1 exponent
00239      00AD             FAC1_1            = FAC1_e+1  ; FAC1 mantissa1
00240      00AE             FAC1_2            = FAC1_e+2  ; FAC1 mantissa2
00241      00AF             FAC1_3            = FAC1_e+3  ; FAC1 mantissa3
00242      00B0             FAC1_s            = FAC1_e+4  ; FAC1 sign (b7)
00243    
00244      00AC             str_ln            = FAC1_e    ; string length
00245      00AD             str_pl            = FAC1_1    ; string pointer low byte
00246      00AE             str_ph            = FAC1_2    ; string pointer high byte
00247    
00248      00AE             des_pl            = FAC1_2    ; string descriptor pointer low byte
00249      00AF             des_ph            = FAC1_3    ; string descriptor pointer high byte
00250    
00251      00AF             mids_l            = FAC1_3    ; MID$ string temp length byte
00252    
00253      00B1             negnum            = $B1       ; string to float eval -ve flag
00254      00B1             numcon            = $B1       ; series evaluation constant count
00255    
00256      00B2             FAC1_o            = $B2       ; FAC1 overflow byte
00257    
00258      00B3             FAC2_e            = $B3       ; FAC2 exponent
00259      00B4             FAC2_1            = FAC2_e+1  ; FAC2 mantissa1
00260      00B5             FAC2_2            = FAC2_e+2  ; FAC2 mantissa2
00261      00B6             FAC2_3            = FAC2_e+3  ; FAC2 mantissa3
00262      00B7             FAC2_s            = FAC2_e+4  ; FAC2 sign (b7)
00263    
00264      00B8             FAC_sc            = $B8       ; FAC sign comparison, Acc#1 vs #2
00265      00B9             FAC1_r            = $B9       ; FAC1 rounding byte
00266    
00267      00B8             ssptr_l           = FAC_sc    ; string start pointer low byte
00268      00B9             ssptr_h           = FAC1_r    ; string start pointer high byte
00269    
00270      00B8             sdescr            = FAC_sc    ; string descriptor pointer
00271    
00272      00BA             csidx             = $BA       ; line crunch save index
00273      00BA             Asptl             = csidx     ; array size/pointer low byte
00274      00BB             Aspth             = $BB       ; array size/pointer high byte
00275    
00276      00BA             Btmpl             = Asptl     ; BASIC pointer temp low byte
00277      00BB             Btmph             = Aspth     ; BASIC pointer temp low byte
00278    
00279      00BA             Cptrl             = Asptl     ; BASIC pointer temp low byte
00280      00BB             Cptrh             = Aspth     ; BASIC pointer temp low byte
00281    
00282      00BA             Sendl             = Asptl     ; BASIC pointer temp low byte
00283      00BB             Sendh             = Aspth     ; BASIC pointer temp low byte
00284    
00285    ; the following locations are bulk initialized from LAB_2CEE at LAB_2D4E
00286      00BC             LAB_IGBY          = $BC       ; get next BASIC byte subroutine
00287    
00288      00C2             LAB_GBYT          = $C2       ; get current BASIC byte subroutine
00289      00C3             Bpntrl            = $C3       ; BASIC execute (get byte) pointer low byte
00290      00C4             Bpntrh            = Bpntrl+1  ; BASIC execute (get byte) pointer high byte
00291    
00292    ;                 = $D7       ; end of get BASIC char subroutine
00293    ; end bulk initialize from LAB_2CEE at LAB_2D4E
00294    
00295      00D8             Rbyte4            = $D8       ; extra PRNG byte
00296      00D9             Rbyte1            = Rbyte4+1  ; most significant PRNG byte
00297      00DA             Rbyte2            = Rbyte4+2  ; middle PRNG byte
00298      00DB             Rbyte3            = Rbyte4+3  ; least significant PRNG byte
00299    
00300      00DC             NmiBase           = $DC       ; NMI handler enabled/setup/triggered flags
00301                                  ; bit function
00302                                  ; === ========
00303                                  ; 7   interrupt enabled
00304                                  ; 6   interrupt setup
00305                                  ; 5   interrupt happened
00306    ;                 = $DD       ; NMI handler addr low byte
00307    ;                 = $DE       ; NMI handler addr high byte
00308      00DF             IrqBase           = $DF       ; IRQ handler enabled/setup/triggered flags
00309    ;                 = $E0       ; IRQ handler addr low byte
00310    ;                 = $E1       ; IRQ handler addr high byte
00311    
00312    ; *** removed unused comments for $DE-$E1
00313    
00314    ;                 = $E2       ; TPB card temporary location
00315    ;                 = $E3       ; TPB card temporary location
00316    ;                 = $E4       ; TAPE tempoaray location.
00317    ;                 = $E5       ; TAPE BlockLo
00318    ;                 = $E6       ; TAPE blockHi
00319    ;                 = $E7       ; TOE_MemptrLo low byte general purpose pointer
00320    ;                 = $E8       ; TOE_MemptrHi high byte general purpose pointer.
00321    ;                 = $E9       ; unused
00322    ;                 = $EA       ; unused
00323    ;                 = $EB       ; unused
00324    ;                 = $EC       ; unused
00325    ;                 = $ED       ; unused
00326    ;                 = $EE       ; unused
00327    
00328      00EF             Decss             = $EF       ; number to decimal string start
00329      00F0             Decssp1           = Decss+1   ; number to decimal string start
00330    
00331    ;                 = $FF       ; decimal string end
00332    
00333    ; token values needed for BASIC
00334    
00335    ; primary command tokens (can start a statement)
00336    
00337      0080             TK_END            = $80             ; END token
00338      0081             TK_FOR            = TK_END+1        ; FOR token
00339      0082             TK_NEXT           = TK_FOR+1        ; NEXT token
00340      0083             TK_DATA           = TK_NEXT+1       ; DATA token
00341      0084             TK_INPUT          = TK_DATA+1       ; INPUT token
00342      0085             TK_DIM            = TK_INPUT+1      ; DIM token
00343      0086             TK_READ           = TK_DIM+1        ; READ token
00344      0087             TK_LET            = TK_READ+1       ; LET token
00345      0088             TK_DEC            = TK_LET+1        ; DEC token
00346      0089             TK_GOTO           = TK_DEC+1        ; GOTO token
00347      008A             TK_RUN            = TK_GOTO+1       ; RUN token
00348      008B             TK_IF             = TK_RUN+1        ; IF token
00349      008C             TK_RESTORE        = TK_IF+1         ; RESTORE token
00350      008D             TK_GOSUB          = TK_RESTORE+1    ; GOSUB token
00351      008E             TK_RETIRQ         = TK_GOSUB+1      ; RETIRQ token
00352      008F             TK_RETNMI         = TK_RETIRQ+1     ; RETNMI token
00353      0090             TK_RETURN         = TK_RETNMI+1     ; RETURN token
00354      0091             TK_REM            = TK_RETURN+1     ; REM token
00355      0092             TK_STOP           = TK_REM+1        ; STOP token
00356      0093             TK_ON             = TK_STOP+1       ; ON token
00357      0094             TK_NULL           = TK_ON+1         ; NULL token
00358      0095             TK_INC            = TK_NULL+1       ; INC token
00359      0096             TK_WAIT           = TK_INC+1        ; WAIT token
00360      0097             TK_LOAD           = TK_WAIT+1       ; LOAD token
00361      0098             TK_SAVE           = TK_LOAD+1       ; SAVE token
00362      0099             TK_DEF            = TK_SAVE+1       ; DEF token
00363      009A             TK_POKE           = TK_DEF+1        ; POKE token
00364      009B             TK_DOKE           = TK_POKE+1       ; DOKE token
00365      009C             TK_CALL           = TK_DOKE+1       ; CALL token
00366      009D             TK_DO             = TK_CALL+1       ; DO token
00367      009E             TK_LOOP           = TK_DO+1         ; LOOP token
00368      009F             TK_PRINT          = TK_LOOP+1       ; PRINT token
00369      00A0             TK_CONT           = TK_PRINT+1      ; CONT token
00370      00A1             TK_LIST           = TK_CONT+1       ; LIST token
00371      00A2             TK_CLEAR          = TK_LIST+1       ; CLEAR token
00372      00A3             TK_NEW            = TK_CLEAR+1      ; NEW token
00373      00A4             TK_WIDTH          = TK_NEW+1        ; WIDTH token
00374      00A5             TK_GET            = TK_WIDTH+1      ; GET token
00375      00A6             TK_SWAP           = TK_GET+1        ; SWAP token
00376      00A7             TK_BITSET         = TK_SWAP+1       ; BITSET token
00377      00A8             TK_BITCLR         = TK_BITSET+1     ; BITCLR token
00378      00A9             TK_IRQ            = TK_BITCLR+1     ; IRQ token
00379      00AA             TK_NMI            = TK_IRQ+1        ; NMI token
00380      00AB             TK_VERIFY         = TK_NMI+1        ; VERIFY token
00381      00AC             TK_CAT            = TK_VERIFY+1     ; CAT token
00382      00AD             TK_CLS            = TK_CAT+1        ; CLS token
00383      00AE             TK_LOCATE         = TK_CLS+1        ; LOCATE token
00384      00AF             TK_PLOT           = TK_LOCATE+1     ; PLOT token
00385      00B0             TK_SOUND          = TK_PLOT+1       ; SOUND token
00386      00B1             TK_ENVELOPE       = TK_SOUND+1      ; ENVELOPE token
00387    
00388    
00389    ; secondary command tokens, can't start a statement
00390    
00391      00B2             TK_TAB            = TK_ENVELOPE+1   ; TAB token
00392      00B3             TK_ELSE           = TK_TAB+1        ; ELSE token
00393      00B4             TK_TO             = TK_ELSE+1       ; TO token
00394      00B5             TK_FN             = TK_TO+1         ; FN token
00395      00B6             TK_SPC            = TK_FN+1         ; SPC token
00396      00B7             TK_THEN           = TK_SPC+1        ; THEN token
00397      00B8             TK_NOT            = TK_THEN+1       ; NOT token
00398      00B9             TK_STEP           = TK_NOT+1        ; STEP token
00399      00BA             TK_UNTIL          = TK_STEP+1       ; UNTIL token
00400      00BB             TK_WHILE          = TK_UNTIL+1      ; WHILE token
00401      00BC             TK_OFF            = TK_WHILE+1      ; OFF token
00402    
00403    ; opperator tokens
00404    
00405      00BD             TK_PLUS           = TK_OFF+1        ; + token
00406      00BE             TK_MINUS          = TK_PLUS+1       ; - token
00407      00BF             TK_MUL            = TK_MINUS+1      ; * token
00408      00C0             TK_DIV            = TK_MUL+1        ; / token
00409      00C1             TK_POWER          = TK_DIV+1        ; ^ token
00410      00C2             TK_AND            = TK_POWER+1      ; AND token
00411      00C3             TK_EOR            = TK_AND+1        ; EOR token
00412      00C4             TK_OR             = TK_EOR+1        ; OR token
00413      00C5             TK_RSHIFT         = TK_OR+1         ; RSHIFT token
00414      00C6             TK_LSHIFT         = TK_RSHIFT+1     ; LSHIFT token
00415      00C7             TK_GT             = TK_LSHIFT+1     ; > token
00416      00C8             TK_EQUAL          = TK_GT+1         ; = token
00417      00C9             TK_LT             = TK_EQUAL+1      ; < token
00418    
00419    ; functions tokens
00420    
00421      00CA             TK_SGN            = TK_LT+1         ; SGN token
00422      00CB             TK_INT            = TK_SGN+1        ; INT token
00423      00CC             TK_ABS            = TK_INT+1        ; ABS token
00424      00CD             TK_USR            = TK_ABS+1        ; USR token
00425      00CE             TK_FRE            = TK_USR+1        ; FRE token
00426      00CF             TK_POS            = TK_FRE+1        ; POS token
00427      00D0             TK_SQR            = TK_POS+1        ; SQR token
00428      00D1             TK_RND            = TK_SQR+1        ; RND token
00429      00D2             TK_LOG            = TK_RND+1        ; LOG token
00430      00D3             TK_EXP            = TK_LOG+1        ; EXP token
00431      00D4             TK_COS            = TK_EXP+1        ; COS token
00432      00D5             TK_SIN            = TK_COS+1        ; SIN token
00433      00D6             TK_TAN            = TK_SIN+1        ; TAN token
00434      00D7             TK_ATN            = TK_TAN+1        ; ATN token
00435      00D8             TK_PEEK           = TK_ATN+1        ; PEEK token
00436      00D9             TK_DEEK           = TK_PEEK+1       ; DEEK token
00437      00DA             TK_SADD           = TK_DEEK+1       ; SADD token
00438      00DB             TK_LEN            = TK_SADD+1       ; LEN token
00439      00DC             TK_STRS           = TK_LEN+1        ; STR$ token
00440      00DD             TK_VAL            = TK_STRS+1       ; VAL token
00441      00DE             TK_ASC            = TK_VAL+1        ; ASC token
00442      00DF             TK_UCASES         = TK_ASC+1        ; UCASE$ token
00443      00E0             TK_LCASES         = TK_UCASES+1     ; LCASE$ token
00444      00E1             TK_CHRS           = TK_LCASES+1     ; CHR$ token
00445      00E2             TK_HEXS           = TK_CHRS+1       ; HEX$ token
00446      00E3             TK_BINS           = TK_HEXS+1       ; BIN$ token
00447      00E4             TK_BITTST         = TK_BINS+1       ; BITTST token
00448      00E5             TK_MAX            = TK_BITTST+1     ; MAX token
00449      00E6             TK_MIN            = TK_MAX+1        ; MIN token
00450      00E7             TK_PI             = TK_MIN+1        ; PI token
00451      00E8             TK_TWOPI          = TK_PI+1         ; TWOPI token
00452      00E9             TK_VPTR           = TK_TWOPI+1      ; VARPTR token
00453      00EA             TK_LEFTS          = TK_VPTR+1       ; LEFT$ token
00454      00EB             TK_RIGHTS         = TK_LEFTS+1      ; RIGHT$ token
00455      00EC             TK_MIDS           = TK_RIGHTS+1     ; MID$ token
00456    
00457    ; offsets from a base of X or Y
00458    
00459      0000             PLUS_0            = $00       ; X or Y plus 0
00460      0001             PLUS_1            = $01       ; X or Y plus 1
00461      0002             PLUS_2            = $02       ; X or Y plus 2
00462      0003             PLUS_3            = $03       ; X or Y plus 3
00463    
00464      0100             LAB_STAK          = $0100     ; stack bottom, no offset
00465    
00466      01FE             LAB_SKFE          = LAB_STAK+$FE
00467                                  ; flushed stack address
00468      01FF             LAB_SKFF          = LAB_STAK+$FF
00469                                  ; flushed stack address
00470    
00471    ; the following locations are bulk initialized from PG2_TABS at LAB_COLD
00472      0200             ccflag            = $0200     ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
00473      0201             ccbyte            = ccflag+1  ; BASIC CTRL-C byte
00474      0202             ccnull            = ccbyte+1  ; BASIC CTRL-C byte timeout
00475    
00476      0203             VEC_CC            = ccnull+1  ; ctrl c check vector
00477    ; end bulk initialize from PG2_TABS at LAB_COLD
00478    
00479    ; the following locations are bulk initialized by min_mon.asm from LAB_vec at LAB_stlp
00480      0205             VEC_IN            = VEC_CC+2		; input vector
00481      0207             VEC_OUT           = VEC_IN+2		; output vector
00482      0209             VEC_LD            = VEC_OUT+2		; load vector
00483      020B             VEC_SV            = VEC_LD+2		; save vector
00484      020D             VEC_VERIFY        = VEC_SV+2		; verify vector
00485      020F             VEC_CAT           = VEC_VERIFY+2	; cat vector
00486    ; end bulk initialize by min_mon.asm from LAB_vec at LAB_stlp
00487    
00488    ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
00489    ; the input buffer must not cross a page boundary and must not overlap with
00490    ; program RAM pages!
00491    
00492    ; FINDME_LOWRAM
00493    
00494    ; $5D0-$5DF for I2C
00495    ; $5E0-$5EF for ToE_Mon
00496    ; $5F2-$7FF for TPB bus card
00497    ; $800-$8FF unallocated
00498    ; $900-$AFF Allocated to the cassette file system.  This is probably generous.
00499    ; $A00-$A1F reserved for the AY card
00500    ; $A20-$A49 Countdown timer IRQ memory
00501    ; $A4A-$AFF unallocated
00502    
00503    ;Ibuffs            = IRQ_vec+$14
00504      0B00             Ibuffs            = $B00       ; TODO: Create a method of allocation controlled from an
00505                                   ; external file
00506                                   ; start of input buffer after IRQ/NMI code
00507      0B7F             Ibuffe            = Ibuffs+$7F ; end of input buffer
00508    
00509      0C00             Ram_base          = $0C00      ; start of user RAM (set as needed, should be page aligned)
00510      C000             Ram_top           = $C000      ; end of user RAM+1 (set as needed, should be page aligned)
00511    
00512      0010             Stack_floor       = 16         ; bytes left free on stack for background interrupts
00513    
00514    ; This start can be changed to suit your system
00515    
00516    C100                     *=    $C100
00517    
00518    ; BASIC cold start entry point
00519    
00520    ; new page 2 initialisation, copy block to ccflag on
00521    
00522    LAB_COLD
00523    C100  A0 04              LDY   #PG2_TABE-PG2_TABS-1
00524                                  ; byte count-1
00525    LAB_2D13
00526    C102  B9 11 E2           LDA   PG2_TABS,Y        ; get byte
00527    C105  99 00 02           STA   ccflag,Y          ; store in page 2
00528    C108  88                 DEY                     ; decrement count
00529    C109  10 F7              BPL   LAB_2D13          ; loop if not done
00530    
00531    C10B  A2 FF              LDX   #$FF              ; set byte
00532    C10D  86 88              STX   Clineh            ; set current line high byte (set immediate mode)
00533    C10F  9A                 TXS                     ; reset stack pointer
00534    
00535    C110  A9 4C              LDA   #$4C              ; code for JMP
00536    C112  85 A1              STA   Fnxjmp            ; save for jump vector for functions
00537    
00538    ; copy block from LAB_2CEE to $00BC - $00D7
00539    
00540    C114  A2 1C              LDX   #StrTab-LAB_2CEE  ; set byte count
00541    LAB_2D4E
00542    C116  BD 15 E2           LDA   LAB_2CEE-1,X      ; get byte from table
00543    C119  95 BB              STA   LAB_IGBY-1,X      ; save byte in page zero
00544    C11B  CA                 DEX                     ; decrement count
00545    C11C  D0 F8              BNE   LAB_2D4E          ; loop if not all done
00546    
00547    ; copy block from StrTab to $0000 - $0012
00548    
00549    LAB_GMEM
00550    C11E  A2 12              LDX   #EndTab-StrTab-1  ; set byte count-1
00551    TabLoop
00552    C120  BD 32 E2           LDA   StrTab,X          ; get byte from table
00553    C123  95 00              STA   PLUS_0,X          ; save byte in page zero
00554    C125  CA                 DEX                     ; decrement count
00555    C126  10 F8              BPL   TabLoop           ; loop if not all done
00556    
00557    ; set-up start values
00558    
00559    C128  A9 00              LDA   #$00              ; clear A
00560    C12A  85 DC              STA   NmiBase           ; clear NMI handler enabled flag
00561    C12C  85 DF              STA   IrqBase           ; clear IRQ handler enabled flag
00562    C12E  85 B2              STA   FAC1_o            ; clear FAC1 overflow byte
00563    C130  85 67              STA   last_sh           ; clear descriptor stack top item pointer high byte
00564    
00565    C132  A9 0E              LDA   #$0E              ; set default tab size
00566    C134  85 64              STA   TabSiz            ; save it
00567    C136  A9 03              LDA   #$03              ; set garbage collect step size for descriptor stack
00568    C138  85 A0              STA   g_step            ; save it
00569    C13A  A2 68              LDX   #des_sk           ; descriptor stack start
00570    C13C  86 65              STX   next_s            ; set descriptor stack pointer
00571    C13E  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
00572    C141  A9 45              LDA   #<LAB_MSZM        ; point to memory size message (low addr)
00573    C143  A0 E2              LDY   #>LAB_MSZM        ; point to memory size message (high addr)
00574    C145  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00575    C148  20 43 C3           JSR   LAB_INLN          ; print "? " and get BASIC input
00576    C14B  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00577    C14D  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00578    C14F  20 C2 00           JSR   LAB_GBYT          ; get last byte back
00579    
00580    C152  D0 1F              BNE   LAB_2DAA          ; branch if not null (user typed something)
00581    
00582    C154  A0 00              LDY   #$00              ; else clear Y
00583                                  ; character was null so get memory size the hard way
00584                                  ; we get here with Y=0 and Itempl/h = Ram_base
00585    LAB_2D93
00586    C156  E6 11              INC   Itempl            ; increment temporary integer low byte
00587    C158  D0 08              BNE   LAB_2D99          ; branch if no overflow
00588    
00589    C15A  E6 12              INC   Itemph            ; increment temporary integer high byte
00590    C15C  A5 12              LDA   Itemph            ; get high byte
00591    C15E  C9 C0              CMP   #>Ram_top         ; compare with top of RAM+1
00592    C160  F0 1D              BEQ   LAB_2DB6          ; branch if match (end of user RAM)
00593    
00594    LAB_2D99
00595    C162  A9 55              LDA   #$55              ; set test byte
00596    C164  91 11              STA   (Itempl),Y        ; save via temporary integer
00597    C166  D1 11              CMP   (Itempl),Y        ; compare via temporary integer
00598    C168  D0 15              BNE   LAB_2DB6          ; branch if fail
00599    
00600    C16A  0A                 ASL                     ; shift test byte left (now $AA)
00601    C16B  91 11              STA   (Itempl),Y        ; save via temporary integer
00602    C16D  D1 11              CMP   (Itempl),Y        ; compare via temporary integer
00603    C16F  F0 E5              BEQ   LAB_2D93          ; if ok go do next byte
00604    
00605    C171  D0 0C              BNE   LAB_2DB6          ; branch if fail
00606    
00607    LAB_2DAA
00608    C173  20 B9 DA           JSR   LAB_2887          ; get FAC1 from string
00609    C176  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00610    C178  C9 98              CMP   #$98              ; compare with exponent = 2^24
00611    C17A  B0 A2              BCS   LAB_GMEM          ; if too large go try again
00612    
00613    C17C  20 0A D6           JSR   LAB_F2FU          ; save integer part of FAC1 in temporary integer
00614                                  ; (no range check)
00615    
00616    LAB_2DB6
00617    C17F  A5 11              LDA   Itempl            ; get temporary integer low byte
00618    C181  A4 12              LDY   Itemph            ; get temporary integer high byte
00619    ; *** begin patch  2.22p5.0 RAM top sanity check ***
00620    ; *** replace
00621    ;      CPY   #<Ram_base+1      ; compare with start of RAM+$100 high byte
00622    ; +++ with
00623    C183  C0 0D              CPY   #>Ram_base+1      ; compare with start of RAM+$100 high byte
00624    ; *** end patch    2.22p5.0 ***
00625    C185  90 97              BCC   LAB_GMEM          ; if too small go try again
00626    
00627    
00628    ; uncomment these lines if you want to check on the high limit of memory. Note if
00629    ; Ram_top is set too low then this will fail. default is ignore it and assume the
00630    ; users know what they're doing!
00631    
00632    ;     CPY   #>Ram_top         ; compare with top of RAM high byte
00633    ;     BCC   MEM_OK            ; branch if < RAM top
00634    
00635    ;     BNE   LAB_GMEM          ; if too large go try again
00636                                  ; else was = so compare low bytes
00637    ;     CMP   #<Ram_top         ; compare with top of RAM low byte
00638    ;     BEQ   MEM_OK            ; branch if = RAM top
00639    
00640    ;     BCS   LAB_GMEM          ; if too large go try again
00641    
00642    ;MEM_OK
00643    C187  85 85              STA   Ememl             ; set end of mem low byte
00644    C189  84 86              STY   Ememh             ; set end of mem high byte
00645    C18B  85 81              STA   Sstorl            ; set bottom of string space low byte
00646    C18D  84 82              STY   Sstorh            ; set bottom of string space high byte
00647    
00648    C18F  A0 00              LDY   #<Ram_base        ; set start addr low byte
00649    C191  A2 0C              LDX   #>Ram_base        ; set start addr high byte
00650    C193  84 79              STY   Smeml             ; save start of mem low byte
00651    C195  86 7A              STX   Smemh             ; save start of mem high byte
00652    
00653    ; this line is only needed if Ram_base is not $xx00
00654          .IF   Ram_base&$FF>0
00655    
00656    C197  98                 TYA                     ; clear A
00657    C198  91 79              STA   (Smeml),Y         ; clear first byte
00658    C19A  E6 79              INC   Smeml             ; increment start of mem low byte
00659    
00660    ; these two lines are only needed if Ram_base is $xxFF
00661          .IF   Ram_base&$FF==$FF
00662    
00663    C19C  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
00664    C19F  20 59 C4           JSR   LAB_1463          ; do "NEW" and "CLEAR"
00665    C1A2  A5 85              LDA   Ememl             ; get end of mem low byte
00666    C1A4  38                 SEC                     ; set carry for subtract
00667    C1A5  E5 79              SBC   Smeml             ; subtract start of mem low byte
00668    C1A7  AA                 TAX                     ; copy to X
00669    C1A8  A5 86              LDA   Ememh             ; get end of mem high byte
00670    C1AA  E5 7A              SBC   Smemh             ; subtract start of mem high byte
00671    C1AC  20 95 DB           JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
00672    C1AF  A9 54              LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
00673    C1B1  A0 E2              LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
00674    C1B3  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00675    C1B6  A9 5D              LDA   #<LAB_1274        ; warm start vector low byte
00676    C1B8  A0 C2              LDY   #>LAB_1274        ; warm start vector high byte
00677    C1BA  85 01              STA   Wrmjpl            ; save warm start vector low byte
00678    C1BC  84 02              STY   Wrmjph            ; save warm start vector high byte
00679    C1BE  6C 01 00           JMP   (Wrmjpl)          ; go do warm start
00680    
00681    ; open up space in memory
00682    ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00683    
00684    ; Nbendl,Nbendh - new block end address (A/Y)
00685    ; Obendl,Obendh - old block end address
00686    ; Ostrtl,Ostrth - old block start address
00687    
00688    ; returns with ..
00689    
00690    ; Nbendl,Nbendh - new block start address (high byte - $100)
00691    ; Obendl,Obendh - old block start address (high byte - $100)
00692    ; Ostrtl,Ostrth - old block start address (unchanged)
00693    
00694    LAB_11CF
00695    C1C1  20 0E C2           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
00696                                  ; addr to check is in AY (low/high)
00697    C1C4  85 7F              STA   Earryl            ; save new array mem end low byte
00698    C1C6  84 80              STY   Earryh            ; save new array mem end high byte
00699    
00700    ; open up space in memory
00701    ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00702    ; don't set array end
00703    
00704    LAB_11D6
00705    C1C8  38                 SEC                     ; set carry for subtract
00706    C1C9  A5 A6              LDA   Obendl            ; get block end low byte
00707    C1CB  E5 AA              SBC   Ostrtl            ; subtract block start low byte
00708    C1CD  A8                 TAY                     ; copy MOD(block length/$100) byte to Y
00709    C1CE  A5 A7              LDA   Obendh            ; get block end high byte
00710    C1D0  E5 AB              SBC   Ostrth            ; subtract block start high byte
00711    C1D2  AA                 TAX                     ; copy block length high byte to X
00712    C1D3  E8                 INX                     ; +1 to allow for count=0 exit
00713    C1D4  98                 TYA                     ; copy block length low byte to A
00714    C1D5  F0 24              BEQ   LAB_120A          ; branch if length low byte=0
00715    
00716                                  ; block is (X-1)*256+Y bytes, do the Y bytes first
00717    
00718    C1D7  38                 SEC                     ; set carry for add + 1, two's complement
00719    C1D8  49 FF              EOR   #$FF              ; invert low byte for subtract
00720    C1DA  65 A6              ADC   Obendl            ; add block end low byte
00721    
00722    C1DC  85 A6              STA   Obendl            ; save corrected old block end low byte
00723    C1DE  B0 03              BCS   LAB_11F3          ; branch if no underflow
00724    
00725    C1E0  C6 A7              DEC   Obendh            ; else decrement block end high byte
00726    C1E2  38                 SEC                     ; set carry for add + 1, two's complement
00727    LAB_11F3
00728    C1E3  98                 TYA                     ; get MOD(block length/$100) byte
00729    C1E4  49 FF              EOR   #$FF              ; invert low byte for subtract
00730    C1E6  65 A4              ADC   Nbendl            ; add destination end low byte
00731    C1E8  85 A4              STA   Nbendl            ; save modified new block end low byte
00732    C1EA  B0 08              BCS   LAB_1203          ; branch if no underflow
00733    
00734    C1EC  C6 A5              DEC   Nbendh            ; else decrement block end high byte
00735    C1EE  90 04              BCC   LAB_1203          ; branch always
00736    
00737    LAB_11FF
00738    C1F0  B1 A6              LDA   (Obendl),Y        ; get byte from source
00739    C1F2  91 A4              STA   (Nbendl),Y        ; copy byte to destination
00740    LAB_1203
00741    C1F4  88                 DEY                     ; decrement index
00742    C1F5  D0 F9              BNE   LAB_11FF          ; loop until Y=0
00743    
00744                                  ; now do Y=0 indexed byte
00745    C1F7  B1 A6              LDA   (Obendl),Y        ; get byte from source
00746    C1F9  91 A4              STA   (Nbendl),Y        ; save byte to destination
00747    LAB_120A
00748    C1FB  C6 A7              DEC   Obendh            ; decrement source pointer high byte
00749    C1FD  C6 A5              DEC   Nbendh            ; decrement destination pointer high byte
00750    C1FF  CA                 DEX                     ; decrement block count
00751    C200  D0 F2              BNE   LAB_1203          ; loop until count = $0
00752    
00753    C202  60                 RTS
00754    
00755    ; check room on stack for A bytes
00756    ; stack too deep? do OM error
00757    
00758    LAB_1212
00759    ; *** patch - additional stack floor protection for background interrupts
00760    ; *** add
00761          .IF   Stack_floor
00762    C203  18                 CLC                     ; prep ADC
00763    C204  69 10              ADC   #Stack_floor      ; stack pointer lower limit before interrupts
00764          .ENDIF
00765    ; *** end patch
00766    C206  85 78              STA   TempB             ; save result in temp byte
00767    C208  BA                 TSX                     ; copy stack
00768    C209  E4 78              CPX   TempB             ; compare new "limit" with stack
00769    C20B  90 30              BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
00770    
00771    C20D  60                 RTS
00772    
00773    ; check available memory, "Out of memory" error if no room
00774    ; addr to check is in AY (low/high)
00775    
00776    LAB_121F
00777    C20E  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
00778    C210  90 2A              BCC   LAB_124B          ; if less then exit (is ok)
00779    
00780    C212  D0 04              BNE   LAB_1229          ; skip next test if greater (tested <)
00781    
00782                                  ; high byte was =, now do low byte
00783    C214  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
00784    C216  90 24              BCC   LAB_124B          ; if less then exit (is ok)
00785    
00786                                  ; addr is > string storage ptr (oops!)
00787    LAB_1229
00788    C218  48                 PHA                     ; push addr low byte
00789    C219  A2 08              LDX   #$08              ; set index to save Adatal to expneg inclusive
00790    C21B  98                 TYA                     ; copy addr high byte (to push on stack)
00791    
00792                                  ; save misc numeric work area
00793    LAB_122D
00794    C21C  48                 PHA                     ; push byte
00795    C21D  B5 A3              LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
00796    C21F  CA                 DEX                     ; decrement index
00797    C220  10 FA              BPL   LAB_122D          ; loop until all done
00798    
00799    C222  20 F5 D2           JSR   LAB_GARB          ; garbage collection routine
00800    
00801                                  ; restore misc numeric work area
00802    C225  A2 00              LDX   #$00              ; clear the index to restore bytes
00803    LAB_1238
00804    C227  68                 PLA                     ; pop byte
00805    C228  95 A4              STA   Adatal,X          ; save byte to Adatal to expneg
00806    C22A  E8                 INX                     ; increment index
00807    C22B  E0 08              CPX   #$08              ; compare with end + 1
00808    C22D  30 F8              BMI   LAB_1238          ; loop if more to do
00809    
00810    C22F  68                 PLA                     ; pop addr high byte
00811    C230  A8                 TAY                     ; copy back to Y
00812    C231  68                 PLA                     ; pop addr low byte
00813    C232  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
00814    C234  90 06              BCC   LAB_124B          ; if less then exit (is ok)
00815    
00816    C236  D0 05              BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
00817    
00818                                  ; high byte was =, now do low byte
00819    C238  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
00820    C23A  B0 01              BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
00821    
00822                                  ; ok exit, carry clear
00823    LAB_124B
00824    C23C  60                 RTS
00825    
00826    ; do "Out of memory" error then warm start
00827    
00828    LAB_OMER
00829    C23D  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
00830    
00831    ; do error #X, then warm start
00832    
00833    LAB_XERR
00834    C23F  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
00835    
00836    C242  BD 17 E8           LDA   LAB_BAER,X        ; get error message pointer low byte
00837    C245  BC 18 E8           LDY   LAB_BAER+1,X      ; get error message pointer high byte
00838    C248  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00839    
00840    C24B  20 92 C4           JSR   LAB_1491          ; flush stack and clear continue flag
00841    C24E  A9 68              LDA   #<LAB_EMSG        ; point to " Error" low addr
00842    C250  A0 E9              LDY   #>LAB_EMSG        ; point to " Error" high addr
00843    LAB_1269
00844    C252  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00845    C255  A4 88              LDY   Clineh            ; get current line high byte
00846    C257  C8                 INY                     ; increment it
00847    C258  F0 03              BEQ   LAB_1274          ; go do warm start (was immediate mode)
00848    
00849                                  ; else print line number
00850    C25A  20 8A DB           JSR   LAB_2953          ; print " in line [LINE #]"
00851    
00852    ; BASIC warm start entry point
00853    ; wait for Basic command
00854    
00855    LAB_1274
00856                                  ; clear ON IRQ/NMI bytes
00857    C25D  A9 00              LDA   #$00              ; clear A
00858    C25F  85 DF              STA   IrqBase           ; clear enabled byte
00859    C261  85 DC              STA   NmiBase           ; clear enabled byte
00860    C263  A9 79              LDA   #<LAB_RMSG        ; point to "Ready" message low byte
00861    C265  A0 E9              LDY   #>LAB_RMSG        ; point to "Ready" message high byte
00862    
00863    C267  20 DA C9           JSR   LAB_18C3          ; go do print string
00864    
00865    ; wait for Basic command (no "Ready")
00866    
00867    LAB_127D
00868    C26A  20 50 C3           JSR   LAB_1357          ; call for BASIC input
00869    LAB_1280
00870    C26D  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00871    C26F  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00872    C271  20 C2 00           JSR   LAB_GBYT          ; scan memory
00873    C274  F0 F4              BEQ   LAB_127D          ; loop while null
00874    
00875    ; got to interpret input line now ..
00876    
00877    C276  A2 FF              LDX   #$FF              ; current line to null value
00878    C278  86 88              STX   Clineh            ; set current line high byte
00879    C27A  90 06              BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
00880    
00881                                  ; no line number .. immediate mode
00882    C27C  20 81 C3           JSR   LAB_13A6          ; crunch keywords into Basic tokens
00883    C27F  4C FB C5           JMP   LAB_15F6          ; go scan and interpret code
00884    
00885    ; handle new BASIC line
00886    
00887    LAB_1295
00888    C282  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00889    C285  20 81 C3           JSR   LAB_13A6          ; crunch keywords into Basic tokens
00890    C288  84 5D              STY   Ibptr             ; save index pointer to end of crunched line
00891    C28A  20 2D C4           JSR   LAB_SSLN          ; search BASIC for temp integer line number
00892    C28D  90 44              BCC   LAB_12E6          ; branch if not found
00893    
00894                                  ; aroooogah! line # already exists! delete it
00895    C28F  A0 01              LDY   #$01              ; set index to next line pointer high byte
00896    C291  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
00897    C293  85 72              STA   ut1_ph            ; save it
00898    C295  A5 7B              LDA   Svarl             ; get start of vars low byte
00899    C297  85 71              STA   ut1_pl            ; save it
00900    C299  A5 AB              LDA   Baslnh            ; get found line pointer high byte
00901    C29B  85 74              STA   ut2_ph            ; save it
00902    C29D  A5 AA              LDA   Baslnl            ; get found line pointer low byte
00903    C29F  88                 DEY                     ; decrement index
00904    C2A0  F1 AA              SBC   (Baslnl),Y        ; subtract next line pointer low byte
00905    C2A2  18                 CLC                     ; clear carry for add
00906    C2A3  65 7B              ADC   Svarl             ; add start of vars low byte
00907    C2A5  85 7B              STA   Svarl             ; save new start of vars low byte
00908    C2A7  85 73              STA   ut2_pl            ; save destination pointer low byte
00909    C2A9  A5 7C              LDA   Svarh             ; get start of vars high byte
00910    C2AB  69 FF              ADC   #$FF              ; -1 + carry
00911    C2AD  85 7C              STA   Svarh             ; save start of vars high byte
00912    C2AF  E5 AB              SBC   Baslnh            ; subtract found line pointer high byte
00913    C2B1  AA                 TAX                     ; copy to block count
00914    C2B2  38                 SEC                     ; set carry for subtract
00915    C2B3  A5 AA              LDA   Baslnl            ; get found line pointer low byte
00916    C2B5  E5 7B              SBC   Svarl             ; subtract start of vars low byte
00917    C2B7  A8                 TAY                     ; copy to bytes in first block count
00918    C2B8  B0 03              BCS   LAB_12D0          ; branch if overflow
00919    
00920    C2BA  E8                 INX                     ; increment block count (correct for =0 loop exit)
00921    C2BB  C6 74              DEC   ut2_ph            ; decrement destination high byte
00922    LAB_12D0
00923    C2BD  18                 CLC                     ; clear carry for add
00924    C2BE  65 71              ADC   ut1_pl            ; add source pointer low byte
00925    C2C0  90 03              BCC   LAB_12D8          ; branch if no overflow
00926    
00927    C2C2  C6 72              DEC   ut1_ph            ; else decrement source pointer high byte
00928    C2C4  18                 CLC                     ; clear carry
00929    
00930                                  ; close up memory to delete old line
00931    LAB_12D8
00932    C2C5  B1 71              LDA   (ut1_pl),Y        ; get byte from source
00933    C2C7  91 73              STA   (ut2_pl),Y        ; copy to destination
00934    C2C9  C8                 INY                     ; increment index
00935    C2CA  D0 F9              BNE   LAB_12D8          ; while <> 0 do this block
00936    
00937    C2CC  E6 72              INC   ut1_ph            ; increment source pointer high byte
00938    C2CE  E6 74              INC   ut2_ph            ; increment destination pointer high byte
00939    C2D0  CA                 DEX                     ; decrement block count
00940    C2D1  D0 F2              BNE   LAB_12D8          ; loop until all done
00941    
00942                                  ; got new line in buffer and no existing same #
00943    LAB_12E6
00944    C2D3  AD 00 0B           LDA   Ibuffs            ; get byte from start of input buffer
00945    C2D6  F0 3F              BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
00946    
00947                                  ; got new line and it isn't empty line
00948    C2D8  A5 85              LDA   Ememl             ; get end of mem low byte
00949    C2DA  A4 86              LDY   Ememh             ; get end of mem high byte
00950    C2DC  85 81              STA   Sstorl            ; set bottom of string space low byte
00951    C2DE  84 82              STY   Sstorh            ; set bottom of string space high byte
00952    C2E0  A5 7B              LDA   Svarl             ; get start of vars low byte  (end of BASIC)
00953    C2E2  85 A6              STA   Obendl            ; save old block end low byte
00954    C2E4  A4 7C              LDY   Svarh             ; get start of vars high byte (end of BASIC)
00955    C2E6  84 A7              STY   Obendh            ; save old block end high byte
00956    C2E8  65 5D              ADC   Ibptr             ; add input buffer pointer    (also buffer length)
00957    C2EA  90 01              BCC   LAB_1301          ; branch if no overflow from add
00958    
00959    C2EC  C8                 INY                     ; else increment high byte
00960    LAB_1301
00961    C2ED  85 A4              STA   Nbendl            ; save new block end low byte (move to, low byte)
00962    C2EF  84 A5              STY   Nbendh            ; save new block end high byte
00963    C2F1  20 C1 C1           JSR   LAB_11CF          ; open up space in memory
00964                                  ; old start pointer Ostrtl,Ostrth set by the find line call
00965    C2F4  A5 7F              LDA   Earryl            ; get array mem end low byte
00966    C2F6  A4 80              LDY   Earryh            ; get array mem end high byte
00967    C2F8  85 7B              STA   Svarl             ; save start of vars low byte
00968    C2FA  84 7C              STY   Svarh             ; save start of vars high byte
00969    C2FC  A4 5D              LDY   Ibptr             ; get input buffer pointer    (also buffer length)
00970    C2FE  88                 DEY                     ; adjust for loop type
00971    LAB_1311
00972    C2FF  B9 FC 0A           LDA   Ibuffs-4,Y        ; get byte from crunched line
00973    C302  91 AA              STA   (Baslnl),Y        ; save it to program memory
00974    C304  88                 DEY                     ; decrement count
00975    C305  C0 03              CPY   #$03              ; compare with first byte-1
00976    C307  D0 F6              BNE   LAB_1311          ; continue while count <> 3
00977    
00978    C309  A5 12              LDA   Itemph            ; get line # high byte
00979    C30B  91 AA              STA   (Baslnl),Y        ; save it to program memory
00980    C30D  88                 DEY                     ; decrement count
00981    C30E  A5 11              LDA   Itempl            ; get line # low byte
00982    C310  91 AA              STA   (Baslnl),Y        ; save it to program memory
00983    C312  88                 DEY                     ; decrement count
00984    C313  A9 FF              LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
00985                                  ; byte then a zero already here would stop the chain rebuild
00986                                  ; as it would think it was the [EOT] marker.
00987    C315  91 AA              STA   (Baslnl),Y        ; save it to program memory
00988    
00989    LAB_1319
00990    C317  20 6E C4           JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
00991    C31A  A6 79              LDX   Smeml             ; get start of mem low byte
00992    C31C  A5 7A              LDA   Smemh             ; get start of mem high byte
00993    C31E  A0 01              LDY   #$01              ; index to high byte of next line pointer
00994    LAB_1325
00995    C320  86 71              STX   ut1_pl            ; set line start pointer low byte
00996    C322  85 72              STA   ut1_ph            ; set line start pointer high byte
00997    C324  B1 71              LDA   (ut1_pl),Y        ; get it
00998    C326  F0 18              BEQ   LAB_133E          ; exit if end of program
00999    
01000    ; rebuild chaining of Basic lines
01001    
01002    C328  A0 04              LDY   #$04              ; point to first code byte of line
01003                                  ; there is always 1 byte + [EOL] as null entries are deleted
01004    LAB_1330
01005    C32A  C8                 INY                     ; next code byte
01006    C32B  B1 71              LDA   (ut1_pl),Y        ; get byte
01007    C32D  D0 FB              BNE   LAB_1330          ; loop if not [EOL]
01008    
01009    C32F  38                 SEC                     ; set carry for add + 1
01010    C330  98                 TYA                     ; copy end index
01011    C331  65 71              ADC   ut1_pl            ; add to line start pointer low byte
01012    C333  AA                 TAX                     ; copy to X
01013    C334  A0 00              LDY   #$00              ; clear index, point to this line's next line pointer
01014    C336  91 71              STA   (ut1_pl),Y        ; set next line pointer low byte
01015    C338  98                 TYA                     ; clear A
01016    C339  65 72              ADC   ut1_ph            ; add line start pointer high byte + carry
01017    C33B  C8                 INY                     ; increment index to high byte
01018    C33C  91 71              STA   (ut1_pl),Y        ; save next line pointer low byte
01019    C33E  90 E0              BCC   LAB_1325          ; go do next line, branch always, carry clear
01020    
01021    
01022    LAB_133E
01023    C340  4C 6A C2           JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
01024    
01025    ; print "? " and get BASIC input
01026    
01027    LAB_INLN
01028    C343  20 F2 C9           JSR   LAB_18E3          ; print "?" character
01029    C346  20 EF C9           JSR   LAB_18E0          ; print " "
01030    C349  D0 05              BNE   LAB_1357          ; call for BASIC input and return
01031    
01032    ; receive line from keyboard
01033    
01034                                  ; $08 as delete key (BACKSPACE on standard keyboard)
01035    LAB_134B
01036    C34B  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01037    C34E  CA                 DEX                     ; decrement the buffer counter (delete)
01038          .byte $2C               ; make LDX into BIT abs
01039    
01040    ; call for BASIC input (main entry point)
01041    
01042    LAB_1357
01043    C350  A2 00              LDX   #$00              ; clear BASIC line buffer pointer
01044    LAB_1359
01045    C352  20 FF E1           JSR   V_INPT            ; call scan input device
01046    C355  90 FB              BCC   LAB_1359          ; loop if no byte
01047    
01048    C357  F0 F9              BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
01049    
01050    C359  C9 07              CMP   #$07              ; compare with [BELL]
01051    C35B  F0 10              BEQ   LAB_1378          ; branch if [BELL]
01052    
01053    C35D  C9 0D              CMP   #$0D              ; compare with [CR]
01054    C35F  F0 19              BEQ   LAB_1384          ; do CR/LF exit if [CR]
01055    
01056    C361  E0 00              CPX   #$00              ; compare pointer with $00
01057    C363  D0 04              BNE   LAB_1374          ; branch if not empty
01058    
01059    ; next two lines ignore any non print character and [SPACE] if input buffer empty
01060    ; FINDME_INPUTMOD
01061    
01062    C365  C9 21              CMP   #$21              ; compare with [SP]+1
01063    C367  90 E9              BCC   LAB_1359          ; if < ignore character
01064    
01065    LAB_1374
01066    C369  C9 08              CMP   #$08              ; compare with [BACKSPACE] (delete last character)
01067    C36B  F0 DE              BEQ   LAB_134B          ; go delete last character
01068    
01069    LAB_1378
01070    C36D  E0 7F              CPX   #Ibuffe-Ibuffs    ; compare character count with max
01071    C36F  B0 0C              BCS   LAB_138E          ; skip store and do [BELL] if buffer full
01072    
01073    C371  9D 00 0B           STA   Ibuffs,X          ; else store in buffer
01074    C374  E8                 INX                     ; increment pointer
01075    LAB_137F
01076    C375  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01077    C378  D0 D8              BNE   LAB_1359          ; always loop for next character
01078    
01079    LAB_1384
01080    C37A  4C 90 C9           JMP   LAB_1866          ; do CR/LF exit to BASIC
01081    
01082    ; announce buffer full
01083    
01084    LAB_138E
01085    C37D  A9 07              LDA   #$07              ; [BELL] character into A
01086    C37F  D0 F4              BNE   LAB_137F          ; go print the [BELL] but ignore input character
01087                                  ; branch always
01088    
01089    ; crunch keywords into Basic tokens
01090    ; position independent buffer version ..
01091    ; faster, dictionary search version ....
01092    
01093    LAB_13A6
01094    C381  A0 FF              LDY   #$FF              ; set save index (makes for easy math later)
01095    
01096    C383  38                 SEC                     ; set carry for subtract
01097    C384  A5 C3              LDA   Bpntrl            ; get basic execute pointer low byte
01098    C386  E9 00              SBC   #<Ibuffs          ; subtract input buffer start pointer
01099    C388  AA                 TAX                     ; copy result to X (index past line # if any)
01100    
01101    C389  86 60              STX   Oquote            ; clear open quote/DATA flag
01102    LAB_13AC
01103    C38B  BD 00 0B           LDA   Ibuffs,X          ; get byte from input buffer
01104    C38E  F0 51              BEQ   LAB_13EC          ; if null save byte then exit
01105    
01106    C390  C9 5F              CMP   #'_'              ; compare with "_"
01107    C392  B0 4D              BCS   LAB_13EC          ; if >= go save byte then continue crunching
01108    
01109    C394  C9 3C              CMP   #'<'              ; compare with "<"
01110    C396  B0 0E              BCS   LAB_13CC          ; if >= go crunch now
01111    
01112    C398  C9 30              CMP   #'0'              ; compare with "0"
01113    C39A  B0 45              BCS   LAB_13EC          ; if >= go save byte then continue crunching
01114    
01115    C39C  85 5C              STA   Scnquo            ; save buffer byte as search character
01116    C39E  C9 22              CMP   #$22              ; is it quote character?
01117    C3A0  F0 61              BEQ   LAB_1410          ; branch if so (copy quoted string)
01118    
01119    C3A2  C9 2A              CMP   #'*'              ; compare with "*"
01120    C3A4  90 3B              BCC   LAB_13EC          ; if < go save byte then continue crunching
01121    
01122                                  ; else crunch now
01123    LAB_13CC
01124    C3A6  24 60              BIT   Oquote            ; get open quote/DATA token flag
01125    C3A8  70 37              BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
01126                                  ; go save byte then continue crunching
01127    
01128    C3AA  86 78              STX   TempB             ; save buffer read index
01129    C3AC  84 BA              STY   csidx             ; copy buffer save index
01130    C3AE  A0 3F              LDY   #<TAB_1STC        ; get keyword first character table low address
01131    C3B0  84 73              STY   ut2_pl            ; save pointer low byte
01132    C3B2  A0 E4              LDY   #>TAB_1STC        ; get keyword first character table high address
01133    C3B4  84 74              STY   ut2_ph            ; save pointer high byte
01134    C3B6  A0 00              LDY   #$00              ; clear table pointer
01135    
01136    LAB_13D0
01137    C3B8  D1 73              CMP   (ut2_pl),Y        ; compare with keyword first character table byte
01138    C3BA  F0 05              BEQ   LAB_13D1          ; go do word_table_chr if match
01139    
01140    C3BC  90 21              BCC   LAB_13EA          ; if < keyword first character table byte go restore
01141                                  ; Y and save to crunched
01142    
01143    C3BE  C8                 INY                     ; else increment pointer
01144    C3BF  D0 F7              BNE   LAB_13D0          ; and loop (branch always)
01145    
01146    ; have matched first character of some keyword
01147    
01148    LAB_13D1
01149    C3C1  98                 TYA                     ; copy matching index
01150    C3C2  0A                 ASL                     ; *2 (bytes per pointer)
01151    C3C3  AA                 TAX                     ; copy to new index
01152    C3C4  BD 5D E4           LDA   TAB_CHRT,X        ; get keyword table pointer low byte
01153    C3C7  85 73              STA   ut2_pl            ; save pointer low byte
01154    C3C9  BD 5E E4           LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
01155    C3CC  85 74              STA   ut2_ph            ; save pointer high byte
01156    
01157    C3CE  A0 FF              LDY   #$FF              ; clear table pointer (make -1 for start)
01158    
01159    C3D0  A6 78              LDX   TempB             ; restore buffer read index
01160    
01161    LAB_13D6
01162    C3D2  C8                 INY                     ; next table byte
01163    C3D3  B1 73              LDA   (ut2_pl),Y        ; get byte from table
01164    LAB_13D8
01165    C3D5  30 08              BMI   LAB_13EA          ; all bytes matched so go save token
01166    
01167    C3D7  E8                 INX                     ; next buffer byte
01168    C3D8  DD 00 0B           CMP   Ibuffs,X          ; compare with byte from input buffer
01169    C3DB  F0 F5              BEQ   LAB_13D6          ; go compare next if match
01170    
01171    C3DD  D0 2B              BNE   LAB_1417          ; branch if >< (not found keyword)
01172    
01173    LAB_13EA
01174    C3DF  A4 BA              LDY   csidx             ; restore save index
01175    
01176                                  ; save crunched to output
01177    LAB_13EC
01178    C3E1  E8                 INX                     ; increment buffer index (to next input byte)
01179    C3E2  C8                 INY                     ; increment save index (to next output byte)
01180    C3E3  99 00 0B           STA   Ibuffs,Y          ; save byte to output
01181    C3E6  C9 00              CMP   #$00              ; set the flags, set carry
01182    C3E8  F0 32              BEQ   LAB_142A          ; do exit if was null [EOL]
01183    
01184                                  ; A holds token or byte here
01185    C3EA  E9 3A              SBC   #':'              ; subtract ":" (carry set by CMP #00)
01186    C3EC  F0 04              BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
01187    
01188                                  ; A now holds token-$3A
01189    C3EE  C9 49              CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
01190    C3F0  D0 02              BNE   LAB_1401          ; branch if not DATA
01191    
01192                                  ; token was : or DATA
01193    LAB_13FF
01194    C3F2  85 60              STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
01195    LAB_1401
01196    C3F4  49 57              EOR   #TK_REM-$3A       ; effectively subtract REM token offset
01197    C3F6  D0 93              BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
01198    
01199    C3F8  85 5C              STA   Asrch             ; else was REM so set search for [EOL]
01200    
01201                                  ; loop for REM, "..." etc.
01202    LAB_1408
01203    C3FA  BD 00 0B           LDA   Ibuffs,X          ; get byte from input buffer
01204    C3FD  F0 E2              BEQ   LAB_13EC          ; branch if null [EOL]
01205    
01206    C3FF  C5 5C              CMP   Asrch             ; compare with stored character
01207    C401  F0 DE              BEQ   LAB_13EC          ; branch if match (end quote)
01208    
01209                                  ; entry for copy string in quotes, don't crunch
01210    LAB_1410
01211    C403  C8                 INY                     ; increment buffer save index
01212    C404  99 00 0B           STA   Ibuffs,Y          ; save byte to output
01213    C407  E8                 INX                     ; increment buffer read index
01214    C408  D0 F0              BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
01215    
01216                                  ; not found keyword this go
01217    LAB_1417
01218    C40A  A6 78              LDX   TempB             ; compare has failed, restore buffer index (start byte!)
01219    
01220                                  ; now find the end of this word in the table
01221    LAB_141B
01222    C40C  B1 73              LDA   (ut2_pl),Y        ; get table byte
01223    C40E  08                 PHP                     ; save status
01224    C40F  C8                 INY                     ; increment table index
01225    C410  28                 PLP                     ; restore byte status
01226    C411  10 F9              BPL   LAB_141B          ; if not end of keyword go do next
01227    
01228    C413  B1 73              LDA   (ut2_pl),Y        ; get byte from keyword table
01229    C415  D0 BE              BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
01230    
01231                                  ; reached end of table with no match
01232    C417  BD 00 0B           LDA   Ibuffs,X          ; restore byte from input buffer
01233    C41A  10 C3              BPL   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
01234                                  ; go save byte in output and continue crunching
01235    
01236                                  ; reached [EOL]
01237    LAB_142A
01238    C41C  C8                 INY                     ; increment pointer
01239    C41D  C8                 INY                     ; increment pointer (makes it next line pointer high byte)
01240    C41E  99 00 0B           STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
01241    C421  C8                 INY                     ; adjust for line copy
01242    C422  C8                 INY                     ; adjust for line copy
01243    C423  C8                 INY                     ; adjust for line copy
01244    ; *** begin patch for when Ibuffs is $xx00 - Daryl Rictor ***
01245    ; *** insert
01246          .IF   Ibuffs&$FF==0
01247    C424  A5 C3              LDA   Bpntrl            ; test for $00
01248    C426  D0 02              BNE   LAB_142P          ; not $00
01249    C428  C6 C4              DEC   Bpntrh            ; allow for increment when $xx00
01250    LAB_142P
01251          .ENDIF
01252    ; *** end   patch for when Ibuffs is $xx00 - Daryl Rictor ***
01253    ; end of patch
01254    C42A  C6 C3              DEC   Bpntrl            ; allow for increment
01255    C42C  60                 RTS
01256    
01257    ; search Basic for temp integer line number from start of mem
01258    
01259    LAB_SSLN
01260    C42D  A5 79              LDA   Smeml             ; get start of mem low byte
01261    C42F  A6 7A              LDX   Smemh             ; get start of mem high byte
01262    
01263    ; search Basic for temp integer line number from AX
01264    ; returns carry set if found
01265    ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
01266    
01267    ; old 541 new 507
01268    
01269    LAB_SHLN
01270    C431  A0 01              LDY   #$01              ; set index
01271    C433  85 AA              STA   Baslnl            ; save low byte as current
01272    C435  86 AB              STX   Baslnh            ; save high byte as current
01273    C437  B1 AA              LDA   (Baslnl),Y        ; get pointer high byte from addr
01274    C439  F0 1A              BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
01275    
01276    C43B  A0 03              LDY   #$03              ; set index to line # high byte
01277    C43D  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
01278    C43F  88                 DEY                     ; decrement index (point to low byte)
01279    C440  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01280    C442  D0 04              BNE   LAB_1455          ; if <> skip low byte check
01281    
01282    C444  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
01283    C446  C5 11              CMP   Itempl            ; compare with temporary integer low byte
01284    LAB_1455
01285    C448  B0 09              BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
01286    
01287    LAB_1456
01288    C44A  88                 DEY                     ; decrement index to next line ptr high byte
01289    C44B  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
01290    C44D  AA                 TAX                     ; copy to X
01291    C44E  88                 DEY                     ; decrement index to next line ptr low byte
01292    C44F  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
01293    C451  90 DE              BCC   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
01294                                  ; (carry always clear)
01295    
01296    LAB_145E
01297    C453  F0 01              BEQ   LAB_1460          ; exit if temp = found line #, carry is set
01298    
01299    LAB_145F
01300    C455  18                 CLC                     ; clear found flag
01301    LAB_1460
01302    C456  60                 RTS
01303    
01304    ; perform NEW
01305    
01306    LAB_NEW
01307    C457  D0 FD              BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
01308    
01309    LAB_1463
01310    C459  A9 00              LDA   #$00              ; clear A
01311    C45B  A8                 TAY                     ; clear Y
01312    C45C  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, low byte
01313    C45E  C8                 INY                     ; increment index
01314    C45F  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, high byte
01315    C461  18                 CLC                     ; clear carry
01316    C462  A5 79              LDA   Smeml             ; get start of mem low byte
01317    C464  69 02              ADC   #$02              ; calculate end of BASIC low byte
01318    C466  85 7B              STA   Svarl             ; save start of vars low byte
01319    C468  A5 7A              LDA   Smemh             ; get start of mem high byte
01320    C46A  69 00              ADC   #$00              ; add any carry
01321    C46C  85 7C              STA   Svarh             ; save start of vars high byte
01322    
01323    ; reset execution to start, clear vars and flush stack
01324    
01325    LAB_1477
01326    C46E  18                 CLC                     ; clear carry
01327    C46F  A5 79              LDA   Smeml             ; get start of mem low byte
01328    C471  69 FF              ADC   #$FF              ; -1
01329    C473  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01330    C475  A5 7A              LDA   Smemh             ; get start of mem high byte
01331    C477  69 FF              ADC   #$FF              ; -1+carry
01332    C479  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
01333    
01334    ; "CLEAR" command gets here
01335    
01336    LAB_147A
01337    C47B  A5 85              LDA   Ememl             ; get end of mem low byte
01338    C47D  A4 86              LDY   Ememh             ; get end of mem high byte
01339    C47F  85 81              STA   Sstorl            ; set bottom of string space low byte
01340    C481  84 82              STY   Sstorh            ; set bottom of string space high byte
01341    C483  A5 7B              LDA   Svarl             ; get start of vars low byte
01342    C485  A4 7C              LDY   Svarh             ; get start of vars high byte
01343    C487  85 7D              STA   Sarryl            ; save var mem end low byte
01344    C489  84 7E              STY   Sarryh            ; save var mem end high byte
01345    C48B  85 7F              STA   Earryl            ; save array mem end low byte
01346    C48D  84 80              STY   Earryh            ; save array mem end high byte
01347    C48F  20 46 C6           JSR   LAB_161A          ; perform RESTORE command
01348    
01349    ; flush stack and clear continue flag
01350    
01351    LAB_1491
01352    C492  A2 68              LDX   #des_sk           ; set descriptor stack pointer
01353    C494  86 65              STX   next_s            ; save descriptor stack pointer
01354    C496  68                 PLA                     ; pull return address low byte
01355    C497  AA                 TAX                     ; copy return address low byte
01356    C498  68                 PLA                     ; pull return address high byte
01357    C499  8E FE 01           STX   LAB_SKFE          ; save to cleared stack
01358    C49C  8D FF 01           STA   LAB_SKFF          ; save to cleared stack
01359    C49F  A2 FD              LDX   #$FD              ; new stack pointer
01360    C4A1  9A                 TXS                     ; reset stack
01361    C4A2  A9 00              LDA   #$00              ; clear byte
01362    ;*** fix p2: no longer necessary as the continue pointer is saved anyway
01363    ;      STA   Cpntrh            ; clear continue pointer high byte
01364    C4A4  85 61              STA   Sufnxf            ; clear subscript/FNX flag
01365    LAB_14A6
01366    C4A6  60                 RTS
01367    
01368    ; perform CLEAR
01369    
01370    LAB_CLEAR
01371    C4A7  F0 D2              BEQ   LAB_147A          ; if no following token go do "CLEAR"
01372    
01373                                  ; else there was a following token (go do syntax error)
01374    C4A9  60                 RTS
01375    
01376    ; perform LIST [n][-m]
01377    ; bigger, faster version (a _lot_ faster)
01378    
01379    LAB_LIST
01380    C4AA  90 06              BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
01381    
01382    C4AC  F0 04              BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
01383    
01384    C4AE  C9 BE              CMP   #TK_MINUS         ; compare with token for -
01385    C4B0  D0 F4              BNE   LAB_14A6          ; exit if not - (LIST -m)
01386    
01387                                  ; LIST [[n][-m]]
01388                                  ; this bit sets the n , if present, as the start and end
01389    LAB_14BD
01390    C4B2  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01391    C4B5  20 2D C4           JSR   LAB_SSLN          ; search BASIC for temp integer line number
01392                                  ; (pointer in Baslnl/Baslnh)
01393    C4B8  20 C2 00           JSR   LAB_GBYT          ; scan memory
01394    C4BB  F0 0C              BEQ   LAB_14D4          ; branch if no more characters
01395    
01396                                  ; this bit checks the - is present
01397    C4BD  C9 BE              CMP   #TK_MINUS         ; compare with token for -
01398    C4BF  D0 95              BNE   LAB_1460          ; return if not "-" (will be Syntax error)
01399    
01400                                  ; LIST [n]-m
01401                                  ; the - was there so set m as the end value
01402    C4C1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01403    C4C4  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01404    C4C7  D0 8D              BNE   LAB_1460          ; exit if not ok
01405    
01406    LAB_14D4
01407    C4C9  A5 11              LDA   Itempl            ; get temporary integer low byte
01408    C4CB  05 12              ORA   Itemph            ; OR temporary integer high byte
01409    C4CD  D0 06              BNE   LAB_14E2          ; branch if start set
01410    
01411    C4CF  A9 FF              LDA   #$FF              ; set for -1
01412    C4D1  85 11              STA   Itempl            ; set temporary integer low byte
01413    C4D3  85 12              STA   Itemph            ; set temporary integer high byte
01414    LAB_14E2
01415    C4D5  A0 01              LDY   #$01              ; set index for line
01416    C4D7  84 60              STY   Oquote            ; clear open quote flag
01417    C4D9  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
01418    C4DC  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
01419                                  ; pointer initially set by search at LAB_14BD
01420    C4DE  F0 3E              BEQ   LAB_152B          ; if null all done so exit
01421    C4E0  20 1C C6           JSR   LAB_1629          ; do CRTL-C check vector
01422    
01423    C4E3  C8                 INY                     ; increment index for line
01424    C4E4  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
01425    C4E6  AA                 TAX                     ; copy to X
01426    C4E7  C8                 INY                     ; increment index
01427    C4E8  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
01428    C4EA  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01429    C4EC  D0 04              BNE   LAB_14FF          ; branch if no high byte match
01430    
01431    C4EE  E4 11              CPX   Itempl            ; compare with temporary integer low byte
01432    C4F0  F0 02              BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
01433    
01434    LAB_14FF                      ; else ..
01435    C4F2  B0 2A              BCS   LAB_152B          ; if greater all done so exit
01436    
01437    LAB_1501
01438    C4F4  84 97              STY   Tidx1             ; save index for line
01439    C4F6  20 95 DB           JSR   LAB_295E          ; print XA as unsigned integer
01440    C4F9  A9 20              LDA   #$20              ; space is the next character
01441    LAB_1508
01442    C4FB  A4 97              LDY   Tidx1             ; get index for line
01443    C4FD  29 7F              AND   #$7F              ; mask top out bit of character
01444    LAB_150C
01445    C4FF  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01446    C502  C9 22              CMP   #$22              ; was it " character
01447    C504  D0 06              BNE   LAB_1519          ; branch if not
01448    
01449                                  ; we are either entering or leaving a pair of quotes
01450    C506  A5 60              LDA   Oquote            ; get open quote flag
01451    C508  49 FF              EOR   #$FF              ; toggle it
01452    C50A  85 60              STA   Oquote            ; save it back
01453    LAB_1519
01454    C50C  C8                 INY                     ; increment index
01455    C50D  B1 AA              LDA   (Baslnl),Y        ; get next byte
01456    C50F  D0 0E              BNE   LAB_152E          ; branch if not [EOL] (go print character)
01457    C511  A8                 TAY                     ; else clear index
01458    C512  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
01459    C514  AA                 TAX                     ; copy to X
01460    C515  C8                 INY                     ; increment index
01461    C516  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
01462    C518  86 AA              STX   Baslnl            ; set pointer to line low byte
01463    C51A  85 AB              STA   Baslnh            ; set pointer to line high byte
01464    C51C  D0 B7              BNE   LAB_14E2          ; go do next line if not [EOT]
01465                                  ; else ..
01466    LAB_152B
01467    C51E  60                 RTS
01468    
01469    LAB_152E
01470    C51F  10 DE              BPL   LAB_150C          ; just go print it if not token byte
01471    
01472                                  ; else was token byte so uncrunch it (maybe)
01473    C521  24 60              BIT   Oquote            ; test the open quote flag
01474    C523  30 DA              BMI   LAB_150C          ; just go print character if open quote set
01475    
01476    C525  A2 E6              LDX   #>LAB_KEYT        ; get table address high byte
01477    C527  0A                 ASL                     ; *2
01478    C528  0A                 ASL                     ; *4
01479    C529  90 02              BCC   LAB_152F          ; branch if no carry
01480    
01481    C52B  E8                 INX                     ; else increment high byte
01482    C52C  18                 CLC                     ; clear carry for add
01483    LAB_152F
01484    C52D  69 63              ADC   #<LAB_KEYT        ; add low byte
01485    C52F  90 01              BCC   LAB_1530          ; branch if no carry
01486    
01487    C531  E8                 INX                     ; else increment high byte
01488    LAB_1530
01489    C532  85 73              STA   ut2_pl            ; save table pointer low byte
01490    C534  86 74              STX   ut2_ph            ; save table pointer high byte
01491    C536  84 97              STY   Tidx1             ; save index for line
01492    C538  A0 00              LDY   #$00              ; clear index
01493    C53A  B1 73              LDA   (ut2_pl),Y        ; get length
01494    C53C  AA                 TAX                     ; copy length
01495    C53D  C8                 INY                     ; increment index
01496    C53E  B1 73              LDA   (ut2_pl),Y        ; get 1st character
01497    C540  CA                 DEX                     ; decrement length
01498    C541  F0 B8              BEQ   LAB_1508          ; if no more characters exit and print
01499    
01500    C543  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01501    C546  C8                 INY                     ; increment index
01502    C547  B1 73              LDA   (ut2_pl),Y        ; get keyword address low byte
01503    C549  48                 PHA                     ; save it for now
01504    C54A  C8                 INY                     ; increment index
01505    C54B  B1 73              LDA   (ut2_pl),Y        ; get keyword address high byte
01506    C54D  A0 00              LDY   #$00
01507    C54F  85 74              STA   ut2_ph            ; save keyword pointer high byte
01508    C551  68                 PLA                     ; pull low byte
01509    C552  85 73              STA   ut2_pl            ; save keyword pointer low byte
01510    LAB_1540
01511    C554  B1 73              LDA   (ut2_pl),Y        ; get character
01512    C556  CA                 DEX                     ; decrement character count
01513    C557  F0 A2              BEQ   LAB_1508          ; if last character exit and print
01514    
01515    C559  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01516    C55C  C8                 INY                     ; increment index
01517    C55D  D0 F5              BNE   LAB_1540          ; loop for next character
01518    
01519    ; perform FOR
01520    
01521    LAB_FOR
01522    C55F  A9 80              LDA   #$80              ; set FNX
01523    C561  85 61              STA   Sufnxf            ; set subscript/FNX flag
01524    C563  20 BB C8           JSR   LAB_LET           ; go do LET
01525    C566  68                 PLA                     ; pull return address
01526    C567  68                 PLA                     ; pull return address
01527    C568  A9 10              LDA   #$10              ; we need 16d bytes !
01528    C56A  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
01529    C56D  20 A1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
01530    C570  18                 CLC                     ; clear carry for add
01531    C571  98                 TYA                     ; copy index to A
01532    C572  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01533    C574  48                 PHA                     ; push onto stack
01534    C575  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
01535    C577  69 00              ADC   #$00              ; add carry
01536    C579  48                 PHA                     ; push onto stack
01537    C57A  A5 88              LDA   Clineh            ; get current line high byte
01538    C57C  48                 PHA                     ; push onto stack
01539    C57D  A5 87              LDA   Clinel            ; get current line low byte
01540    C57F  48                 PHA                     ; push onto stack
01541    C580  A9 B4              LDA   #TK_TO            ; get "TO" token
01542    C582  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
01543    C585  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
01544    C588  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
01545                                  ; else do type mismatch
01546    ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
01547    ; *** add
01548    C58B  20 EC D9           JSR   LAB_27BA          ; round FAC1
01549    ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
01550    C58E  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
01551    C590  09 7F              ORA   #$7F              ; set all non sign bits
01552    C592  25 AD              AND   FAC1_1            ; and FAC1 mantissa1
01553    C594  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
01554    C596  A9 A1              LDA   #<LAB_159F        ; set return address low byte
01555    C598  A0 C5              LDY   #>LAB_159F        ; set return address high byte
01556    C59A  85 71              STA   ut1_pl            ; save return address low byte
01557    C59C  84 72              STY   ut1_ph            ; save return address high byte
01558    C59E  4C 8D CC           JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
01559    
01560    LAB_159F
01561    C5A1  A9 01              LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
01562    C5A3  A0 E3              LDY   #>LAB_259C        ; set 1 pointer high addr
01563    C5A5  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
01564    C5A8  20 C2 00           JSR   LAB_GBYT          ; scan memory
01565    C5AB  C9 B9              CMP   #TK_STEP          ; compare with STEP token
01566    C5AD  D0 06              BNE   LAB_15B3          ; jump if not "STEP"
01567    
01568                                  ;.was step so ..
01569    C5AF  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01570    C5B2  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
01571                                  ; else do type mismatch
01572    LAB_15B3
01573    C5B5  20 FC D9           JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
01574    C5B8  85 B0              STA   FAC1_s            ; set FAC1 sign (b7)
01575                                  ; this is +1 for +ve step and -1 for -ve step, in NEXT we
01576                                  ; compare the FOR value and the TO value and return +1 if
01577                                  ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
01578                                  ; here (+/-1) is then compared to that result and if they
01579                                  ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
01580                                  ; the loop is done
01581                                 
01582    ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
01583    ; *** add
01584       .IF [* & $FF] == $FD
01585    ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
01586    C5BA  20 7F CC           JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
01587    C5BD  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
01588    C5BF  48                 PHA                     ; push on stack
01589    C5C0  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
01590    C5C2  48                 PHA                     ; push on stack
01591    C5C3  A9 81              LDA   #TK_FOR           ; get FOR token
01592    C5C5  48                 PHA                     ; push on stack
01593    
01594    ; interpreter inner loop
01595    
01596    LAB_15C2
01597    C5C6  20 1C C6           JSR   LAB_1629          ; do CRTL-C check vector
01598    C5C9  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
01599    C5CB  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
01600    
01601    C5CD  A6 88              LDX   Clineh            ; continue line is $FFxx for immediate mode
01602                                  ; ($00xx for RUN from immediate mode)
01603    C5CF  E8                 INX                     ; increment it (now $00 if immediate mode)
01604    ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
01605    ;      BEQ   LAB_15D1          ; branch if null (immediate mode)
01606    
01607    C5D0  85 8B              STA   Cpntrl            ; save continue pointer low byte
01608    C5D2  84 8C              STY   Cpntrh            ; save continue pointer high byte
01609    LAB_15D1
01610    C5D4  A0 00              LDY   #$00              ; clear index
01611    C5D6  B1 C3              LDA   (Bpntrl),Y        ; get next byte
01612    C5D8  F0 07              BEQ   LAB_15DC          ; branch if null [EOL]
01613    
01614    C5DA  C9 3A              CMP   #':'              ; compare with ":"
01615    C5DC  F0 1D              BEQ   LAB_15F6          ; branch if = (statement separator)
01616    
01617    LAB_15D9
01618    C5DE  4C 08 CD           JMP   LAB_SNER          ; else syntax error then warm start
01619    
01620                                  ; have reached [EOL]
01621    LAB_15DC
01622    C5E1  A0 02              LDY   #$02              ; set index
01623    C5E3  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
01624    C5E5  18                 CLC                     ; clear carry for no "BREAK" message
01625    C5E6  F0 50              BEQ   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
01626                                  ; marker)
01627    
01628    C5E8  C8                 INY                     ; increment index
01629    C5E9  B1 C3              LDA   (Bpntrl),Y        ; get line # low byte
01630    C5EB  85 87              STA   Clinel            ; save current line low byte
01631    C5ED  C8                 INY                     ; increment index
01632    C5EE  B1 C3              LDA   (Bpntrl),Y        ; get line # high byte
01633    C5F0  85 88              STA   Clineh            ; save current line high byte
01634    C5F2  98                 TYA                     ; A now = 4
01635    C5F3  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01636    C5F5  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01637    C5F7  90 02              BCC   LAB_15F6          ; branch if no overflow
01638    
01639    C5F9  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
01640    LAB_15F6
01641    C5FB  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01642    
01643    LAB_15F9
01644    C5FE  20 04 C6           JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
01645    
01646    LAB_15FC
01647    C601  4C C6 C5           JMP   LAB_15C2          ; loop
01648    
01649    ; interpret BASIC code from (Bpntrl)
01650    
01651    LAB_15FF
01652    C604  F0 4E              BEQ   LAB_1628          ; exit if zero [EOL]
01653    
01654    LAB_1602
01655    C606  0A                 ASL                     ; *2 bytes per vector and normalise token
01656    C607  B0 03              BCS   LAB_1609          ; branch if was token
01657    
01658    C609  4C BB C8           JMP   LAB_LET           ; else go do implied LET
01659    
01660    LAB_1609
01661    C60C  C9 64              CMP   #[TK_TAB-$80]*2   ; compare normalised token * 2 with TAB
01662    C60E  B0 CE              BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
01663                                  ; only tokens before TAB can start a line
01664    C610  A8                 TAY                     ; copy to index
01665    C611  B9 29 E3           LDA   LAB_CTBL+1,Y      ; get vector high byte
01666    C614  48                 PHA                     ; onto stack
01667    C615  B9 28 E3           LDA   LAB_CTBL,Y        ; get vector low byte
01668    C618  48                 PHA                     ; onto stack
01669    C619  4C BC 00           JMP   LAB_IGBY          ; jump to increment and scan memory
01670                                  ; then "return" to vector
01671    
01672    ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
01673    ; key press is detected.
01674    
01675    LAB_1629
01676    C61C  6C 03 02           JMP   (VEC_CC)          ; ctrl c check vector
01677    
01678    ; if there was a key press it gets back here ..
01679    
01680    LAB_1636
01681    C61F  C9 03              CMP   #$03              ; compare with CTRL-C
01682    
01683    ; perform STOP
01684    
01685    LAB_STOP
01686    C621  B0 01              BCS   LAB_163B          ; branch if token follows STOP
01687                                  ; else just END
01688    ; END
01689    
01690    LAB_END
01691    C623  18                 CLC                     ; clear the carry, indicate a normal program end
01692    LAB_163B
01693    C624  D0 61              BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
01694    
01695    C626  A5 C4              LDA   Bpntrh            ; get the BASIC execute pointer high byte
01696    ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
01697    ;      EOR   #>Ibuffs          ; compare with buffer address high byte (Cb unchanged)
01698    ;      BEQ   LAB_164F          ; branch if the BASIC pointer is in the input buffer
01699    ;                              ; (can't continue in immediate mode)
01700    ;                              ; else ..
01701    ;      EOR   #>Ibuffs          ; correct the bits
01702    C628  A4 C3              LDY   Bpntrl            ; get BASIC execute pointer low byte
01703    C62A  84 8B              STY   Cpntrl            ; save continue pointer low byte
01704    C62C  85 8C              STA   Cpntrh            ; save continue pointer high byte
01705    LAB_1647
01706    C62E  A5 87              LDA   Clinel            ; get current line low byte
01707    C630  A4 88              LDY   Clineh            ; get current line high byte
01708    C632  85 89              STA   Blinel            ; save break line low byte
01709    C634  84 8A              STY   Blineh            ; save break line high byte
01710    LAB_164F
01711    C636  68                 PLA                     ; pull return address low
01712    C637  68                 PLA                     ; pull return address high
01713    LAB_1651
01714    C638  90 07              BCC   LAB_165E          ; if was program end just do warm start
01715    
01716                                  ; else ..
01717    C63A  A9 60              LDA   #<LAB_BMSG        ; point to "Break" low byte
01718    C63C  A0 E9              LDY   #>LAB_BMSG        ; point to "Break" high byte
01719    C63E  4C 52 C2           JMP   LAB_1269          ; print "Break" and do warm start
01720    
01721    LAB_165E
01722    C641  4C 5D C2           JMP   LAB_1274          ; go do warm start
01723    
01724    ; perform RESTORE
01725    
01726    LAB_RESTORE
01727    C644  D0 0F              BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
01728    
01729    LAB_161A
01730    C646  38                 SEC                     ; set carry for subtract
01731    C647  A5 79              LDA   Smeml             ; get start of mem low byte
01732    C649  E9 01              SBC   #$01              ; -1
01733    C64B  A4 7A              LDY   Smemh             ; get start of mem high byte
01734    C64D  B0 01              BCS   LAB_1624          ; branch if no underflow
01735    
01736    LAB_uflow
01737    C64F  88                 DEY                     ; else decrement high byte
01738    LAB_1624
01739    C650  85 8F              STA   Dptrl             ; save DATA pointer low byte
01740    C652  84 90              STY   Dptrh             ; save DATA pointer high byte
01741    LAB_1628
01742    C654  60                 RTS
01743    
01744                                  ; is RESTORE n
01745    LAB_RESTOREn
01746    C655  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01747    C658  20 A4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
01748    C65B  A5 88              LDA   Clineh            ; get current line high byte
01749    C65D  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01750    C65F  B0 0B              BCS   LAB_reset_search  ; branch if >= (start search from beginning)
01751    
01752    C661  98                 TYA                     ; else copy line index to A
01753    C662  38                 SEC                     ; set carry (+1)
01754    C663  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01755    C665  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
01756    C667  90 07              BCC   LAB_go_search     ; branch if no overflow to high byte
01757    
01758    C669  E8                 INX                     ; increment high byte
01759    C66A  B0 04              BCS   LAB_go_search     ; branch always (can never be carry clear)
01760    
01761    ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
01762    
01763    LAB_reset_search
01764    C66C  A5 79              LDA   Smeml             ; get start of mem low byte
01765    C66E  A6 7A              LDX   Smemh             ; get start of mem high byte
01766    
01767    ; search for line # in temp (Itempl/Itemph) from (AX)
01768    
01769    LAB_go_search
01770    
01771    C670  20 31 C4           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
01772    C673  B0 03              BCS   LAB_line_found    ; if carry set go set pointer
01773    
01774    C675  4C 76 C7           JMP   LAB_16F7          ; else go do "Undefined statement" error
01775    
01776    LAB_line_found
01777                                  ; carry already set for subtract
01778    C678  A5 AA              LDA   Baslnl            ; get pointer low byte
01779    C67A  E9 01              SBC   #$01              ; -1
01780    C67C  A4 AB              LDY   Baslnh            ; get pointer high byte
01781    C67E  B0 D0              BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
01782    
01783    C680  90 CD              BCC   LAB_uflow         ; else decrement high byte then save DATA pointer and
01784                                  ; return (branch always)
01785    
01786    ; perform NULL
01787    
01788    LAB_NULL
01789    C682  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
01790    C685  86 0D              STX   Nullct            ; save new NULL count
01791    LAB_167A
01792    C687  60                 RTS
01793    
01794    ; perform CONT
01795    
01796    LAB_CONT
01797    C688  D0 FD              BNE   LAB_167A          ; if following byte exit to do syntax error
01798    
01799    C68A  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
01800    C68C  C0 0B              CPY   #>Ibuffs          ; *** fix p2: test direct mode
01801    C68E  D0 05              BNE   LAB_166C          ; go do continue if we can
01802    
01803    C690  A2 1E              LDX   #$1E              ; error code $1E ("Can't continue" error)
01804    C692  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
01805    
01806                                  ; we can continue so ..
01807    LAB_166C
01808    C695  A9 93              LDA   #TK_ON            ; set token for ON
01809    C697  20 29 E0           JSR   LAB_IRQ           ; set IRQ flags
01810    C69A  A9 93              LDA   #TK_ON            ; set token for ON
01811    C69C  20 2C E0           JSR   LAB_NMI           ; set NMI flags
01812    
01813    C69F  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
01814    C6A1  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
01815    C6A3  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01816    C6A5  A5 89              LDA   Blinel            ; get break line low byte
01817    C6A7  A4 8A              LDY   Blineh            ; get break line high byte
01818    C6A9  85 87              STA   Clinel            ; set current line low byte
01819    C6AB  84 88              STY   Clineh            ; set current line high byte
01820    C6AD  60                 RTS
01821    
01822    ; perform RUN
01823    
01824    LAB_RUN
01825    C6AE  D0 03              BNE   LAB_1696          ; branch if RUN n
01826    C6B0  4C 6E C4           JMP   LAB_1477          ; reset execution to start, clear variables, flush stack and
01827                                  ; return
01828    
01829    ; does RUN n
01830    
01831    LAB_1696
01832    C6B3  20 7B C4           JSR   LAB_147A          ; go do "CLEAR"
01833    C6B6  F0 2E              BEQ   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
01834    
01835    ; perform DO
01836    
01837    LAB_DO
01838    C6B8  A9 05              LDA   #$05              ; need 5 bytes for DO
01839    C6BA  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
01840    C6BD  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
01841    C6BF  48                 PHA                     ; push on stack
01842    C6C0  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
01843    C6C2  48                 PHA                     ; push on stack
01844    C6C3  A5 88              LDA   Clineh            ; get current line high byte
01845    C6C5  48                 PHA                     ; push on stack
01846    C6C6  A5 87              LDA   Clinel            ; get current line low byte
01847    C6C8  48                 PHA                     ; push on stack
01848    C6C9  A9 9D              LDA   #TK_DO            ; token for DO
01849    C6CB  48                 PHA                     ; push on stack
01850    C6CC  20 C2 00           JSR   LAB_GBYT          ; scan memory
01851    C6CF  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
01852    
01853    ; perform GOSUB
01854    
01855    LAB_GOSUB
01856    C6D2  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
01857    C6D4  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
01858    C6D7  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
01859    C6D9  48                 PHA                     ; push on stack
01860    C6DA  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
01861    C6DC  48                 PHA                     ; push on stack
01862    C6DD  A5 88              LDA   Clineh            ; get current line high byte
01863    C6DF  48                 PHA                     ; push on stack
01864    C6E0  A5 87              LDA   Clinel            ; get current line low byte
01865    C6E2  48                 PHA                     ; push on stack
01866    C6E3  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
01867    C6E5  48                 PHA                     ; push on stack
01868    LAB_16B0
01869    C6E6  20 C2 00           JSR   LAB_GBYT          ; scan memory
01870    C6E9  20 EF C6           JSR   LAB_GOTO          ; perform GOTO n
01871    C6EC  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
01872                                  ; (can't RTS, we used the stack!)
01873    
01874    ; perform GOTO
01875    
01876    LAB_GOTO
01877    C6EF  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01878    C6F2  20 A4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
01879    C6F5  A5 88              LDA   Clineh            ; get current line high byte
01880    C6F7  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01881    C6F9  B0 0B              BCS   LAB_16D0          ; branch if >= (start search from beginning)
01882    
01883    C6FB  98                 TYA                     ; else copy line index to A
01884    C6FC  38                 SEC                     ; set carry (+1)
01885    C6FD  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01886    C6FF  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
01887    C701  90 07              BCC   LAB_16D4          ; branch if no overflow to high byte
01888    
01889    C703  E8                 INX                     ; increment high byte
01890    C704  B0 04              BCS   LAB_16D4          ; branch always (can never be carry)
01891    
01892    ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
01893    
01894    LAB_16D0
01895    C706  A5 79              LDA   Smeml             ; get start of mem low byte
01896    C708  A6 7A              LDX   Smemh             ; get start of mem high byte
01897    
01898    ; search for line # in temp (Itempl/Itemph) from (AX)
01899    
01900    LAB_16D4
01901    C70A  20 31 C4           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
01902    C70D  90 67              BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
01903                                  ; (unspecified statement)
01904    
01905                                  ; carry already set for subtract
01906    C70F  A5 AA              LDA   Baslnl            ; get pointer low byte
01907    C711  E9 01              SBC   #$01              ; -1
01908    C713  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01909    C715  A5 AB              LDA   Baslnh            ; get pointer high byte
01910    C717  E9 00              SBC   #$00              ; subtract carry
01911    C719  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
01912    LAB_16E5
01913    C71B  60                 RTS
01914    
01915    LAB_DONOK
01916    C71C  A2 22              LDX   #$22              ; error code $22 ("LOOP without DO" error)
01917    C71E  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
01918    
01919    ; perform LOOP
01920    
01921    LAB_LOOP
01922    C721  A8                 TAY                     ; save following token
01923    C722  BA                 TSX                     ; copy stack pointer
01924    C723  BD 03 01           LDA   LAB_STAK+3,X      ; get token byte from stack
01925    C726  C9 9D              CMP   #TK_DO            ; compare with DO token
01926    C728  D0 F2              BNE   LAB_DONOK         ; branch if no matching DO
01927    
01928    C72A  E8                 INX                     ; dump calling routine return address
01929    C72B  E8                 INX                     ; dump calling routine return address
01930    C72C  9A                 TXS                     ; correct stack
01931    C72D  98                 TYA                     ; get saved following token back
01932    C72E  F0 20              BEQ   LoopAlways        ; if no following token loop forever
01933                                  ; (stack pointer in X)
01934    
01935    C730  C9 3A              CMP   #':'              ; could be ':'
01936    C732  F0 1C              BEQ   LoopAlways        ; if :... loop forever
01937    
01938    C734  E9 BA              SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
01939    C736  AA                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)
01940    C737  F0 04              BEQ   DoRest            ; branch if was UNTIL
01941    
01942    C739  CA                 DEX                     ; decrement result
01943    C73A  D0 62              BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
01944                                  ; only if the token was WHILE will this fail
01945    
01946    C73C  CA                 DEX                     ; set invert result byte
01947    DoRest
01948    C73D  86 98              STX   Frnxth            ; save invert result byte
01949    C73F  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01950    C742  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
01951    C745  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
01952    C747  F0 02              BEQ   DoCmp             ; if =0 go do straight compare
01953    
01954    C749  A9 FF              LDA   #$FF              ; else set all bits
01955    DoCmp
01956    C74B  BA                 TSX                     ; copy stack pointer
01957    C74C  45 98              EOR   Frnxth            ; EOR with invert byte
01958    C74E  D0 1A              BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
01959    
01960                                  ; loop condition wasn't met so do it again
01961    LoopAlways
01962    C750  BD 02 01           LDA   LAB_STAK+2,X      ; get current line low byte
01963    C753  85 87              STA   Clinel            ; save current line low byte
01964    C755  BD 03 01           LDA   LAB_STAK+3,X      ; get current line high byte
01965    C758  85 88              STA   Clineh            ; save current line high byte
01966    C75A  BD 04 01           LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
01967    C75D  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01968    C75F  BD 05 01           LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
01969    C762  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
01970    C764  20 C2 00           JSR   LAB_GBYT          ; scan memory
01971    C767  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
01972    
01973                                  ; clear stack and back to interpreter loop
01974    LoopDone
01975    C76A  E8                 INX                     ; dump DO token
01976    C76B  E8                 INX                     ; dump current line low byte
01977    C76C  E8                 INX                     ; dump current line high byte
01978    C76D  E8                 INX                     ; dump BASIC execute pointer low byte
01979    C76E  E8                 INX                     ; dump BASIC execute pointer high byte
01980    C76F  9A                 TXS                     ; correct stack
01981    C770  4C 90 C7           JMP   LAB_DATA          ; go perform DATA (find : or [EOL])
01982    
01983    ; do the return without gosub error
01984    
01985    LAB_16F4
01986    C773  A2 04              LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
01987          .byte $2C               ; makes next line BIT LAB_0EA2
01988    
01989    LAB_16F7                      ; do undefined statement error
01990    C776  A2 0E              LDX   #$0E              ; error code $0E ("Undefined statement" error)
01991    C778  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
01992    
01993    ; perform RETURN
01994    
01995    LAB_RETURN
01996    C77B  D0 9E              BNE   LAB_16E5          ; exit if following token (to allow syntax error)
01997    
01998    LAB_16E8
01999    C77D  68                 PLA                     ; dump calling routine return address
02000    C77E  68                 PLA                     ; dump calling routine return address
02001    C77F  68                 PLA                     ; pull token
02002    C780  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
02003    C782  D0 EF              BNE   LAB_16F4          ; branch if no matching GOSUB
02004    
02005    LAB_16FF
02006    C784  68                 PLA                     ; pull current line low byte
02007    C785  85 87              STA   Clinel            ; save current line low byte
02008    C787  68                 PLA                     ; pull current line high byte
02009    C788  85 88              STA   Clineh            ; save current line high byte
02010    C78A  68                 PLA                     ; pull BASIC execute pointer low byte
02011    C78B  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
02012    C78D  68                 PLA                     ; pull BASIC execute pointer high byte
02013    C78E  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
02014    
02015                                  ; now do the DATA statement as we could be returning into
02016                                  ; the middle of an ON <var> GOSUB n,m,p,q line
02017                                  ; (the return address used by the DATA statement is the one
02018                                  ; pushed before the GOSUB was executed!)
02019    
02020    ; perform DATA
02021    
02022    LAB_DATA
02023    C790  20 A1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
02024    
02025                                  ; set BASIC execute pointer
02026    LAB_170F
02027    C793  98                 TYA                     ; copy index to A
02028    C794  18                 CLC                     ; clear carry for add
02029    C795  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
02030    C797  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
02031    C799  90 02              BCC   LAB_1719          ; skip next if no carry
02032    
02033    C79B  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
02034    LAB_1719
02035    C79D  60                 RTS
02036    
02037    LAB_16FC
02038    C79E  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
02039    
02040    ; scan for next BASIC statement ([:] or [EOL])
02041    ; returns Y as index to [:] or [EOL]
02042    
02043    LAB_SNBS
02044    C7A1  A2 3A              LDX   #':'              ; set look for character = ":"
02045          .byte $2C               ; makes next line BIT $00A2
02046    
02047    ; scan for next BASIC line
02048    ; returns Y as index to [EOL]
02049    
02050    LAB_SNBL
02051    C7A4  A2 00              LDX   #$00              ; set alt search character = [EOL]
02052    C7A6  A0 00              LDY   #$00              ; set search character = [EOL]
02053    C7A8  84 5C              STY   Asrch             ; store search character
02054    LAB_1725
02055    C7AA  8A                 TXA                     ; get alt search character
02056    C7AB  45 5C              EOR   Asrch             ; toggle search character, effectively swap with $00
02057    C7AD  85 5C              STA   Asrch             ; save swapped search character
02058    LAB_172D
02059    C7AF  B1 C3              LDA   (Bpntrl),Y        ; get next byte
02060    C7B1  F0 EA              BEQ   LAB_1719          ; exit if null [EOL]
02061    
02062    C7B3  C5 5C              CMP   Asrch             ; compare with search character
02063    C7B5  F0 E6              BEQ   LAB_1719          ; exit if found
02064    
02065    C7B7  C8                 INY                     ; increment index
02066    C7B8  C9 22              CMP   #$22              ; compare current character with open quote
02067    C7BA  D0 F3              BNE   LAB_172D          ; if not open quote go get next character
02068    
02069    C7BC  F0 EC              BEQ   LAB_1725          ; if found go swap search character for alt search character
02070    
02071    ; perform IF
02072    
02073    LAB_IF
02074    C7BE  20 E7 CB           JSR   LAB_EVEX          ; evaluate the expression
02075    C7C1  20 C2 00           JSR   LAB_GBYT          ; scan memory
02076    C7C4  C9 B7              CMP   #TK_THEN          ; compare with THEN token
02077    C7C6  F0 11              BEQ   LAB_174B          ; if it was THEN go do IF
02078    
02079                                  ; wasn't IF .. THEN so must be IF .. GOTO
02080    C7C8  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
02081    C7CA  D0 D2              BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
02082    
02083    C7CC  A6 C3              LDX   Bpntrl            ; save the basic pointer low byte
02084    C7CE  A4 C4              LDY   Bpntrh            ; save the basic pointer high byte
02085    C7D0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02086    C7D3  B0 C9              BCS   LAB_16FC          ; if not numeric go do syntax error
02087    
02088    C7D5  86 C3              STX   Bpntrl            ; restore the basic pointer low byte
02089    C7D7  84 C4              STY   Bpntrh            ; restore the basic pointer high byte
02090    LAB_174B
02091    C7D9  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
02092    C7DB  F0 1E              BEQ   LAB_174E          ; if the result was zero go look for an ELSE
02093    
02094    C7DD  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
02095    C7E0  B0 03              BCS   LAB_174D          ; if not numeric go do var or keyword
02096    
02097    LAB_174C
02098    C7E2  4C EF C6           JMP   LAB_GOTO          ; else was numeric so do GOTO n
02099    
02100                                  ; is var or keyword
02101    LAB_174D
02102    ; *** patch       allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
02103    ; *** replace
02104    ;      CMP   #TK_RETURN        ; compare the byte with the token for RETURN
02105    ;      BNE   LAB_174G          ; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
02106    ;                              ; and return to this code to process any following code
02107    ;
02108    ;      JMP   LAB_1602          ; else it was RETURN so interpret BASIC code from (Bpntrl)
02109    ;                              ; but don't return here
02110    ;
02111    ;LAB_174G
02112    ;      JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
02113    ;
02114    ;; the IF was executed and there may be a following ELSE so the code needs to return
02115    ;; here to check and ignore the ELSE if present
02116    ;
02117    ;      LDY   #$00              ; clear the index
02118    ;      LDA   (Bpntrl),Y        ; get the next BASIC byte
02119    ;      CMP   #TK_ELSE          ; compare it with the token for ELSE
02120    ;      BEQ   LAB_DATA          ; if ELSE ignore the following statement
02121    ;
02122    ;; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
02123    ;; following ELSE will, correctly, cause a syntax error
02124    ;
02125    ;      RTS                     ; else return to the interpreter inner loop
02126    ;
02127    ; *** with
02128    C7E5  68                 PLA                     ; discard interpreter loop return address
02129    C7E6  68                 PLA                     ; so data structures are at the correct stack offset
02130    C7E7  20 C2 00           JSR   LAB_GBYT          ; restore token or variable
02131    C7EA  20 04 C6           JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
02132    
02133    ; the IF was executed and there may be a following ELSE so the code needs to return
02134    ; here to check and ignore the ELSE if present
02135    
02136    C7ED  A0 00              LDY   #$00              ; clear the index
02137    C7EF  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
02138    C7F1  C9 B3              CMP   #TK_ELSE          ; compare it with the token for ELSE
02139    C7F3  D0 03              BNE   LAB_no_ELSE       ; no - continue on this line
02140    C7F5  20 90 C7           JSR   LAB_DATA          ; yes - skip the rest of the line
02141    
02142    ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
02143    ; following ELSE will, correctly, cause a syntax error
02144    
02145    LAB_no_ELSE
02146    C7F8  4C C6 C5           JMP LAB_15C2            ; return to the interpreter inner loop
02147    ; *** end patch  allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
02148    
02149    ; perform ELSE after IF
02150    
02151    LAB_174E
02152    C7FB  A0 00              LDY   #$00              ; clear the BASIC byte index
02153    C7FD  A2 01              LDX   #$01              ; clear the nesting depth
02154    LAB_1750
02155    C7FF  C8                 INY                     ; increment the BASIC byte index
02156    C800  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
02157    C802  F0 0F              BEQ   LAB_1753          ; if EOL go add the pointer and return
02158    
02159    C804  C9 8B              CMP   #TK_IF            ; compare the byte with the token for IF
02160    C806  D0 03              BNE   LAB_1752          ; if not IF token skip the depth increment
02161    
02162    C808  E8                 INX                     ; else increment the nesting depth ..
02163    C809  D0 F4              BNE   LAB_1750          ; .. and continue looking
02164    
02165    LAB_1752
02166    C80B  C9 B3              CMP   #TK_ELSE          ; compare the byte with the token for ELSE
02167    C80D  D0 F0              BNE   LAB_1750          ; if not ELSE token continue looking
02168    
02169    C80F  CA                 DEX                     ; was ELSE so decrement the nesting depth
02170    C810  D0 ED              BNE   LAB_1750          ; loop if still nested
02171    
02172    C812  C8                 INY                     ; increment the BASIC byte index past the ELSE
02173    
02174    ; found the matching ELSE, now do <{n|statement}>
02175    
02176    LAB_1753
02177    C813  98                 TYA                     ; else copy line index to A
02178    C814  18                 CLC                     ; clear carry for add
02179    C815  65 C3              ADC   Bpntrl            ; add the BASIC execute pointer low byte
02180    C817  85 C3              STA   Bpntrl            ; save the BASIC execute pointer low byte
02181    C819  90 02              BCC   LAB_1754          ; branch if no overflow to high byte
02182    
02183    C81B  E6 C4              INC   Bpntrh            ; else increment the BASIC execute pointer high byte
02184    LAB_1754
02185    C81D  20 C2 00           JSR   LAB_GBYT          ; scan memory
02186    C820  90 C0              BCC   LAB_174C          ; if numeric do GOTO n
02187                                  ; the code will return to the interpreter loop at the
02188                                  ; tail end of the GOTO <n>
02189    
02190    C822  4C 04 C6           JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
02191                                  ; the code will return to the interpreter loop at the
02192                                  ; tail end of the <statement>
02193    
02194    ; perform REM, skip (rest of) line
02195    
02196    LAB_REM
02197    C825  20 A4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
02198    C828  4C 93 C7           JMP   LAB_170F          ; go set BASIC execute pointer and return, branch always
02199    
02200    LAB_16FD
02201    C82B  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
02202    
02203    ; perform ON
02204    
02205    LAB_ON
02206    C82E  C9 A9              CMP   #TK_IRQ           ; was it IRQ token ?
02207    C830  D0 03              BNE   LAB_NOIN          ; if not go check NMI
02208    
02209    C832  4C 4D E0           JMP   LAB_SIRQ          ; else go set-up IRQ
02210    
02211    LAB_NOIN
02212    C835  C9 AA              CMP   #TK_NMI           ; was it NMI token ?
02213    C837  D0 03              BNE   LAB_NONM          ; if not go do normal ON command
02214    
02215    C839  4C 51 E0           JMP   LAB_SNMI          ; else go set-up NMI
02216    
02217    LAB_NONM
02218    C83C  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
02219    C83F  48                 PHA                     ; push GOTO/GOSUB token
02220    C840  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
02221    C842  F0 04              BEQ   LAB_176B          ; branch if GOSUB
02222    
02223    C844  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
02224    LAB_1767
02225    C846  D0 E3              BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
02226    
02227    
02228    ; next character was GOTO or GOSUB
02229    
02230    LAB_176B
02231    C848  C6 AF              DEC   FAC1_3            ; decrement index (byte value)
02232    C84A  D0 04              BNE   LAB_1773          ; branch if not zero
02233    
02234    C84C  68                 PLA                     ; pull GOTO/GOSUB token
02235    C84D  4C 06 C6           JMP   LAB_1602          ; go execute it
02236    
02237    LAB_1773
02238    C850  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02239    C853  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
02240                                  ; (we could LDX #',' and JSR LAB_SNBL+2, then we
02241                                  ; just BNE LAB_176B for the loop. should be quicker ..
02242                                  ; no we can't, what if we meet a colon or [EOL]?)
02243    C856  C9 2C              CMP   #$2C              ; compare next character with ","
02244    C858  F0 EE              BEQ   LAB_176B          ; loop if ","
02245    
02246    LAB_177E
02247    C85A  68                 PLA                     ; else pull keyword token (run out of options)
02248                                  ; also dump +/-1 pointer low byte and exit
02249    LAB_177F
02250    C85B  60                 RTS
02251    
02252    ; takes n * 106 + 11 cycles where n is the number of digits
02253    
02254    ; get fixed-point number into temp integer
02255    
02256    LAB_GFPN
02257    C85C  A2 00              LDX   #$00              ; clear reg
02258    C85E  86 11              STX   Itempl            ; clear temporary integer low byte
02259    LAB_1785
02260    C860  86 12              STX   Itemph            ; save temporary integer high byte
02261    C862  B0 F7              BCS   LAB_177F          ; return if carry set, end of scan, character was
02262                                  ; not 0-9
02263    
02264    C864  E0 19              CPX   #$19              ; compare high byte with $19
02265    C866  A8                 TAY                     ; ensure Zb = 0 if the branch is taken
02266    C867  B0 DD              BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
02267                                  ; bit does *$0A, = 64000, compare at target will fail
02268                                  ; and do syntax error
02269    
02270    C869  E9 2F              SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
02271    C86B  A8                 TAY                     ; copy binary digit
02272    C86C  A5 11              LDA   Itempl            ; get temporary integer low byte
02273    C86E  0A                 ASL                     ; *2 low byte
02274    C86F  26 12              ROL   Itemph            ; *2 high byte
02275    C871  0A                 ASL                     ; *2 low byte
02276    C872  26 12              ROL   Itemph            ; *2 high byte, *4
02277    C874  65 11              ADC   Itempl            ; + low byte, *5
02278    C876  85 11              STA   Itempl            ; save it
02279    C878  8A                 TXA                     ; get high byte copy to A
02280    C879  65 12              ADC   Itemph            ; + high byte, *5
02281    C87B  06 11              ASL   Itempl            ; *2 low byte, *10d
02282    C87D  2A                 ROL                     ; *2 high byte, *10d
02283    C87E  AA                 TAX                     ; copy high byte back to X
02284    C87F  98                 TYA                     ; get binary digit back
02285    C880  65 11              ADC   Itempl            ; add number low byte
02286    C882  85 11              STA   Itempl            ; save number low byte
02287    C884  90 01              BCC   LAB_17B3          ; if no overflow to high byte get next character
02288    
02289    C886  E8                 INX                     ; else increment high byte
02290    LAB_17B3
02291    C887  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02292    C88A  4C 60 C8           JMP   LAB_1785          ; loop for next character
02293    
02294    ; perform DEC
02295    
02296    LAB_DEC
02297    C88D  A9 05              LDA   #<LAB_2AFD        ; set -1 pointer low byte
02298          .byte $2C               ; BIT abs to skip the LDA below
02299    
02300    ; perform INC
02301    
02302    LAB_INC
02303    C890  A9 01              LDA   #<LAB_259C        ; set 1 pointer low byte
02304    LAB_17B5
02305    C892  48                 PHA                     ; save +/-1 pointer low byte
02306    LAB_17B7
02307    C893  20 BE CE           JSR   LAB_GVAR          ; get var address
02308    C896  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
02309    C898  30 1E              BMI   IncrErr           ; exit if string
02310    
02311    C89A  85 97              STA   Lvarpl            ; save var address low byte
02312    C89C  84 98              STY   Lvarph            ; save var address high byte
02313    C89E  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
02314    C8A1  68                 PLA                     ; get +/-1 pointer low byte
02315    C8A2  48                 PHA                     ; save +/-1 pointer low byte
02316    C8A3  A0 E3              LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
02317    C8A5  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
02318    C8A8  20 B6 D9           JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
02319    
02320    C8AB  20 C2 00           JSR   LAB_GBYT          ; scan memory
02321    C8AE  C9 2C              CMP   #','              ; compare with ","
02322    C8B0  D0 A8              BNE   LAB_177E          ; exit if not "," (either end or error)
02323    
02324                                  ; was "," so another INCR variable to do
02325    C8B2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02326    C8B5  4C 93 C8           JMP   LAB_17B7          ; go do next var
02327    
02328    IncrErr
02329    C8B8  4C E2 CB           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
02330    
02331    ; perform LET
02332    
02333    LAB_LET
02334    C8BB  20 BE CE           JSR   LAB_GVAR          ; get var address
02335    C8BE  85 97              STA   Lvarpl            ; save var address low byte
02336    C8C0  84 98              STY   Lvarph            ; save var address high byte
02337    C8C2  A9 C8              LDA   #TK_EQUAL         ; get = token
02338    C8C4  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
02339    C8C7  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
02340    C8C9  48                 PHA                     ; push data type flag
02341    C8CA  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
02342    C8CD  68                 PLA                     ; pop data type flag
02343    C8CE  2A                 ROL                     ; set carry if type = string
02344    ; *** begin patch  result of a string compare stores string pointer to variable
02345    ;                  but should store FAC1 (true/false value)
02346    ; *** replace
02347    ;      JSR   LAB_CKTM          ; type match check, set C for string
02348    ;      BNE   LAB_17D5          ; branch if string
02349    ; *** with
02350    C8CF  20 D9 CB           JSR   LAB_CKTM          ; type match check, keep C (expected type)
02351    C8D2  B0 03              BCS   LAB_17D5          ; branch if string
02352    ; *** end patch
02353    
02354    C8D4  4C B6 D9           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
02355    
02356    ; string LET
02357    
02358    LAB_17D5
02359    C8D7  A0 02              LDY   #$02              ; set index to pointer high byte
02360    C8D9  B1 AE              LDA   (des_pl),Y        ; get string pointer high byte
02361    C8DB  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
02362    C8DD  90 17              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
02363    
02364    C8DF  D0 07              BNE   LAB_17E6          ; branch if >
02365                                  ; else was equal so compare low bytes
02366    C8E1  88                 DEY                     ; decrement index
02367    C8E2  B1 AE              LDA   (des_pl),Y        ; get pointer low byte
02368    C8E4  C5 81              CMP   Sstorl            ; compare bottom of string space low byte
02369    C8E6  90 0E              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
02370    
02371                                  ; pointer was >= to bottom of string space pointer
02372    LAB_17E6
02373    C8E8  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
02374    C8EA  C4 7C              CPY   Svarh             ; compare start of vars high byte
02375    C8EC  90 08              BCC   LAB_17F4          ; branch if less (descriptor is on stack)
02376    
02377    C8EE  D0 0D              BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
02378    
02379                                  ; else high bytes were equal so ..
02380    C8F0  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
02381    C8F2  C5 7B              CMP   Svarl             ; compare start of vars low byte
02382    C8F4  B0 07              BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
02383    
02384    LAB_17F4
02385    C8F6  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
02386    C8F8  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
02387    C8FA  4C 13 C9           JMP   LAB_1811          ; clean stack, copy descriptor to variable and return
02388    
02389                                  ; make space and copy string
02390    LAB_17FB
02391    C8FD  A0 00              LDY   #$00              ; index to length
02392    C8FF  B1 AE              LDA   (des_pl),Y        ; get string length
02393    C901  20 46 D2           JSR   LAB_209C          ; copy string
02394    C904  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
02395    C906  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
02396    C908  85 B8              STA   ssptr_l           ; save descriptor pointer low byte
02397    C90A  84 B9              STY   ssptr_h           ; save descriptor pointer high byte
02398    C90C  20 2B D4           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
02399    C90F  A9 AC              LDA   #<FAC1_e          ; set descriptor pointer low byte
02400    C911  A0 00              LDY   #>FAC1_e          ; get descriptor pointer high byte
02401    
02402                                  ; clean stack and assign value to string variable
02403    LAB_1811
02404    C913  85 9E              STA   des_2l            ; save descriptor_2 pointer low byte
02405    C915  84 9F              STY   des_2h            ; save descriptor_2 pointer high byte
02406    C917  20 8D D4           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
02407    C91A  A0 00              LDY   #$00              ; index to length
02408    C91C  B1 9E              LDA   (des_2l),Y        ; get string length
02409    C91E  91 97              STA   (Lvarpl),Y        ; copy to let string variable
02410    C920  C8                 INY                     ; index to string pointer low byte
02411    C921  B1 9E              LDA   (des_2l),Y        ; get string pointer low byte
02412    C923  91 97              STA   (Lvarpl),Y        ; copy to let string variable
02413    C925  C8                 INY                     ; index to string pointer high byte
02414    C926  B1 9E              LDA   (des_2l),Y        ; get string pointer high byte
02415    C928  91 97              STA   (Lvarpl),Y        ; copy to let string variable
02416    C92A  60                 RTS
02417    
02418    ; perform GET
02419    
02420    LAB_GET
02421    C92B  20 BE CE           JSR   LAB_GVAR          ; get var address
02422    C92E  85 97              STA   Lvarpl            ; save var address low byte
02423    C930  84 98              STY   Lvarph            ; save var address high byte
02424    C932  20 15 E0           JSR   INGET             ; get input byte
02425    C935  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
02426    C937  30 07              BMI   LAB_GETS          ; go get string character
02427    
02428                                  ; was numeric get
02429    C939  A8                 TAY                     ; copy character to Y
02430    C93A  20 7A D1           JSR   LAB_1FD0          ; convert Y to byte in FAC1
02431    C93D  4C B6 D9           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
02432    
02433    LAB_GETS
02434    C940  48                 PHA                     ; save character
02435    C941  A9 01              LDA   #$01              ; string is single byte
02436    C943  B0 01              BCS   LAB_IsByte        ; branch if byte received
02437    
02438    C945  68                 PLA                     ; string is null
02439    LAB_IsByte
02440    C946  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
02441                                  ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
02442    C949  F0 05              BEQ   LAB_NoSt          ; skip store if null string
02443    
02444    C94B  68                 PLA                     ; get character back
02445    C94C  A0 00              LDY   #$00              ; clear index
02446    C94E  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
02447    LAB_NoSt
02448    C950  20 9B D2           JSR   LAB_RTST          ; check for space on descriptor stack then put address
02449                                  ; and length on descriptor stack and update stack pointers
02450    
02451    C953  4C D7 C8           JMP   LAB_17D5          ; do string LET and return
02452    
02453    ; perform PRINT
02454    
02455    LAB_1829
02456    C956  20 DD C9           JSR   LAB_18C6          ; print string from Sutill/Sutilh
02457    LAB_182C
02458    C959  20 C2 00           JSR   LAB_GBYT          ; scan memory
02459    
02460    ; PRINT
02461    
02462    LAB_PRINT
02463    C95C  F0 3B              BEQ   LAB_CRLF          ; if nothing following just print CR/LF
02464    
02465    LAB_1831
02466    C95E  C9 B2              CMP   #TK_TAB           ; compare with TAB( token
02467    C960  F0 56              BEQ   LAB_18A2          ; go do TAB/SPC
02468    
02469    C962  C9 B6              CMP   #TK_SPC           ; compare with SPC( token
02470    C964  F0 52              BEQ   LAB_18A2          ; go do TAB/SPC
02471    
02472    C966  C9 2C              CMP   #','              ; compare with ","
02473    C968  F0 38              BEQ   LAB_188B          ; go do move to next TAB mark
02474    
02475    C96A  C9 3B              CMP   #';'              ; compare with ";"
02476    C96C  F0 66              BEQ   LAB_18BD          ; if ";" continue with PRINT processing
02477    
02478    C96E  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
02479    C971  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
02480    C973  30 E1              BMI   LAB_1829          ; branch if string
02481    
02482    C975  20 A8 DB           JSR   LAB_296E          ; convert FAC1 to string
02483    C978  20 58 D2           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
02484    C97B  A0 00              LDY   #$00              ; clear index
02485    
02486    ; don't check fit if terminal width byte is zero
02487    
02488    C97D  A5 0F              LDA   TWidth            ; get terminal width byte
02489    C97F  F0 0A              BEQ   LAB_185E          ; skip check if zero
02490    
02491    C981  38                 SEC                     ; set carry for subtract
02492    C982  E5 0E              SBC   TPos              ; subtract terminal position
02493    C984  F1 AE              SBC   (des_pl),Y        ; subtract string length
02494    C986  B0 03              BCS   LAB_185E          ; branch if less than terminal width
02495    
02496    C988  20 99 C9           JSR   LAB_CRLF          ; else print CR/LF
02497    LAB_185E
02498    C98B  20 DD C9           JSR   LAB_18C6          ; print string from Sutill/Sutilh
02499    C98E  F0 C9              BEQ   LAB_182C          ; always go continue processing line
02500    
02501    ; CR/LF return to BASIC from BASIC input handler
02502    
02503    LAB_1866
02504    C990  A9 00              LDA   #$00              ; clear byte
02505    C992  9D 00 0B           STA   Ibuffs,X          ; null terminate input
02506    C995  A2 00              LDX   #<Ibuffs          ; set X to buffer start-1 low byte
02507    C997  A0 0B              LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
02508    
02509    ; print CR/LF
02510    
02511    LAB_CRLF
02512    C999  A9 0D              LDA   #$0D              ; load [CR]
02513    C99B  20 F4 C9           JSR   LAB_PRNA          ; go print the character
02514    C99E  A9 0A              LDA   #$0A              ; load [LF]
02515    C9A0  D0 52              BNE   LAB_PRNA          ; go print the character and return, branch always
02516    
02517    LAB_188B
02518    C9A2  A5 0E              LDA   TPos              ; get terminal position
02519    C9A4  C5 10              CMP   Iclim             ; compare with input column limit
02520    C9A6  90 05              BCC   LAB_1897          ; branch if less
02521    
02522    C9A8  20 99 C9           JSR   LAB_CRLF          ; else print CR/LF (next line)
02523    C9AB  D0 27              BNE   LAB_18BD          ; continue with PRINT processing (branch always)
02524    
02525    LAB_1897
02526    C9AD  38                 SEC                     ; set carry for subtract
02527    LAB_1898
02528    C9AE  E5 64              SBC   TabSiz            ; subtract TAB size
02529    C9B0  B0 FC              BCS   LAB_1898          ; loop if result was +ve
02530    
02531    C9B2  49 FF              EOR   #$FF              ; complement it
02532    C9B4  69 01              ADC   #$01              ; +1 (twos complement)
02533    C9B6  D0 12              BNE   LAB_18B6          ; always print A spaces (result is never $00)
02534    
02535                                  ; do TAB/SPC
02536    LAB_18A2
02537    C9B8  48                 PHA                     ; save token
02538    C9B9  20 A3 D5           JSR   LAB_SGBY          ; scan and get byte parameter
02539    C9BC  C9 29              CMP   #$29              ; is next character )
02540    C9BE  D0 7B              BNE   LAB_1910          ; if not do syntax error then warm start
02541    
02542    C9C0  68                 PLA                     ; get token back
02543    C9C1  C9 B2              CMP   #TK_TAB           ; was it TAB ?
02544    C9C3  D0 06              BNE   LAB_18B7          ; if not go do SPC
02545    
02546                                  ; calculate TAB offset
02547    C9C5  8A                 TXA                     ; copy integer value to A
02548    C9C6  E5 0E              SBC   TPos              ; subtract terminal position
02549    C9C8  90 0A              BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
02550    
02551                                  ; print A spaces
02552    LAB_18B6
02553    C9CA  AA                 TAX                     ; copy result to X
02554    LAB_18B7
02555    C9CB  8A                 TXA                     ; set flags on size for SPC
02556    C9CC  F0 06              BEQ   LAB_18BD          ; branch if result was = $0, already here
02557    
02558                                  ; print X spaces
02559    LAB_18BA
02560    C9CE  20 EF C9           JSR   LAB_18E0          ; print " "
02561    C9D1  CA                 DEX                     ; decrement count
02562    C9D2  D0 FA              BNE   LAB_18BA          ; loop if not all done
02563    
02564                                  ; continue with PRINT processing
02565    LAB_18BD
02566    C9D4  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02567    C9D7  D0 85              BNE   LAB_1831          ; if more to print go do it
02568    
02569    C9D9  60                 RTS
02570    
02571    ; print null terminated string from memory
02572    
02573    LAB_18C3
02574    C9DA  20 58 D2           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
02575    
02576    ; print string from Sutill/Sutilh
02577    
02578    LAB_18C6
02579    C9DD  20 58 D4           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
02580                                  ; space returns with A = length, X=$71=pointer low byte,
02581                                  ; Y=$72=pointer high byte
02582    C9E0  A0 00              LDY   #$00              ; reset index
02583    C9E2  AA                 TAX                     ; copy length to X
02584    C9E3  F0 49              BEQ   LAB_188C          ; exit (RTS) if null string
02585    
02586    LAB_18CD
02587    
02588    C9E5  B1 71              LDA   (ut1_pl),Y        ; get next byte
02589    C9E7  20 F4 C9           JSR   LAB_PRNA          ; go print the character
02590    C9EA  C8                 INY                     ; increment index
02591    C9EB  CA                 DEX                     ; decrement count
02592    C9EC  D0 F7              BNE   LAB_18CD          ; loop if not done yet
02593    
02594    C9EE  60                 RTS
02595    
02596                                  ; Print single format character
02597    ; print " "
02598    
02599    LAB_18E0
02600    C9EF  A9 20              LDA   #$20              ; load " "
02601          .byte $2C               ; change next line to BIT LAB_3FA9
02602    
02603    ; print "?" character
02604    
02605    LAB_18E3
02606    C9F2  A9 3F              LDA   #$3F              ; load "?" character
02607    
02608    ; print character in A
02609    ; now includes the null handler
02610    ; also includes infinite line length code
02611    ; note! some routines expect this one to exit with Zb=0
02612    
02613    LAB_PRNA
02614    C9F4  C9 20              CMP   #' '              ; compare with " "
02615    C9F6  90 19              BCC   LAB_18F9          ; branch if less (non printing)
02616    
02617                                  ; else printable character
02618    C9F8  48                 PHA                     ; save the character
02619    
02620    ; don't check fit if terminal width byte is zero
02621    
02622    C9F9  A5 0F              LDA   TWidth            ; get terminal width
02623    C9FB  D0 0A              BNE   LAB_18F0          ; branch if not zero (not infinite length)
02624    
02625    ; is "infinite line" so check TAB position
02626    
02627    C9FD  A5 0E              LDA   TPos              ; get position
02628    C9FF  E5 64              SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
02629    CA01  D0 0B              BNE   LAB_18F7          ; skip reset if different
02630    
02631    CA03  85 0E              STA   TPos              ; else reset position
02632    CA05  F0 07              BEQ   LAB_18F7          ; go print character
02633    
02634    LAB_18F0
02635    CA07  C5 0E              CMP   TPos              ; compare with terminal character position
02636    CA09  D0 03              BNE   LAB_18F7          ; branch if not at end of line
02637    
02638    CA0B  20 99 C9           JSR   LAB_CRLF          ; else print CR/LF
02639    LAB_18F7
02640    CA0E  E6 0E              INC   TPos              ; increment terminal position
02641    CA10  68                 PLA                     ; get character back
02642    LAB_18F9
02643    CA11  20 02 E2           JSR   V_OUTP            ; output byte via output vector
02644    CA14  C9 0D              CMP   #$0D              ; compare with [CR]
02645    CA16  D0 14              BNE   LAB_188A          ; branch if not [CR]
02646    
02647                                  ; else print nullct nulls after the [CR]
02648    CA18  86 78              STX   TempB             ; save buffer index
02649    CA1A  A6 0D              LDX   Nullct            ; get null count
02650    CA1C  F0 0A              BEQ   LAB_1886          ; branch if no nulls
02651    
02652    CA1E  A9 00              LDA   #$00              ; load [NULL]
02653    LAB_1880
02654    CA20  20 F4 C9           JSR   LAB_PRNA          ; go print the character
02655    CA23  CA                 DEX                     ; decrement count
02656    CA24  D0 FA              BNE   LAB_1880          ; loop if not all done
02657    
02658    CA26  A9 0D              LDA   #$0D              ; restore the character (and set the flags)
02659    LAB_1886
02660    CA28  86 0E              STX   TPos              ; clear terminal position (X always = zero when we get here)
02661    CA2A  A6 78              LDX   TempB             ; restore buffer index
02662    LAB_188A
02663    CA2C  29 FF              AND   #$FF              ; set the flags
02664    LAB_188C
02665    CA2E  60                 RTS
02666    
02667    ; handle bad input data
02668    
02669    LAB_1904
02670    CA2F  A5 62              LDA   Imode             ; get input mode flag, $00=INPUT, $00=READ
02671    CA31  10 0B              BPL   LAB_1913          ; branch if INPUT (go do redo)
02672    
02673    CA33  A5 8D              LDA   Dlinel            ; get current DATA line low byte
02674    CA35  A4 8E              LDY   Dlineh            ; get current DATA line high byte
02675    CA37  85 87              STA   Clinel            ; save current line low byte
02676    CA39  84 88              STY   Clineh            ; save current line high byte
02677    LAB_1910
02678    CA3B  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
02679    
02680                                  ; mode was INPUT
02681    LAB_1913
02682    CA3E  A9 94              LDA   #<LAB_REDO        ; point to redo message (low addr)
02683    CA40  A0 E9              LDY   #>LAB_REDO        ; point to redo message (high addr)
02684    CA42  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
02685    CA45  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
02686    CA47  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
02687    CA49  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
02688    CA4B  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
02689    CA4D  60                 RTS
02690    
02691    ; perform INPUT
02692    
02693    LAB_INPUT
02694    CA4E  C9 22              CMP   #$22              ; compare next byte with open quote
02695    CA50  D0 0B              BNE   LAB_1934          ; branch if no prompt string
02696    
02697    CA52  20 C4 CC           JSR   LAB_1BC1          ; print "..." string
02698    CA55  A9 3B              LDA   #$3B              ; load A with ";"
02699    CA57  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
02700    CA5A  20 DD C9           JSR   LAB_18C6          ; print string from Sutill/Sutilh
02701    
02702                                  ; done with prompt, now get data
02703    LAB_1934
02704    CA5D  20 7E D1           JSR   LAB_CKRN          ; check not Direct, back here if ok
02705    CA60  20 43 C3           JSR   LAB_INLN          ; print "? " and get BASIC input
02706    CA63  A9 00              LDA   #$00              ; set mode = INPUT
02707    CA65  CD 00 0B           CMP   Ibuffs            ; test first byte in buffer
02708    CA68  D0 09              BNE   LAB_1953          ; branch if not null input
02709    
02710    ; *** change p2: keep carry set to throw break message
02711    ;      CLC                     ; was null input so clear carry to exit program
02712    CA6A  4C 2E C6           JMP   LAB_1647          ; go do BREAK exit
02713    
02714    ; perform READ
02715    
02716    LAB_READ
02717    CA6D  A6 8F              LDX   Dptrl             ; get DATA pointer low byte
02718    CA6F  A4 90              LDY   Dptrh             ; get DATA pointer high byte
02719    CA71  A9 80              LDA   #$80              ; set mode = READ
02720    
02721    LAB_1953
02722    CA73  85 62              STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
02723    CA75  86 91              STX   Rdptrl            ; save READ pointer low byte
02724    CA77  84 92              STY   Rdptrh            ; save READ pointer high byte
02725    
02726                                  ; READ or INPUT next variable from list
02727    LAB_195B
02728    CA79  20 BE CE           JSR   LAB_GVAR          ; get (var) address
02729    CA7C  85 97              STA   Lvarpl            ; save address low byte
02730    CA7E  84 98              STY   Lvarph            ; save address high byte
02731    CA80  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
02732    CA82  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
02733    CA84  85 11              STA   Itempl            ; save as temporary integer low byte
02734    CA86  84 12              STY   Itemph            ; save as temporary integer high byte
02735    CA88  A6 91              LDX   Rdptrl            ; get READ pointer low byte
02736    CA8A  A4 92              LDY   Rdptrh            ; get READ pointer high byte
02737    CA8C  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
02738    CA8E  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
02739    CA90  20 C2 00           JSR   LAB_GBYT          ; scan memory
02740    CA93  D0 11              BNE   LAB_1988          ; branch if not null
02741    
02742                                  ; pointer was to null entry
02743    CA95  24 62              BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
02744    CA97  30 65              BMI   LAB_19DD          ; branch if READ
02745    
02746                                  ; mode was INPUT
02747    CA99  20 F2 C9           JSR   LAB_18E3          ; print "?" character (double ? for extended input)
02748    CA9C  20 43 C3           JSR   LAB_INLN          ; print "? " and get BASIC input
02749    CA9F  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
02750    CAA1  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
02751    LAB_1985
02752    CAA3  20 C2 00           JSR   LAB_GBYT          ; scan memory
02753    LAB_1988
02754    CAA6  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
02755    CAA8  10 24              BPL   LAB_19B0          ; branch if numeric
02756    
02757                                  ; else get string
02758    CAAA  85 5B              STA   Srchc             ; save search character
02759    CAAC  C9 22              CMP   #$22              ; was it " ?
02760    CAAE  F0 07              BEQ   LAB_1999          ; branch if so
02761    
02762    CAB0  A9 3A              LDA   #':'              ; else search character is ":"
02763    CAB2  85 5B              STA   Srchc             ; set new search character
02764    CAB4  A9 2C              LDA   #','              ; other search character is ","
02765    CAB6  18                 CLC                     ; clear carry for add
02766    LAB_1999
02767    CAB7  85 5C              STA   Asrch             ; set second search character
02768    CAB9  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
02769    CABB  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
02770    
02771    CABD  69 00              ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
02772    CABF  90 01              BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
02773    
02774    CAC1  C8                 INY                     ; else increment high byte
02775    LAB_19A4
02776    CAC2  20 5E D2           JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
02777    CAC5  20 E2 D5           JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
02778    CAC8  20 D7 C8           JSR   LAB_17D5          ; go do string LET
02779    CACB  4C D4 CA           JMP   LAB_19B6          ; go check string terminator
02780    
02781                                  ; get numeric INPUT
02782    LAB_19B0
02783    CACE  20 B9 DA           JSR   LAB_2887          ; get FAC1 from string
02784    CAD1  20 B6 D9           JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
02785    LAB_19B6
02786    CAD4  20 C2 00           JSR   LAB_GBYT          ; scan memory
02787    CAD7  F0 0A              BEQ   LAB_19C5          ; branch if null (last entry)
02788    
02789    CAD9  C9 2C              CMP   #','              ; else compare with ","
02790    CADB  F0 03              BEQ   LAB_19C2          ; branch if ","
02791    
02792    CADD  4C 2F CA           JMP   LAB_1904          ; else go handle bad input data
02793    
02794                                  ; got good input data
02795    LAB_19C2
02796    CAE0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02797    LAB_19C5
02798    CAE3  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
02799    CAE5  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
02800    CAE7  85 91              STA   Rdptrl            ; save for now
02801    CAE9  84 92              STY   Rdptrh            ; save for now
02802    CAEB  A5 11              LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
02803    CAED  A4 12              LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
02804    CAEF  85 C3              STA   Bpntrl            ; set BASIC execute pointer low byte
02805    CAF1  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
02806    CAF3  20 C2 00           JSR   LAB_GBYT          ; scan memory
02807    CAF6  F0 2C              BEQ   LAB_1A03          ; if null go do extra ignored message
02808    
02809    CAF8  20 04 CD           JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
02810    CAFB  4C 79 CA           JMP   LAB_195B          ; go INPUT next variable from list
02811    
02812                                  ; find next DATA statement or do "Out of DATA" error
02813    LAB_19DD
02814    CAFE  20 A1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
02815    CB01  C8                 INY                     ; increment index
02816    CB02  AA                 TAX                     ; copy character ([:] or [EOL])
02817    CB03  D0 12              BNE   LAB_19F6          ; branch if [:]
02818    
02819    CB05  A2 06              LDX   #$06              ; set for "Out of DATA" error
02820    CB07  C8                 INY                     ; increment index, now points to next line pointer high byte
02821    CB08  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
02822    CB0A  F0 73              BEQ   LAB_1A54          ; branch if end (eventually does error X)
02823    
02824    CB0C  C8                 INY                     ; increment index
02825    CB0D  B1 C3              LDA   (Bpntrl),Y        ; get next line # low byte
02826    CB0F  85 8D              STA   Dlinel            ; save current DATA line low byte
02827    CB11  C8                 INY                     ; increment index
02828    CB12  B1 C3              LDA   (Bpntrl),Y        ; get next line # high byte
02829    CB14  C8                 INY                     ; increment index
02830    CB15  85 8E              STA   Dlineh            ; save current DATA line high byte
02831    LAB_19F6
02832    CB17  B1 C3              LDA   (Bpntrl),Y        ; get byte
02833    CB19  C8                 INY                     ; increment index
02834    CB1A  AA                 TAX                     ; copy to X
02835    CB1B  20 93 C7           JSR   LAB_170F          ; set BASIC execute pointer
02836    CB1E  E0 83              CPX   #TK_DATA          ; compare with "DATA" token
02837    CB20  F0 81              BEQ   LAB_1985          ; was "DATA" so go do next READ
02838    
02839    CB22  D0 DA              BNE   LAB_19DD          ; go find next statement if not "DATA"
02840    
02841    ; end of INPUT/READ routine
02842    
02843    LAB_1A03
02844    CB24  A5 91              LDA   Rdptrl            ; get temp READ pointer low byte
02845    CB26  A4 92              LDY   Rdptrh            ; get temp READ pointer high byte
02846    CB28  A6 62              LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
02847    CB2A  10 03              BPL   LAB_1A0E          ; branch if INPUT
02848    
02849    CB2C  4C 50 C6           JMP   LAB_1624          ; save AY as DATA pointer and return
02850    
02851                                  ; we were getting INPUT
02852    LAB_1A0E
02853    CB2F  A0 00              LDY   #$00              ; clear index
02854    CB31  B1 91              LDA   (Rdptrl),Y        ; get next byte
02855    CB33  D0 01              BNE   LAB_1A1B          ; error if not end of INPUT
02856    
02857    CB35  60                 RTS
02858    
02859                                  ; user typed too much
02860    LAB_1A1B
02861    CB36  A9 83              LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
02862    CB38  A0 E9              LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
02863    CB3A  4C DA C9           JMP   LAB_18C3          ; print null terminated string from memory and return
02864    
02865    ; search the stack for FOR activity
02866    ; exit with z=1 if FOR else exit with z=0
02867    
02868    LAB_11A1
02869    CB3D  BA                 TSX                     ; copy stack pointer
02870    CB3E  E8                 INX                     ; +1 pass return address
02871    CB3F  E8                 INX                     ; +2 pass return address
02872    CB40  E8                 INX                     ; +3 pass calling routine return address
02873    CB41  E8                 INX                     ; +4 pass calling routine return address
02874    LAB_11A6
02875    CB42  BD 01 01           LDA   LAB_STAK+1,X      ; get token byte from stack
02876    CB45  C9 81              CMP   #TK_FOR           ; is it FOR token
02877    CB47  D0 21              BNE   LAB_11CE          ; exit if not FOR token
02878    
02879                                  ; was FOR token
02880    CB49  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
02881    CB4B  D0 0A              BNE   LAB_11BB          ; branch if not null
02882    
02883    CB4D  BD 02 01           LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
02884    CB50  85 97              STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
02885    CB52  BD 03 01           LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
02886    CB55  85 98              STA   Frnxth            ; save var pointer for FOR/NEXT high byte
02887    LAB_11BB
02888    CB57  DD 03 01           CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
02889    CB5A  D0 07              BNE   LAB_11C7          ; branch if no match
02890    
02891    CB5C  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
02892    CB5E  DD 02 01           CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
02893    CB61  F0 07              BEQ   LAB_11CE          ; exit if match found
02894    
02895    LAB_11C7
02896    CB63  8A                 TXA                     ; copy index
02897    CB64  18                 CLC                     ; clear carry for add
02898    CB65  69 10              ADC   #$10              ; add FOR stack use size
02899    CB67  AA                 TAX                     ; copy back to index
02900    CB68  D0 D8              BNE   LAB_11A6          ; loop if not at start of stack
02901    
02902    LAB_11CE
02903    CB6A  60                 RTS
02904    
02905    ; perform NEXT
02906    
02907    LAB_NEXT
02908    CB6B  D0 04              BNE   LAB_1A46          ; branch if NEXT var
02909    
02910    CB6D  A0 00              LDY   #$00              ; else clear Y
02911    CB6F  F0 03              BEQ   LAB_1A49          ; branch always (no variable to search for)
02912    
02913    ; NEXT var
02914    
02915    LAB_1A46
02916    CB71  20 BE CE           JSR   LAB_GVAR          ; get variable address
02917    LAB_1A49
02918    CB74  85 97              STA   Frnxtl            ; store variable pointer low byte
02919    CB76  84 98              STY   Frnxth            ; store variable pointer high byte
02920                                  ; (both cleared if no variable defined)
02921    CB78  20 3D CB           JSR   LAB_11A1          ; search the stack for FOR activity
02922    CB7B  F0 04              BEQ   LAB_1A56          ; branch if found
02923    
02924    CB7D  A2 00              LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
02925    LAB_1A54
02926    CB7F  F0 63              BEQ   LAB_1ABE          ; do error #X, then warm start
02927    
02928    LAB_1A56
02929    CB81  9A                 TXS                     ; set stack pointer, X set by search, dumps return addresses
02930    
02931    CB82  8A                 TXA                     ; copy stack pointer
02932    CB83  38                 SEC                     ; set carry for subtract
02933    CB84  E9 F7              SBC   #$F7              ; point to TO var
02934    CB86  85 73              STA   ut2_pl            ; save pointer to TO var for compare
02935    CB88  69 FB              ADC   #$FB              ; point to STEP var
02936    
02937    CB8A  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
02938    CB8C  20 90 D9           JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
02939    CB8F  BA                 TSX                     ; get stack pointer back
02940    CB90  BD 08 01           LDA   LAB_STAK+8,X      ; get step sign
02941    CB93  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
02942    CB95  A5 97              LDA   Frnxtl            ; get FOR variable pointer low byte
02943    CB97  A4 98              LDY   Frnxth            ; get FOR variable pointer high byte
02944    CB99  20 D1 D6           JSR   LAB_246C          ; add (FOR variable) to FAC1
02945    CB9C  20 B6 D9           JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
02946    CB9F  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
02947    CBA1  20 2C DA           JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
02948    CBA4  BA                 TSX                     ; get stack pointer back
02949    CBA5  DD 08 01           CMP   LAB_STAK+8,X      ; compare step sign
02950    CBA8  F0 17              BEQ   LAB_1A9B          ; branch if = (loop complete)
02951    
02952                                  ; loop back and do it all again
02953    CBAA  BD 0D 01           LDA   LAB_STAK+$0D,X    ; get FOR line low byte
02954    CBAD  85 87              STA   Clinel            ; save current line low byte
02955    CBAF  BD 0E 01           LDA   LAB_STAK+$0E,X    ; get FOR line high byte
02956    CBB2  85 88              STA   Clineh            ; save current line high byte
02957    CBB4  BD 10 01           LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
02958    CBB7  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
02959    CBB9  BD 0F 01           LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
02960    CBBC  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
02961    LAB_1A98
02962    CBBE  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
02963    
02964                                  ; loop complete so carry on
02965    LAB_1A9B
02966    CBC1  8A                 TXA                     ; stack copy to A
02967    CBC2  69 0F              ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
02968    CBC4  AA                 TAX                     ; copy back to index
02969    CBC5  9A                 TXS                     ; copy to stack pointer
02970    CBC6  20 C2 00           JSR   LAB_GBYT          ; scan memory
02971    CBC9  C9 2C              CMP   #','              ; compare with ","
02972    CBCB  D0 F1              BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
02973    
02974                                  ; was "," so another NEXT variable to do
02975    CBCD  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
02976    CBD0  20 71 CB           JSR   LAB_1A46          ; do NEXT (var)
02977    
02978    ; evaluate expression and check is numeric, else do type mismatch
02979    
02980    LAB_EVNM
02981    CBD3  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
02982    
02983    ; check if source is numeric, else do type mismatch
02984    
02985    LAB_CTNM
02986    CBD6  18                 CLC                     ; destination is numeric
02987          .byte $24               ; makes next line BIT $38
02988    
02989    ; check if source is string, else do type mismatch
02990    
02991    LAB_CTST
02992    CBD8  38                 SEC                     ; required type is string
02993    
02994    ; type match check, set C for string, clear C for numeric
02995    
02996    LAB_CKTM
02997    CBD9  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
02998    CBDB  30 03              BMI   LAB_1ABA          ; branch if data type is string
02999    
03000                                  ; else data type was numeric
03001    CBDD  B0 03              BCS   LAB_1ABC          ; if required type is string do type mismatch error
03002    LAB_1AB9
03003    CBDF  60                 RTS
03004    
03005                                  ; data type was string, now check required type
03006    LAB_1ABA
03007    CBE0  B0 FD              BCS   LAB_1AB9          ; exit if required type is string
03008    
03009                                  ; else do type mismatch error
03010    LAB_1ABC
03011    CBE2  A2 18              LDX   #$18              ; error code $18 ("Type mismatch" error)
03012    LAB_1ABE
03013    CBE4  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
03014    
03015    ; evaluate expression
03016    
03017    LAB_EVEX
03018    CBE7  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
03019    CBE9  D0 02              BNE   LAB_1AC7          ; skip next if not zero
03020    
03021    CBEB  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
03022    LAB_1AC7
03023    CBED  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
03024    
03025    LAB_EVEZ
03026    CBEF  A9 00              LDA   #$00              ; set null precedence (flag done)
03027    LAB_1ACC
03028    CBF1  48                 PHA                     ; push precedence byte
03029    CBF2  A9 02              LDA   #$02              ; 2 bytes
03030    CBF4  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
03031    CBF7  20 D3 CC           JSR   LAB_GVAL          ; get value from line
03032    CBFA  A9 00              LDA   #$00              ; clear A
03033    CBFC  85 9B              STA   comp_f            ; clear compare function flag
03034    LAB_1ADB
03035    CBFE  20 C2 00           JSR   LAB_GBYT          ; scan memory
03036    LAB_1ADE
03037    CC01  38                 SEC                     ; set carry for subtract
03038    CC02  E9 C7              SBC   #TK_GT            ; subtract token for > (lowest comparison function)
03039    CC04  90 17              BCC   LAB_1AFA          ; branch if < TK_GT
03040    
03041    CC06  C9 03              CMP   #$03              ; compare with ">" to "<" tokens
03042    CC08  B0 13              BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
03043    
03044                                  ; was token for > = or < (A = 0, 1 or 2)
03045    CC0A  C9 01              CMP   #$01              ; compare with token for =
03046    CC0C  2A                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
03047                                  ; (A = 0, 3 or 5)
03048    CC0D  49 01              EOR   #$01              ; toggle b0
03049                                  ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
03050    CC0F  45 9B              EOR   comp_f            ; EOR with compare function flag bits
03051    CC11  C5 9B              CMP   comp_f            ; compare with compare function flag
03052    CC13  90 67              BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
03053                                  ; was more than one <, = or >)
03054    
03055    CC15  85 9B              STA   comp_f            ; save new compare function flag
03056    CC17  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03057    CC1A  4C 01 CC           JMP   LAB_1ADE          ; go do next character
03058    
03059                                  ; token is < ">" or > "<" tokens
03060    LAB_1AFA
03061    CC1D  A6 9B              LDX   comp_f            ; get compare function flag
03062    CC1F  D0 2C              BNE   LAB_1B2A          ; branch if compare function
03063    
03064    CC21  B0 79              BCS   LAB_1B78          ; go do functions
03065    
03066                                  ; else was <  TK_GT so is operator or lower
03067    CC23  69 0A              ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
03068    CC25  90 75              BCC   LAB_1B78          ; branch if < + operator
03069    
03070                                  ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
03071    CC27  D0 07              BNE   LAB_1B0B          ; branch if not + token
03072    
03073    CC29  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
03074    CC2B  10 03              BPL   LAB_1B0B          ; branch if not string
03075    
03076                                  ; will only be $00 if type is string and token was +
03077    CC2D  4C EE D3           JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
03078                                  ; is in line, and return
03079    
03080    LAB_1B0B
03081    CC30  85 71              STA   ut1_pl            ; save it
03082    CC32  0A                 ASL                     ; *2
03083    CC33  65 71              ADC   ut1_pl            ; *3
03084    CC35  A8                 TAY                     ; copy to index
03085    LAB_1B13
03086    CC36  68                 PLA                     ; pull previous precedence
03087    CC37  D9 18 E4           CMP   LAB_OPPT,Y        ; compare with precedence byte
03088    CC3A  B0 65              BCS   LAB_1B7D          ; branch if A >=
03089    
03090    CC3C  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
03091    LAB_1B1C
03092    CC3F  48                 PHA                     ; save precedence
03093    LAB_1B1D
03094    CC40  20 68 CC           JSR   LAB_1B43          ; get vector, execute function then continue evaluation
03095    CC43  68                 PLA                     ; restore precedence
03096    CC44  A4 99              LDY   prstk             ; get precedence stacked flag
03097    CC46  10 19              BPL   LAB_1B3C          ; branch if stacked values
03098    
03099    CC48  AA                 TAX                     ; copy precedence (set flags)
03100    CC49  F0 76              BEQ   LAB_1B9D          ; exit if done
03101    
03102    CC4B  D0 5D              BNE   LAB_1B86          ; else pop FAC2 and return, branch always
03103    
03104    LAB_1B2A
03105    CC4D  26 5F              ROL   Dtypef            ; shift data type flag into Cb
03106    CC4F  8A                 TXA                     ; copy compare function flag
03107    CC50  85 5F              STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
03108    CC52  2A                 ROL                     ; shift data type into compare function byte b0
03109    CC53  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
03110    CC55  D0 02              BNE   LAB_1B34          ; branch if no underflow
03111    
03112    CC57  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
03113    LAB_1B34
03114    CC59  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
03115      000C             TK_LT_PLUS  = TK_LT-TK_PLUS
03116    CC5B  A0 24              LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
03117    CC5D  85 9B              STA   comp_f            ; save new compare function flag
03118    CC5F  D0 D5              BNE   LAB_1B13          ; branch always
03119    
03120    LAB_1B3C
03121    CC61  D9 18 E4           CMP   LAB_OPPT,Y        ;.compare with stacked function precedence
03122    CC64  B0 44              BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
03123    
03124    CC66  90 D7              BCC   LAB_1B1C          ; branch always
03125    
03126    ;.get vector, execute function then continue evaluation
03127    
03128    LAB_1B43
03129    CC68  B9 1A E4           LDA   LAB_OPPT+2,Y      ; get function vector high byte
03130    CC6B  48                 PHA                     ; onto stack
03131    CC6C  B9 19 E4           LDA   LAB_OPPT+1,Y      ; get function vector low byte
03132    CC6F  48                 PHA                     ; onto stack
03133                                  ; now push sign, round FAC1 and put on stack
03134    ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
03135    ; *** add
03136       .IF [* & $FF] == $FD
03137    ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
03138    CC70  20 7F CC           JSR   LAB_1B5B          ; function will return here, then the next RTS will call
03139                                  ; the function
03140    CC73  A5 9B              LDA   comp_f            ; get compare function flag
03141    CC75  48                 PHA                     ; push compare evaluation byte
03142    CC76  B9 18 E4           LDA   LAB_OPPT,Y        ; get precedence byte
03143    CC79  4C F1 CB           JMP   LAB_1ACC          ; continue evaluating expression
03144    
03145    LAB_1B53
03146    CC7C  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
03147    
03148    ; push sign, round FAC1 and put on stack
03149    
03150    LAB_1B5B
03151    CC7F  68                 PLA                     ; get return addr low byte
03152    CC80  85 71              STA   ut1_pl            ; save it
03153    CC82  E6 71              INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
03154                                  ; note! no check is made on the high byte! if the calling
03155                                  ; routine assembles to a page edge then this all goes
03156                                  ; horribly wrong !!!
03157    CC84  68                 PLA                     ; get return addr high byte
03158    CC85  85 72              STA   ut1_ph            ; save it
03159    CC87  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
03160    CC89  48                 PHA                     ; push sign
03161    
03162    ; round FAC1 and put on stack
03163    
03164    ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
03165    ; *** replace
03166    ;LAB_1B66
03167    ;      JSR   LAB_27BA          ; round FAC1
03168    ; *** with
03169    CC8A  20 EC D9           JSR   LAB_27BA          ; round FAC1
03170    LAB_1B66
03171    ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
03172    CC8D  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03173    CC8F  48                 PHA                     ; push on stack
03174    CC90  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03175    CC92  48                 PHA                     ; push on stack
03176    CC93  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
03177    CC95  48                 PHA                     ; push on stack
03178    CC96  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03179    CC98  48                 PHA                     ; push on stack
03180    CC99  6C 71 00           JMP   (ut1_pl)          ; return, sort of
03181    
03182    ; do functions
03183    
03184    LAB_1B78
03185    CC9C  A0 FF              LDY   #$FF              ; flag function
03186    CC9E  68                 PLA                     ; pull precedence byte
03187    LAB_1B7B
03188    CC9F  F0 20              BEQ   LAB_1B9D          ; exit if done
03189    
03190    LAB_1B7D
03191    CCA1  C9 64              CMP   #$64              ; compare previous precedence with $64
03192    CCA3  F0 03              BEQ   LAB_1B84          ; branch if was $64 (< function)
03193    
03194    CCA5  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
03195    LAB_1B84
03196    CCA8  84 99              STY   prstk             ; save precedence stacked flag
03197    
03198                                  ; pop FAC2 and return
03199    LAB_1B86
03200    CCAA  68                 PLA                     ; pop byte
03201    CCAB  4A                 LSR                     ; shift out comparison evaluation lowest bit
03202    CCAC  85 63              STA   Cflag             ; save comparison evaluation flag
03203    CCAE  68                 PLA                     ; pop exponent
03204    CCAF  85 B3              STA   FAC2_e            ; save FAC2 exponent
03205    CCB1  68                 PLA                     ; pop mantissa1
03206    CCB2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
03207    CCB4  68                 PLA                     ; pop mantissa2
03208    CCB5  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
03209    CCB7  68                 PLA                     ; pop mantissa3
03210    CCB8  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
03211    CCBA  68                 PLA                     ; pop sign
03212    CCBB  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
03213    CCBD  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
03214    CCBF  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
03215    LAB_1B9D
03216    CCC1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03217    CCC3  60                 RTS
03218    
03219    ; print "..." string to string util area
03220    
03221    LAB_1BC1
03222    CCC4  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
03223    CCC6  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
03224    CCC8  69 00              ADC   #$00              ; add carry to low byte
03225    CCCA  90 01              BCC   LAB_1BCA          ; branch if no overflow
03226    
03227    CCCC  C8                 INY                     ; increment high byte
03228    LAB_1BCA
03229    CCCD  20 58 D2           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
03230    CCD0  4C E2 D5           JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
03231    
03232    ; get value from line
03233    
03234    LAB_GVAL
03235    CCD3  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03236    CCD6  B0 03              BCS   LAB_1BAC          ; branch if not numeric character
03237    
03238                                  ; else numeric string found (e.g. 123)
03239    LAB_1BA9
03240    CCD8  4C B9 DA           JMP   LAB_2887          ; get FAC1 from string and return
03241    
03242    ; get value from line .. continued
03243    
03244                                  ; wasn't a number so ..
03245    LAB_1BAC
03246    CCDB  AA                 TAX                     ; set the flags
03247    CCDC  30 2F              BMI   LAB_1BD0          ; if -ve go test token values
03248    
03249                                  ; else it is either a string, number, variable or (<expr>)
03250    CCDE  C9 24              CMP   #'$'              ; compare with "$"
03251    CCE0  F0 F6              BEQ   LAB_1BA9          ; branch if "$", hex number
03252    
03253    CCE2  C9 25              CMP   #'%'              ; else compare with "%"
03254    CCE4  F0 F2              BEQ   LAB_1BA9          ; branch if "%", binary number
03255    
03256    CCE6  C9 2E              CMP   #'.'              ; compare with "."
03257    CCE8  F0 EE              BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
03258    
03259                                  ; it wasn't any sort of number so ..
03260    CCEA  C9 22              CMP   #$22              ; compare with "
03261    CCEC  F0 D6              BEQ   LAB_1BC1          ; branch if open quote
03262    
03263                                  ; wasn't any sort of number so ..
03264    
03265    ; evaluate expression within parentheses
03266    
03267    CCEE  C9 28              CMP   #'('              ; compare with "("
03268    CCF0  D0 5B              BNE   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
03269    
03270    LAB_1BF7
03271    CCF2  20 EF CB           JSR   LAB_EVEZ          ; evaluate expression, no decrement
03272    
03273    ; all the 'scan for' routines return the character after the sought character
03274    
03275    ; scan for ")" , else do syntax error then warm start
03276    
03277    LAB_1BFB
03278    CCF5  A9 29              LDA   #$29              ; load A with ")"
03279    
03280    ; scan for CHR$(A) , else do syntax error then warm start
03281    
03282    LAB_SCCA
03283    CCF7  A0 00              LDY   #$00              ; clear index
03284    CCF9  D1 C3              CMP   (Bpntrl),Y        ; check next byte is = A
03285    CCFB  D0 0B              BNE   LAB_SNER          ; if not do syntax error then warm start
03286    
03287    CCFD  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then return
03288    
03289    ; scan for "(" , else do syntax error then warm start
03290    
03291    LAB_1BFE
03292    CD00  A9 28              LDA   #$28              ; load A with "("
03293    CD02  D0 F3              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
03294                                  ; (branch always)
03295    
03296    ; scan for "," , else do syntax error then warm start
03297    
03298    LAB_1C01
03299    CD04  A9 2C              LDA   #$2C              ; load A with ","
03300    CD06  D0 EF              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
03301                                  ; (branch always)
03302    
03303    ; syntax error then warm start
03304    
03305    LAB_SNER
03306    CD08  A2 02              LDX   #$02              ; error code $02 ("Syntax" error)
03307    CD0A  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
03308    
03309    ; get value from line .. continued
03310    ; do tokens
03311    
03312    LAB_1BD0
03313    CD0D  C9 BE              CMP   #TK_MINUS         ; compare with token for -
03314    CD0F  F0 29              BEQ   LAB_1C11          ; branch if - token (do set-up for functions)
03315    
03316                                  ; wasn't -n so ..
03317    CD11  C9 BD              CMP   #TK_PLUS          ; compare with token for +
03318    CD13  F0 BE              BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
03319    
03320    CD15  C9 B8              CMP   #TK_NOT           ; compare with token for NOT
03321    CD17  D0 13              BNE   LAB_1BE7          ; branch if not token for NOT
03322    
03323                                  ; was NOT token
03324      000B             TK_EQUAL_PLUS     = TK_EQUAL-TK_PLUS
03325    CD19  A0 21              LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
03326    CD1B  D0 1F              BNE   LAB_1C13          ; do set-up for function then execute (branch always)
03327    
03328    ; do = compare
03329    
03330    LAB_EQUAL
03331    CD1D  20 BA CF           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
03332    CD20  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03333    CD22  49 FF              EOR   #$FF              ; invert it
03334    CD24  A8                 TAY                     ; copy it
03335    CD25  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03336    CD27  49 FF              EOR   #$FF              ; invert it
03337    CD29  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03338    
03339    ; get value from line .. continued
03340    
03341                                  ; wasn't +, -, or NOT so ..
03342    LAB_1BE7
03343    CD2C  C9 B5              CMP   #TK_FN            ; compare with token for FN
03344    CD2E  D0 03              BNE   LAB_1BEE          ; branch if not token for FN
03345    
03346    CD30  4C C8 D1           JMP   LAB_201E          ; go evaluate FNx
03347    
03348    ; get value from line .. continued
03349    
03350                                  ; wasn't +, -, NOT or FN so ..
03351    LAB_1BEE
03352    CD33  E9 CA              SBC   #TK_SGN           ; subtract with token for SGN
03353    CD35  B0 27              BCS   LAB_1C27          ; if a function token go do it
03354    
03355    CD37  4C 08 CD           JMP   LAB_SNER          ; else do syntax error
03356    
03357    ; set-up for functions
03358    
03359    LAB_1C11
03360      000A             TK_GT_PLUS  = TK_GT-TK_PLUS
03361    CD3A  A0 1E              LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
03362    LAB_1C13
03363    CD3C  68                 PLA                     ; dump return address low byte
03364    ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
03365    ; *** replace
03366    ;      PLA                     ; dump return address high byte
03367    ;      JMP   LAB_1B1D          ; execute function then continue evaluation
03368    ; *** with
03369    CD3D  AA                 TAX                     ; save to trap concatenate
03370    CD3E  68                 PLA                     ; dump return address high byte
03371    CD3F  E0 F6              CPX   #<[LAB_224Da+2]   ; from concatenate low return address?
03372    CD41  D0 04              BNE   LAB_1C13b         ; No - continue!
03373    CD43  C9 D3              CMP   #>[LAB_224Da+2]   ; from concatenate high return address?
03374    CD45  F0 03              BEQ   LAB_1C13a         ; Yes - error!
03375    LAB_1C13b
03376    CD47  4C 40 CC           JMP   LAB_1B1D          ; execute function then continue evaluation
03377    LAB_1C13a
03378    CD4A  4C E2 CB           JMP   LAB_1ABC          ; throw "type mismatch error" then warm start      
03379    ; *** end   patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
03380    
03381    ; variable name set-up
03382    ; get (var), return value in FAC_1 and $ flag
03383    
03384    LAB_1C18
03385    CD4D  20 BE CE           JSR   LAB_GVAR          ; get (var) address
03386    CD50  85 AE              STA   FAC1_2            ; save address low byte in FAC1 mantissa2
03387    CD52  84 AF              STY   FAC1_3            ; save address high byte in FAC1 mantissa3
03388    CD54  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
03389    CD56  30 03              BMI   LAB_1C25          ; if string then return (does RTS)
03390    
03391    LAB_1C24
03392    CD58  4C 90 D9           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
03393    
03394    LAB_1C25
03395    ; *** begin patch  string pointer high byte trashed when moved to stack
03396    ; *** add
03397    CD5B  46 B9              LSR   FAC1_r            ; clear bit 7 (<$80) = do not round up
03398    ; *** end patch 
03399    CD5D  60                 RTS
03400    
03401    ; get value from line .. continued
03402    ; only functions left so ..
03403    
03404    ; set up function references
03405    
03406    ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
03407    ; to process function calls. now the function vector is computed and pushed on the stack
03408    ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
03409    ; is calculated and the routine called, if not this routine just does RTS. whichever
03410    ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
03411    ; the function code
03412    
03413    ; this also removes some less than elegant code that was used to bypass type checking
03414    ; for functions that returned strings
03415    
03416    LAB_1C27
03417    CD5E  0A                 ASL                     ; *2 (2 bytes per function address)
03418    CD5F  A8                 TAY                     ; copy to index
03419    
03420    CD60  B9 D3 E3           LDA   LAB_FTBM,Y        ; get function jump vector high byte
03421    CD63  48                 PHA                     ; push functions jump vector high byte
03422    CD64  B9 D2 E3           LDA   LAB_FTBL,Y        ; get function jump vector low byte
03423    CD67  48                 PHA                     ; push functions jump vector low byte
03424    
03425    CD68  B9 8D E3           LDA   LAB_FTPM,Y        ; get function pre process vector high byte
03426    CD6B  F0 05              BEQ   LAB_1C56          ; skip pre process if null vector
03427    
03428    CD6D  48                 PHA                     ; push functions pre process vector high byte
03429    CD6E  B9 8C E3           LDA   LAB_FTPL,Y        ; get function pre process vector low byte
03430    CD71  48                 PHA                     ; push functions pre process vector low byte
03431    
03432    LAB_1C56
03433    CD72  60                 RTS                     ; do function, or pre process, call
03434    
03435    ; process string expression in parenthesis
03436    
03437    LAB_PPFS
03438    CD73  20 F2 CC           JSR   LAB_1BF7          ; process expression in parenthesis
03439    CD76  4C D8 CB           JMP   LAB_CTST          ; check if source is string then do function,
03440                                  ; else do type mismatch
03441    
03442    ; process numeric expression in parenthesis
03443    
03444    LAB_PPFN
03445    CD79  20 F2 CC           JSR   LAB_1BF7          ; process expression in parenthesis
03446    CD7C  4C D6 CB           JMP   LAB_CTNM          ; check if source is numeric then do function,
03447                                  ; else do type mismatch
03448    
03449    ; set numeric data type and increment BASIC execute pointer
03450    
03451    LAB_PPBI
03452    CD7F  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
03453    CD81  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then do function
03454    
03455    ; process string for LEFT$, RIGHT$ or MID$
03456    
03457    LAB_LRMS
03458    CD84  20 EF CB           JSR   LAB_EVEZ          ; evaluate (should be string) expression
03459    CD87  20 04 CD           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
03460    CD8A  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
03461    
03462    CD8D  68                 PLA                     ; get function jump vector low byte
03463    CD8E  AA                 TAX                     ; save functions jump vector low byte
03464    CD8F  68                 PLA                     ; get function jump vector high byte
03465    CD90  A8                 TAY                     ; save functions jump vector high byte
03466    CD91  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
03467    CD93  48                 PHA                     ; push string pointer high byte
03468    CD94  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
03469    CD96  48                 PHA                     ; push string pointer low byte
03470    CD97  98                 TYA                     ; get function jump vector high byte back
03471    CD98  48                 PHA                     ; save functions jump vector high byte
03472    CD99  8A                 TXA                     ; get function jump vector low byte back
03473    CD9A  48                 PHA                     ; save functions jump vector low byte
03474    CD9B  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
03475    CD9E  8A                 TXA                     ; copy byte parameter to A
03476    CD9F  60                 RTS                     ; go do function
03477    
03478    ; process numeric expression(s) for BIN$ or HEX$
03479    
03480    LAB_BHSS
03481    CDA0  20 EF CB           JSR   LAB_EVEZ          ; process expression
03482    CDA3  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
03483    CDA6  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03484    CDA8  C9 98              CMP   #$98              ; compare with exponent = 2^24
03485    CDAA  B0 20              BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
03486    
03487    CDAC  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
03488    CDAF  A2 02              LDX   #$02              ; 3 bytes to do
03489    LAB_CFAC
03490    CDB1  B5 AD              LDA   FAC1_1,X          ; get byte from FAC1
03491    CDB3  95 11              STA   nums_1,X          ; save byte to temp
03492    CDB5  CA                 DEX                     ; decrement index
03493    CDB6  10 F9              BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
03494    
03495    CDB8  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
03496    CDBB  A2 00              LDX   #$00              ; set default to no leading "0"s
03497    CDBD  C9 29              CMP   #')'              ; compare with close bracket
03498    CDBF  F0 0A              BEQ   LAB_1C54          ; if ")" go do rest of function
03499    
03500    CDC1  20 F1 D5           JSR   LAB_SCGB          ; scan for "," and get byte
03501    CDC4  20 C2 00           JSR   LAB_GBYT          ; get last byte back
03502    CDC7  C9 29              CMP   #')'              ; is next character )
03503    CDC9  D0 01              BNE   LAB_BHER          ; if not ")" go do error
03504    
03505    LAB_1C54
03506    CDCB  60                 RTS                     ; else do function
03507    
03508    LAB_BHER
03509    CDCC  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
03510    
03511    ; perform EOR
03512    
03513    ; added operator format is the same as AND or OR, precedence is the same as OR
03514    
03515    ; this bit worked first time but it took a while to sort out the operator table
03516    ; pointers and offsets afterwards!
03517    
03518    LAB_EOR
03519    CDCF  20 F6 CD           JSR   GetFirst          ; get first integer expression (no sign check)
03520    CDD2  45 5B              EOR   XOAw_l            ; EOR with expression 1 low byte
03521    CDD4  A8                 TAY                     ; save in Y
03522    CDD5  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03523    CDD7  45 5C              EOR   XOAw_h            ; EOR with expression 1 high byte
03524    CDD9  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03525    
03526    ; perform OR
03527    
03528    LAB_OR
03529    CDDC  20 F6 CD           JSR   GetFirst          ; get first integer expression (no sign check)
03530    CDDF  05 5B              ORA   XOAw_l            ; OR with expression 1 low byte
03531    CDE1  A8                 TAY                     ; save in Y
03532    CDE2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03533    CDE4  05 5C              ORA   XOAw_h            ; OR with expression 1 high byte
03534    CDE6  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03535    
03536    ; perform AND
03537    
03538    LAB_AND
03539    CDE9  20 F6 CD           JSR   GetFirst          ; get first integer expression (no sign check)
03540    CDEC  25 5B              AND   XOAw_l            ; AND with expression 1 low byte
03541    CDEE  A8                 TAY                     ; save in Y
03542    CDEF  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03543    CDF1  25 5C              AND   XOAw_h            ; AND with expression 1 high byte
03544    CDF3  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03545    
03546    ; get first value for OR, AND or EOR
03547    
03548    GetFirst
03549    CDF6  20 BA CF           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
03550    CDF9  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03551    CDFB  85 5C              STA   XOAw_h            ; save it
03552    CDFD  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03553    CDFF  85 5B              STA   XOAw_l            ; save it
03554    CE01  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
03555    CE04  20 BA CF           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
03556    CE07  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03557    LAB_1C95
03558    CE09  60                 RTS
03559    
03560    ; perform comparisons
03561    
03562    ; do < compare
03563    
03564    LAB_LTHAN
03565    CE0A  20 D9 CB           JSR   LAB_CKTM          ; type match check, set C for string
03566    CE0D  B0 13              BCS   LAB_1CAE          ; branch if string
03567    
03568                                  ; do numeric < compare
03569    CE0F  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
03570    CE11  09 7F              ORA   #$7F              ; set all non sign bits
03571    CE13  25 B4              AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
03572    CE15  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
03573    CE17  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
03574    CE19  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
03575    CE1B  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
03576    CE1E  AA                 TAX                     ; copy result
03577    CE1F  4C 53 CE           JMP   LAB_1CE1          ; go evaluate result
03578    
03579                                  ; do string < compare
03580    LAB_1CAE
03581    CE22  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
03582    CE24  C6 9B              DEC   comp_f            ; clear < bit in compare function flag
03583    CE26  20 58 D4           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
03584                                  ; space returns with A = length, X=pointer low byte,
03585                                  ; Y=pointer high byte
03586    CE29  85 AC              STA   str_ln            ; save length
03587    CE2B  86 AD              STX   str_pl            ; save string pointer low byte
03588    CE2D  84 AE              STY   str_ph            ; save string pointer high byte
03589    CE2F  A5 B5              LDA   FAC2_2            ; get descriptor pointer low byte
03590    CE31  A4 B6              LDY   FAC2_3            ; get descriptor pointer high byte
03591    CE33  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
03592                                  ; returns with A = length, X=pointer low byte,
03593                                  ; Y=pointer high byte
03594    CE36  86 B5              STX   FAC2_2            ; save string pointer low byte
03595    CE38  84 B6              STY   FAC2_3            ; save string pointer high byte
03596    CE3A  AA                 TAX                     ; copy length
03597    CE3B  38                 SEC                     ; set carry for subtract
03598    CE3C  E5 AC              SBC   str_ln            ; subtract string 1 length
03599    CE3E  F0 08              BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
03600    
03601    CE40  A9 01              LDA   #$01              ; set str 1 length > string 2 length
03602    CE42  90 04              BCC   LAB_1CD6          ; branch if so
03603    
03604    CE44  A6 AC              LDX   str_ln            ; get string 1 length
03605    CE46  A9 FF              LDA   #$FF              ; set str 1 length < string 2 length
03606    LAB_1CD6
03607    CE48  85 B0              STA   FAC1_s            ; save length compare
03608    CE4A  A0 FF              LDY   #$FF              ; set index
03609    CE4C  E8                 INX                     ; adjust for loop
03610    LAB_1CDB
03611    CE4D  C8                 INY                     ; increment index
03612    CE4E  CA                 DEX                     ; decrement count
03613    CE4F  D0 07              BNE   LAB_1CE6          ; branch if still bytes to do
03614    
03615    CE51  A6 B0              LDX   FAC1_s            ; get length compare back
03616    LAB_1CE1
03617    CE53  30 0F              BMI   LAB_1CF2          ; branch if str 1 < str 2
03618    
03619    CE55  18                 CLC                     ; flag str 1 <= str 2
03620    CE56  90 0C              BCC   LAB_1CF2          ; go evaluate result
03621    
03622    LAB_1CE6
03623    CE58  B1 B5              LDA   (FAC2_2),Y        ; get string 2 byte
03624    CE5A  D1 AD              CMP   (FAC1_1),Y        ; compare with string 1 byte
03625    CE5C  F0 EF              BEQ   LAB_1CDB          ; loop if bytes =
03626    
03627    CE5E  A2 FF              LDX   #$FF              ; set str 1 < string 2
03628    CE60  B0 02              BCS   LAB_1CF2          ; branch if so
03629    
03630    CE62  A2 01              LDX   #$01              ;  set str 1 > string 2
03631    LAB_1CF2
03632    CE64  E8                 INX                     ; x = 0, 1 or 2
03633    CE65  8A                 TXA                     ; copy to A
03634    CE66  2A                 ROL                     ; *2 (1, 2 or 4)
03635    CE67  25 63              AND   Cflag             ; AND with comparison evaluation flag
03636    CE69  F0 02              BEQ   LAB_1CFB          ; branch if 0 (compare is false)
03637    
03638    CE6B  A9 FF              LDA   #$FF              ; else set result true
03639    LAB_1CFB
03640    CE6D  4C 0D DA           JMP   LAB_27DB          ; save A as integer byte and return
03641    
03642    LAB_1CFE
03643    CE70  20 04 CD           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
03644    
03645    ; perform DIM
03646    
03647    LAB_DIM
03648    CE73  AA                 TAX                     ; copy "DIM" flag to X
03649    CE74  20 C3 CE           JSR   LAB_1D10          ; search for variable
03650    CE77  20 C2 00           JSR   LAB_GBYT          ; scan memory
03651    CE7A  D0 F4              BNE   LAB_1CFE          ; scan for "," and loop if not null
03652    
03653    CE7C  60                 RTS
03654    
03655    ; perform << (left shift)
03656    
03657    LAB_LSHIFT
03658    CE7D  20 B3 CE           JSR   GetPair           ; get integer expression and byte (no sign check)
03659    CE80  A5 AE              LDA   FAC1_2            ; get expression high byte
03660    CE82  A6 78              LDX   TempB             ; get shift count
03661    CE84  F0 22              BEQ   NoShift           ; branch if zero
03662    
03663    CE86  E0 10              CPX   #$10              ; compare bit count with 16d
03664    CE88  B0 23              BCS   TooBig            ; branch if >=
03665    
03666    Ls_loop
03667    CE8A  06 AF              ASL   FAC1_3            ; shift low byte
03668    CE8C  2A                 ROL                     ; shift high byte
03669    CE8D  CA                 DEX                     ; decrement bit count
03670    CE8E  D0 FA              BNE   Ls_loop           ; loop if shift not complete
03671    
03672    CE90  A4 AF              LDY   FAC1_3            ; get expression low byte
03673    CE92  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03674    
03675    ; perform >> (right shift)
03676    
03677    LAB_RSHIFT
03678    CE95  20 B3 CE           JSR   GetPair           ; get integer expression and byte (no sign check)
03679    CE98  A5 AE              LDA   FAC1_2            ; get expression high byte
03680    CE9A  A6 78              LDX   TempB             ; get shift count
03681    CE9C  F0 0A              BEQ   NoShift           ; branch if zero
03682    
03683    CE9E  E0 10              CPX   #$10              ; compare bit count with 16d
03684    CEA0  B0 0B              BCS   TooBig            ; branch if >=
03685    
03686    Rs_loop
03687    CEA2  4A                 LSR                     ; shift high byte
03688    CEA3  66 AF              ROR   FAC1_3            ; shift low byte
03689    CEA5  CA                 DEX                     ; decrement bit count
03690    CEA6  D0 FA              BNE   Rs_loop           ; loop if shift not complete
03691    
03692    NoShift
03693    CEA8  A4 AF              LDY   FAC1_3            ; get expression low byte
03694    CEAA  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03695    
03696    TooBig
03697    CEAD  A9 00              LDA   #$00              ; clear high byte
03698    CEAF  A8                 TAY                     ; copy to low byte
03699    CEB0  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03700    
03701    GetPair
03702    CEB3  20 A9 D5           JSR   LAB_EVBY          ; evaluate byte expression, result in X
03703    CEB6  86 78              STX   TempB             ; save it
03704    CEB8  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
03705    CEBB  4C BA CF           JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
03706    
03707    ; search for variable
03708    
03709    ; return pointer to variable in Cvaral/Cvarah
03710    
03711    LAB_GVAR
03712    CEBE  A2 00              LDX   #$00              ; set DIM flag = $00
03713    CEC0  20 C2 00           JSR   LAB_GBYT          ; scan memory (1st character)
03714    LAB_1D10
03715    CEC3  86 5E              STX   Defdim            ; save DIM flag
03716    LAB_1D12
03717    CEC5  85 93              STA   Varnm1            ; save 1st character
03718    CEC7  29 7F              AND   #$7F              ; clear FN flag bit
03719    CEC9  20 32 CF           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
03720    CECC  B0 03              BCS   LAB_1D1F          ; branch if ok
03721    
03722    CECE  4C 08 CD           JMP   LAB_SNER          ; else syntax error then warm start
03723    
03724                                  ; was variable name so ..
03725    LAB_1D1F
03726    CED1  A2 00              LDX   #$00              ; clear 2nd character temp
03727    CED3  86 5F              STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
03728    CED5  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (2nd character)
03729    CED8  90 05              BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
03730    
03731                                  ; 2nd character wasn't "0" to "9" so ..
03732    CEDA  20 32 CF           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
03733    CEDD  90 0B              BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
03734    
03735    LAB_1D2D
03736    CEDF  AA                 TAX                     ; copy 2nd character
03737    
03738                                  ; ignore further (valid) characters in the variable name
03739    LAB_1D2E
03740    CEE0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (3rd character)
03741    CEE3  90 FB              BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
03742    
03743    CEE5  20 32 CF           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
03744    CEE8  B0 F6              BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
03745    
03746                                  ; check if string variable
03747    LAB_1D38
03748    CEEA  C9 24              CMP   #'$'              ; compare with "$"
03749    CEEC  D0 0B              BNE   LAB_1D47          ; branch if not string
03750    
03751    ; to introduce a new variable type (% suffix for integers say) then this branch
03752    ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
03753    
03754                                  ; type is string
03755    CEEE  A9 FF              LDA   #$FF              ; set data type = string
03756    CEF0  85 5F              STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
03757    CEF2  8A                 TXA                     ; get 2nd character back
03758    CEF3  09 80              ORA   #$80              ; set top bit (indicate string var)
03759    CEF5  AA                 TAX                     ; copy back to 2nd character temp
03760    CEF6  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03761    
03762    ; after we have determined the variable type we need to come back here to determine
03763    ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
03764    
03765    
03766    LAB_1D47                      ; gets here with character after var name in A
03767    CEF9  86 94              STX   Varnm2            ; save 2nd character
03768    CEFB  05 61              ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
03769    CEFD  C9 28              CMP   #'('              ; compare with "("
03770    CEFF  D0 03              BNE   LAB_1D53          ; branch if not "("
03771    
03772    CF01  4C CC CF           JMP   LAB_1E17          ; go find, or make, array
03773    
03774    ; either find or create var
03775    ; var name (1st two characters only!) is in Varnm1,Varnm2
03776    
03777                                  ; variable name wasn't var(... so look for plain var
03778    LAB_1D53
03779    CF04  A9 00              LDA   #$00              ; clear A
03780    CF06  85 61              STA   Sufnxf            ; clear subscript/FNX flag
03781    CF08  A5 7B              LDA   Svarl             ; get start of vars low byte
03782    CF0A  A6 7C              LDX   Svarh             ; get start of vars high byte
03783    CF0C  A0 00              LDY   #$00              ; clear index
03784    LAB_1D5D
03785    CF0E  86 AB              STX   Vrschh            ; save search address high byte
03786    LAB_1D5F
03787    CF10  85 AA              STA   Vrschl            ; save search address low byte
03788    CF12  E4 7E              CPX   Sarryh            ; compare high address with var space end
03789    CF14  D0 04              BNE   LAB_1D69          ; skip next compare if <>
03790    
03791                                  ; high addresses were = so compare low addresses
03792    CF16  C5 7D              CMP   Sarryl            ; compare low address with var space end
03793    CF18  F0 2C              BEQ   LAB_1D8B          ; if not found go make new var
03794    
03795    LAB_1D69
03796    CF1A  A5 93              LDA   Varnm1            ; get 1st character of var to find
03797    CF1C  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 1st character
03798    CF1E  D0 08              BNE   LAB_1D77          ; branch if no match
03799    
03800                                  ; 1st characters match so compare 2nd characters
03801    CF20  A5 94              LDA   Varnm2            ; get 2nd character of var to find
03802    CF22  C8                 INY                     ; index to point to variable name 2nd character
03803    CF23  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 2nd character
03804    CF25  F0 69              BEQ   LAB_1DD7          ; branch if match (found var)
03805    
03806    CF27  88                 DEY                     ; else decrement index (now = $00)
03807    LAB_1D77
03808    CF28  18                 CLC                     ; clear carry for add
03809    CF29  A5 AA              LDA   Vrschl            ; get search address low byte
03810    CF2B  69 06              ADC   #$06              ; +6 (offset to next var name)
03811    CF2D  90 E1              BCC   LAB_1D5F          ; loop if no overflow to high byte
03812    
03813    CF2F  E8                 INX                     ; else increment high byte
03814    CF30  D0 DC              BNE   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
03815    
03816    ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
03817    
03818    LAB_CASC
03819    CF32  C9 61              CMP   #'a'              ; compare with "a"
03820    CF34  B0 0A              BCS   LAB_1D83          ; go check <"z"+1
03821    
03822    ; check byte, return C=0 if<"A" or >"Z"
03823    
03824    LAB_1D82
03825    CF36  C9 41              CMP   #'A'              ; compare with "A"
03826    CF38  90 05              BCC   LAB_1D8A          ; exit if less
03827    
03828                                  ; carry is set
03829    CF3A  E9 5B              SBC   #$5B              ; subtract "Z"+1
03830    CF3C  38                 SEC                     ; set carry
03831    CF3D  E9 A5              SBC   #$A5              ; subtract $A5 (restore byte)
03832                                  ; carry clear if byte>$5A
03833    LAB_1D8A
03834    CF3F  60                 RTS
03835    
03836    LAB_1D83
03837    CF40  E9 7B              SBC   #$7B              ; subtract "z"+1
03838    CF42  38                 SEC                     ; set carry
03839    CF43  E9 85              SBC   #$85              ; subtract $85 (restore byte)
03840                                  ; carry clear if byte>$7A
03841    CF45  60                 RTS
03842    
03843                                  ; reached end of variable mem without match
03844                                  ; .. so create new variable
03845    LAB_1D8B
03846    CF46  68                 PLA                     ; pop return address low byte
03847    CF47  48                 PHA                     ; push return address low byte
03848      CD4F             LAB_1C18p2  = LAB_1C18+2
03849    CF48  C9 4F              CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
03850    CF4A  D0 05              BNE   LAB_1D98          ; if not get (var) go create new var
03851    
03852    ; This will only drop through if the call was from LAB_1C18 and is only called
03853    ; from there if it is searching for a variable from the RHS of a LET a=b statement
03854    ; it prevents the creation of variables not assigned a value.
03855    
03856    ; value returned by this is either numeric zero (exponent byte is $00) or null string
03857    ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
03858    
03859    ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
03860    
03861    ; this is where you would put the undefined variable error call e.g.
03862    
03863    ;                             ; variable doesn't exist so flag error
03864    ;     LDX   #$24              ; error code $24 ("undefined variable" error)
03865    ;     JMP   LAB_XERR          ; do error #X then warm start
03866    
03867    ; the above code has been tested and works a treat! (it replaces the three code lines
03868    ; below)
03869    
03870                                  ; else return dummy null value
03871    CF4C  A9 02              LDA   #<LAB_1D96        ; low byte point to $00,$00
03872                                  ; (uses part of misc constants table)
03873    CF4E  A0 E3              LDY   #>LAB_1D96        ; high byte point to $00,$00
03874    CF50  60                 RTS
03875    
03876                                  ; create new numeric variable
03877    LAB_1D98
03878    CF51  A5 7D              LDA   Sarryl            ; get var mem end low byte
03879    CF53  A4 7E              LDY   Sarryh            ; get var mem end high byte
03880    CF55  85 AA              STA   Ostrtl            ; save old block start low byte
03881    CF57  84 AB              STY   Ostrth            ; save old block start high byte
03882    CF59  A5 7F              LDA   Earryl            ; get array mem end low byte
03883    CF5B  A4 80              LDY   Earryh            ; get array mem end high byte
03884    CF5D  85 A6              STA   Obendl            ; save old block end low byte
03885    CF5F  84 A7              STY   Obendh            ; save old block end high byte
03886    CF61  18                 CLC                     ; clear carry for add
03887    CF62  69 06              ADC   #$06              ; +6 (space for one var)
03888    CF64  90 01              BCC   LAB_1DAE          ; branch if no overflow to high byte
03889    
03890    CF66  C8                 INY                     ; else increment high byte
03891    LAB_1DAE
03892    CF67  85 A4              STA   Nbendl            ; set new block end low byte
03893    CF69  84 A5              STY   Nbendh            ; set new block end high byte
03894    CF6B  20 C1 C1           JSR   LAB_11CF          ; open up space in memory
03895    CF6E  A5 A4              LDA   Nbendl            ; get new start low byte
03896    CF70  A4 A5              LDY   Nbendh            ; get new start high byte (-$100)
03897    CF72  C8                 INY                     ; correct high byte
03898    CF73  85 7D              STA   Sarryl            ; save new var mem end low byte
03899    CF75  84 7E              STY   Sarryh            ; save new var mem end high byte
03900    CF77  A0 00              LDY   #$00              ; clear index
03901    CF79  A5 93              LDA   Varnm1            ; get var name 1st character
03902    CF7B  91 AA              STA   (Vrschl),Y        ; save var name 1st character
03903    CF7D  C8                 INY                     ; increment index
03904    CF7E  A5 94              LDA   Varnm2            ; get var name 2nd character
03905    CF80  91 AA              STA   (Vrschl),Y        ; save var name 2nd character
03906    CF82  A9 00              LDA   #$00              ; clear A
03907    CF84  C8                 INY                     ; increment index
03908    CF85  91 AA              STA   (Vrschl),Y        ; initialise var byte
03909    CF87  C8                 INY                     ; increment index
03910    CF88  91 AA              STA   (Vrschl),Y        ; initialise var byte
03911    CF8A  C8                 INY                     ; increment index
03912    CF8B  91 AA              STA   (Vrschl),Y        ; initialise var byte
03913    CF8D  C8                 INY                     ; increment index
03914    CF8E  91 AA              STA   (Vrschl),Y        ; initialise var byte
03915    
03916                                  ; found a match for var ((Vrschl) = ptr)
03917    LAB_1DD7
03918    CF90  A5 AA              LDA   Vrschl            ; get var address low byte
03919    CF92  18                 CLC                     ; clear carry for add
03920    CF93  69 02              ADC   #$02              ; +2 (offset past var name bytes)
03921    CF95  A4 AB              LDY   Vrschh            ; get var address high byte
03922    CF97  90 01              BCC   LAB_1DE1          ; branch if no overflow from add
03923    
03924    CF99  C8                 INY                     ; else increment high byte
03925    LAB_1DE1
03926    CF9A  85 95              STA   Cvaral            ; save current var address low byte
03927    CF9C  84 96              STY   Cvarah            ; save current var address high byte
03928    CF9E  60                 RTS
03929    
03930    ; set-up array pointer (Adatal/h) to first element in array
03931    ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
03932    
03933    LAB_1DE6
03934    CF9F  A5 5D              LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
03935    CFA1  0A                 ASL                     ; *2 (also clears the carry !)
03936    CFA2  69 05              ADC   #$05              ; +5 (result is 7, 9 or 11 here)
03937    CFA4  65 AA              ADC   Astrtl            ; add array start pointer low byte
03938    CFA6  A4 AB              LDY   Astrth            ; get array pointer high byte
03939    CFA8  90 01              BCC   LAB_1DF2          ; branch if no overflow
03940    
03941    CFAA  C8                 INY                     ; else increment high byte
03942    LAB_1DF2
03943    CFAB  85 A4              STA   Adatal            ; save array data pointer low byte
03944    CFAD  84 A5              STY   Adatah            ; save array data pointer high byte
03945    CFAF  60                 RTS
03946    
03947    ; evaluate integer expression
03948    
03949    LAB_EVIN
03950    CFB0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03951    CFB3  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
03952                                  ; else do type mismatch
03953    
03954    ; evaluate integer expression (no check)
03955    
03956    LAB_EVPI
03957    CFB6  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
03958    CFB8  30 0D              BMI   LAB_1E12          ; do function call error if -ve
03959    
03960    ; evaluate integer expression (no sign check)
03961    
03962    LAB_EVIR
03963    CFBA  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03964    CFBC  C9 90              CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
03965    CFBE  90 09              BCC   LAB_1E14          ; branch if n<2^16 (is ok)
03966    
03967    CFC0  A9 09              LDA   #<LAB_1DF7        ; set pointer low byte to -32768
03968    CFC2  A0 E3              LDY   #>LAB_1DF7        ; set pointer high byte to -32768
03969    CFC4  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
03970    LAB_1E12
03971    CFC7  D0 74              BNE   LAB_FCER          ; if <> do function call error then warm start
03972    
03973    LAB_1E14
03974    CFC9  4C 63 DA           JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
03975    
03976    ; find or make array
03977    
03978    LAB_1E17
03979    CFCC  A5 5E              LDA   Defdim            ; get DIM flag
03980    CFCE  48                 PHA                     ; push it
03981    CFCF  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
03982    CFD1  48                 PHA                     ; push it
03983    CFD2  A0 00              LDY   #$00              ; clear dimensions count
03984    
03985    ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
03986    
03987    LAB_1E1F
03988    CFD4  98                 TYA                     ; copy dimensions count
03989    CFD5  48                 PHA                     ; save it
03990    CFD6  A5 94              LDA   Varnm2            ; get array name 2nd byte
03991    CFD8  48                 PHA                     ; save it
03992    CFD9  A5 93              LDA   Varnm1            ; get array name 1st byte
03993    CFDB  48                 PHA                     ; save it
03994    CFDC  20 B0 CF           JSR   LAB_EVIN          ; evaluate integer expression
03995    CFDF  68                 PLA                     ; pull array name 1st byte
03996    CFE0  85 93              STA   Varnm1            ; restore array name 1st byte
03997    CFE2  68                 PLA                     ; pull array name 2nd byte
03998    CFE3  85 94              STA   Varnm2            ; restore array name 2nd byte
03999    CFE5  68                 PLA                     ; pull dimensions count
04000    CFE6  A8                 TAY                     ; restore it
04001    CFE7  BA                 TSX                     ; copy stack pointer
04002    CFE8  BD 02 01           LDA   LAB_STAK+2,X      ; get DIM flag
04003    CFEB  48                 PHA                     ; push it
04004    CFEC  BD 01 01           LDA   LAB_STAK+1,X      ; get data type flag
04005    CFEF  48                 PHA                     ; push it
04006    CFF0  A5 AE              LDA   FAC1_2            ; get this dimension size high byte
04007    CFF2  9D 02 01           STA   LAB_STAK+2,X      ; stack before flag bytes
04008    CFF5  A5 AF              LDA   FAC1_3            ; get this dimension size low byte
04009    CFF7  9D 01 01           STA   LAB_STAK+1,X      ; stack before flag bytes
04010    CFFA  C8                 INY                     ; increment dimensions count
04011    CFFB  20 C2 00           JSR   LAB_GBYT          ; scan memory
04012    CFFE  C9 2C              CMP   #','              ; compare with ","
04013    D000  F0 D2              BEQ   LAB_1E1F          ; if found go do next dimension
04014    
04015    D002  84 5D              STY   Dimcnt            ; store dimensions count
04016    D004  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
04017    D007  68                 PLA                     ; pull data type flag
04018    D008  85 5F              STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
04019    D00A  68                 PLA                     ; pull DIM flag
04020    D00B  85 5E              STA   Defdim            ; restore DIM flag
04021    D00D  A6 7D              LDX   Sarryl            ; get array mem start low byte
04022    D00F  A5 7E              LDA   Sarryh            ; get array mem start high byte
04023    
04024    ; now check to see if we are at the end of array memory (we would be if there were
04025    ; no arrays).
04026    
04027    LAB_1E5C
04028    D011  86 AA              STX   Astrtl            ; save as array start pointer low byte
04029    D013  85 AB              STA   Astrth            ; save as array start pointer high byte
04030    D015  C5 80              CMP   Earryh            ; compare with array mem end high byte
04031    D017  D0 04              BNE   LAB_1E68          ; branch if not reached array mem end
04032    
04033    D019  E4 7F              CPX   Earryl            ; else compare with array mem end low byte
04034    D01B  F0 39              BEQ   LAB_1EA1          ; go build array if not found
04035    
04036                                  ; search for array
04037    LAB_1E68
04038    D01D  A0 00              LDY   #$00              ; clear index
04039    D01F  B1 AA              LDA   (Astrtl),Y        ; get array name first byte
04040    D021  C8                 INY                     ; increment index to second name byte
04041    D022  C5 93              CMP   Varnm1            ; compare with this array name first byte
04042    D024  D0 06              BNE   LAB_1E77          ; branch if no match
04043    
04044    D026  A5 94              LDA   Varnm2            ; else get this array name second byte
04045    D028  D1 AA              CMP   (Astrtl),Y        ; compare with array name second byte
04046    D02A  F0 16              BEQ   LAB_1E8D          ; array found so branch
04047    
04048                                  ; no match
04049    LAB_1E77
04050    D02C  C8                 INY                     ; increment index
04051    D02D  B1 AA              LDA   (Astrtl),Y        ; get array size low byte
04052    D02F  18                 CLC                     ; clear carry for add
04053    D030  65 AA              ADC   Astrtl            ; add array start pointer low byte
04054    D032  AA                 TAX                     ; copy low byte to X
04055    D033  C8                 INY                     ; increment index
04056    D034  B1 AA              LDA   (Astrtl),Y        ; get array size high byte
04057    D036  65 AB              ADC   Astrth            ; add array mem pointer high byte
04058    D038  90 D7              BCC   LAB_1E5C          ; if no overflow go check next array
04059    
04060    ; do array bounds error
04061    
04062    LAB_1E85
04063    D03A  A2 10              LDX   #$10              ; error code $10 ("Array bounds" error)
04064          .byte $2C               ; makes next bit BIT LAB_08A2
04065    
04066    ; do function call error
04067    
04068    LAB_FCER
04069    D03D  A2 08              LDX   #$08              ; error code $08 ("Function call" error)
04070    LAB_1E8A
04071    D03F  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
04072    
04073                                  ; found array, are we trying to dimension it?
04074    LAB_1E8D
04075    D042  A2 12              LDX   #$12              ; set error $12 ("Double dimension" error)
04076    D044  A5 5E              LDA   Defdim            ; get DIM flag
04077    D046  D0 F7              BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
04078                                  ; start
04079    
04080    ; found the array and we're not dimensioning it so we must find an element in it
04081    
04082    D048  20 9F CF           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
04083                                  ; (Astrtl,Astrth points to start of array)
04084    D04B  A5 5D              LDA   Dimcnt            ; get dimensions count
04085    D04D  A0 04              LDY   #$04              ; set index to array's # of dimensions
04086    D04F  D1 AA              CMP   (Astrtl),Y        ; compare with no of dimensions
04087    D051  D0 E7              BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
04088                                  ; dimensions" error here .. if we want a different
04089                                  ; error message
04090    
04091    D053  4C D9 D0           JMP   LAB_1F28          ; found array so go get element
04092                                  ; (could jump to LAB_1F28 as all LAB_1F24 does is take
04093                                  ; Dimcnt and save it at (Astrtl),Y which is already the
04094                                  ; same or we would have taken the BNE)
04095    
04096                                  ; array not found, so build it
04097    LAB_1EA1
04098    D056  20 9F CF           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
04099                                  ; (Astrtl,Astrth points to start of array)
04100    D059  20 0E C2           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
04101                                  ; addr to check is in AY (low/high)
04102    D05C  A0 00              LDY   #$00              ; clear Y (don't need to clear A)
04103    D05E  84 BB              STY   Aspth             ; clear array data size high byte
04104    D060  A5 93              LDA   Varnm1            ; get variable name 1st byte
04105    D062  91 AA              STA   (Astrtl),Y        ; save array name 1st byte
04106    D064  C8                 INY                     ; increment index
04107    D065  A5 94              LDA   Varnm2            ; get variable name 2nd byte
04108    D067  91 AA              STA   (Astrtl),Y        ; save array name 2nd byte
04109    D069  A5 5D              LDA   Dimcnt            ; get dimensions count
04110    D06B  A0 04              LDY   #$04              ; index to dimension count
04111    D06D  84 BA              STY   Asptl             ; set array data size low byte (four bytes per element)
04112    D06F  91 AA              STA   (Astrtl),Y        ; set array's dimensions count
04113    
04114                                  ; now calculate the size of the data space for the array
04115    D071  18                 CLC                     ; clear carry for add (clear on subsequent loops)
04116    LAB_1EC0
04117    D072  A2 0B              LDX   #$0B              ; set default dimension value low byte
04118    D074  A9 00              LDA   #$00              ; set default dimension value high byte
04119    D076  24 5E              BIT   Defdim            ; test default DIM flag
04120    D078  50 07              BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
04121    
04122    D07A  68                 PLA                     ; else pull dimension value low byte
04123    D07B  69 01              ADC   #$01              ; +1 (allow for zeroeth element)
04124    D07D  AA                 TAX                     ; copy low byte to X
04125    D07E  68                 PLA                     ; pull dimension value high byte
04126    D07F  69 00              ADC   #$00              ; add carry from low byte
04127    
04128    LAB_1ED0
04129    D081  C8                 INY                     ; index to dimension value high byte
04130    D082  91 AA              STA   (Astrtl),Y        ; save dimension value high byte
04131    D084  C8                 INY                     ; index to dimension value high byte
04132    D085  8A                 TXA                     ; get dimension value low byte
04133    D086  91 AA              STA   (Astrtl),Y        ; save dimension value low byte
04134    D088  20 28 D1           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
04135    D08B  86 BA              STX   Asptl             ; save array data size low byte
04136    D08D  85 BB              STA   Aspth             ; save array data size high byte
04137    D08F  A4 71              LDY   ut1_pl            ; restore index (saved by subroutine)
04138    D091  C6 5D              DEC   Dimcnt            ; decrement dimensions count
04139    D093  D0 DD              BNE   LAB_1EC0          ; loop while not = 0
04140    
04141    D095  65 A5              ADC   Adatah            ; add size high byte to first element high byte
04142                                  ; (carry is always clear here)
04143    D097  B0 5D              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
04144    
04145    D099  85 A5              STA   Adatah            ; save end of array high byte
04146    D09B  A8                 TAY                     ; copy end high byte to Y
04147    D09C  8A                 TXA                     ; get array size low byte
04148    D09D  65 A4              ADC   Adatal            ; add array start low byte
04149    D09F  90 03              BCC   LAB_1EF3          ; branch if no carry
04150    
04151    D0A1  C8                 INY                     ; else increment end of array high byte
04152    D0A2  F0 52              BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
04153    
04154                                  ; set-up mostly complete, now zero the array
04155    LAB_1EF3
04156    D0A4  20 0E C2           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
04157                                  ; addr to check is in AY (low/high)
04158    D0A7  85 7F              STA   Earryl            ; save array mem end low byte
04159    D0A9  84 80              STY   Earryh            ; save array mem end high byte
04160    D0AB  A9 00              LDA   #$00              ; clear byte for array clear
04161    D0AD  E6 BB              INC   Aspth             ; increment array size high byte (now block count)
04162    D0AF  A4 BA              LDY   Asptl             ; get array size low byte (now index to block)
04163    D0B1  F0 05              BEQ   LAB_1F07          ; branch if low byte = $00
04164    
04165    LAB_1F02
04166    D0B3  88                 DEY                     ; decrement index (do 0 to n-1)
04167    D0B4  91 A4              STA   (Adatal),Y        ; zero byte
04168    D0B6  D0 FB              BNE   LAB_1F02          ; loop until this block done
04169    
04170    LAB_1F07
04171    D0B8  C6 A5              DEC   Adatah            ; decrement array pointer high byte
04172    D0BA  C6 BB              DEC   Aspth             ; decrement block count high byte
04173    D0BC  D0 F5              BNE   LAB_1F02          ; loop until all blocks done
04174    
04175    D0BE  E6 A5              INC   Adatah            ; correct for last loop
04176    D0C0  38                 SEC                     ; set carry for subtract
04177    D0C1  A0 02              LDY   #$02              ; index to array size low byte
04178    D0C3  A5 7F              LDA   Earryl            ; get array mem end low byte
04179    D0C5  E5 AA              SBC   Astrtl            ; subtract array start low byte
04180    D0C7  91 AA              STA   (Astrtl),Y        ; save array size low byte
04181    D0C9  C8                 INY                     ; index to array size high byte
04182    D0CA  A5 80              LDA   Earryh            ; get array mem end high byte
04183    D0CC  E5 AB              SBC   Astrth            ; subtract array start high byte
04184    D0CE  91 AA              STA   (Astrtl),Y        ; save array size high byte
04185    D0D0  A5 5E              LDA   Defdim            ; get default DIM flag
04186    D0D2  D0 53              BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
04187    
04188                                  ; else, find element
04189    D0D4  C8                 INY                     ; index to # of dimensions
04190    
04191    LAB_1F24
04192    D0D5  B1 AA              LDA   (Astrtl),Y        ; get array's dimension count
04193    D0D7  85 5D              STA   Dimcnt            ; save it
04194    
04195    ; we have found, or built, the array. now we need to find the element
04196    
04197    LAB_1F28
04198    D0D9  A9 00              LDA   #$00              ; clear byte
04199    D0DB  85 BA              STA   Asptl             ; clear array data pointer low byte
04200    LAB_1F2C
04201    D0DD  85 BB              STA   Aspth             ; save array data pointer high byte
04202    D0DF  C8                 INY                     ; increment index (point to array bound high byte)
04203    D0E0  68                 PLA                     ; pull array index low byte
04204    D0E1  AA                 TAX                     ; copy to X
04205    D0E2  85 AE              STA   FAC1_2            ; save index low byte to FAC1 mantissa2
04206    D0E4  68                 PLA                     ; pull array index high byte
04207    D0E5  85 AF              STA   FAC1_3            ; save index high byte to FAC1 mantissa3
04208    D0E7  D1 AA              CMP   (Astrtl),Y        ; compare with array bound high byte
04209    D0E9  90 0E              BCC   LAB_1F48          ; branch if within bounds
04210    
04211    D0EB  D0 06              BNE   LAB_1F42          ; if outside bounds do array bounds error
04212    
04213                                  ; else high byte was = so test low bytes
04214    D0ED  C8                 INY                     ; index to array bound low byte
04215    D0EE  8A                 TXA                     ; get array index low byte
04216    D0EF  D1 AA              CMP   (Astrtl),Y        ; compare with array bound low byte
04217    D0F1  90 07              BCC   LAB_1F49          ; branch if within bounds
04218    
04219    LAB_1F42
04220    D0F3  4C 3A D0           JMP   LAB_1E85          ; else do array bounds error
04221    
04222    LAB_1F45
04223    D0F6  4C 3D C2           JMP   LAB_OMER          ; do "Out of memory" error then warm start
04224    
04225    LAB_1F48
04226    D0F9  C8                 INY                     ; index to array bound low byte
04227    LAB_1F49
04228    D0FA  A5 BB              LDA   Aspth             ; get array data pointer high byte
04229    D0FC  05 BA              ORA   Asptl             ; OR with array data pointer low byte
04230    D0FE  F0 0A              BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
04231    
04232    D100  20 28 D1           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
04233    D103  8A                 TXA                     ; get result low byte
04234    D104  65 AE              ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
04235    D106  AA                 TAX                     ; save result low byte
04236    D107  98                 TYA                     ; get result high byte
04237    D108  A4 71              LDY   ut1_pl            ; restore index
04238    LAB_1F5A
04239    D10A  65 AF              ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
04240    D10C  86 BA              STX   Asptl             ; save array data pointer low byte
04241    D10E  C6 5D              DEC   Dimcnt            ; decrement dimensions count
04242    D110  D0 CB              BNE   LAB_1F2C          ; loop if dimensions still to do
04243    
04244    D112  06 BA              ASL   Asptl             ; array data pointer low byte * 2
04245    D114  2A                 ROL                     ; array data pointer high byte * 2
04246    D115  06 BA              ASL   Asptl             ; array data pointer low byte * 4
04247    D117  2A                 ROL                     ; array data pointer high byte * 4
04248    D118  A8                 TAY                     ; copy high byte
04249    D119  A5 BA              LDA   Asptl             ; get low byte
04250    D11B  65 A4              ADC   Adatal            ; add array data start pointer low byte
04251    D11D  85 95              STA   Cvaral            ; save as current var address low byte
04252    D11F  98                 TYA                     ; get high byte back
04253    D120  65 A5              ADC   Adatah            ; add array data start pointer high byte
04254    D122  85 96              STA   Cvarah            ; save as current var address high byte
04255    D124  A8                 TAY                     ; copy high byte to Y
04256    D125  A5 95              LDA   Cvaral            ; get current var address low byte
04257    LAB_1F7B
04258    D127  60                 RTS
04259    
04260    ; does XY = (Astrtl),Y * (Asptl)
04261    
04262    LAB_1F7C
04263    D128  84 71              STY   ut1_pl            ; save index
04264    D12A  B1 AA              LDA   (Astrtl),Y        ; get dimension size low byte
04265    D12C  85 76              STA   dims_l            ; save dimension size low byte
04266    D12E  88                 DEY                     ; decrement index
04267    D12F  B1 AA              LDA   (Astrtl),Y        ; get dimension size high byte
04268    D131  85 77              STA   dims_h            ; save dimension size high byte
04269    
04270    D133  A9 10              LDA   #$10              ; count = $10 (16 bit multiply)
04271    D135  85 A8              STA   numbit            ; save bit count
04272    D137  A2 00              LDX   #$00              ; clear result low byte
04273    D139  A0 00              LDY   #$00              ; clear result high byte
04274    LAB_1F8F
04275    D13B  8A                 TXA                     ; get result low byte
04276    D13C  0A                 ASL                     ; *2
04277    D13D  AA                 TAX                     ; save result low byte
04278    D13E  98                 TYA                     ; get result high byte
04279    D13F  2A                 ROL                     ; *2
04280    D140  A8                 TAY                     ; save result high byte
04281    D141  B0 B3              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
04282    
04283    D143  06 BA              ASL   Asptl             ; shift multiplier low byte
04284    D145  26 BB              ROL   Aspth             ; shift multiplier high byte
04285    D147  90 0B              BCC   LAB_1FA8          ; skip add if no carry
04286    
04287    D149  18                 CLC                     ; else clear carry for add
04288    D14A  8A                 TXA                     ; get result low byte
04289    D14B  65 76              ADC   dims_l            ; add dimension size low byte
04290    D14D  AA                 TAX                     ; save result low byte
04291    D14E  98                 TYA                     ; get result high byte
04292    D14F  65 77              ADC   dims_h            ; add dimension size high byte
04293    D151  A8                 TAY                     ; save result high byte
04294    D152  B0 A2              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
04295    
04296    LAB_1FA8
04297    D154  C6 A8              DEC   numbit            ; decrement bit count
04298    D156  D0 E3              BNE   LAB_1F8F          ; loop until all done
04299    
04300    D158  60                 RTS
04301    
04302    ; perform FRE()
04303    
04304    LAB_FRE
04305    D159  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
04306    D15B  10 03              BPL   LAB_1FB4          ; branch if numeric
04307    
04308    D15D  20 58 D4           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
04309                                  ; space returns with A = length, X=$71=pointer low byte,
04310                                  ; Y=$72=pointer high byte
04311    
04312                                  ; FRE(n) was numeric so do this
04313    LAB_1FB4
04314    D160  20 F5 D2           JSR   LAB_GARB          ; go do garbage collection
04315    D163  38                 SEC                     ; set carry for subtract
04316    D164  A5 81              LDA   Sstorl            ; get bottom of string space low byte
04317    D166  E5 7F              SBC   Earryl            ; subtract array mem end low byte
04318    D168  A8                 TAY                     ; copy result to Y
04319    D169  A5 82              LDA   Sstorh            ; get bottom of string space high byte
04320    D16B  E5 80              SBC   Earryh            ; subtract array mem end high byte
04321    
04322    ; save and convert integer AY to FAC1
04323    
04324    LAB_AYFC
04325    D16D  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
04326    D16F  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
04327    D171  84 AE              STY   FAC1_2            ; save FAC1 mantissa2
04328    D173  A2 90              LDX   #$90              ; set exponent=2^16 (integer)
04329    D175  4C 15 DA           JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
04330    
04331    ; perform POS()
04332    
04333    LAB_POS
04334    D178  A4 0E              LDY   TPos              ; get terminal position
04335    
04336    ; convert Y to byte in FAC1
04337    
04338    LAB_1FD0
04339    D17A  A9 00              LDA   #$00              ; clear high byte
04340    D17C  F0 EF              BEQ   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
04341    
04342    ; check not Direct (used by DEF and INPUT)
04343    
04344    LAB_CKRN
04345    D17E  A6 88              LDX   Clineh            ; get current line high byte
04346    D180  E8                 INX                     ; increment it
04347    D181  D0 A4              BNE   LAB_1F7B          ; return if can continue not direct mode
04348    
04349                                  ; else do illegal direct error
04350    LAB_1FD9
04351    D183  A2 16              LDX   #$16              ; error code $16 ("Illegal direct" error)
04352    LAB_1FDB
04353    D185  4C 3F C2           JMP   LAB_XERR          ; go do error #X, then warm start
04354    
04355    ; perform DEF
04356    
04357    LAB_DEF
04358    D188  20 B9 D1           JSR   LAB_200B          ; check FNx syntax
04359    D18B  85 9C              STA   func_l            ; save function pointer low byte
04360    D18D  84 9D              STY   func_h            ; save function pointer high byte
04361    D18F  20 7E D1           JSR   LAB_CKRN          ; check not Direct (back here if ok)
04362    D192  20 00 CD           JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
04363    D195  A9 80              LDA   #$80              ; set flag for FNx
04364    D197  85 61              STA   Sufnxf            ; save subscript/FNx flag
04365    D199  20 BE CE           JSR   LAB_GVAR          ; get (var) address
04366    D19C  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
04367    D19F  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
04368    D1A2  A9 C8              LDA   #TK_EQUAL         ; get = token
04369    D1A4  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
04370    D1A7  A5 96              LDA   Cvarah            ; get current var address high byte
04371    D1A9  48                 PHA                     ; push it
04372    D1AA  A5 95              LDA   Cvaral            ; get current var address low byte
04373    D1AC  48                 PHA                     ; push it
04374    D1AD  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
04375    D1AF  48                 PHA                     ; push it
04376    D1B0  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
04377    D1B2  48                 PHA                     ; push it
04378    D1B3  20 90 C7           JSR   LAB_DATA          ; go perform DATA
04379    D1B6  4C 28 D2           JMP   LAB_207A          ; put execute pointer and variable pointer into function
04380                                  ; and return
04381    
04382    ; check FNx syntax
04383    
04384    LAB_200B
04385    D1B9  A9 B5              LDA   #TK_FN            ; get FN" token
04386    D1BB  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
04387                                  ; return character after A
04388    D1BE  09 80              ORA   #$80              ; set FN flag bit
04389    D1C0  85 61              STA   Sufnxf            ; save FN flag so array variable test fails
04390    D1C2  20 C5 CE           JSR   LAB_1D12          ; search for FN variable
04391    D1C5  4C D6 CB           JMP   LAB_CTNM          ; check if source is numeric and return, else do type
04392                                  ; mismatch
04393    
04394                                  ; Evaluate FNx
04395    LAB_201E
04396    D1C8  20 B9 D1           JSR   LAB_200B          ; check FNx syntax
04397    D1CB  48                 PHA                     ; push function pointer low byte
04398    D1CC  98                 TYA                     ; copy function pointer high byte
04399    D1CD  48                 PHA                     ; push function pointer high byte
04400    D1CE  20 00 CD           JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
04401    D1D1  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
04402    D1D4  20 F5 CC           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
04403    D1D7  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
04404    D1DA  68                 PLA                     ; pop function pointer high byte
04405    D1DB  85 9D              STA   func_h            ; restore it
04406    D1DD  68                 PLA                     ; pop function pointer low byte
04407    D1DE  85 9C              STA   func_l            ; restore it
04408    D1E0  A2 20              LDX   #$20              ; error code $20 ("Undefined function" error)
04409    D1E2  A0 03              LDY   #$03              ; index to variable pointer high byte
04410    D1E4  B1 9C              LDA   (func_l),Y        ; get variable pointer high byte
04411    D1E6  F0 9D              BEQ   LAB_1FDB          ; if zero go do undefined function error
04412    
04413    D1E8  85 96              STA   Cvarah            ; save variable address high byte
04414    D1EA  88                 DEY                     ; index to variable address low byte
04415    D1EB  B1 9C              LDA   (func_l),Y        ; get variable address low byte
04416    D1ED  85 95              STA   Cvaral            ; save variable address low byte
04417    D1EF  AA                 TAX                     ; copy address low byte
04418    
04419                                  ; now stack the function variable value before use
04420    D1F0  C8                 INY                     ; index to mantissa_3
04421    LAB_2043
04422    D1F1  B1 95              LDA   (Cvaral),Y        ; get byte from variable
04423    D1F3  48                 PHA                     ; stack it
04424    D1F4  88                 DEY                     ; decrement index
04425    D1F5  10 FA              BPL   LAB_2043          ; loop until variable stacked
04426    
04427    D1F7  A4 96              LDY   Cvarah            ; get variable address high byte
04428    D1F9  20 BA D9           JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
04429                                  ; (function variable), return Y=0, always
04430    D1FC  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
04431    D1FE  48                 PHA                     ; push it
04432    D1FF  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
04433    D201  48                 PHA                     ; push it
04434    D202  B1 9C              LDA   (func_l),Y        ; get function execute pointer low byte
04435    D204  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
04436    D206  C8                 INY                     ; index to high byte
04437    D207  B1 9C              LDA   (func_l),Y        ; get function execute pointer high byte
04438    D209  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
04439    D20B  A5 96              LDA   Cvarah            ; get variable address high byte
04440    D20D  48                 PHA                     ; push it
04441    D20E  A5 95              LDA   Cvaral            ; get variable address low byte
04442    D210  48                 PHA                     ; push it
04443    D211  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
04444                                  ; else do type mismatch
04445    D214  68                 PLA                     ; pull variable address low byte
04446    D215  85 9C              STA   func_l            ; save variable address low byte
04447    D217  68                 PLA                     ; pull variable address high byte
04448    D218  85 9D              STA   func_h            ; save variable address high byte
04449    D21A  20 C2 00           JSR   LAB_GBYT          ; scan memory
04450    D21D  F0 03              BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
04451    
04452    D21F  4C 08 CD           JMP   LAB_SNER          ; else syntax error then warm start
04453    
04454    ; restore Bpntrl,Bpntrh and function variable from stack
04455    
04456    LAB_2074
04457    D222  68                 PLA                     ; pull BASIC execute pointer low byte
04458    D223  85 C3              STA   Bpntrl            ; restore BASIC execute pointer low byte
04459    D225  68                 PLA                     ; pull BASIC execute pointer high byte
04460    D226  85 C4              STA   Bpntrh            ; restore BASIC execute pointer high byte
04461    
04462    ; put execute pointer and variable pointer into function
04463    
04464    LAB_207A
04465    D228  A0 00              LDY   #$00              ; clear index
04466    D22A  68                 PLA                     ; pull BASIC execute pointer low byte
04467    D22B  91 9C              STA   (func_l),Y        ; save to function
04468    D22D  C8                 INY                     ; increment index
04469    D22E  68                 PLA                     ; pull BASIC execute pointer high byte
04470    D22F  91 9C              STA   (func_l),Y        ; save to function
04471    D231  C8                 INY                     ; increment index
04472    D232  68                 PLA                     ; pull current var address low byte
04473    D233  91 9C              STA   (func_l),Y        ; save to function
04474    D235  C8                 INY                     ; increment index
04475    D236  68                 PLA                     ; pull current var address high byte
04476    D237  91 9C              STA   (func_l),Y        ; save to function
04477    D239  60                 RTS
04478    
04479    ; perform STR$()
04480    
04481    LAB_STRS
04482    D23A  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
04483    D23D  20 A8 DB           JSR   LAB_296E          ; convert FAC1 to string
04484    D240  A9 F0              LDA   #<Decssp1         ; set result string low pointer
04485    D242  A0 00              LDY   #>Decssp1         ; set result string high pointer
04486    D244  F0 12              BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
04487    
04488    ; Do string vector
04489    ; copy des_pl/h to des_2l/h and make string space A bytes long
04490    
04491    LAB_209C
04492    D246  A6 AE              LDX   des_pl            ; get descriptor pointer low byte
04493    D248  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
04494    D24A  86 9E              STX   des_2l            ; save descriptor pointer low byte
04495    D24C  84 9F              STY   des_2h            ; save descriptor pointer high byte
04496    
04497    ; make string space A bytes long
04498    ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
04499    
04500    LAB_MSSP
04501    D24E  20 C3 D2           JSR   LAB_2115          ; make space in string memory for string A long
04502                                  ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
04503    D251  86 AD              STX   str_pl            ; save string pointer low byte
04504    D253  84 AE              STY   str_ph            ; save string pointer high byte
04505    D255  85 AC              STA   str_ln            ; save length
04506    D257  60                 RTS
04507    
04508    ; Scan, set up string
04509    ; print " terminated string to Sutill/Sutilh
04510    
04511    LAB_20AE
04512    D258  A2 22              LDX   #$22              ; set terminator to "
04513    D25A  86 5B              STX   Srchc             ; set search character (terminator 1)
04514    D25C  86 5C              STX   Asrch             ; set terminator 2
04515    
04516    ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
04517    ; source is AY
04518    
04519    LAB_20B4
04520    D25E  85 B8              STA   ssptr_l           ; store string start low byte
04521    D260  84 B9              STY   ssptr_h           ; store string start high byte
04522    D262  85 AD              STA   str_pl            ; save string pointer low byte
04523    D264  84 AE              STY   str_ph            ; save string pointer high byte
04524    D266  A0 FF              LDY   #$FF              ; set length to -1
04525    LAB_20BE
04526    D268  C8                 INY                     ; increment length
04527    D269  B1 B8              LDA   (ssptr_l),Y       ; get byte from string
04528    D26B  F0 0C              BEQ   LAB_20CF          ; exit loop if null byte [EOS]
04529    
04530    D26D  C5 5B              CMP   Srchc             ; compare with search character (terminator 1)
04531    D26F  F0 04              BEQ   LAB_20CB          ; branch if terminator
04532    
04533    D271  C5 5C              CMP   Asrch             ; compare with terminator 2
04534    D273  D0 F3              BNE   LAB_20BE          ; loop if not terminator 2
04535    
04536    LAB_20CB
04537    D275  C9 22              CMP   #$22              ; compare with "
04538    D277  F0 01              BEQ   LAB_20D0          ; branch if " (carry set if = !)
04539    
04540    LAB_20CF
04541    D279  18                 CLC                     ; clear carry for add (only if [EOL] terminated string)
04542    LAB_20D0
04543    D27A  84 AC              STY   str_ln            ; save length in FAC1 exponent
04544    D27C  98                 TYA                     ; copy length to A
04545    D27D  65 B8              ADC   ssptr_l           ; add string start low byte
04546    D27F  85 BA              STA   Sendl             ; save string end low byte
04547    D281  A6 B9              LDX   ssptr_h           ; get string start high byte
04548    D283  90 01              BCC   LAB_20DC          ; branch if no low byte overflow
04549    
04550    D285  E8                 INX                     ; else increment high byte
04551    LAB_20DC
04552    D286  86 BB              STX   Sendh             ; save string end high byte
04553    D288  A5 B9              LDA   ssptr_h           ; get string start high byte
04554    ; *** begin RAM above code / Ibuff above EhBASIC patch V2 ***
04555    ; *** replace
04556    ;      CMP   #>Ram_base        ; compare with start of program memory
04557    ;      BCS   LAB_RTST          ; branch if not in utility area
04558    ; *** with
04559    D28A  F0 04              BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
04560    D28C  C9 0B              CMP   #>Ibuffs          ; compare with location of input buffer page
04561    D28E  D0 0B              BNE   LAB_RTST          ; branch if not in utility area
04562    LAB_MVST      
04563    ; *** end   RAM above code / Ibuff above EhBASIC patch V2 ***
04564    
04565                                  ; string in utility area, move to string memory
04566    D290  98                 TYA                     ; copy length to A
04567    D291  20 46 D2           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
04568                                  ; long
04569    D294  A6 B8              LDX   ssptr_l           ; get string start low byte
04570    D296  A4 B9              LDY   ssptr_h           ; get string start high byte
04571    D298  20 39 D4           JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
04572    
04573    ; check for space on descriptor stack then ..
04574    ; put string address and length on descriptor stack and update stack pointers
04575    
04576    LAB_RTST
04577    D29B  A6 65              LDX   next_s            ; get string stack pointer
04578    D29D  E0 71              CPX   #des_sk+$09       ; compare with max+1
04579    D29F  D0 05              BNE   LAB_20F8          ; branch if space on string stack
04580    
04581                                  ; else do string too complex error
04582    D2A1  A2 1C              LDX   #$1C              ; error code $1C ("String too complex" error)
04583    LAB_20F5
04584    D2A3  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
04585    
04586    ; put string address and length on descriptor stack and update stack pointers
04587    
04588    LAB_20F8
04589    D2A6  A5 AC              LDA   str_ln            ; get string length
04590    D2A8  95 00              STA   PLUS_0,X          ; put on string stack
04591    D2AA  A5 AD              LDA   str_pl            ; get string pointer low byte
04592    D2AC  95 01              STA   PLUS_1,X          ; put on string stack
04593    D2AE  A5 AE              LDA   str_ph            ; get string pointer high byte
04594    D2B0  95 02              STA   PLUS_2,X          ; put on string stack
04595    D2B2  A0 00              LDY   #$00              ; clear Y
04596    D2B4  86 AE              STX   des_pl            ; save string descriptor pointer low byte
04597    D2B6  84 AF              STY   des_ph            ; save string descriptor pointer high byte (always $00)
04598    D2B8  88                 DEY                     ; Y = $FF
04599    D2B9  84 5F              STY   Dtypef            ; save data type flag, $FF=string
04600    D2BB  86 66              STX   last_sl           ; save old stack pointer (current top item)
04601    D2BD  E8                 INX                     ; update stack pointer
04602    D2BE  E8                 INX                     ; update stack pointer
04603    D2BF  E8                 INX                     ; update stack pointer
04604    D2C0  86 65              STX   next_s            ; save new top item value
04605    D2C2  60                 RTS
04606    
04607    ; Build descriptor
04608    ; make space in string memory for string A long
04609    ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
04610    
04611    LAB_2115
04612    D2C3  46 60              LSR   Gclctd            ; clear garbage collected flag (b7)
04613    
04614                                  ; make space for string A long
04615    LAB_2117
04616    D2C5  48                 PHA                     ; save string length
04617    D2C6  49 FF              EOR   #$FF              ; complement it
04618    D2C8  38                 SEC                     ; set carry for subtract (twos comp add)
04619    D2C9  65 81              ADC   Sstorl            ; add bottom of string space low byte (subtract length)
04620    D2CB  A4 82              LDY   Sstorh            ; get bottom of string space high byte
04621    D2CD  B0 01              BCS   LAB_2122          ; skip decrement if no underflow
04622    
04623    D2CF  88                 DEY                     ; decrement bottom of string space high byte
04624    LAB_2122
04625    D2D0  C4 80              CPY   Earryh            ; compare with array mem end high byte
04626    D2D2  90 11              BCC   LAB_2137          ; do out of memory error if less
04627    
04628    D2D4  D0 04              BNE   LAB_212C          ; if not = skip next test
04629    
04630    D2D6  C5 7F              CMP   Earryl            ; compare with array mem end low byte
04631    D2D8  90 0B              BCC   LAB_2137          ; do out of memory error if less
04632    
04633    LAB_212C
04634    D2DA  85 81              STA   Sstorl            ; save bottom of string space low byte
04635    D2DC  84 82              STY   Sstorh            ; save bottom of string space high byte
04636    D2DE  85 83              STA   Sutill            ; save string utility ptr low byte
04637    D2E0  84 84              STY   Sutilh            ; save string utility ptr high byte
04638    D2E2  AA                 TAX                     ; copy low byte to X
04639    D2E3  68                 PLA                     ; get string length back
04640    D2E4  60                 RTS
04641    
04642    LAB_2137
04643    D2E5  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
04644    D2E7  A5 60              LDA   Gclctd            ; get garbage collected flag
04645    D2E9  30 B8              BMI   LAB_20F5          ; if set then do error code X
04646    
04647    D2EB  20 F5 D2           JSR   LAB_GARB          ; else go do garbage collection
04648    D2EE  A9 80              LDA   #$80              ; flag for garbage collected
04649    D2F0  85 60              STA   Gclctd            ; set garbage collected flag
04650    D2F2  68                 PLA                     ; pull length
04651    D2F3  D0 D0              BNE   LAB_2117          ; go try again (loop always, length should never be = $00)
04652    
04653    ; garbage collection routine
04654    
04655    LAB_GARB
04656    D2F5  A6 85              LDX   Ememl             ; get end of mem low byte
04657    D2F7  A5 86              LDA   Ememh             ; get end of mem high byte
04658    
04659    ; re-run routine from last ending
04660    
04661    LAB_214B
04662    D2F9  86 81              STX   Sstorl            ; set string storage low byte
04663    D2FB  85 82              STA   Sstorh            ; set string storage high byte
04664    D2FD  A0 00              LDY   #$00              ; clear index
04665    D2FF  84 9D              STY   garb_h            ; clear working pointer high byte (flag no strings to move)
04666    ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
04667    ; *** add
04668    D301  84 9C              STY   garb_l            ; clear working pointer low byte (flag no strings to move)
04669    ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
04670    D303  A5 7F              LDA   Earryl            ; get array mem end low byte
04671    D305  A6 80              LDX   Earryh            ; get array mem end high byte
04672    D307  85 AA              STA   Histrl            ; save as highest string low byte
04673    D309  86 AB              STX   Histrh            ; save as highest string high byte
04674    D30B  A9 68              LDA   #des_sk           ; set descriptor stack pointer
04675    D30D  85 71              STA   ut1_pl            ; save descriptor stack pointer low byte
04676    D30F  84 72              STY   ut1_ph            ; save descriptor stack pointer high byte ($00)
04677    LAB_2161
04678    D311  C5 65              CMP   next_s            ; compare with descriptor stack pointer
04679    D313  F0 05              BEQ   LAB_216A          ; branch if =
04680    
04681    D315  20 7B D3           JSR   LAB_21D7          ; go garbage collect descriptor stack
04682    D318  F0 F7              BEQ   LAB_2161          ; loop always
04683    
04684                                  ; done stacked strings, now do string vars
04685    LAB_216A
04686    D31A  06 A0              ASL   g_step            ; set step size = $06
04687    D31C  A5 7B              LDA   Svarl             ; get start of vars low byte
04688    D31E  A6 7C              LDX   Svarh             ; get start of vars high byte
04689    D320  85 71              STA   ut1_pl            ; save as pointer low byte
04690    D322  86 72              STX   ut1_ph            ; save as pointer high byte
04691    LAB_2176
04692    D324  E4 7E              CPX   Sarryh            ; compare start of arrays high byte
04693    D326  D0 04              BNE   LAB_217E          ; branch if no high byte match
04694    
04695    D328  C5 7D              CMP   Sarryl            ; else compare start of arrays low byte
04696    D32A  F0 05              BEQ   LAB_2183          ; branch if = var mem end
04697    
04698    LAB_217E
04699    D32C  20 75 D3           JSR   LAB_21D1          ; go garbage collect strings
04700    D32F  F0 F3              BEQ   LAB_2176          ; loop always
04701    
04702                                  ; done string vars, now do string arrays
04703    LAB_2183
04704    D331  85 A4              STA   Nbendl            ; save start of arrays low byte as working pointer
04705    D333  86 A5              STX   Nbendh            ; save start of arrays high byte as working pointer
04706    D335  A9 04              LDA   #$04              ; set step size
04707    D337  85 A0              STA   g_step            ; save step size
04708    LAB_218B
04709    D339  A5 A4              LDA   Nbendl            ; get pointer low byte
04710    D33B  A6 A5              LDX   Nbendh            ; get pointer high byte
04711    LAB_218F
04712    D33D  E4 80              CPX   Earryh            ; compare with array mem end high byte
04713    D33F  D0 04              BNE   LAB_219A          ; branch if not at end
04714    
04715    D341  C5 7F              CMP   Earryl            ; else compare with array mem end low byte
04716    D343  F0 75              BEQ   LAB_2216          ; tidy up and exit if at end
04717    
04718    LAB_219A
04719    D345  85 71              STA   ut1_pl            ; save pointer low byte
04720    D347  86 72              STX   ut1_ph            ; save pointer high byte
04721    D349  A0 02              LDY   #$02              ; set index
04722    D34B  B1 71              LDA   (ut1_pl),Y        ; get array size low byte
04723    D34D  65 A4              ADC   Nbendl            ; add start of this array low byte
04724    D34F  85 A4              STA   Nbendl            ; save start of next array low byte
04725    D351  C8                 INY                     ; increment index
04726    D352  B1 71              LDA   (ut1_pl),Y        ; get array size high byte
04727    D354  65 A5              ADC   Nbendh            ; add start of this array high byte
04728    D356  85 A5              STA   Nbendh            ; save start of next array high byte
04729    D358  A0 01              LDY   #$01              ; set index
04730    D35A  B1 71              LDA   (ut1_pl),Y        ; get name second byte
04731    D35C  10 DB              BPL   LAB_218B          ; skip if not string array
04732    
04733    ; was string array so ..
04734    
04735    D35E  A0 04              LDY   #$04              ; set index
04736    D360  B1 71              LDA   (ut1_pl),Y        ; get # of dimensions
04737    D362  0A                 ASL                     ; *2
04738    D363  69 05              ADC   #$05              ; +5 (array header size)
04739    D365  20 AD D3           JSR   LAB_2208          ; go set up for first element
04740    LAB_21C4
04741    D368  E4 A5              CPX   Nbendh            ; compare with start of next array high byte
04742    D36A  D0 04              BNE   LAB_21CC          ; branch if <> (go do this array)
04743    
04744    D36C  C5 A4              CMP   Nbendl            ; else compare element pointer low byte with next array
04745                                  ; low byte
04746    D36E  F0 CD              BEQ   LAB_218F          ; if equal then go do next array
04747    
04748    LAB_21CC
04749    D370  20 7B D3           JSR   LAB_21D7          ; go defrag array strings
04750    D373  F0 F3              BEQ   LAB_21C4          ; go do next array string (loop always)
04751    
04752    ; defrag string variables
04753    ; enter with XA = variable pointer
04754    ; return with XA = next variable pointer
04755    
04756    LAB_21D1
04757    D375  C8                 INY                     ; increment index (Y was $00)
04758    D376  B1 71              LDA   (ut1_pl),Y        ; get var name byte 2
04759    D378  10 30              BPL   LAB_2206          ; if not string, step pointer to next var and return
04760    
04761    D37A  C8                 INY                     ; else increment index
04762    LAB_21D7
04763    D37B  B1 71              LDA   (ut1_pl),Y        ; get string length
04764    D37D  F0 2B              BEQ   LAB_2206          ; if null, step pointer to next string and return
04765    
04766    D37F  C8                 INY                     ; else increment index
04767    D380  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte
04768    D382  AA                 TAX                     ; copy to X
04769    D383  C8                 INY                     ; increment index
04770    D384  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte
04771    D386  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
04772    D388  90 06              BCC   LAB_21EC          ; branch if less
04773    
04774    D38A  D0 1E              BNE   LAB_2206          ; if greater, step pointer to next string and return
04775    
04776                                  ; high bytes were = so compare low bytes
04777    D38C  E4 81              CPX   Sstorl            ; compare bottom of string space low byte
04778    D38E  B0 1A              BCS   LAB_2206          ; if >=, step pointer to next string and return
04779    
04780                                  ; string pointer is < string storage pointer (pos in mem)
04781    LAB_21EC
04782    D390  C5 AB              CMP   Histrh            ; compare to highest string high byte
04783    D392  90 17              BCC   LAB_2207          ; if <, step pointer to next string and return
04784    
04785    D394  D0 04              BNE   LAB_21F6          ; if > update pointers, step to next and return
04786    
04787                                  ; high bytes were = so compare low bytes
04788    D396  E4 AA              CPX   Histrl            ; compare to highest string low byte
04789    D398  90 11              BCC   LAB_2207          ; if <, step pointer to next string and return
04790    
04791                                  ; string is in string memory space
04792    LAB_21F6
04793    D39A  86 AA              STX   Histrl            ; save as new highest string low byte
04794    D39C  85 AB              STA   Histrh            ; save as new highest string high byte
04795    D39E  A5 71              LDA   ut1_pl            ; get start of vars(descriptors) low byte
04796    D3A0  A6 72              LDX   ut1_ph            ; get start of vars(descriptors) high byte
04797    D3A2  85 9C              STA   garb_l            ; save as working pointer low byte
04798    D3A4  86 9D              STX   garb_h            ; save as working pointer high byte
04799    D3A6  88                 DEY                     ; decrement index DIFFERS
04800    D3A7  88                 DEY                     ; decrement index (should point to descriptor start)
04801    D3A8  84 A2              STY   g_indx            ; save index pointer
04802    
04803                                  ; step pointer to next string
04804    LAB_2206
04805    D3AA  18                 CLC                     ; clear carry for add
04806    LAB_2207
04807    D3AB  A5 A0              LDA   g_step            ; get step size
04808    LAB_2208
04809    D3AD  65 71              ADC   ut1_pl            ; add pointer low byte
04810    D3AF  85 71              STA   ut1_pl            ; save pointer low byte
04811    D3B1  90 02              BCC   LAB_2211          ; branch if no overflow
04812    
04813    D3B3  E6 72              INC   ut1_ph            ; else increment high byte
04814    LAB_2211
04815    D3B5  A6 72              LDX   ut1_ph            ; get pointer high byte
04816    D3B7  A0 00              LDY   #$00              ; clear Y
04817    D3B9  60                 RTS
04818    
04819    ; search complete, now either exit or set-up and move string
04820    
04821    LAB_2216
04822    D3BA  C6 A0              DEC   g_step            ; decrement step size (now $03 for descriptor stack)
04823    ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
04824    ; *** replace
04825    ;      LDX   garb_h            ; get string to move high byte
04826    ; *** with
04827    D3BC  A5 9D              LDA   garb_h            ; any string to move?
04828    D3BE  05 9C              ORA   garb_l
04829    ; *** end   patch  2.22p5.5  garbage collection may overlap temporary strings
04830    D3C0  F0 F3              BEQ   LAB_2211          ; exit if nothing to move
04831    
04832    D3C2  A4 A2              LDY   g_indx            ; get index byte back (points to descriptor)
04833    D3C4  18                 CLC                     ; clear carry for add
04834    D3C5  B1 9C              LDA   (garb_l),Y        ; get string length
04835    D3C7  65 AA              ADC   Histrl            ; add highest string low byte
04836    D3C9  85 A6              STA   Obendl            ; save old block end low pointer
04837    D3CB  A5 AB              LDA   Histrh            ; get highest string high byte
04838    D3CD  69 00              ADC   #$00              ; add any carry
04839    D3CF  85 A7              STA   Obendh            ; save old block end high byte
04840    D3D1  A5 81              LDA   Sstorl            ; get bottom of string space low byte
04841    D3D3  A6 82              LDX   Sstorh            ; get bottom of string space high byte
04842    D3D5  85 A4              STA   Nbendl            ; save new block end low byte
04843    D3D7  86 A5              STX   Nbendh            ; save new block end high byte
04844    D3D9  20 C8 C1           JSR   LAB_11D6          ; open up space in memory, don't set array end
04845    D3DC  A4 A2              LDY   g_indx            ; get index byte
04846    D3DE  C8                 INY                     ; point to descriptor low byte
04847    D3DF  A5 A4              LDA   Nbendl            ; get string pointer low byte
04848    D3E1  91 9C              STA   (garb_l),Y        ; save new string pointer low byte
04849    D3E3  AA                 TAX                     ; copy string pointer low byte
04850    D3E4  E6 A5              INC   Nbendh            ; correct high byte (move sets high byte -1)
04851    D3E6  A5 A5              LDA   Nbendh            ; get new string pointer high byte
04852    D3E8  C8                 INY                     ; point to descriptor high byte
04853    D3E9  91 9C              STA   (garb_l),Y        ; save new string pointer high byte
04854    D3EB  4C F9 D2           JMP   LAB_214B          ; re-run routine from last ending
04855                                  ; (but don't collect this string)
04856    
04857    ; concatenate
04858    ; add strings, string 1 is in descriptor des_pl, string 2 is in line
04859    
04860    LAB_224D
04861    D3EE  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
04862    D3F0  48                 PHA                     ; put on stack
04863    D3F1  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
04864    D3F3  48                 PHA                     ; put on stack
04865    ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
04866    ; *** add extra label to verify originating function
04867    LAB_224Da
04868    ; *** end patch    2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
04869    D3F4  20 D3 CC           JSR   LAB_GVAL          ; get value from line
04870    D3F7  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
04871    D3FA  68                 PLA                     ; get descriptor pointer low byte back
04872    D3FB  85 B8              STA   ssptr_l           ; set pointer low byte
04873    D3FD  68                 PLA                     ; get descriptor pointer high byte back
04874    D3FE  85 B9              STA   ssptr_h           ; set pointer high byte
04875    D400  A0 00              LDY   #$00              ; clear index
04876    D402  B1 B8              LDA   (ssptr_l),Y       ; get length_1 from descriptor
04877    D404  18                 CLC                     ; clear carry for add
04878    D405  71 AE              ADC   (des_pl),Y        ; add length_2
04879    D407  90 05              BCC   LAB_226D          ; branch if no overflow
04880    
04881    D409  A2 1A              LDX   #$1A              ; else set error code $1A ("String too long" error)
04882    D40B  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
04883    
04884    LAB_226D
04885    D40E  20 46 D2           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
04886                                  ; long
04887    D411  20 2B D4           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
04888    D414  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
04889    D416  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
04890    D418  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
04891                                  ; returns with A = length, ut1_pl = pointer low byte,
04892                                  ; ut1_ph = pointer high byte
04893    D41B  20 3D D4           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
04894    D41E  A5 B8              LDA   ssptr_l           ;.set descriptor pointer low byte
04895    D420  A4 B9              LDY   ssptr_h           ;.set descriptor pointer high byte
04896    D422  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
04897                                  ; returns with A = length, X=ut1_pl=pointer low byte,
04898                                  ; Y=ut1_ph=pointer high byte
04899    D425  20 9B D2           JSR   LAB_RTST          ; check for space on descriptor stack then put string
04900                                  ; address and length on descriptor stack and update stack
04901                                  ; pointers
04902    D428  4C FE CB           JMP   LAB_1ADB          ;.continue evaluation
04903    
04904    ; copy string from descriptor (sdescr) to (Sutill)
04905    
04906    LAB_228A
04907    D42B  A0 00              LDY   #$00              ; clear index
04908    D42D  B1 B8              LDA   (sdescr),Y        ; get string length
04909    D42F  48                 PHA                     ; save on stack
04910    D430  C8                 INY                     ; increment index
04911    D431  B1 B8              LDA   (sdescr),Y        ; get source string pointer low byte
04912    D433  AA                 TAX                     ; copy to X
04913    D434  C8                 INY                     ; increment index
04914    D435  B1 B8              LDA   (sdescr),Y        ; get source string pointer high byte
04915    D437  A8                 TAY                     ; copy to Y
04916    D438  68                 PLA                     ; get length back
04917    
04918    ; store string A bytes long from YX to (Sutill)
04919    
04920    LAB_2298
04921    D439  86 71              STX   ut1_pl            ; save source string pointer low byte
04922    D43B  84 72              STY   ut1_ph            ; save source string pointer high byte
04923    
04924    ; store string A bytes long from (ut1_pl) to (Sutill)
04925    
04926    LAB_229C
04927    D43D  AA                 TAX                     ; copy length to index (don't count with Y)
04928    D43E  F0 14              BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
04929    
04930    D440  A0 00              LDY   #$00              ; zero pointer (copy forward)
04931    LAB_22A0
04932    D442  B1 71              LDA   (ut1_pl),Y        ; get source byte
04933    D444  91 83              STA   (Sutill),Y        ; save destination byte
04934    
04935    D446  C8                 INY                     ; increment index
04936    D447  CA                 DEX                     ; decrement counter
04937    D448  D0 F8              BNE   LAB_22A0          ; loop while <> 0
04938    
04939    D44A  98                 TYA                     ; restore length from Y
04940    LAB_22A9
04941    D44B  18                 CLC                     ; clear carry for add
04942    D44C  65 83              ADC   Sutill            ; add string utility ptr low byte
04943    D44E  85 83              STA   Sutill            ; save string utility ptr low byte
04944    D450  90 02              BCC   LAB_22B2          ; branch if no carry
04945    
04946    D452  E6 84              INC   Sutilh            ; else increment string utility ptr high byte
04947    LAB_22B2
04948    D454  60                 RTS
04949    
04950    ; evaluate string
04951    
04952    LAB_EVST
04953    D455  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
04954    
04955    ; pop string off descriptor stack, or from top of string space
04956    ; returns with A = length, X=pointer low byte, Y=pointer high byte
04957    
04958    LAB_22B6
04959    D458  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
04960    D45A  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
04961    
04962    ; pop (YA) descriptor off stack or from top of string space
04963    ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
04964    
04965    LAB_22BA
04966    D45C  85 71              STA   ut1_pl            ; save descriptor pointer low byte
04967    D45E  84 72              STY   ut1_ph            ; save descriptor pointer high byte
04968    D460  20 8D D4           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
04969    D463  08                 PHP                     ; save status flags
04970    D464  A0 00              LDY   #$00              ; clear index
04971    D466  B1 71              LDA   (ut1_pl),Y        ; get length from string descriptor
04972    D468  48                 PHA                     ; put on stack
04973    D469  C8                 INY                     ; increment index
04974    D46A  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
04975    D46C  AA                 TAX                     ; copy to X
04976    D46D  C8                 INY                     ; increment index
04977    D46E  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
04978    D470  A8                 TAY                     ; copy to Y
04979    D471  68                 PLA                     ; get string length back
04980    D472  28                 PLP                     ; restore status
04981    D473  D0 13              BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
04982    
04983    D475  C4 82              CPY   Sstorh            ; compare bottom of string space high byte
04984    D477  D0 0F              BNE   LAB_22E6          ; branch if <>
04985    
04986    D479  E4 81              CPX   Sstorl            ; else compare bottom of string space low byte
04987    D47B  D0 0B              BNE   LAB_22E6          ; branch if <>
04988    
04989    D47D  48                 PHA                     ; save string length
04990    D47E  18                 CLC                     ; clear carry for add
04991    D47F  65 81              ADC   Sstorl            ; add bottom of string space low byte
04992    D481  85 81              STA   Sstorl            ; save bottom of string space low byte
04993    D483  90 02              BCC   LAB_22E5          ; skip increment if no overflow
04994    
04995    D485  E6 82              INC   Sstorh            ; increment bottom of string space high byte
04996    LAB_22E5
04997    D487  68                 PLA                     ; restore string length
04998    LAB_22E6
04999    D488  86 71              STX   ut1_pl            ; save string pointer low byte
05000    D48A  84 72              STY   ut1_ph            ; save string pointer high byte
05001    D48C  60                 RTS
05002    
05003    ; clean descriptor stack, YA = pointer
05004    ; checks if AY is on the descriptor stack, if so does a stack discard
05005    
05006    LAB_22EB
05007    D48D  C4 67              CPY   last_sh           ; compare pointer high byte
05008    D48F  D0 0C              BNE   LAB_22FB          ; exit if <>
05009    
05010    D491  C5 66              CMP   last_sl           ; compare pointer low byte
05011    D493  D0 08              BNE   LAB_22FB          ; exit if <>
05012    
05013    D495  85 65              STA   next_s            ; save descriptor stack pointer
05014    D497  E9 03              SBC   #$03              ; -3
05015    D499  85 66              STA   last_sl           ; save low byte -3
05016    D49B  A0 00              LDY   #$00              ; clear high byte
05017    LAB_22FB
05018    D49D  60                 RTS
05019    
05020    ; perform CHR$()
05021    
05022    LAB_CHRS
05023    D49E  20 A9 D5           JSR   LAB_EVBY          ; evaluate byte expression, result in X
05024    D4A1  8A                 TXA                     ; copy to A
05025    D4A2  48                 PHA                     ; save character
05026    D4A3  A9 01              LDA   #$01              ; string is single byte
05027    D4A5  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
05028                                  ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
05029    D4A8  68                 PLA                     ; get character back
05030    D4A9  A0 00              LDY   #$00              ; clear index
05031    D4AB  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
05032    D4AD  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put string
05033                                  ; address and length on descriptor stack and update stack
05034                                  ; pointers
05035    
05036    ; perform LEFT$()
05037    
05038    LAB_LEFT
05039    D4B0  48                 PHA                     ; push byte parameter
05040    D4B1  20 11 D5           JSR   LAB_236F          ; pull string data and byte parameter from stack
05041                                  ; return pointer in des_2l/h, byte in A (and X), Y=0
05042    D4B4  D1 9E              CMP   (des_2l),Y        ; compare byte parameter with string length
05043    D4B6  98                 TYA                     ; clear A
05044    D4B7  F0 09              BEQ   LAB_2316          ; go do string copy (branch always)
05045    
05046    ; perform RIGHT$()
05047    
05048    LAB_RIGHT
05049    D4B9  48                 PHA                     ; push byte parameter
05050    D4BA  20 11 D5           JSR   LAB_236F          ; pull string data and byte parameter from stack
05051                                  ; return pointer in des_2l/h, byte in A (and X), Y=0
05052    D4BD  18                 CLC                     ; clear carry for add-1
05053    D4BE  F1 9E              SBC   (des_2l),Y        ; subtract string length
05054    D4C0  49 FF              EOR   #$FF              ; invert it (A=LEN(expression$)-l)
05055    
05056    LAB_2316
05057    D4C2  90 04              BCC   LAB_231C          ; branch if string length > byte parameter
05058    
05059    D4C4  B1 9E              LDA   (des_2l),Y        ; else make parameter = length
05060    D4C6  AA                 TAX                     ; copy to byte parameter copy
05061    D4C7  98                 TYA                     ; clear string start offset
05062    LAB_231C
05063    D4C8  48                 PHA                     ; save string start offset
05064    LAB_231D
05065    D4C9  8A                 TXA                     ; copy byte parameter (or string length if <)
05066    LAB_231E
05067    D4CA  48                 PHA                     ; save string length
05068    D4CB  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
05069                                  ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
05070    D4CE  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
05071    D4D0  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
05072    D4D2  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
05073                                  ; returns with A = length, X=ut1_pl=pointer low byte,
05074                                  ; Y=ut1_ph=pointer high byte
05075    D4D5  68                 PLA                     ; get string length back
05076    D4D6  A8                 TAY                     ; copy length to Y
05077    D4D7  68                 PLA                     ; get string start offset back
05078    D4D8  18                 CLC                     ; clear carry for add
05079    D4D9  65 71              ADC   ut1_pl            ; add start offset to string start pointer low byte
05080    D4DB  85 71              STA   ut1_pl            ; save string start pointer low byte
05081    D4DD  90 02              BCC   LAB_2335          ; branch if no overflow
05082    
05083    D4DF  E6 72              INC   ut1_ph            ; else increment string start pointer high byte
05084    LAB_2335
05085    D4E1  98                 TYA                     ; copy length to A
05086    D4E2  20 3D D4           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
05087    D4E5  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put string
05088                                  ; address and length on descriptor stack and update stack
05089                                  ; pointers
05090    
05091    ; perform MID$()
05092    
05093    LAB_MIDS
05094    D4E8  48                 PHA                     ; push byte parameter
05095    D4E9  A9 FF              LDA   #$FF              ; set default length = 255
05096    D4EB  85 AF              STA   mids_l            ; save default length
05097    D4ED  20 C2 00           JSR   LAB_GBYT          ; scan memory
05098    D4F0  C9 29              CMP   #')'              ; compare with ")"
05099    D4F2  F0 06              BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
05100    
05101    D4F4  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05102    D4F7  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
05103    LAB_2358
05104    D4FA  20 11 D5           JSR   LAB_236F          ; pull string data and byte parameter from stack
05105                                  ; return pointer in des_2l/h, byte in A (and X), Y=0
05106    D4FD  CA                 DEX                     ; decrement start index
05107    D4FE  8A                 TXA                     ; copy to A
05108    D4FF  48                 PHA                     ; save string start offset
05109    D500  18                 CLC                     ; clear carry for sub-1
05110    D501  A2 00              LDX   #$00              ; clear output string length
05111    D503  F1 9E              SBC   (des_2l),Y        ; subtract string length
05112    D505  B0 C2              BCS   LAB_231D          ; if start>string length go do null string
05113    
05114    D507  49 FF              EOR   #$FF              ; complement -length
05115    D509  C5 AF              CMP   mids_l            ; compare byte parameter
05116    D50B  90 BD              BCC   LAB_231E          ; if length>remaining string go do RIGHT$
05117    
05118    D50D  A5 AF              LDA   mids_l            ; get length byte
05119    D50F  B0 B9              BCS   LAB_231E          ; go do string copy (branch always)
05120    
05121    ; pull string data and byte parameter from stack
05122    ; return pointer in des_2l/h, byte in A (and X), Y=0
05123    
05124    LAB_236F
05125    D511  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
05126    D514  68                 PLA                     ; pull return address low byte (return address)
05127    D515  85 A2              STA   Fnxjpl            ; save functions jump vector low byte
05128    D517  68                 PLA                     ; pull return address high byte (return address)
05129    D518  85 A3              STA   Fnxjph            ; save functions jump vector high byte
05130    D51A  68                 PLA                     ; pull byte parameter
05131    D51B  AA                 TAX                     ; copy byte parameter to X
05132    D51C  68                 PLA                     ; pull string pointer low byte
05133    D51D  85 9E              STA   des_2l            ; save it
05134    D51F  68                 PLA                     ; pull string pointer high byte
05135    D520  85 9F              STA   des_2h            ; save it
05136    D522  A0 00              LDY   #$00              ; clear index
05137    D524  8A                 TXA                     ; copy byte parameter
05138    D525  F0 79              BEQ   LAB_23A8          ; if null do function call error then warm start
05139    
05140    D527  E6 A2              INC   Fnxjpl            ; increment function jump vector low byte
05141                                  ; (JSR pushes return addr-1. this is all very nice
05142                                  ; but will go tits up if either call is on a page
05143                                  ; boundary!)
05144    D529  6C A2 00           JMP   (Fnxjpl)          ; in effect, RTS
05145    
05146    ; perform LCASE$()
05147    
05148    LAB_LCASE
05149    D52C  20 55 D4           JSR   LAB_EVST          ; evaluate string
05150    D52F  85 AC              STA   str_ln            ; set string length
05151    D531  A8                 TAY                     ; copy length to Y
05152    D532  F0 38              BEQ   NoString          ; branch if null string
05153    
05154    D534  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=length,
05155                                  ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
05156    D537  86 AD              STX   str_pl            ; save string pointer low byte
05157    D539  84 AE              STY   str_ph            ; save string pointer high byte
05158    D53B  A8                 TAY                     ; get string length back
05159    
05160    LC_loop
05161    D53C  88                 DEY                     ; decrement index
05162    D53D  B1 71              LDA   (ut1_pl),Y        ; get byte from string
05163    D53F  20 36 CF           JSR   LAB_1D82          ; is character "A" to "Z"
05164    D542  90 02              BCC   NoUcase           ; branch if not upper case alpha
05165    
05166    D544  09 20              ORA   #$20              ; convert upper to lower case
05167    NoUcase
05168    D546  91 83              STA   (Sutill),Y        ; save byte back to string
05169    D548  98                 TYA                     ; test index
05170    D549  D0 F1              BNE   LC_loop           ; loop if not all done
05171    
05172    D54B  F0 1F              BEQ   NoString          ; tidy up and exit, branch always
05173    
05174    ; perform UCASE$()
05175    
05176    LAB_UCASE
05177    D54D  20 55 D4           JSR   LAB_EVST          ; evaluate string
05178    D550  85 AC              STA   str_ln            ; set string length
05179    D552  A8                 TAY                     ; copy length to Y
05180    D553  F0 17              BEQ   NoString          ; branch if null string
05181    
05182    D555  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=length,
05183                                  ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
05184    D558  86 AD              STX   str_pl            ; save string pointer low byte
05185    D55A  84 AE              STY   str_ph            ; save string pointer high byte
05186    D55C  A8                 TAY                     ; get string length back
05187    
05188    UC_loop
05189    D55D  88                 DEY                     ; decrement index
05190    D55E  B1 71              LDA   (ut1_pl),Y        ; get byte from string
05191    D560  20 32 CF           JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
05192    D563  90 02              BCC   NoLcase           ; branch if not alpha
05193    
05194    D565  29 DF              AND   #$DF              ; convert lower to upper case
05195    NoLcase
05196    D567  91 83              STA   (Sutill),Y        ; save byte back to string
05197    D569  98                 TYA                     ; test index
05198    D56A  D0 F1              BNE   UC_loop           ; loop if not all done
05199    
05200    NoString
05201    D56C  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put string
05202                                  ; address and length on descriptor stack and update stack
05203                                  ; pointers
05204    
05205    ; perform SADD()
05206    
05207    LAB_SADD
05208    D56F  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
05209    D572  20 BE CE           JSR   LAB_GVAR          ; get var address
05210    
05211    D575  20 F5 CC           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
05212    D578  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
05213    
05214    D57B  A0 02              LDY   #$02              ; index to string pointer high byte
05215    D57D  B1 95              LDA   (Cvaral),Y        ; get string pointer high byte
05216    D57F  AA                 TAX                     ; copy string pointer high byte to X
05217    D580  88                 DEY                     ; index to string pointer low byte
05218    D581  B1 95              LDA   (Cvaral),Y        ; get string pointer low byte
05219    D583  A8                 TAY                     ; copy string pointer low byte to Y
05220    D584  8A                 TXA                     ; copy string pointer high byte to A
05221    D585  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
05222    
05223    ; perform LEN()
05224    
05225    LAB_LENS
05226    D588  20 8E D5           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
05227    D58B  4C 7A D1           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
05228    
05229    ; evaluate string, get length in Y
05230    
05231    LAB_ESGL
05232    D58E  20 55 D4           JSR   LAB_EVST          ; evaluate string
05233    D591  A8                 TAY                     ; copy length to Y
05234    D592  60                 RTS
05235    
05236    ; perform ASC()
05237    
05238    LAB_ASC
05239    D593  20 8E D5           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
05240    D596  F0 08              BEQ   LAB_23A8          ; if null do function call error then warm start
05241    
05242    D598  A0 00              LDY   #$00              ; set index to first character
05243    D59A  B1 71              LDA   (ut1_pl),Y        ; get byte
05244    D59C  A8                 TAY                     ; copy to Y
05245    D59D  4C 7A D1           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
05246    
05247    ; do function call error then warm start
05248    
05249    LAB_23A8
05250    D5A0  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
05251    
05252    ; scan and get byte parameter
05253    
05254    LAB_SGBY
05255    D5A3  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
05256    
05257    ; get byte parameter
05258    
05259    LAB_GTBY
05260    D5A6  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05261                                  ; else do type mismatch
05262    
05263    ; evaluate byte expression, result in X
05264    
05265    LAB_EVBY
05266    D5A9  20 B6 CF           JSR   LAB_EVPI          ; evaluate integer expression (no check)
05267    
05268    D5AC  A4 AE              LDY   FAC1_2            ; get FAC1 mantissa2
05269    D5AE  D0 F0              BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
05270    
05271    D5B0  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
05272    D5B2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
05273    
05274    ; perform VAL()
05275    
05276    LAB_VAL
05277    D5B5  20 8E D5           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
05278    D5B8  D0 03              BNE   LAB_23C5          ; branch if not null string
05279    
05280                                  ; string was null so set result = $00
05281    D5BA  4C 63 D7           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
05282    
05283    LAB_23C5
05284    ; *** begin patch  2.22p5.7  VAL() may cause string variables to be trashed
05285    ; *** replace     
05286    ;      LDX   Bpntrl            ; get BASIC execute pointer low byte
05287    ;      LDY   Bpntrh            ; get BASIC execute pointer high byte
05288    ;      STX   Btmpl             ; save BASIC execute pointer low byte
05289    ;      STY   Btmph             ; save BASIC execute pointer high byte
05290    ;      LDX   ut1_pl            ; get string pointer low byte
05291    ;      STX   Bpntrl            ; save as BASIC execute pointer low byte
05292    ;      CLC                     ; clear carry
05293    ;      ADC   ut1_pl            ; add string length
05294    ;      STA   ut2_pl            ; save string end low byte
05295    ;      LDA   ut1_ph            ; get string pointer high byte
05296    ;      STA   Bpntrh            ; save as BASIC execute pointer high byte
05297    ;      ADC   #$00              ; add carry to high byte
05298    ;      STA   ut2_ph            ; save string end high byte
05299    ;      LDY   #$00              ; set index to $00
05300    ;      LDA   (ut2_pl),Y        ; get string end +1 byte
05301    ;      PHA                     ; push it
05302    ;      TYA                     ; clear A
05303    ;      STA   (ut2_pl),Y        ; terminate string with $00
05304    ;      JSR   LAB_GBYT          ; scan memory
05305    ;      JSR   LAB_2887          ; get FAC1 from string
05306    ;      PLA                     ; restore string end +1 byte
05307    ;      LDY   #$00              ; set index to zero
05308    ;      STA   (ut2_pl),Y        ; put string end byte back
05309    ; *** with
05310    D5BD  48                 PHA                     ; save length
05311    D5BE  C8                 INY                     ; string length +1
05312    D5BF  98                 TYA
05313    D5C0  20 4E D2           JSR   LAB_MSSP          ; allocate temp string +1 bytes long
05314    D5C3  68                 PLA                     ; get length back
05315    D5C4  20 3D D4           JSR   LAB_229C          ; copy string (ut1_pl) -> (Sutill) for A bytes
05316    D5C7  A9 00              LDA   #0                ; add delimiter to end of string
05317    D5C9  A8                 TAY
05318    D5CA  91 83              STA   (Sutill),Y
05319    D5CC  A6 C3              LDX   Bpntrl            ; save BASIC execute pointer low byte
05320    D5CE  A4 C4              LDY   Bpntrh
05321    D5D0  86 BA              STX   Btmpl
05322    D5D2  84 BB              STY   Btmph
05323    D5D4  A6 AD              LDX   str_pl            ; point to temporary string
05324    D5D6  A4 AE              LDY   str_ph
05325    D5D8  86 C3              STX   Bpntrl
05326    D5DA  84 C4              STY   Bpntrh
05327    D5DC  20 C2 00           JSR   LAB_GBYT          ; scan memory
05328    D5DF  20 B9 DA           JSR   LAB_2887          ; get FAC1 from string
05329    ; *** end patch    2.22p5.7  VAL() may cause string variables to be trashed
05330    
05331    ; restore BASIC execute pointer from temp (Btmpl/Btmph)
05332    
05333    LAB_23F3
05334    D5E2  A6 BA              LDX   Btmpl             ; get BASIC execute pointer low byte back
05335    D5E4  A4 BB              LDY   Btmph             ; get BASIC execute pointer high byte back
05336    D5E6  86 C3              STX   Bpntrl            ; save BASIC execute pointer low byte
05337    D5E8  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
05338    D5EA  60                 RTS
05339    
05340    ; get two parameters for POKE or WAIT
05341    
05342    LAB_GADB
05343    D5EB  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05344                                  ; else do type mismatch
05345    D5EE  20 04 D6           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
05346    
05347    ; scan for "," and get byte, else do Syntax error then warm start
05348    
05349    LAB_SCGB
05350    D5F1  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05351    D5F4  A5 12              LDA   Itemph            ; save temporary integer high byte
05352    D5F6  48                 PHA                     ; on stack
05353    D5F7  A5 11              LDA   Itempl            ; save temporary integer low byte
05354    D5F9  48                 PHA                     ; on stack
05355    D5FA  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
05356    D5FD  68                 PLA                     ; pull low byte
05357    D5FE  85 11              STA   Itempl            ; restore temporary integer low byte
05358    D600  68                 PLA                     ; pull high byte
05359    D601  85 12              STA   Itemph            ; restore temporary integer high byte
05360    D603  60                 RTS
05361    
05362    ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
05363    ; -ve and converts it into a right truncated integer in Itempl and Itemph
05364    
05365    ; save unsigned 16 bit integer part of FAC1 in temporary integer
05366    
05367    LAB_F2FX
05368    D604  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05369    D606  C9 98              CMP   #$98              ; compare with exponent = 2^24
05370    D608  B0 96              BCS   LAB_23A8          ; if >= do function call error then warm start
05371    
05372    LAB_F2FU
05373    D60A  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
05374    D60D  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05375    D60F  A4 AF              LDY   FAC1_3            ; get FAC1 mantissa3
05376    D611  84 11              STY   Itempl            ; save temporary integer low byte
05377    D613  85 12              STA   Itemph            ; save temporary integer high byte
05378    D615  60                 RTS
05379    
05380    ; perform PEEK()
05381    
05382    LAB_PEEK
05383    D616  20 04 D6           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
05384    D619  A2 00              LDX   #$00              ; clear index
05385    D61B  A1 11              LDA   (Itempl,X)        ; get byte via temporary integer (addr)
05386    D61D  A8                 TAY                     ; copy byte to Y
05387    D61E  4C 7A D1           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
05388    
05389    ; perform POKE
05390    
05391    LAB_POKE
05392    D621  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
05393    D624  8A                 TXA                     ; copy byte argument to A
05394    D625  A2 00              LDX   #$00              ; clear index
05395    D627  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
05396    D629  60                 RTS
05397    
05398    ; perform DEEK()
05399    
05400    LAB_DEEK
05401    D62A  20 04 D6           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
05402    D62D  A2 00              LDX   #$00              ; clear index
05403    D62F  A1 11              LDA   (Itempl,X)        ; PEEK low byte
05404    D631  A8                 TAY                     ; copy to Y
05405    D632  E6 11              INC   Itempl            ; increment pointer low byte
05406    D634  D0 02              BNE   Deekh             ; skip high increment if no rollover
05407    
05408    D636  E6 12              INC   Itemph            ; increment pointer high byte
05409    Deekh
05410    D638  A1 11              LDA   (Itempl,X)        ; PEEK high byte
05411    D63A  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
05412    
05413    ; perform DOKE
05414    
05415    LAB_DOKE
05416    D63D  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05417                                  ; else do type mismatch
05418    D640  20 04 D6           JSR   LAB_F2FX          ; convert floating-to-fixed
05419    
05420    D643  84 97              STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
05421    D645  85 98              STA   Frnxth            ; save pointer high byte
05422    
05423    D647  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05424    D64A  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05425                                  ; else do type mismatch
05426    D64D  20 04 D6           JSR   LAB_F2FX          ; convert floating-to-fixed
05427    
05428    D650  98                 TYA                     ; copy value low byte (float to fixed returns word in AY)
05429    D651  A2 00              LDX   #$00              ; clear index
05430    D653  81 97              STA   (Frnxtl,X)        ; POKE low byte
05431    D655  E6 97              INC   Frnxtl            ; increment pointer low byte
05432    D657  D0 02              BNE   Dokeh             ; skip high increment if no rollover
05433    
05434    D659  E6 98              INC   Frnxth            ; increment pointer high byte
05435    Dokeh
05436    D65B  A5 12              LDA   Itemph            ; get value high byte
05437    D65D  81 97              STA   (Frnxtl,X)        ; POKE high byte
05438    D65F  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
05439    
05440    ; perform SWAP
05441    
05442    LAB_SWAP
05443    D662  20 BE CE           JSR   LAB_GVAR          ; get var1 address
05444    D665  85 97              STA   Lvarpl            ; save var1 address low byte
05445    D667  84 98              STY   Lvarph            ; save var1 address high byte
05446    D669  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
05447    D66B  48                 PHA                     ; save data type flag
05448    
05449    D66C  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05450    D66F  20 BE CE           JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
05451    D672  68                 PLA                     ; pull var1 data type flag
05452    D673  45 5F              EOR   Dtypef            ; compare with var2 data type
05453    D675  10 10              BPL   SwapErr           ; exit if not both the same type
05454    
05455    D677  A0 03              LDY   #$03              ; four bytes to swap (either value or descriptor+1)
05456    SwapLp
05457    D679  B1 97              LDA   (Lvarpl),Y        ; get byte from var1
05458    D67B  AA                 TAX                     ; save var1 byte
05459    D67C  B1 95              LDA   (Cvaral),Y        ; get byte from var2
05460    D67E  91 97              STA   (Lvarpl),Y        ; save byte to var1
05461    D680  8A                 TXA                     ; restore var1 byte
05462    D681  91 95              STA   (Cvaral),Y        ; save byte to var2
05463    D683  88                 DEY                     ; decrement index
05464    D684  10 F3              BPL   SwapLp            ; loop until done
05465    
05466    D686  60                 RTS
05467    
05468    SwapErr
05469    D687  4C E2 CB           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
05470    
05471    ; perform CALL
05472    
05473    LAB_CALL
05474    D68A  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05475                                  ; else do type mismatch
05476    D68D  20 04 D6           JSR   LAB_F2FX          ; convert floating-to-fixed
05477    D690  A9 D6              LDA   #>CallExit        ; set return address high byte
05478    D692  48                 PHA                     ; put on stack
05479    D693  A9 98              LDA   #<CallExit-1      ; set return address low byte
05480    D695  48                 PHA                     ; put on stack
05481    D696  6C 11 00           JMP   (Itempl)          ; do indirect jump to user routine
05482    
05483    ; if the called routine exits correctly then it will return to here. this will then get
05484    ; the next byte for the interpreter and return
05485    
05486    CallExit
05487    D699  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
05488    
05489    ; perform WAIT
05490    
05491    LAB_WAIT
05492    D69C  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
05493    D69F  86 97              STX   Frnxtl            ; save byte
05494    D6A1  A2 00              LDX   #$00              ; clear mask
05495    D6A3  20 C2 00           JSR   LAB_GBYT          ; scan memory
05496    D6A6  F0 03              BEQ   LAB_2441          ; skip if no third argument
05497    
05498    D6A8  20 F1 D5           JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
05499    LAB_2441
05500    D6AB  86 98              STX   Frnxth            ; save EOR argument
05501    LAB_2445
05502    D6AD  B1 11              LDA   (Itempl),Y        ; get byte via temporary integer (addr)
05503    D6AF  45 98              EOR   Frnxth            ; EOR with second argument (mask)
05504    D6B1  25 97              AND   Frnxtl            ; AND with first argument (byte)
05505    D6B3  F0 F8              BEQ   LAB_2445          ; loop if result is zero
05506    
05507    LAB_244D
05508    D6B5  60                 RTS
05509    
05510    ; perform subtraction, FAC1 from (AY)
05511    
05512    LAB_2455
05513    D6B6  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
05514    
05515    ; perform subtraction, FAC1 from FAC2
05516    
05517    LAB_SUBTRACT
05518    D6B9  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
05519    D6BB  49 FF              EOR   #$FF              ; complement it
05520    D6BD  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05521    D6BF  45 B7              EOR   FAC2_s            ; EOR with FAC2 sign (b7)
05522    D6C1  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
05523    D6C3  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05524    D6C5  4C D4 D6           JMP   LAB_ADD           ; go add FAC2 to FAC1
05525    
05526    ; perform addition
05527    
05528    LAB_2467
05529    D6C8  20 ED D7           JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
05530    D6CB  90 4D              BCC   LAB_24A8          ;.go subtract mantissas
05531    
05532    ; add 0.5 to FAC1
05533    
05534    LAB_244E
05535    D6CD  A9 0A              LDA   #<LAB_2A96        ; set 0.5 pointer low byte
05536    D6CF  A0 E3              LDY   #>LAB_2A96        ; set 0.5 pointer high byte
05537    
05538    ; add (AY) to FAC1
05539    
05540    LAB_246C
05541    D6D1  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
05542    
05543    ; add FAC2 to FAC1
05544    
05545    LAB_ADD
05546    D6D4  D0 10              BNE   LAB_2474          ; branch if FAC1 was not zero
05547    
05548    ; copy FAC2 to FAC1
05549    
05550    LAB_279B
05551    D6D6  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
05552    
05553    ; save FAC1 sign and copy ABS(FAC2) to FAC1
05554    
05555    LAB_279D
05556    D6D8  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05557    D6DA  A2 04              LDX   #$04              ; 4 bytes to copy
05558    LAB_27A1
05559    D6DC  B5 B2              LDA   FAC1_o,X          ; get byte from FAC2,X
05560    D6DE  95 AB              STA   FAC1_e-1,X        ; save byte at FAC1,X
05561    D6E0  CA                 DEX                     ; decrement count
05562    D6E1  D0 F9              BNE   LAB_27A1          ; loop if not all done
05563    
05564    D6E3  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
05565    D6E5  60                 RTS
05566    
05567                                  ; FAC1 is non zero
05568    LAB_2474
05569    D6E6  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
05570    D6E8  86 A3              STX   FAC2_r            ; save as FAC2 rounding byte
05571    D6EA  A2 B3              LDX   #FAC2_e           ; set index to FAC2 exponent addr
05572    D6EC  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
05573    LAB_247C
05574    D6EE  A8                 TAY                     ; copy exponent
05575    D6EF  F0 C4              BEQ   LAB_244D          ; exit if zero
05576    
05577    D6F1  38                 SEC                     ; set carry for subtract
05578    D6F2  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
05579    D6F4  F0 24              BEQ   LAB_24A8          ; branch if = (go add mantissa)
05580    
05581    D6F6  90 12              BCC   LAB_2498          ; branch if <
05582    
05583                                  ; FAC2>FAC1
05584    D6F8  84 AC              STY   FAC1_e            ; save FAC1 exponent
05585    D6FA  A4 B7              LDY   FAC2_s            ; get FAC2 sign (b7)
05586    D6FC  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
05587    D6FE  49 FF              EOR   #$FF              ; complement A
05588    D700  69 00              ADC   #$00              ; +1 (twos complement, carry is set)
05589    D702  A0 00              LDY   #$00              ; clear Y
05590    D704  84 A3              STY   FAC2_r            ; clear FAC2 rounding byte
05591    D706  A2 AC              LDX   #FAC1_e           ; set index to FAC1 exponent addr
05592    D708  D0 04              BNE   LAB_249C          ; branch always
05593    
05594    LAB_2498
05595    D70A  A0 00              LDY   #$00              ; clear Y
05596    D70C  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
05597    LAB_249C
05598    D70E  C9 F9              CMP   #$F9              ; compare exponent diff with $F9
05599    D710  30 B6              BMI   LAB_2467          ; branch if range $79-$F8
05600    
05601    D712  A8                 TAY                     ; copy exponent difference to Y
05602    D713  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05603    D715  56 01              LSR   PLUS_1,X          ; shift FAC? mantissa1
05604    D717  20 04 D8           JSR   LAB_2592          ; shift FACX Y times right
05605    
05606                                  ; exponents are equal now do mantissa subtract
05607    LAB_24A8
05608    D71A  24 B8              BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
05609    D71C  10 4C              BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
05610    
05611    D71E  A0 AC              LDY   #FAC1_e           ; set index to FAC1 exponent addr
05612    D720  E0 B3              CPX   #FAC2_e           ; compare X to FAC2 exponent addr
05613    D722  F0 02              BEQ   LAB_24B4          ; branch if =
05614    
05615    D724  A0 B3              LDY   #FAC2_e           ; else set index to FAC2 exponent addr
05616    
05617                                  ; subtract smaller from bigger (take sign of bigger)
05618    LAB_24B4
05619    D726  38                 SEC                     ; set carry for subtract
05620    D727  49 FF              EOR   #$FF              ; ones complement A
05621    D729  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
05622    D72B  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
05623    D72D  B9 03 00           LDA   PLUS_3,Y          ; get FACY mantissa3
05624    D730  F5 03              SBC   PLUS_3,X          ; subtract FACX mantissa3
05625    D732  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
05626    D734  B9 02 00           LDA   PLUS_2,Y          ; get FACY mantissa2
05627    D737  F5 02              SBC   PLUS_2,X          ; subtract FACX mantissa2
05628    D739  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
05629    D73B  B9 01 00           LDA   PLUS_1,Y          ; get FACY mantissa1
05630    D73E  F5 01              SBC   PLUS_1,X          ; subtract FACX mantissa1
05631    D740  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
05632    
05633    ; do ABS and normalise FAC1
05634    
05635    LAB_24D0
05636    D742  B0 03              BCS   LAB_24D5          ; branch if number is +ve
05637    
05638    D744  20 A9 D7           JSR   LAB_2537          ; negate FAC1
05639    
05640    ; normalise FAC1
05641    
05642    LAB_24D5
05643    D747  A0 00              LDY   #$00              ; clear Y
05644    D749  98                 TYA                     ; clear A
05645    D74A  18                 CLC                     ; clear carry for add
05646    LAB_24D9
05647    D74B  A6 AD              LDX   FAC1_1            ; get FAC1 mantissa1
05648    D74D  D0 3E              BNE   LAB_251B          ; if not zero normalise FAC1
05649    
05650    D74F  A6 AE              LDX   FAC1_2            ; get FAC1 mantissa2
05651    D751  86 AD              STX   FAC1_1            ; save FAC1 mantissa1
05652    D753  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
05653    D755  86 AE              STX   FAC1_2            ; save FAC1 mantissa2
05654    D757  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
05655    D759  86 AF              STX   FAC1_3            ; save FAC1 mantissa3
05656    D75B  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
05657    D75D  69 08              ADC   #$08              ; add x to exponent offset
05658    D75F  C9 18              CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
05659    D761  D0 E8              BNE   LAB_24D9          ; loop if not max
05660    
05661    ; clear FAC1 exponent and sign
05662    
05663    LAB_24F1
05664    D763  A9 00              LDA   #$00              ; clear A
05665    LAB_24F3
05666    D765  85 AC              STA   FAC1_e            ; set FAC1 exponent
05667    
05668    ; save FAC1 sign
05669    
05670    LAB_24F5
05671    D767  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05672    D769  60                 RTS
05673    
05674    ; add FAC2 mantissa to FAC1 mantissa
05675    
05676    LAB_24F8
05677    D76A  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
05678    D76C  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
05679    D76E  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
05680    D770  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
05681    D772  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
05682    D774  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05683    D776  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
05684    D778  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
05685    D77A  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
05686    D77C  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
05687    D77E  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
05688    D780  B0 1A              BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
05689    
05690    D782  60                 RTS                     ; else just exit
05691    
05692    LAB_2511
05693    D783  69 01              ADC   #$01              ; add 1 to exponent offset
05694    D785  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
05695    D787  26 AF              ROL   FAC1_3            ; shift FAC1 mantissa3
05696    D789  26 AE              ROL   FAC1_2            ; shift FAC1 mantissa2
05697    D78B  26 AD              ROL   FAC1_1            ; shift FAC1 mantissa1
05698    
05699    ; normalise FAC1
05700    
05701    LAB_251B
05702    D78D  10 F4              BPL   LAB_2511          ; loop if not normalised
05703    
05704    D78F  38                 SEC                     ; set carry for subtract
05705    D790  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
05706    D792  B0 CF              BCS   LAB_24F1          ; branch if underflow (set result = $0)
05707    
05708    D794  49 FF              EOR   #$FF              ; complement exponent
05709    D796  69 01              ADC   #$01              ; +1 (twos complement)
05710    D798  85 AC              STA   FAC1_e            ; save FAC1 exponent
05711    
05712    ; test and normalise FAC1 for C=0/1
05713    
05714    LAB_2528
05715    D79A  90 0C              BCC   LAB_2536          ; exit if no overflow
05716    
05717    ; normalise FAC1 for C=1
05718    
05719    LAB_252A
05720    D79C  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
05721    D79E  F0 36              BEQ   LAB_2564          ; if zero do overflow error and warm start
05722    
05723    D7A0  66 AD              ROR   FAC1_1            ; shift FAC1 mantissa1
05724    D7A2  66 AE              ROR   FAC1_2            ; shift FAC1 mantissa2
05725    D7A4  66 AF              ROR   FAC1_3            ; shift FAC1 mantissa3
05726    D7A6  66 B9              ROR   FAC1_r            ; shift FAC1 rounding byte
05727    LAB_2536
05728    D7A8  60                 RTS
05729    
05730    ; negate FAC1
05731    
05732    LAB_2537
05733    D7A9  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
05734    D7AB  49 FF              EOR   #$FF              ; complement it
05735    D7AD  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05736    
05737    ; twos complement FAC1 mantissa
05738    
05739    LAB_253D
05740    D7AF  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
05741    D7B1  49 FF              EOR   #$FF              ; complement it
05742    D7B3  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
05743    D7B5  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05744    D7B7  49 FF              EOR   #$FF              ; complement it
05745    D7B9  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
05746    D7BB  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
05747    D7BD  49 FF              EOR   #$FF              ; complement it
05748    D7BF  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
05749    D7C1  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05750    D7C3  49 FF              EOR   #$FF              ; complement it
05751    D7C5  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
05752    D7C7  E6 B9              INC   FAC1_r            ; increment FAC1 rounding byte
05753    D7C9  D0 0A              BNE   LAB_2563          ; exit if no overflow
05754    
05755    ; increment FAC1 mantissa
05756    
05757    LAB_2559
05758    D7CB  E6 AF              INC   FAC1_3            ; increment FAC1 mantissa3
05759    D7CD  D0 06              BNE   LAB_2563          ; finished if no rollover
05760    
05761    D7CF  E6 AE              INC   FAC1_2            ; increment FAC1 mantissa2
05762    D7D1  D0 02              BNE   LAB_2563          ; finished if no rollover
05763    
05764    D7D3  E6 AD              INC   FAC1_1            ; increment FAC1 mantissa1
05765    LAB_2563
05766    D7D5  60                 RTS
05767    
05768    ; do overflow error (overflow exit)
05769    
05770    LAB_2564
05771    D7D6  A2 0A              LDX   #$0A              ; error code $0A ("Overflow" error)
05772    D7D8  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
05773    
05774    ; shift FCAtemp << A+8 times
05775    
05776    LAB_2569
05777    D7DB  A2 74              LDX   #FACt_1-1         ; set offset to FACtemp
05778    LAB_256B
05779    D7DD  B4 03              LDY   PLUS_3,X          ; get FACX mantissa3
05780    D7DF  84 B9              STY   FAC1_r            ; save as FAC1 rounding byte
05781    D7E1  B4 02              LDY   PLUS_2,X          ; get FACX mantissa2
05782    D7E3  94 03              STY   PLUS_3,X          ; save FACX mantissa3
05783    D7E5  B4 01              LDY   PLUS_1,X          ; get FACX mantissa1
05784    D7E7  94 02              STY   PLUS_2,X          ; save FACX mantissa2
05785    D7E9  A4 B2              LDY   FAC1_o            ; get FAC1 overflow byte
05786    D7EB  94 01              STY   PLUS_1,X          ; save FACX mantissa1
05787    
05788    ; shift FACX -A times right (> 8 shifts)
05789    
05790    LAB_257B
05791    D7ED  69 08              ADC   #$08              ; add 8 to shift count
05792    D7EF  30 EC              BMI   LAB_256B          ; go do 8 shift if still -ve
05793    
05794    D7F1  F0 EA              BEQ   LAB_256B          ; go do 8 shift if zero
05795    
05796    D7F3  E9 08              SBC   #$08              ; else subtract 8 again
05797    D7F5  A8                 TAY                     ; save count to Y
05798    D7F6  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05799    D7F8  B0 12              BCS   LAB_259A          ;.
05800    
05801    LAB_2588
05802    D7FA  16 01              ASL   PLUS_1,X          ; shift FACX mantissa1
05803    D7FC  90 02              BCC   LAB_258E          ; branch if +ve
05804    
05805    D7FE  F6 01              INC   PLUS_1,X          ; this sets b7 eventually
05806    LAB_258E
05807    D800  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
05808    D802  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
05809    
05810    ; shift FACX Y times right
05811    
05812    LAB_2592
05813    D804  76 02              ROR   PLUS_2,X          ; shift FACX mantissa2
05814    D806  76 03              ROR   PLUS_3,X          ; shift FACX mantissa3
05815    D808  6A                 ROR                     ; shift FACX rounding byte
05816    D809  C8                 INY                     ; increment exponent diff
05817    D80A  D0 EE              BNE   LAB_2588          ; branch if range adjust not complete
05818    
05819    LAB_259A
05820    D80C  18                 CLC                     ; just clear it
05821    D80D  60                 RTS
05822    
05823    ; perform LOG()
05824    
05825    LAB_LOG
05826    D80E  20 FC D9           JSR   LAB_27CA          ; test sign and zero
05827    D811  F0 02              BEQ   LAB_25C4          ; if zero do function call error then warm start
05828    
05829    D813  10 03              BPL   LAB_25C7          ; skip error if +ve
05830    
05831    LAB_25C4
05832    D815  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start (-ve)
05833    
05834    LAB_25C7
05835    D818  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05836    D81A  E9 7F              SBC   #$7F              ; normalise it
05837    D81C  48                 PHA                     ; save it
05838    D81D  A9 80              LDA   #$80              ; set exponent to zero
05839    D81F  85 AC              STA   FAC1_e            ; save FAC1 exponent
05840    D821  A9 8A              LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
05841    D823  A0 E2              LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
05842    D825  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
05843    D828  A9 8E              LDA   #<LAB_25B1        ; set root2 pointer low byte
05844    D82A  A0 E2              LDY   #>LAB_25B1        ; set root2 pointer high byte
05845    D82C  20 14 D9           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
05846    D82F  A9 01              LDA   #<LAB_259C        ; set 1 pointer low byte
05847    D831  A0 E3              LDY   #>LAB_259C        ; set 1 pointer high byte
05848    D833  20 B6 D6           JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
05849    D836  A9 7D              LDA   #<LAB_25A0        ; set pointer low byte to counter
05850    D838  A0 E2              LDY   #>LAB_25A0        ; set pointer high byte to counter
05851    D83A  20 64 DD           JSR   LAB_2B6E          ; ^2 then series evaluation
05852    D83D  A9 92              LDA   #<LAB_25B5        ; set -0.5 pointer low byte
05853    D83F  A0 E2              LDY   #>LAB_25B5        ; set -0.5 pointer high byte
05854    D841  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
05855    D844  68                 PLA                     ; restore FAC1 exponent
05856    D845  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
05857    D848  A9 96              LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
05858    D84A  A0 E2              LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
05859    
05860    ; do convert AY, FCA1*(AY)
05861    
05862    LAB_25FB
05863    D84C  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
05864    LAB_MULTIPLY
05865    D84F  F0 4C              BEQ   LAB_264C          ; exit if zero
05866    
05867    D851  20 C4 D8           JSR   LAB_2673          ; test and adjust accumulators
05868    D854  A9 00              LDA   #$00              ; clear A
05869    D856  85 75              STA   FACt_1            ; clear temp mantissa1
05870    D858  85 76              STA   FACt_2            ; clear temp mantissa2
05871    D85A  85 77              STA   FACt_3            ; clear temp mantissa3
05872    D85C  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05873    D85E  20 73 D8           JSR   LAB_2622          ; go do shift/add FAC2
05874    D861  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
05875    D863  20 73 D8           JSR   LAB_2622          ; go do shift/add FAC2
05876    D866  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05877    D868  20 73 D8           JSR   LAB_2622          ; go do shift/add FAC2
05878    D86B  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
05879    D86D  20 79 D8           JSR   LAB_2627          ; go do shift/add FAC2
05880    D870  4C 81 D9           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
05881    
05882    LAB_2622
05883    D873  D0 04              BNE   LAB_2627          ; branch if byte <> zero
05884    ; *** begin patch  2.22p5.6  floating point multiply rounding bug
05885    ; *** replace
05886    ;      JMP   LAB_2569          ; shift FCAtemp << A+8 times
05887    ;
05888    ;                              ; else do shift and add
05889    ;LAB_2627
05890    ;      LSR                     ; shift byte
05891    ;      ORA   #$80              ; set top bit (mark for 8 times)
05892    ; *** with
05893    D875  38                 SEC
05894    D876  4C DB D7           JMP   LAB_2569          ; shift FACtemp << A+8 times
05895    
05896                                  ; else do shift and add
05897    LAB_2627
05898    D879  38                 SEC                     ; set top bit (mark for 8 times)
05899    D87A  6A                 ROR
05900    ; *** end patch    2.22p5.6  floating point multiply rounding bug
05901    LAB_262A
05902    D87B  A8                 TAY                     ; copy result
05903    D87C  90 13              BCC   LAB_2640          ; skip next if bit was zero
05904    
05905    D87E  18                 CLC                     ; clear carry for add
05906    D87F  A5 77              LDA   FACt_3            ; get temp mantissa3
05907    D881  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
05908    D883  85 77              STA   FACt_3            ; save temp mantissa3
05909    D885  A5 76              LDA   FACt_2            ; get temp mantissa2
05910    D887  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
05911    D889  85 76              STA   FACt_2            ; save temp mantissa2
05912    D88B  A5 75              LDA   FACt_1            ; get temp mantissa1
05913    D88D  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
05914    D88F  85 75              STA   FACt_1            ; save temp mantissa1
05915    LAB_2640
05916    D891  66 75              ROR   FACt_1            ; shift temp mantissa1
05917    D893  66 76              ROR   FACt_2            ; shift temp mantissa2
05918    D895  66 77              ROR   FACt_3            ; shift temp mantissa3
05919    D897  66 B9              ROR   FAC1_r            ; shift temp rounding byte
05920    D899  98                 TYA                     ; get byte back
05921    D89A  4A                 LSR                     ; shift byte
05922    D89B  D0 DE              BNE   LAB_262A          ; loop if all bits not done
05923    
05924    LAB_264C
05925    D89D  60                 RTS
05926    
05927    ; unpack memory (AY) into FAC2
05928    
05929    LAB_264D
05930    D89E  85 71              STA   ut1_pl            ; save pointer low byte
05931    D8A0  84 72              STY   ut1_ph            ; save pointer high byte
05932    D8A2  A0 03              LDY   #$03              ; 4 bytes to get (0-3)
05933    D8A4  B1 71              LDA   (ut1_pl),Y        ; get mantissa3
05934    D8A6  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
05935    D8A8  88                 DEY                     ; decrement index
05936    D8A9  B1 71              LDA   (ut1_pl),Y        ; get mantissa2
05937    D8AB  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
05938    D8AD  88                 DEY                     ; decrement index
05939    D8AE  B1 71              LDA   (ut1_pl),Y        ; get mantissa1+sign
05940    D8B0  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
05941    D8B2  45 B0              EOR   FAC1_s            ; EOR with FAC1 sign (b7)
05942    D8B4  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
05943    D8B6  A5 B7              LDA   FAC2_s            ; recover FAC2 sign (b7)
05944    D8B8  09 80              ORA   #$80              ; set 1xxx xxx (set normal bit)
05945    D8BA  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
05946    D8BC  88                 DEY                     ; decrement index
05947    D8BD  B1 71              LDA   (ut1_pl),Y        ; get exponent byte
05948    D8BF  85 B3              STA   FAC2_e            ; save FAC2 exponent
05949    D8C1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05950    D8C3  60                 RTS
05951    
05952    ; test and adjust accumulators
05953    
05954    LAB_2673
05955    D8C4  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
05956    LAB_2675
05957    D8C6  F0 1D              BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
05958    
05959    D8C8  18                 CLC                     ; clear carry for add
05960    D8C9  65 AC              ADC   FAC1_e            ; add FAC1 exponent
05961    D8CB  90 04              BCC   LAB_2680          ; branch if sum of exponents <$0100
05962    
05963    D8CD  30 31              BMI   LAB_269B          ; do overflow error
05964    
05965    D8CF  18                 CLC                     ; clear carry for the add
05966          .byte $2C               ; makes next line BIT $1410
05967    LAB_2680
05968    D8D1  10 12              BPL   LAB_2696          ; if +ve go handle underflow
05969    
05970    D8D3  69 80              ADC   #$80              ; adjust exponent
05971    D8D5  85 AC              STA   FAC1_e            ; save FAC1 exponent
05972    D8D7  D0 03              BNE   LAB_268B          ; branch if not zero
05973    
05974    D8D9  4C 67 D7           JMP   LAB_24F5          ; save FAC1 sign and return
05975    
05976    LAB_268B
05977    D8DC  A5 B8              LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
05978    D8DE  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05979    LAB_268F
05980    D8E0  60                 RTS
05981    
05982    ; handle overflow and underflow
05983    
05984    LAB_2690
05985    D8E1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
05986    D8E3  10 1B              BPL   LAB_269B          ; do overflow error
05987    
05988                                  ; handle underflow
05989    LAB_2696
05990    D8E5  68                 PLA                     ; pop return address low byte
05991    D8E6  68                 PLA                     ; pop return address high byte
05992    D8E7  4C 63 D7           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
05993    
05994    ; multiply by 10
05995    
05996    LAB_269E
05997    D8EA  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
05998    D8ED  AA                 TAX                     ; copy exponent (set the flags)
05999    D8EE  F0 F0              BEQ   LAB_268F          ; exit if zero
06000    
06001    D8F0  18                 CLC                     ; clear carry for add
06002    D8F1  69 02              ADC   #$02              ; add two to exponent (*4)
06003    D8F3  B0 0B              BCS   LAB_269B          ; do overflow error if > $FF
06004    
06005    D8F5  A2 00              LDX   #$00              ; clear byte
06006    D8F7  86 B8              STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
06007    D8F9  20 EE D6           JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
06008    D8FC  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*10)
06009    D8FE  D0 E0              BNE   LAB_268F          ; if non zero just do RTS
06010    
06011    LAB_269B
06012    D900  4C D6 D7           JMP   LAB_2564          ; do overflow error and warm start
06013    
06014    ; divide by 10
06015    
06016    LAB_26B9
06017    D903  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
06018    D906  A9 12              LDA   #<LAB_26B5        ; set pointer to 10d low addr
06019    D908  A0 E3              LDY   #>LAB_26B5        ; set pointer to 10d high addr
06020    D90A  A2 00              LDX   #$00              ; clear sign
06021    
06022    ; divide by (AY) (X=sign)
06023    
06024    LAB_26C2
06025    D90C  86 B8              STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
06026    D90E  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
06027    D911  4C 17 D9           JMP   LAB_DIVIDE        ; do FAC2/FAC1
06028    
06029                                  ; Perform divide-by
06030    ; convert AY and do (AY)/FAC1
06031    
06032    LAB_26CA
06033    D914  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
06034    
06035                                  ; Perform divide-into
06036    LAB_DIVIDE
06037    D917  F0 63              BEQ   LAB_2737          ; if zero go do /0 error
06038    
06039    D919  20 EC D9           JSR   LAB_27BA          ; round FAC1
06040    D91C  A9 00              LDA   #$00              ; clear A
06041    D91E  38                 SEC                     ; set carry for subtract
06042    D91F  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
06043    D921  85 AC              STA   FAC1_e            ; save FAC1 exponent
06044    D923  20 C4 D8           JSR   LAB_2673          ; test and adjust accumulators
06045    D926  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
06046    D928  F0 D6              BEQ   LAB_269B          ; if zero do overflow error
06047    
06048    D92A  A2 FF              LDX   #$FF              ; set index for pre increment
06049    D92C  A9 01              LDA   #$01              ; set bit to flag byte save
06050    LAB_26E4
06051    D92E  A4 B4              LDY   FAC2_1            ; get FAC2 mantissa1
06052    D930  C4 AD              CPY   FAC1_1            ; compare FAC1 mantissa1
06053    D932  D0 0A              BNE   LAB_26F4          ; branch if <>
06054    
06055    D934  A4 B5              LDY   FAC2_2            ; get FAC2 mantissa2
06056    D936  C4 AE              CPY   FAC1_2            ; compare FAC1 mantissa2
06057    D938  D0 04              BNE   LAB_26F4          ; branch if <>
06058    
06059    D93A  A4 B6              LDY   FAC2_3            ; get FAC2 mantissa3
06060    D93C  C4 AF              CPY   FAC1_3            ; compare FAC1 mantissa3
06061    LAB_26F4
06062    D93E  08                 PHP                     ; save FAC2-FAC1 compare status
06063    D93F  2A                 ROL                     ; shift the result byte
06064    D940  90 0E              BCC   LAB_2702          ; if no carry skip the byte save
06065    
06066    D942  A0 01              LDY   #$01              ; set bit to flag byte save
06067    D944  E8                 INX                     ; else increment the index to FACt
06068    D945  E0 02              CPX   #$02              ; compare with the index to FACt_3
06069    D947  30 04              BMI   LAB_2701          ; if not last byte just go save it
06070    
06071    D949  D0 28              BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
06072                                  ; return
06073    
06074    D94B  A0 40              LDY   #$40              ; set bit to flag byte save for the rounding byte
06075    LAB_2701
06076    D94D  95 75              STA   FACt_1,X          ; write result byte to FACt_1 + index
06077    D94F  98                 TYA                     ; copy the next save byte flag
06078    LAB_2702
06079    D950  28                 PLP                     ; restore FAC2-FAC1 compare status
06080    D951  90 14              BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
06081    
06082    D953  A8                 TAY                     ; save FAC2-FAC1 compare status
06083    D954  A5 B6              LDA   FAC2_3            ; get FAC2 mantissa3
06084    D956  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
06085    D958  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
06086    D95A  A5 B5              LDA   FAC2_2            ; get FAC2 mantissa2
06087    D95C  E5 AE              SBC   FAC1_2            ; subtract FAC1 mantissa2
06088    D95E  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
06089    D960  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
06090    D962  E5 AD              SBC   FAC1_1            ; subtract FAC1 mantissa1
06091    D964  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
06092    D966  98                 TYA                     ; restore FAC2-FAC1 compare status
06093    
06094                                  ; FAC2 = FAC2*2
06095    LAB_2704
06096    D967  06 B6              ASL   FAC2_3            ; shift FAC2 mantissa3
06097    D969  26 B5              ROL   FAC2_2            ; shift FAC2 mantissa2
06098    D96B  26 B4              ROL   FAC2_1            ; shift FAC2 mantissa1
06099    D96D  B0 CF              BCS   LAB_26F4          ; loop with no compare
06100    
06101    D96F  30 BD              BMI   LAB_26E4          ; loop with compare
06102    
06103    D971  10 CB              BPL   LAB_26F4          ; loop always with no compare
06104    
06105    ; do A<<6, save as FAC1 rounding byte, normalise and return
06106    
06107    LAB_272B
06108    D973  4A                 LSR                     ; shift b1 - b0 ..
06109    D974  6A                 ROR                     ; ..
06110    D975  6A                 ROR                     ; .. to b7 - b6
06111    D976  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
06112    D978  28                 PLP                     ; dump FAC2-FAC1 compare status
06113    D979  4C 81 D9           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
06114    
06115    ; do "Divide by zero" error
06116    
06117    LAB_2737
06118    D97C  A2 14              LDX   #$14              ; error code $14 ("Divide by zero" error)
06119    D97E  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
06120    
06121    ; copy temp to FAC1 and normalise
06122    
06123    LAB_273C
06124    D981  A5 75              LDA   FACt_1            ; get temp mantissa1
06125    D983  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06126    D985  A5 76              LDA   FACt_2            ; get temp mantissa2
06127    D987  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
06128    D989  A5 77              LDA   FACt_3            ; get temp mantissa3
06129    D98B  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
06130    D98D  4C 47 D7           JMP   LAB_24D5          ; normalise FAC1 and return
06131    
06132    ; unpack memory (AY) into FAC1
06133    
06134    LAB_UFAC
06135    D990  85 71              STA   ut1_pl            ; save pointer low byte
06136    D992  84 72              STY   ut1_ph            ; save pointer high byte
06137    D994  A0 03              LDY   #$03              ; 4 bytes to do
06138    D996  B1 71              LDA   (ut1_pl),Y        ; get last byte
06139    D998  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
06140    D99A  88                 DEY                     ; decrement index
06141    D99B  B1 71              LDA   (ut1_pl),Y        ; get last-1 byte
06142    D99D  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
06143    D99F  88                 DEY                     ; decrement index
06144    D9A0  B1 71              LDA   (ut1_pl),Y        ; get second byte
06145    D9A2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
06146    D9A4  09 80              ORA   #$80              ; set 1xxx xxxx (add normal bit)
06147    D9A6  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06148    D9A8  88                 DEY                     ; decrement index
06149    D9A9  B1 71              LDA   (ut1_pl),Y        ; get first byte (exponent)
06150    D9AB  85 AC              STA   FAC1_e            ; save FAC1 exponent
06151    D9AD  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
06152    D9AF  60                 RTS
06153    
06154    ; pack FAC1 into Adatal
06155    
06156    LAB_276E
06157    D9B0  A2 A4              LDX   #<Adatal          ; set pointer low byte
06158    LAB_2770
06159    D9B2  A0 00              LDY   #>Adatal          ; set pointer high byte
06160    D9B4  F0 04              BEQ   LAB_2778          ; pack FAC1 into (XY) and return
06161    
06162    ; pack FAC1 into (Lvarpl)
06163    
06164    LAB_PFAC
06165    D9B6  A6 97              LDX   Lvarpl            ; get destination pointer low byte
06166    D9B8  A4 98              LDY   Lvarph            ; get destination pointer high byte
06167    
06168    ; pack FAC1 into (XY)
06169    
06170    LAB_2778
06171    D9BA  20 EC D9           JSR   LAB_27BA          ; round FAC1
06172    D9BD  86 71              STX   ut1_pl            ; save pointer low byte
06173    D9BF  84 72              STY   ut1_ph            ; save pointer high byte
06174    D9C1  A0 03              LDY   #$03              ; set index
06175    D9C3  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
06176    D9C5  91 71              STA   (ut1_pl),Y        ; store in destination
06177    D9C7  88                 DEY                     ; decrement index
06178    D9C8  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
06179    D9CA  91 71              STA   (ut1_pl),Y        ; store in destination
06180    D9CC  88                 DEY                     ; decrement index
06181    D9CD  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06182    D9CF  09 7F              ORA   #$7F              ; set bits x111 1111
06183    D9D1  25 AD              AND   FAC1_1            ; AND in FAC1 mantissa1
06184    D9D3  91 71              STA   (ut1_pl),Y        ; store in destination
06185    D9D5  88                 DEY                     ; decrement index
06186    D9D6  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06187    D9D8  91 71              STA   (ut1_pl),Y        ; store in destination
06188    D9DA  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
06189    D9DC  60                 RTS
06190    
06191    ; round and copy FAC1 to FAC2
06192    
06193    LAB_27AB
06194    D9DD  20 EC D9           JSR   LAB_27BA          ; round FAC1
06195    
06196    ; copy FAC1 to FAC2
06197    
06198    LAB_27AE
06199    D9E0  A2 05              LDX   #$05              ; 5 bytes to copy
06200    LAB_27B0
06201    D9E2  B5 AB              LDA   FAC1_e-1,X        ; get byte from FAC1,X
06202    D9E4  95 B2              STA   FAC1_o,X          ; save byte at FAC2,X
06203    D9E6  CA                 DEX                     ; decrement count
06204    D9E7  D0 F9              BNE   LAB_27B0          ; loop if not all done
06205    
06206    D9E9  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
06207    LAB_27B9
06208    D9EB  60                 RTS
06209    
06210    ; round FAC1
06211    
06212    LAB_27BA
06213    D9EC  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06214    D9EE  F0 FB              BEQ   LAB_27B9          ; exit if zero
06215    
06216    D9F0  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
06217    D9F2  90 F7              BCC   LAB_27B9          ; exit if no overflow
06218    
06219    ; round FAC1 (no check)
06220    
06221    LAB_27C2
06222    D9F4  20 CB D7           JSR   LAB_2559          ; increment FAC1 mantissa
06223    D9F7  D0 F2              BNE   LAB_27B9          ; branch if no overflow
06224    
06225    D9F9  4C 9C D7           JMP   LAB_252A          ; normalise FAC1 for C=1 and return
06226    
06227    ; get FAC1 sign
06228    ; return A=FF,C=1/-ve A=01,C=0/+ve
06229    
06230    LAB_27CA
06231    D9FC  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06232    D9FE  F0 09              BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
06233    
06234    ; return A=FF,C=1/-ve A=01,C=0/+ve
06235    ; no = 0 check
06236    
06237    LAB_27CE
06238    DA00  A5 B0              LDA   FAC1_s            ; else get FAC1 sign (b7)
06239    
06240    ; return A=FF,C=1/-ve A=01,C=0/+ve
06241    ; no = 0 check, sign in A
06242    
06243    LAB_27D0
06244    DA02  2A                 ROL                     ; move sign bit to carry
06245    DA03  A9 FF              LDA   #$FF              ; set byte for -ve result
06246    DA05  B0 02              BCS   LAB_27D7          ; return if sign was set (-ve)
06247    
06248    DA07  A9 01              LDA   #$01              ; else set byte for +ve result
06249    LAB_27D7
06250    DA09  60                 RTS
06251    
06252    ; perform SGN()
06253    
06254    LAB_SGN
06255    DA0A  20 FC D9           JSR   LAB_27CA          ; get FAC1 sign
06256                                  ; return A=$FF/-ve A=$01/+ve
06257    ; save A as integer byte
06258    
06259    LAB_27DB
06260    DA0D  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06261    DA0F  A9 00              LDA   #$00              ; clear A
06262    DA11  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
06263    DA13  A2 88              LDX   #$88              ; set exponent
06264    
06265    ; set exp=X, clearFAC1 mantissa3 and normalise
06266    
06267    LAB_27E3
06268    DA15  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
06269    DA17  49 FF              EOR   #$FF              ; complement it
06270    DA19  2A                 ROL                     ; sign bit into carry
06271    
06272    ; set exp=X, clearFAC1 mantissa3 and normalise
06273    
06274    LAB_STFA
06275    DA1A  A9 00              LDA   #$00              ; clear A
06276    DA1C  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
06277    DA1E  86 AC              STX   FAC1_e            ; set FAC1 exponent
06278    DA20  85 B9              STA   FAC1_r            ; clear FAC1 rounding byte
06279    DA22  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
06280    DA24  4C 42 D7           JMP   LAB_24D0          ; do ABS and normalise FAC1
06281    
06282    ; perform ABS()
06283    
06284    LAB_ABS
06285    DA27  46 B0              LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
06286    DA29  60                 RTS
06287    
06288    ; compare FAC1 with (AY)
06289    ; returns A=$00 if FAC1 = (AY)
06290    ; returns A=$01 if FAC1 > (AY)
06291    ; returns A=$FF if FAC1 < (AY)
06292    
06293    LAB_27F8
06294    DA2A  85 73              STA   ut2_pl            ; save pointer low byte
06295    LAB_27FA
06296    DA2C  84 74              STY   ut2_ph            ; save pointer high byte
06297    DA2E  A0 00              LDY   #$00              ; clear index
06298    DA30  B1 73              LDA   (ut2_pl),Y        ; get exponent
06299    DA32  C8                 INY                     ; increment index
06300    DA33  AA                 TAX                     ; copy (AY) exponent to X
06301    DA34  F0 C6              BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
06302                                  ; A=FF,C=1/-ve A=01,C=0/+ve
06303    
06304    DA36  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
06305    DA38  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
06306    DA3A  30 C4              BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
06307                                  ; A=01,C=0/+ve and return
06308    
06309    DA3C  E4 AC              CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
06310    DA3E  D0 1A              BNE   LAB_2828          ; branch if different
06311    
06312    DA40  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
06313    DA42  09 80              ORA   #$80              ; normalise top bit
06314    DA44  C5 AD              CMP   FAC1_1            ; compare with FAC1 mantissa1
06315    DA46  D0 12              BNE   LAB_2828          ; branch if different
06316    
06317    DA48  C8                 INY                     ; increment index
06318    DA49  B1 73              LDA   (ut2_pl),Y        ; get mantissa2
06319    DA4B  C5 AE              CMP   FAC1_2            ; compare with FAC1 mantissa2
06320    DA4D  D0 0B              BNE   LAB_2828          ; branch if different
06321    
06322    DA4F  C8                 INY                     ; increment index
06323    DA50  A9 7F              LDA   #$7F              ; set for 1/2 value rounding byte
06324    DA52  C5 B9              CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
06325    DA54  B1 73              LDA   (ut2_pl),Y        ; get mantissa3
06326    DA56  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
06327    DA58  F0 28              BEQ   LAB_2850          ; exit if mantissa3 equal
06328    
06329    ; gets here if number <> FAC1
06330    
06331    LAB_2828
06332    DA5A  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06333    DA5C  90 02              BCC   LAB_282E          ; branch if FAC1 > (AY)
06334    
06335    DA5E  49 FF              EOR   #$FF              ; else toggle FAC1 sign
06336    LAB_282E
06337    DA60  4C 02 DA           JMP   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
06338    
06339    ; convert FAC1 floating-to-fixed
06340    
06341    LAB_2831
06342    DA63  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06343    DA65  F0 4A              BEQ   LAB_287F          ; if zero go clear FAC1 and return
06344    
06345    DA67  38                 SEC                     ; set carry for subtract
06346    DA68  E9 98              SBC   #$98              ; subtract maximum integer range exponent
06347    DA6A  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
06348    DA6C  10 09              BPL   LAB_2845          ; branch if FAC1 +ve
06349    
06350                                  ; FAC1 was -ve
06351    DA6E  AA                 TAX                     ; copy subtracted exponent
06352    DA6F  A9 FF              LDA   #$FF              ; overflow for -ve number
06353    DA71  85 B2              STA   FAC1_o            ; set FAC1 overflow byte
06354    DA73  20 AF D7           JSR   LAB_253D          ; twos complement FAC1 mantissa
06355    DA76  8A                 TXA                     ; restore subtracted exponent
06356    LAB_2845
06357    DA77  A2 AC              LDX   #FAC1_e           ; set index to FAC1
06358    DA79  C9 F9              CMP   #$F9              ; compare exponent result
06359    DA7B  10 06              BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
06360    
06361    DA7D  20 ED D7           JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
06362    DA80  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
06363    LAB_2850
06364    DA82  60                 RTS
06365    
06366    ; shift FAC1 A times right
06367    
06368    LAB_2851
06369    DA83  A8                 TAY                     ; copy shift count
06370    DA84  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06371    DA86  29 80              AND   #$80              ; mask sign bit only (x000 0000)
06372    DA88  46 AD              LSR   FAC1_1            ; shift FAC1 mantissa1
06373    DA8A  05 AD              ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
06374    DA8C  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06375    DA8E  20 04 D8           JSR   LAB_2592          ; shift FAC1 Y times right
06376    DA91  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
06377    DA93  60                 RTS
06378    
06379    ; perform INT()
06380    
06381    LAB_INT
06382    DA94  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06383    DA96  C9 98              CMP   #$98              ; compare with max int
06384    DA98  B0 1E              BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
06385    
06386    DA9A  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
06387    DA9D  84 B9              STY   FAC1_r            ; save FAC1 rounding byte
06388    DA9F  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06389    DAA1  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
06390    DAA3  49 80              EOR   #$80              ; toggle FAC1 sign
06391    DAA5  2A                 ROL                     ; shift into carry
06392    DAA6  A9 98              LDA   #$98              ; set new exponent
06393    DAA8  85 AC              STA   FAC1_e            ; save FAC1 exponent
06394    DAAA  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
06395    DAAC  85 5B              STA   Temp3             ; save for EXP() function
06396    DAAE  4C 42 D7           JMP   LAB_24D0          ; do ABS and normalise FAC1
06397    
06398    ; clear FAC1 and return
06399    
06400    LAB_287F
06401    DAB1  85 AD              STA   FAC1_1            ; clear FAC1 mantissa1
06402    DAB3  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
06403    DAB5  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
06404    DAB7  A8                 TAY                     ; clear Y
06405    LAB_2886
06406    DAB8  60                 RTS
06407    
06408    ; get FAC1 from string
06409    ; this routine now handles hex and binary values from strings
06410    ; starting with "$" and "%" respectively
06411    
06412    LAB_2887
06413    DAB9  A0 00              LDY   #$00              ; clear Y
06414    DABB  84 5F              STY   Dtypef            ; clear data type flag, $FF=string, $00=numeric
06415    DABD  A2 09              LDX   #$09              ; set index
06416    LAB_288B
06417    DABF  94 A8              STY   numexp,X          ; clear byte
06418    DAC1  CA                 DEX                     ; decrement index
06419    DAC2  10 FB              BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
06420    
06421    DAC4  90 7F              BCC   LAB_28FE          ; branch if 1st character numeric
06422    
06423    ; get FAC1 from string .. first character wasn't numeric
06424    
06425    DAC6  C9 2D              CMP   #'-'              ; else compare with "-"
06426    DAC8  D0 04              BNE   LAB_289A          ; branch if not "-"
06427    
06428    DACA  86 B1              STX   negnum            ; set flag for -ve number (X = $FF)
06429    DACC  F0 04              BEQ   LAB_289C          ; branch always (go scan and check for hex/bin)
06430    
06431    ; get FAC1 from string .. first character wasn't numeric or -
06432    
06433    LAB_289A
06434    DACE  C9 2B              CMP   #'+'              ; else compare with "+"
06435    DAD0  D0 05              BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
06436    
06437    ; was "+" or "-" to start, so get next character
06438    
06439    LAB_289C
06440    DAD2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
06441    DAD5  90 6E              BCC   LAB_28FE          ; branch if numeric character
06442    
06443    ; code here for hex and binary numbers
06444    
06445    LAB_289D
06446    DAD7  C9 24              CMP   #'$'              ; else compare with "$"
06447    DAD9  D0 03              BNE   LAB_NHEX          ; branch if not "$"
06448    
06449    DADB  4C 83 DF           JMP   LAB_CHEX          ; branch if "$"
06450    
06451    LAB_NHEX
06452    DADE  C9 25              CMP   #'%'              ; else compare with "%"
06453    DAE0  D0 08              BNE   LAB_28A3          ; branch if not "%" (continue original code)
06454    
06455    DAE2  4C B1 DF           JMP   LAB_CBIN          ; branch if "%"
06456    
06457    LAB_289E
06458    DAE5  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
06459    LAB_28A1
06460    DAE8  90 5B              BCC   LAB_28FE          ; branch if numeric character
06461    
06462    ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
06463    
06464    LAB_28A3
06465    DAEA  C9 2E              CMP   #'.'              ; else compare with "."
06466    DAEC  F0 2E              BEQ   LAB_28D5          ; branch if "."
06467    
06468    ; get FAC1 from string .. character wasn't numeric, -, + or .
06469    
06470    DAEE  C9 45              CMP   #'E'              ; else compare with "E"
06471    DAF0  D0 30              BNE   LAB_28DB          ; branch if not "E"
06472    
06473                                  ; was "E" so evaluate exponential part
06474    DAF2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
06475    DAF5  90 17              BCC   LAB_28C7          ; branch if numeric character
06476    
06477    DAF7  C9 BE              CMP   #TK_MINUS         ; else compare with token for -
06478    DAF9  F0 0E              BEQ   LAB_28C2          ; branch if token for -
06479    
06480    DAFB  C9 2D              CMP   #'-'              ; else compare with "-"
06481    DAFD  F0 0A              BEQ   LAB_28C2          ; branch if "-"
06482    
06483    DAFF  C9 BD              CMP   #TK_PLUS          ; else compare with token for +
06484    DB01  F0 08              BEQ   LAB_28C4          ; branch if token for +
06485    
06486    DB03  C9 2B              CMP   #'+'              ; else compare with "+"
06487    DB05  F0 04              BEQ   LAB_28C4          ; branch if "+"
06488    
06489    DB07  D0 07              BNE   LAB_28C9          ; branch always
06490    
06491    LAB_28C2
06492    DB09  66 AB              ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
06493    LAB_28C4
06494    DB0B  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
06495    LAB_28C7
06496    DB0E  90 5B              BCC   LAB_2925          ; branch if numeric character
06497    
06498    LAB_28C9
06499    DB10  24 AB              BIT   expneg            ; test exponent -ve flag
06500    DB12  10 0E              BPL   LAB_28DB          ; if +ve go evaluate exponent
06501    
06502                                  ; else do exponent = -exponent 
06503    DB14  A9 00              LDA   #$00              ; clear result
06504    DB16  38                 SEC                     ; set carry for subtract
06505    DB17  E5 A9              SBC   expcnt            ; subtract exponent byte
06506    DB19  4C 24 DB           JMP   LAB_28DD          ; go evaluate exponent
06507    
06508    LAB_28D5
06509    DB1C  66 AA              ROR   numdpf            ; set decimal point flag
06510    DB1E  24 AA              BIT   numdpf            ; test decimal point flag
06511    DB20  50 C3              BVC   LAB_289E          ; branch if only one decimal point so far
06512    
06513                                  ; evaluate exponent
06514    LAB_28DB
06515    DB22  A5 A9              LDA   expcnt            ; get exponent count byte
06516    LAB_28DD
06517    DB24  38                 SEC                     ; set carry for subtract
06518    DB25  E5 A8              SBC   numexp            ; subtract numerator exponent
06519    DB27  85 A9              STA   expcnt            ; save exponent count byte
06520    DB29  F0 12              BEQ   LAB_28F6          ; branch if no adjustment
06521    
06522    DB2B  10 09              BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
06523    
06524                                  ; else go do FAC1/10^(0-expcnt)
06525    LAB_28E6
06526    DB2D  20 03 D9           JSR   LAB_26B9          ; divide by 10
06527    DB30  E6 A9              INC   expcnt            ; increment exponent count byte
06528    DB32  D0 F9              BNE   LAB_28E6          ; loop until all done
06529    
06530    DB34  F0 07              BEQ   LAB_28F6          ; branch always
06531    
06532    LAB_28EF
06533    DB36  20 EA D8           JSR   LAB_269E          ; multiply by 10
06534    DB39  C6 A9              DEC   expcnt            ; decrement exponent count byte
06535    DB3B  D0 F9              BNE   LAB_28EF          ; loop until all done
06536    
06537    LAB_28F6
06538    DB3D  A5 B1              LDA   negnum            ; get -ve flag
06539    DB3F  30 01              BMI   LAB_28FB          ; if -ve do - FAC1 and return
06540    
06541    DB41  60                 RTS
06542    
06543    ; do - FAC1 and return
06544    
06545    LAB_28FB
06546    DB42  4C 07 DD           JMP   LAB_GTHAN         ; do - FAC1 and return
06547    
06548    ; do unsigned FAC1*10+number
06549    
06550    LAB_28FE
06551    DB45  48                 PHA                     ; save character
06552    DB46  24 AA              BIT   numdpf            ; test decimal point flag
06553    DB48  10 02              BPL   LAB_2905          ; skip exponent increment if not set
06554    
06555    DB4A  E6 A8              INC   numexp            ; else increment number exponent
06556    LAB_2905
06557    DB4C  20 EA D8           JSR   LAB_269E          ; multiply FAC1 by 10
06558    DB4F  68                 PLA                     ; restore character
06559    DB50  29 0F              AND   #$0F              ; convert to binary
06560    DB52  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
06561    DB55  4C E5 DA           JMP   LAB_289E          ; go do next character
06562    
06563    ; evaluate new ASCII digit
06564    
06565    LAB_2912
06566    DB58  48                 PHA                     ; save digit
06567    DB59  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
06568    DB5C  68                 PLA                     ; restore digit
06569    DB5D  20 0D DA           JSR   LAB_27DB          ; save A as integer byte
06570    DB60  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
06571    DB62  45 B0              EOR   FAC1_s            ; toggle with FAC1 sign (b7)
06572    DB64  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
06573    DB66  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
06574    DB68  4C D4 D6           JMP   LAB_ADD           ; add FAC2 to FAC1 and return
06575    
06576    ; evaluate next character of exponential part of number
06577    
06578    LAB_2925
06579    DB6B  A5 A9              LDA   expcnt            ; get exponent count byte
06580    DB6D  C9 0A              CMP   #$0A              ; compare with 10 decimal
06581    DB6F  90 09              BCC   LAB_2934          ; branch if less
06582    
06583    DB71  A9 64              LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
06584    DB73  24 AB              BIT   expneg            ; test exponent -ve flag
06585    DB75  30 0E              BMI   LAB_2942          ; branch if -ve
06586    
06587    DB77  4C D6 D7           JMP   LAB_2564          ; else do overflow error
06588    
06589    LAB_2934
06590    DB7A  0A                 ASL                     ; * 2
06591    DB7B  0A                 ASL                     ; * 4
06592    DB7C  65 A9              ADC   expcnt            ; * 5
06593    DB7E  0A                 ASL                     ; * 10
06594    DB7F  A0 00              LDY   #$00              ; set index
06595    DB81  71 C3              ADC   (Bpntrl),Y        ; add character (will be $30 too much!)
06596    DB83  E9 2F              SBC   #'0'-1            ; convert character to binary
06597    LAB_2942
06598    DB85  85 A9              STA   expcnt            ; save exponent count byte
06599    DB87  4C 0B DB           JMP   LAB_28C4          ; go get next character
06600    
06601    ; print " in line [LINE #]"
06602    
06603    LAB_2953
06604    DB8A  A9 6F              LDA   #<LAB_LMSG        ; point to " in line " message low byte
06605    DB8C  A0 E9              LDY   #>LAB_LMSG        ; point to " in line " message high byte
06606    DB8E  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
06607    
06608                                  ; print Basic line #
06609    DB91  A5 88              LDA   Clineh            ; get current line high byte
06610    DB93  A6 87              LDX   Clinel            ; get current line low byte
06611    
06612    ; print XA as unsigned integer
06613    
06614    LAB_295E
06615    DB95  85 AD              STA   FAC1_1            ; save low byte as FAC1 mantissa1
06616    DB97  86 AE              STX   FAC1_2            ; save high byte as FAC1 mantissa2
06617    DB99  A2 90              LDX   #$90              ; set exponent to 16d bits
06618    DB9B  38                 SEC                     ; set integer is +ve flag
06619    DB9C  20 1A DA           JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
06620    DB9F  A0 00              LDY   #$00              ; clear index
06621    DBA1  98                 TYA                     ; clear A
06622    DBA2  20 B5 DB           JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
06623    DBA5  4C DA C9           JMP   LAB_18C3          ; print null terminated string from memory and return
06624    
06625    ; convert FAC1 to ASCII string result in (AY)
06626    ; not any more, moved scratchpad to page 0
06627    
06628    LAB_296E
06629    DBA8  A0 01              LDY   #$01              ; set index = 1
06630    DBAA  A9 20              LDA   #$20              ; character = " " (assume +ve)
06631    DBAC  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
06632    DBAE  10 02              BPL   LAB_2978          ; branch if +ve
06633    
06634    DBB0  A9 2D              LDA   #$2D              ; else character = "-"
06635    LAB_2978
06636    DBB2  99 EF 00           STA   Decss,Y           ; save leading character (" " or "-")
06637    LAB_297B
06638    DBB5  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
06639    DBB7  84 BA              STY   Sendl             ; save index
06640    DBB9  C8                 INY                     ; increment index
06641    DBBA  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
06642    DBBC  D0 05              BNE   LAB_2989          ; branch if FAC1<>0
06643    
06644                                  ; exponent was $00 so FAC1 is 0
06645    DBBE  A9 30              LDA   #'0'              ; set character = "0"
06646    DBC0  4C C1 DC           JMP   LAB_2A89          ; save last character, [EOT] and exit
06647    
06648                                  ; FAC1 is some non zero value
06649    LAB_2989
06650    DBC3  A9 00              LDA   #$00              ; clear (number exponent count)
06651    DBC5  E0 81              CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
06652    
06653    DBC7  B0 09              BCS   LAB_299A          ; branch if FAC1=>1
06654    
06655                                  ; FAC1<1
06656    DBC9  A9 A2              LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
06657    DBCB  A0 E2              LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
06658    DBCD  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06659    DBD0  A9 FA              LDA   #$FA              ; set number exponent count (-6)
06660    LAB_299A
06661    DBD2  85 A8              STA   numexp            ; save number exponent count
06662    LAB_299C
06663    DBD4  A9 9E              LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
06664    DBD6  A0 E2              LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
06665    DBD8  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
06666    DBDB  F0 1E              BEQ   LAB_29C3          ; exit if FAC1 = (AY)
06667    
06668    DBDD  10 12              BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
06669    
06670                                  ; FAC1 < (AY)
06671    LAB_29A7
06672    DBDF  A9 9A              LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
06673    DBE1  A0 E2              LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
06674    DBE3  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
06675    DBE6  F0 02              BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
06676    
06677    DBE8  10 0E              BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
06678    
06679                                  ; FAC1 <= (AY)
06680    LAB_29B2
06681    DBEA  20 EA D8           JSR   LAB_269E          ; multiply by 10
06682    DBED  C6 A8              DEC   numexp            ; decrement number exponent count
06683    DBEF  D0 EE              BNE   LAB_29A7          ; go test again (branch always)
06684    
06685    LAB_29B9
06686    DBF1  20 03 D9           JSR   LAB_26B9          ; divide by 10
06687    DBF4  E6 A8              INC   numexp            ; increment number exponent count
06688    DBF6  D0 DC              BNE   LAB_299C          ; go test again (branch always)
06689    
06690    ; now we have just the digits to do
06691    
06692    LAB_29C0
06693    DBF8  20 CD D6           JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
06694    LAB_29C3
06695    DBFB  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
06696    DBFE  A2 01              LDX   #$01              ; set default digits before dp = 1
06697    DC00  A5 A8              LDA   numexp            ; get number exponent count
06698    DC02  18                 CLC                     ; clear carry for add
06699    DC03  69 07              ADC   #$07              ; up to 6 digits before point
06700    DC05  30 09              BMI   LAB_29D8          ; if -ve then 1 digit before dp
06701    
06702    DC07  C9 08              CMP   #$08              ; A>=8 if n>=1E6
06703    DC09  B0 06              BCS   LAB_29D9          ; branch if >= $08
06704    
06705                                  ; carry is clear
06706    DC0B  69 FF              ADC   #$FF              ; take 1 from digit count
06707    DC0D  AA                 TAX                     ; copy to A
06708    DC0E  A9 02              LDA   #$02              ;.set exponent adjust
06709    LAB_29D8
06710    DC10  38                 SEC                     ; set carry for subtract
06711    LAB_29D9
06712    DC11  E9 02              SBC   #$02              ; -2
06713    DC13  85 A9              STA   expcnt            ;.save exponent adjust
06714    DC15  86 A8              STX   numexp            ; save digits before dp count
06715    DC17  8A                 TXA                     ; copy to A
06716    DC18  F0 02              BEQ   LAB_29E4          ; branch if no digits before dp
06717    
06718    DC1A  10 13              BPL   LAB_29F7          ; branch if digits before dp
06719    
06720    LAB_29E4
06721    DC1C  A4 BA              LDY   Sendl             ; get output string index
06722    DC1E  A9 2E              LDA   #$2E              ; character "."
06723    DC20  C8                 INY                     ; increment index
06724    DC21  99 EF 00           STA   Decss,Y           ; save to output string
06725    DC24  8A                 TXA                     ;.
06726    DC25  F0 06              BEQ   LAB_29F5          ;.
06727    
06728    DC27  A9 30              LDA   #'0'              ; character "0"
06729    DC29  C8                 INY                     ; increment index
06730    DC2A  99 EF 00           STA   Decss,Y           ; save to output string
06731    LAB_29F5
06732    DC2D  84 BA              STY   Sendl             ; save output string index
06733    LAB_29F7
06734    DC2F  A0 00              LDY   #$00              ; clear index (point to 100,000)
06735    DC31  A2 80              LDX   #$80              ; 
06736    LAB_29FB
06737    DC33  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
06738    DC35  18                 CLC                     ; clear carry for add
06739    DC36  79 18 E3           ADC   LAB_2A9C,Y        ; add -ve LSB
06740    DC39  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
06741    DC3B  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
06742    DC3D  79 17 E3           ADC   LAB_2A9B,Y        ; add -ve NMSB
06743    DC40  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
06744    DC42  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
06745    DC44  79 16 E3           ADC   LAB_2A9A,Y        ; add -ve MSB
06746    DC47  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06747    DC49  E8                 INX                     ; 
06748    DC4A  B0 04              BCS   LAB_2A18          ; 
06749    
06750    DC4C  10 E5              BPL   LAB_29FB          ; not -ve so try again
06751    
06752    DC4E  30 02              BMI   LAB_2A1A          ; 
06753    
06754    LAB_2A18
06755    DC50  30 E1              BMI   LAB_29FB          ; 
06756    
06757    LAB_2A1A
06758    DC52  8A                 TXA                     ; 
06759    DC53  90 04              BCC   LAB_2A21          ; 
06760    
06761    DC55  49 FF              EOR   #$FF              ; 
06762    DC57  69 0A              ADC   #$0A              ; 
06763    LAB_2A21
06764    DC59  69 2F              ADC   #'0'-1            ; add "0"-1 to result
06765    DC5B  C8                 INY                     ; increment index ..
06766    DC5C  C8                 INY                     ; .. to next less ..
06767    DC5D  C8                 INY                     ; .. power of ten
06768    DC5E  84 95              STY   Cvaral            ; save as current var address low byte
06769    DC60  A4 BA              LDY   Sendl             ; get output string index
06770    DC62  C8                 INY                     ; increment output string index
06771    DC63  AA                 TAX                     ; copy character to X
06772    DC64  29 7F              AND   #$7F              ; mask out top bit
06773    DC66  99 EF 00           STA   Decss,Y           ; save to output string
06774    DC69  C6 A8              DEC   numexp            ; decrement # of characters before the dp
06775    DC6B  D0 06              BNE   LAB_2A3B          ; branch if still characters to do
06776    
06777                                  ; else output the point
06778    DC6D  A9 2E              LDA   #$2E              ; character "."
06779    DC6F  C8                 INY                     ; increment output string index
06780    DC70  99 EF 00           STA   Decss,Y           ; save to output string
06781    LAB_2A3B
06782    DC73  84 BA              STY   Sendl             ; save output string index
06783    DC75  A4 95              LDY   Cvaral            ; get current var address low byte
06784    DC77  8A                 TXA                     ; get character back
06785    DC78  49 FF              EOR   #$FF              ; 
06786    DC7A  29 80              AND   #$80              ; 
06787    DC7C  AA                 TAX                     ; 
06788    DC7D  C0 12              CPY   #$12              ; compare index with max
06789    DC7F  D0 B2              BNE   LAB_29FB          ; loop if not max
06790    
06791                                  ; now remove trailing zeroes
06792    DC81  A4 BA              LDY   Sendl             ; get output string index
06793    LAB_2A4B
06794    DC83  B9 EF 00           LDA   Decss,Y           ; get character from output string
06795    DC86  88                 DEY                     ; decrement output string index
06796    DC87  C9 30              CMP   #'0'              ; compare with "0"
06797    DC89  F0 F8              BEQ   LAB_2A4B          ; loop until non "0" character found
06798    
06799    DC8B  C9 2E              CMP   #'.'              ; compare with "."
06800    DC8D  F0 01              BEQ   LAB_2A58          ; branch if was dp
06801    
06802                                  ; restore last character
06803    DC8F  C8                 INY                     ; increment output string index
06804    LAB_2A58
06805    DC90  A9 2B              LDA   #$2B              ; character "+"
06806    DC92  A6 A9              LDX   expcnt            ; get exponent count
06807    DC94  F0 2E              BEQ   LAB_2A8C          ; if zero go set null terminator and exit
06808    
06809                                  ; exponent isn't zero so write exponent
06810    DC96  10 08              BPL   LAB_2A68          ; branch if exponent count +ve
06811    
06812    DC98  A9 00              LDA   #$00              ; clear A
06813    DC9A  38                 SEC                     ; set carry for subtract
06814    DC9B  E5 A9              SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
06815    DC9D  AA                 TAX                     ; copy exponent count to X
06816    DC9E  A9 2D              LDA   #'-'              ; character "-"
06817    LAB_2A68
06818    DCA0  99 F1 00           STA   Decss+2,Y         ; save to output string
06819    DCA3  A9 45              LDA   #$45              ; character "E"
06820    DCA5  99 F0 00           STA   Decss+1,Y         ; save exponent sign to output string
06821    DCA8  8A                 TXA                     ; get exponent count back
06822    DCA9  A2 2F              LDX   #'0'-1            ; one less than "0" character
06823    DCAB  38                 SEC                     ; set carry for subtract
06824    LAB_2A74
06825    DCAC  E8                 INX                     ; increment 10's character
06826    DCAD  E9 0A              SBC   #$0A              ;.subtract 10 from exponent count
06827    DCAF  B0 FB              BCS   LAB_2A74          ; loop while still >= 0
06828    
06829    DCB1  69 3A              ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
06830    DCB3  99 F3 00           STA   Decss+4,Y         ; save to output string
06831    DCB6  8A                 TXA                     ; copy 10's character
06832    DCB7  99 F2 00           STA   Decss+3,Y         ; save to output string
06833    DCBA  A9 00              LDA   #$00              ; set null terminator
06834    DCBC  99 F4 00           STA   Decss+5,Y         ; save to output string
06835    DCBF  F0 08              BEQ   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
06836    
06837                                  ; save last character, [EOT] and exit
06838    LAB_2A89
06839    DCC1  99 EF 00           STA   Decss,Y           ; save last character to output string
06840    
06841                                  ; set null terminator and exit
06842    LAB_2A8C
06843    DCC4  A9 00              LDA   #$00              ; set null terminator
06844    DCC6  99 F0 00           STA   Decss+1,Y         ; save after last character
06845    
06846                                  ; set string pointer (AY) and exit
06847    LAB_2A91
06848    DCC9  A9 F0              LDA   #<Decssp1         ; set result string low pointer
06849    DCCB  A0 00              LDY   #>Decssp1         ; set result string high pointer
06850    DCCD  60                 RTS
06851    
06852    ; perform power function
06853    
06854    LAB_POWER
06855    DCCE  F0 42              BEQ   LAB_EXP           ; go do  EXP()
06856    
06857    DCD0  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
06858    DCD2  D0 03              BNE   LAB_2ABF          ; branch if FAC2<>0
06859    
06860    DCD4  4C 65 D7           JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
06861    
06862    LAB_2ABF
06863    DCD7  A2 9C              LDX   #<func_l          ; set destination pointer low byte
06864    DCD9  A0 00              LDY   #>func_l          ; set destination pointer high byte
06865    DCDB  20 BA D9           JSR   LAB_2778          ; pack FAC1 into (XY)
06866    DCDE  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
06867    DCE0  10 0F              BPL   LAB_2AD9          ; branch if FAC2>0
06868    
06869                                  ; else FAC2 is -ve and can only be raised to an
06870                                  ; integer power which gives an x +j0 result
06871    DCE2  20 94 DA           JSR   LAB_INT           ; perform INT
06872    DCE5  A9 9C              LDA   #<func_l          ; set source pointer low byte
06873    DCE7  A0 00              LDY   #>func_l          ; set source pointer high byte
06874    DCE9  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
06875    DCEC  D0 03              BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
06876                                  ; this will leave FAC1 -ve and cause a Function Call
06877                                  ; error when LOG() is called
06878    
06879    DCEE  98                 TYA                     ; clear sign b7
06880    DCEF  A4 5B              LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
06881                                  ; for possible later negation, b0
06882    LAB_2AD9
06883    DCF1  20 D8 D6           JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
06884    DCF4  98                 TYA                     ; copy sign back ..
06885    DCF5  48                 PHA                     ; .. and save it
06886    DCF6  20 0E D8           JSR   LAB_LOG           ; do LOG(n)
06887    DCF9  A9 9C              LDA   #<garb_l          ; set pointer low byte
06888    DCFB  A0 00              LDY   #>garb_l          ; set pointer high byte
06889    DCFD  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
06890    DD00  20 12 DD           JSR   LAB_EXP           ; go do EXP(n)
06891    DD03  68                 PLA                     ; pull sign from stack
06892    DD04  4A                 LSR                     ; b0 is to be tested, shift to Cb
06893    DD05  90 0A              BCC   LAB_2AF9          ; if no bit then exit
06894    
06895                                  ; Perform negation
06896    ; do - FAC1
06897    
06898    LAB_GTHAN
06899    DD07  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06900    DD09  F0 06              BEQ   LAB_2AF9          ; exit if FAC1_e = $00
06901    
06902    DD0B  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06903    DD0D  49 FF              EOR   #$FF              ; complement it
06904    DD0F  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
06905    LAB_2AF9
06906    DD11  60                 RTS
06907    
06908    ; perform EXP()   (x^e)
06909    
06910    LAB_EXP
06911    DD12  A9 A6              LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
06912    DD14  A0 E2              LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
06913    DD16  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06914    DD19  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
06915    DD1B  69 50              ADC   #$50              ; +$50/$100
06916    DD1D  90 03              BCC   LAB_2B2B          ; skip rounding if no carry
06917    
06918    DD1F  20 F4 D9           JSR   LAB_27C2          ; round FAC1 (no check)
06919    LAB_2B2B
06920    DD22  85 A3              STA   FAC2_r            ; save FAC2 rounding byte
06921    DD24  20 E0 D9           JSR   LAB_27AE          ; copy FAC1 to FAC2
06922    DD27  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06923    DD29  C9 88              CMP   #$88              ; compare with EXP limit (256d)
06924    DD2B  90 03              BCC   LAB_2B39          ; branch if less
06925    
06926    LAB_2B36
06927    DD2D  20 E1 D8           JSR   LAB_2690          ; handle overflow and underflow
06928    LAB_2B39
06929    DD30  20 94 DA           JSR   LAB_INT           ; perform INT
06930    DD33  A5 5B              LDA   Temp3             ; get mantissa 3 from INT() function
06931    DD35  18                 CLC                     ; clear carry for add
06932    DD36  69 81              ADC   #$81              ; normalise +1
06933    DD38  F0 F3              BEQ   LAB_2B36          ; if $00 go handle overflow
06934    
06935    DD3A  38                 SEC                     ; set carry for subtract
06936    DD3B  E9 01              SBC   #$01              ; now correct for exponent
06937    DD3D  48                 PHA                     ; save FAC2 exponent
06938    
06939                                  ; swap FAC1 and FAC2
06940    DD3E  A2 04              LDX   #$04              ; 4 bytes to do
06941    LAB_2B49
06942    DD40  B5 B3              LDA   FAC2_e,X          ; get FAC2,X
06943    DD42  B4 AC              LDY   FAC1_e,X          ; get FAC1,X
06944    DD44  95 AC              STA   FAC1_e,X          ; save FAC1,X
06945    DD46  94 B3              STY   FAC2_e,X          ; save FAC2,X
06946    DD48  CA                 DEX                     ; decrement count/index
06947    DD49  10 F5              BPL   LAB_2B49          ; loop if not all done
06948    
06949    DD4B  A5 A3              LDA   FAC2_r            ; get FAC2 rounding byte
06950    DD4D  85 B9              STA   FAC1_r            ; save as FAC1 rounding byte
06951    DD4F  20 B9 D6           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
06952    DD52  20 07 DD           JSR   LAB_GTHAN         ; do - FAC1
06953    DD55  A9 AA              LDA   #<LAB_2AFE        ; set counter pointer low byte
06954    DD57  A0 E2              LDY   #>LAB_2AFE        ; set counter pointer high byte
06955    DD59  20 7A DD           JSR   LAB_2B84          ; go do series evaluation
06956    DD5C  A9 00              LDA   #$00              ; clear A
06957    DD5E  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
06958    DD60  68                 PLA                     ;.get saved FAC2 exponent
06959    DD61  4C C6 D8           JMP   LAB_2675          ; test and adjust accumulators and return
06960    
06961    ; ^2 then series evaluation
06962    
06963    LAB_2B6E
06964    DD64  85 BA              STA   Cptrl             ; save count pointer low byte
06965    DD66  84 BB              STY   Cptrh             ; save count pointer high byte
06966    DD68  20 B0 D9           JSR   LAB_276E          ; pack FAC1 into Adatal
06967    DD6B  A9 A4              LDA   #<Adatal          ; set pointer low byte (Y already $00)
06968    DD6D  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06969    DD70  20 7E DD           JSR   LAB_2B88          ; go do series evaluation
06970    DD73  A9 A4              LDA   #<Adatal          ; pointer to original # low byte
06971    DD75  A0 00              LDY   #>Adatal          ; pointer to original # high byte
06972    DD77  4C 4C D8           JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
06973    
06974    ; series evaluation
06975    
06976    LAB_2B84
06977    DD7A  85 BA              STA   Cptrl             ; save count pointer low byte
06978    DD7C  84 BB              STY   Cptrh             ; save count pointer high byte
06979    LAB_2B88
06980    DD7E  A2 A8              LDX   #<numexp          ; set pointer low byte
06981    DD80  20 B2 D9           JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
06982    DD83  B1 BA              LDA   (Cptrl),Y         ; get constants count
06983    DD85  85 B1              STA   numcon            ; save constants count
06984    DD87  A4 BA              LDY   Cptrl             ; get count pointer low byte
06985    DD89  C8                 INY                     ; increment it (now constants pointer)
06986    DD8A  98                 TYA                     ; copy it
06987    DD8B  D0 02              BNE   LAB_2B97          ; skip next if no overflow
06988    
06989    DD8D  E6 BB              INC   Cptrh             ; else increment high byte
06990    LAB_2B97
06991    DD8F  85 BA              STA   Cptrl             ; save low byte
06992    DD91  A4 BB              LDY   Cptrh             ; get high byte
06993    LAB_2B9B
06994    DD93  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06995    DD96  A5 BA              LDA   Cptrl             ; get constants pointer low byte
06996    DD98  A4 BB              LDY   Cptrh             ; get constants pointer high byte
06997    DD9A  18                 CLC                     ; clear carry for add
06998    DD9B  69 04              ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
06999    DD9D  90 01              BCC   LAB_2BA8          ; skip next if no overflow
07000    
07001    DD9F  C8                 INY                     ; increment high byte
07002    LAB_2BA8
07003    DDA0  85 BA              STA   Cptrl             ; save pointer low byte
07004    DDA2  84 BB              STY   Cptrh             ; save pointer high byte
07005    DDA4  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
07006    DDA7  A9 A8              LDA   #<numexp          ; set pointer low byte to partial @ numexp
07007    DDA9  A0 00              LDY   #>numexp          ; set pointer high byte to partial @ numexp
07008    DDAB  C6 B1              DEC   numcon            ; decrement constants count
07009    DDAD  D0 E4              BNE   LAB_2B9B          ; loop until all done
07010    
07011    DDAF  60                 RTS
07012    
07013    ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
07014    ; to get 19th next number in sequence after seed n. This version of the PRNG uses
07015    ; the Galois method and a sample of 65536 bytes produced gives the following values.
07016    
07017    ; Entropy = 7.997442 bits per byte
07018    ; Optimum compression would reduce these 65536 bytes by 0 percent
07019    
07020    ; Chi square distribution for 65536 samples is 232.01, and
07021    ; randomly would exceed this value 75.00 percent of the time
07022    
07023    ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
07024    ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
07025    ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
07026    
07027    LAB_RND
07028    DDB0  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07029    DDB2  F0 07              BEQ   NextPRN           ; do next random # if zero
07030    
07031                                  ; else get seed into random number store
07032    DDB4  A2 D8              LDX   #Rbyte4           ; set PRNG pointer low byte
07033    DDB6  A0 00              LDY   #$00              ; set PRNG pointer high byte
07034    DDB8  20 BA D9           JSR   LAB_2778          ; pack FAC1 into (XY)
07035    NextPRN
07036    DDBB  A2 AF              LDX   #$AF              ; set EOR byte
07037    DDBD  A0 13              LDY   #$13              ; do this nineteen times
07038    LoopPRN
07039    DDBF  06 D9              ASL   Rbyte1            ; shift PRNG most significant byte
07040    DDC1  26 DA              ROL   Rbyte2            ; shift PRNG middle byte
07041    DDC3  26 DB              ROL   Rbyte3            ; shift PRNG least significant byte
07042    DDC5  26 D8              ROL   Rbyte4            ; shift PRNG extra byte
07043    DDC7  90 05              BCC   Ninc1             ; branch if bit 32 clear
07044    
07045    DDC9  8A                 TXA                     ; set EOR byte
07046    DDCA  45 D9              EOR   Rbyte1            ; EOR PRNG extra byte
07047    DDCC  85 D9              STA   Rbyte1            ; save new PRNG extra byte
07048    Ninc1
07049    DDCE  88                 DEY                     ; decrement loop count
07050    DDCF  D0 EE              BNE   LoopPRN           ; loop if not all done
07051    
07052    DDD1  A2 02              LDX   #$02              ; three bytes to copy
07053    CopyPRNG
07054    DDD3  B5 D9              LDA   Rbyte1,X          ; get PRNG byte
07055    DDD5  95 AD              STA   FAC1_1,X          ; save FAC1 byte
07056    DDD7  CA                 DEX
07057    DDD8  10 F9              BPL   CopyPRNG          ; loop if not complete
07058    
07059    DDDA  A9 80              LDA   #$80              ; set the exponent
07060    DDDC  85 AC              STA   FAC1_e            ; save FAC1 exponent
07061    
07062    DDDE  0A                 ASL                     ; clear A
07063    DDDF  85 B0              STA   FAC1_s            ; save FAC1 sign
07064    
07065    DDE1  4C 47 D7           JMP   LAB_24D5          ; normalise FAC1 and return
07066    
07067    ; perform COS()
07068    
07069    LAB_COS
07070    DDE4  A9 C7              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
07071    DDE6  A0 E2              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
07072    DDE8  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
07073    
07074    ; perform SIN()
07075    
07076    LAB_SIN
07077    DDEB  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
07078    DDEE  A9 DC              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
07079    DDF0  A0 E2              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
07080    DDF2  A6 B7              LDX   FAC2_s            ; get FAC2 sign (b7)
07081    DDF4  20 0C D9           JSR   LAB_26C2          ; divide by (AY) (X=sign)
07082    DDF7  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
07083    DDFA  20 94 DA           JSR   LAB_INT           ; perform INT
07084    DDFD  A9 00              LDA   #$00              ; clear byte
07085    DDFF  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
07086    DE01  20 B9 D6           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
07087    DE04  A9 0E              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
07088    DE06  A0 E3              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
07089    DE08  20 B6 D6           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
07090    DE0B  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
07091    DE0D  48                 PHA                     ; save FAC1 sign
07092    DE0E  10 0D              BPL   LAB_2C35          ; branch if +ve
07093    
07094                                  ; FAC1 sign was -ve
07095    DE10  20 CD D6           JSR   LAB_244E          ; add 0.5 to FAC1
07096    DE13  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
07097    DE15  30 09              BMI   LAB_2C38          ; branch if -ve
07098    
07099    DE17  A5 63              LDA   Cflag             ; get comparison evaluation flag
07100    DE19  49 FF              EOR   #$FF              ; toggle flag
07101    DE1B  85 63              STA   Cflag             ; save comparison evaluation flag
07102    LAB_2C35
07103    DE1D  20 07 DD           JSR   LAB_GTHAN         ; do - FAC1
07104    LAB_2C38
07105    DE20  A9 0E              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
07106    DE22  A0 E3              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
07107    DE24  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
07108    DE27  68                 PLA                     ; restore FAC1 sign
07109    DE28  10 03              BPL   LAB_2C45          ; branch if was +ve
07110    
07111                                  ; else correct FAC1
07112    DE2A  20 07 DD           JSR   LAB_GTHAN         ; do - FAC1
07113    LAB_2C45
07114    DE2D  A9 CB              LDA   #<LAB_2C84        ; set pointer low byte to counter
07115    DE2F  A0 E2              LDY   #>LAB_2C84        ; set pointer high byte to counter
07116    DE31  4C 64 DD           JMP   LAB_2B6E          ; ^2 then series evaluation and return
07117    
07118    ; perform TAN()
07119    
07120    LAB_TAN
07121    DE34  20 B0 D9           JSR   LAB_276E          ; pack FAC1 into Adatal
07122    DE37  A9 00              LDA   #$00              ; clear byte
07123    DE39  85 63              STA   Cflag             ; clear comparison evaluation flag
07124    DE3B  20 EB DD           JSR   LAB_SIN           ; go do SIN(n)
07125    DE3E  A2 9C              LDX   #<func_l          ; set sin(n) pointer low byte
07126    DE40  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
07127    DE42  20 BA D9           JSR   LAB_2778          ; pack FAC1 into (XY)
07128    DE45  A9 A4              LDA   #<Adatal          ; set n pointer low addr
07129    DE47  A0 00              LDY   #>Adatal          ; set n pointer high addr
07130    DE49  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
07131    DE4C  A9 00              LDA   #$00              ; clear byte
07132    DE4E  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
07133    DE50  A5 63              LDA   Cflag             ; get comparison evaluation flag
07134    DE52  20 5C DE           JSR   LAB_2C74          ; save flag and go do series evaluation
07135    
07136    DE55  A9 9C              LDA   #<func_l          ; set sin(n) pointer low byte
07137    DE57  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
07138    DE59  4C 14 D9           JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
07139    
07140    LAB_2C74
07141    DE5C  48                 PHA                     ; save comparison evaluation flag
07142    DE5D  4C 1D DE           JMP   LAB_2C35          ; go do series evaluation
07143    
07144    ; perform USR()
07145    
07146    LAB_USR
07147    DE60  20 0A 00           JSR   Usrjmp            ; call user code
07148    DE63  4C F5 CC           JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
07149    
07150    ; perform ATN()
07151    
07152    LAB_ATN
07153    DE66  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
07154    DE68  48                 PHA                     ; save sign
07155    DE69  10 03              BPL   LAB_2CA1          ; branch if +ve
07156    
07157    DE6B  20 07 DD           JSR   LAB_GTHAN         ; else do - FAC1
07158    LAB_2CA1
07159    DE6E  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07160    DE70  48                 PHA                     ; push exponent
07161    DE71  C9 81              CMP   #$81              ; compare with 1
07162    DE73  90 07              BCC   LAB_2CAF          ; branch if FAC1<1
07163    
07164    DE75  A9 01              LDA   #<LAB_259C        ; set 1 pointer low byte
07165    DE77  A0 E3              LDY   #>LAB_259C        ; set 1 pointer high byte
07166    DE79  20 14 D9           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
07167    LAB_2CAF
07168    DE7C  A9 E0              LDA   #<LAB_2CC9        ; set pointer low byte to counter
07169    DE7E  A0 E2              LDY   #>LAB_2CC9        ; set pointer high byte to counter
07170    DE80  20 64 DD           JSR   LAB_2B6E          ; ^2 then series evaluation
07171    DE83  68                 PLA                     ; restore old FAC1 exponent
07172    DE84  C9 81              CMP   #$81              ; compare with 1
07173    DE86  90 07              BCC   LAB_2CC2          ; branch if FAC1<1
07174    
07175    DE88  A9 C7              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
07176    DE8A  A0 E2              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
07177    DE8C  20 B6 D6           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
07178    LAB_2CC2
07179    DE8F  68                 PLA                     ; restore FAC1 sign
07180    DE90  10 16              BPL   LAB_2D04          ; exit if was +ve
07181    
07182    DE92  4C 07 DD           JMP   LAB_GTHAN         ; else do - FAC1 and return
07183    
07184    ; perform BITSET
07185    
07186    LAB_BITSET
07187    DE95  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
07188    DE98  E0 08              CPX   #$08              ; only 0 to 7 are allowed
07189    DE9A  B0 20              BCS   FCError           ; branch if > 7
07190    
07191    DE9C  A9 00              LDA   #$00              ; clear A
07192    DE9E  38                 SEC                     ; set the carry
07193    S_Bits
07194    DE9F  2A                 ROL                     ; shift bit
07195    DEA0  CA                 DEX                     ; decrement bit number
07196    DEA1  10 FC              BPL   S_Bits            ; loop if still +ve
07197    
07198    DEA3  E8                 INX                     ; make X = $00
07199    DEA4  01 11              ORA   (Itempl,X)        ; or with byte via temporary integer (addr)
07200    DEA6  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
07201    LAB_2D04
07202    DEA8  60                 RTS
07203    
07204    ; perform BITCLR
07205    
07206    LAB_BITCLR
07207    DEA9  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
07208    DEAC  E0 08              CPX   #$08              ; only 0 to 7 are allowed
07209    DEAE  B0 0C              BCS   FCError           ; branch if > 7
07210    
07211    DEB0  A9 FF              LDA   #$FF              ; set A
07212    S_Bitc
07213    DEB2  2A                 ROL                     ; shift bit
07214    DEB3  CA                 DEX                     ; decrement bit number
07215    DEB4  10 FC              BPL   S_Bitc            ; loop if still +ve
07216    
07217    DEB6  E8                 INX                     ; make X = $00
07218    DEB7  21 11              AND   (Itempl,X)        ; and with byte via temporary integer (addr)
07219    DEB9  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
07220    DEBB  60                 RTS
07221    
07222    FCError
07223    DEBC  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
07224    
07225    ; perform BITTST()
07226    
07227    LAB_BTST
07228    DEBF  20 BC 00           JSR   LAB_IGBY          ; increment BASIC pointer
07229    DEC2  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
07230    DEC5  E0 08              CPX   #$08              ; only 0 to 7 are allowed
07231    DEC7  B0 F3              BCS   FCError           ; branch if > 7
07232    
07233    DEC9  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
07234    DECC  C9 29              CMP   #')'              ; is next character ")"
07235    DECE  F0 03              BEQ   TST_OK            ; if ")" go do rest of function
07236    
07237    DED0  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
07238    
07239    TST_OK
07240    DED3  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
07241    DED6  A9 00              LDA   #$00              ; clear A
07242    DED8  38                 SEC                     ; set the carry
07243    T_Bits
07244    DED9  2A                 ROL                     ; shift bit
07245    DEDA  CA                 DEX                     ; decrement bit number
07246    DEDB  10 FC              BPL   T_Bits            ; loop if still +ve
07247    
07248    DEDD  E8                 INX                     ; make X = $00
07249    DEDE  21 11              AND   (Itempl,X)        ; AND with byte via temporary integer (addr)
07250    DEE0  F0 02              BEQ   LAB_NOTT          ; branch if zero (already correct)
07251    
07252    DEE2  A9 FF              LDA   #$FF              ; set for -1 result
07253    LAB_NOTT
07254    DEE4  4C 0D DA           JMP   LAB_27DB          ; go do SGN tail
07255    
07256    ; perform BIN$()
07257    
07258    LAB_BINS
07259    DEE7  E0 19              CPX   #$19              ; max + 1
07260    DEE9  B0 48              BCS   BinFErr           ; exit if too big ( > or = )
07261    
07262    DEEB  86 78              STX   TempB             ; save # of characters ($00 = leading zero remove)
07263    DEED  A9 18              LDA   #$18              ; need A byte long space
07264    DEEF  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long
07265    DEF2  A0 17              LDY   #$17              ; set index
07266    DEF4  A2 18              LDX   #$18              ; character count
07267    NextB1
07268    DEF6  46 11              LSR   nums_1            ; shift highest byte
07269    DEF8  66 12              ROR   nums_2            ; shift middle byte
07270    DEFA  66 13              ROR   nums_3            ; shift lowest byte bit 0 to carry
07271    DEFC  8A                 TXA                     ; load with "0"/2
07272    DEFD  2A                 ROL                     ; shift in carry
07273    DEFE  91 AD              STA   (str_pl),Y        ; save to temp string + index
07274    DF00  88                 DEY                     ; decrement index
07275    DF01  10 F3              BPL   NextB1            ; loop if not done
07276    
07277    DF03  A5 78              LDA   TempB             ; get # of characters
07278    DF05  F0 0A              BEQ   EndBHS            ; branch if truncate
07279    
07280    DF07  AA                 TAX                     ; copy length to X
07281    DF08  38                 SEC                     ; set carry for add !
07282    DF09  49 FF              EOR   #$FF              ; 1's complement
07283    DF0B  69 18              ADC   #$18              ; add 24d
07284    DF0D  F0 1C              BEQ   GoPr2             ; if zero print whole string
07285    
07286    DF0F  D0 0F              BNE   GoPr1             ; else go make output string
07287          
07288    ; this is the exit code and is also used by HEX$()
07289    ; truncate string to remove leading "0"s
07290    
07291    EndBHS
07292    DF11  A8                 TAY                     ; clear index (A=0, X=length here)
07293    NextB2
07294    DF12  B1 AD              LDA   (str_pl),Y        ; get character from string
07295    DF14  C9 30              CMP   #'0'              ; compare with "0"
07296    DF16  D0 07              BNE   GoPr              ; if not "0" then go print string from here
07297    
07298    DF18  CA                 DEX                     ; decrement character count
07299    DF19  F0 03              BEQ   GoPr3             ; if zero then end of string so go print it
07300    
07301    DF1B  C8                 INY                     ; else increment index
07302    DF1C  10 F4              BPL   NextB2            ; loop always
07303    
07304    ; make fixed length output string - ignore overflows!
07305    
07306    GoPr3
07307    DF1E  E8                 INX                     ; need at least 1 character
07308    GoPr
07309    DF1F  98                 TYA                     ; copy result
07310    GoPr1
07311    DF20  18                 CLC                     ; clear carry for add
07312    DF21  65 AD              ADC   str_pl            ; add low address
07313    DF23  85 AD              STA   str_pl            ; save low address
07314    DF25  A9 00              LDA   #$00              ; do high byte
07315    DF27  65 AE              ADC   str_ph            ; add high address
07316    DF29  85 AE              STA   str_ph            ; save high address
07317    GoPr2
07318    DF2B  86 AC              STX   str_ln            ; X holds string length
07319    DF2D  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
07320    DF30  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put address
07321                                  ; and length on descriptor stack and update stack pointers
07322    
07323    BinFErr
07324    DF33  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
07325    
07326    ; perform HEX$()
07327    
07328    LAB_HEXS
07329    DF36  E0 07              CPX   #$07              ; max + 1
07330    DF38  B0 F9              BCS   BinFErr           ; exit if too big ( > or = )
07331    
07332    DF3A  86 78              STX   TempB             ; save # of characters
07333    
07334    DF3C  A9 06              LDA   #$06              ; need 6 bytes for string
07335    DF3E  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long
07336    DF41  A0 05              LDY   #$05              ; set string index
07337    
07338    ; *** disable decimal mode patch - comment next line ***
07339    ;      SED                     ; need decimal mode for nibble convert
07340    DF43  A5 13              LDA   nums_3            ; get lowest byte
07341    DF45  20 62 DF           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
07342    DF48  A5 12              LDA   nums_2            ; get middle byte
07343    DF4A  20 62 DF           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
07344    DF4D  A5 11              LDA   nums_1            ; get highest byte
07345    DF4F  20 62 DF           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
07346    ; *** disable decimal mode patch - comment next line ***
07347    ;      CLD                     ; back to binary
07348    
07349    DF52  A2 06              LDX   #$06              ; character count
07350    DF54  A5 78              LDA   TempB             ; get # of characters
07351    DF56  F0 B9              BEQ   EndBHS            ; branch if truncate
07352    
07353    DF58  AA                 TAX                     ; copy length to X
07354    DF59  38                 SEC                     ; set carry for add !
07355    DF5A  49 FF              EOR   #$FF              ; 1's complement
07356    DF5C  69 06              ADC   #$06              ; add 6d
07357    DF5E  F0 CB              BEQ   GoPr2             ; if zero print whole string
07358    
07359    DF60  D0 BE              BNE   GoPr1             ; else go make output string (branch always)
07360    
07361    ; convert A to ASCII hex byte and output .. note set decimal mode before calling
07362    
07363    LAB_A2HX
07364    DF62  AA                 TAX                     ; save byte
07365    DF63  29 0F              AND   #$0F              ; mask off top bits
07366    DF65  20 6D DF           JSR   LAB_AL2X          ; convert low nibble to ASCII and output
07367    DF68  8A                 TXA                     ; get byte back
07368    DF69  4A                 LSR                     ; /2  shift high nibble to low nibble
07369    DF6A  4A                 LSR                     ; /4
07370    DF6B  4A                 LSR                     ; /8
07371    DF6C  4A                 LSR                     ; /16
07372    LAB_AL2X
07373    DF6D  C9 0A              CMP   #$0A              ; set carry for +1 if >9
07374    ; *** begin disable decimal mode patch ***
07375    ; *** insert
07376    DF6F  90 02              BCC   LAB_AL20          ; skip adjust if <= 9
07377    DF71  69 06              ADC   #$06              ; adjust for A to F
07378    LAB_AL20
07379    ; *** end   disable decimal mode patch ***
07380    DF73  69 30              ADC   #'0'              ; add ASCII "0"
07381    DF75  91 AD              STA   (str_pl),Y        ; save to temp string
07382    DF77  88                 DEY                     ; decrement counter
07383    DF78  60                 RTS
07384    
07385    LAB_NLTO
07386    DF79  85 AC              STA   FAC1_e            ; save FAC1 exponent
07387    DF7B  A9 00              LDA   #$00              ; clear sign compare
07388    LAB_MLTE
07389    DF7D  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
07390    DF7F  8A                 TXA                     ; restore character
07391    DF80  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
07392    
07393    ; gets here if the first character was "$" for hex
07394    ; get hex number
07395    
07396    LAB_CHEX
07397    DF83  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
07398    DF86  90 0A              BCC   LAB_ISHN          ; branch if numeric character
07399    
07400    DF88  09 20              ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
07401    DF8A  E9 61              SBC   #'a'              ; subtract "a" (carry set here)
07402    DF8C  C9 06              CMP   #$06              ; compare normalised with $06 (max+1)
07403    DF8E  B0 2A              BCS   LAB_EXCH          ; exit if >"f" or <"0"
07404    
07405    DF90  69 0A              ADC   #$0A              ; convert to nibble
07406    LAB_ISHN
07407    DF92  29 0F              AND   #$0F              ; convert to binary
07408    DF94  AA                 TAX                     ; save nibble
07409    DF95  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07410    DF97  F0 E4              BEQ   LAB_MLTE          ; skip multiply if zero
07411    
07412    DF99  69 04              ADC   #$04              ; add four to exponent (*16 - carry clear here)
07413    DF9B  90 DC              BCC   LAB_NLTO          ; if no overflow do evaluate digit
07414    
07415    LAB_MLTO
07416    DF9D  4C D6 D7           JMP   LAB_2564          ; do overflow error and warm start
07417    
07418    LAB_NXCH
07419    DFA0  AA                 TAX                     ; save bit
07420    DFA1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07421    DFA3  F0 06              BEQ   LAB_MLBT          ; skip multiply if zero
07422    
07423    DFA5  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*2)
07424    DFA7  F0 F4              BEQ   LAB_MLTO          ; do overflow error if = $00
07425    
07426    DFA9  A9 00              LDA   #$00              ; clear sign compare
07427    LAB_MLBT
07428    DFAB  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
07429    DFAD  8A                 TXA                     ; restore bit
07430    DFAE  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
07431    
07432    ; gets here if the first character was  "%" for binary
07433    ; get binary number
07434    
07435    LAB_CBIN
07436    DFB1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
07437    DFB4  49 30              EOR   #'0'              ; convert "0" to 0 etc.
07438    DFB6  C9 02              CMP   #$02              ; compare with max+1
07439    DFB8  90 E6              BCC   LAB_NXCH          ; branch exit if < 2
07440    
07441    LAB_EXCH
07442    DFBA  4C 3D DB           JMP   LAB_28F6          ; evaluate -ve flag and return
07443    
07444    ; ctrl-c check routine. includes limited "life" byte save for INGET routine
07445    ; now also the code that checks to see if an interrupt has occurred
07446    
07447    CTRLC
07448    DFBD  AD 00 02           LDA   ccflag            ; get [CTRL-C] check flag
07449    DFC0  D0 18              BNE   LAB_FBA2          ; exit if inhibited
07450    
07451    DFC2  20 FF E1           JSR   V_INPT            ; scan input device
07452    DFC5  90 0B              BCC   LAB_FBA0          ; exit if buffer empty
07453    
07454    DFC7  8D 01 02           STA   ccbyte            ; save received byte
07455    DFCA  A2 20              LDX   #$20              ; "life" timer for bytes
07456    DFCC  8E 02 02           STX   ccnull            ; set countdown
07457    DFCF  4C 1F C6           JMP   LAB_1636          ; return to BASIC
07458    
07459    LAB_FBA0
07460    DFD2  AE 02 02           LDX   ccnull            ; get countdown byte
07461    DFD5  F0 03              BEQ   LAB_FBA2          ; exit if finished
07462    
07463    DFD7  CE 02 02           DEC   ccnull            ; else decrement countdown
07464    LAB_FBA2
07465    DFDA  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
07466    DFDC  20 E5 DF           JSR   LAB_CKIN          ; go check interrupt
07467    DFDF  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
07468    DFE1  20 E5 DF           JSR   LAB_CKIN          ; go check interrupt
07469    LAB_CRTS
07470    DFE4  60                 RTS
07471    
07472    ; check whichever interrupt is indexed by X
07473    
07474    LAB_CKIN
07475    DFE5  B5 00              LDA   PLUS_0,X          ; get interrupt flag byte
07476    DFE7  10 FB              BPL   LAB_CRTS          ; branch if interrupt not enabled
07477    
07478    ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
07479    ; automatically enable the interrupt when we exit
07480    
07481    DFE9  0A                 ASL                     ; move happened bit to setup bit
07482    DFEA  29 40              AND   #$40              ; mask happened bits
07483    DFEC  F0 F6              BEQ   LAB_CRTS          ; if no interrupt then exit
07484    
07485    DFEE  95 00              STA   PLUS_0,X          ; save interrupt flag byte
07486    
07487    DFF0  8A                 TXA                     ; copy index ..
07488    DFF1  A8                 TAY                     ; .. to Y
07489    
07490    DFF2  68                 PLA                     ; dump return address low byte, call from CTRL-C
07491    DFF3  68                 PLA                     ; dump return address high byte
07492    
07493    DFF4  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
07494    DFF6  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
07495    DFF9  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
07496    DFFB  48                 PHA                     ; push on stack
07497    DFFC  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
07498    DFFE  48                 PHA                     ; push on stack
07499    DFFF  A5 88              LDA   Clineh            ; get current line high byte
07500    E001  48                 PHA                     ; push on stack
07501    E002  A5 87              LDA   Clinel            ; get current line low byte
07502    E004  48                 PHA                     ; push on stack
07503    E005  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
07504    E007  48                 PHA                     ; push on stack
07505    
07506    E008  B9 01 00           LDA   PLUS_1,Y          ; get interrupt code pointer low byte
07507    E00B  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
07508    E00D  B9 02 00           LDA   PLUS_2,Y          ; get interrupt code pointer high byte
07509    E010  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
07510    
07511    E012  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
07512                                  ; can't RTS, we used the stack! the RTS from the ctrl-c
07513                                  ; check will be taken when the RETIRQ/RETNMI/RETURN is
07514                                  ; executed at the end of the subroutine
07515    
07516    ; get byte from input device, no waiting
07517    ; returns with carry set if byte in A
07518    
07519    INGET
07520    E015  20 FF E1           JSR   V_INPT            ; call scan input device
07521    E018  B0 09              BCS   LAB_FB95          ; if byte go reset timer
07522    
07523    E01A  AD 02 02           LDA   ccnull            ; get countdown
07524    E01D  F0 09              BEQ   LAB_FB96          ; exit if empty
07525    
07526    E01F  AD 01 02           LDA   ccbyte            ; get last received byte
07527    E022  38                 SEC                     ; flag we got a byte
07528    LAB_FB95
07529    E023  A2 00              LDX   #$00              ; clear X
07530    E025  8E 02 02           STX   ccnull            ; clear timer because we got a byte
07531    LAB_FB96
07532    E028  60                 RTS
07533    
07534    ; these routines only enable the interrupts if the set-up flag is set
07535    ; if not they have no effect
07536    
07537    ; perform IRQ {ON|OFF|CLEAR}
07538    
07539    LAB_IRQ
07540    E029  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
07541          .byte $2C               ; make next line BIT abs.
07542    
07543    ; perform NMI {ON|OFF|CLEAR}
07544    
07545    LAB_NMI
07546    E02C  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
07547    E02E  C9 93              CMP   #TK_ON            ; compare with token for ON
07548    E030  F0 11              BEQ   LAB_INON          ; go turn on interrupt
07549    
07550    E032  C9 BC              CMP   #TK_OFF           ; compare with token for OFF
07551    E034  F0 07              BEQ   LAB_IOFF          ; go turn off interrupt
07552    
07553    E036  49 A2              EOR   #TK_CLEAR         ; compare with token for CLEAR, A = $00 if = TK_CLEAR
07554    E038  F0 0E              BEQ   LAB_INEX          ; go clear interrupt flags and return
07555    
07556    E03A  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
07557    
07558    LAB_IOFF
07559    E03D  A9 7F              LDA   #$7F              ; clear A
07560    E03F  35 00              AND   PLUS_0,X          ; AND with interrupt setup flag
07561    E041  10 05              BPL   LAB_INEX          ; go clear interrupt enabled flag and return
07562    
07563    LAB_INON
07564    E043  B5 00              LDA   PLUS_0,X          ; get interrupt setup flag
07565    E045  0A                 ASL                     ; Shift bit to enabled flag
07566    E046  15 00              ORA   PLUS_0,X          ; OR with flag byte
07567    LAB_INEX
07568    E048  95 00              STA   PLUS_0,X          ; save interrupt flag byte
07569    E04A  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer and return
07570    
07571    ; these routines set up the pointers and flags for the interrupt routines
07572    ; note that the interrupts are also enabled by these commands
07573    
07574    ; perform ON IRQ
07575    
07576    LAB_SIRQ
07577    E04D  58                 CLI                     ; enable interrupts
07578    E04E  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
07579          .byte $2C               ; make next line BIT abs.
07580    
07581    ; perform ON NMI
07582    
07583    LAB_SNMI
07584    E051  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
07585    
07586    E053  86 78              STX   TempB             ; save interrupt pointer
07587    E055  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (past token)
07588    E058  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
07589    E05B  A5 79              LDA   Smeml             ; get start of mem low byte
07590    E05D  A6 7A              LDX   Smemh             ; get start of mem high byte
07591    E05F  20 31 C4           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
07592    E062  B0 03              BCS   LAB_LFND          ; if carry set go set-up interrupt
07593    
07594    E064  4C 76 C7           JMP   LAB_16F7          ; else go do "Undefined statement" error and warm start
07595    
07596    LAB_LFND
07597    E067  A6 78              LDX   TempB             ; get interrupt pointer
07598    E069  A5 AA              LDA   Baslnl            ; get pointer low byte
07599    E06B  E9 01              SBC   #$01              ; -1 (carry already set for subtract)
07600    E06D  95 01              STA   PLUS_1,X          ; save as interrupt pointer low byte
07601    E06F  A5 AB              LDA   Baslnh            ; get pointer high byte
07602    E071  E9 00              SBC   #$00              ; subtract carry
07603    E073  95 02              STA   PLUS_2,X          ; save as interrupt pointer high byte
07604    
07605    E075  A9 C0              LDA   #$C0              ; set interrupt enabled/setup bits
07606    E077  95 00              STA   PLUS_0,X          ; set interrupt flags
07607    LAB_IRTS
07608    E079  60                 RTS
07609    
07610    ; return from IRQ service, restores the enabled flag.
07611    
07612    ; perform RETIRQ
07613    
07614    LAB_RETIRQ
07615    E07A  D0 FD              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
07616    
07617    E07C  A5 DF              LDA   IrqBase           ; get interrupt flags
07618    E07E  0A                 ASL                     ; copy setup to enabled (b7)
07619    E07F  05 DF              ORA   IrqBase           ; OR in setup flag
07620    E081  85 DF              STA   IrqBase           ; save enabled flag
07621    E083  4C 7D C7           JMP   LAB_16E8          ; go do rest of RETURN
07622    
07623    ; return from NMI service, restores the enabled flag.
07624    
07625    ; perform RETNMI
07626    
07627    LAB_RETNMI
07628    E086  D0 F1              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
07629    
07630    E088  A5 DC              LDA   NmiBase           ; get set-up flag
07631    E08A  0A                 ASL                     ; copy setup to enabled (b7)
07632    E08B  05 DC              ORA   NmiBase           ; OR in setup flag
07633    E08D  85 DC              STA   NmiBase           ; save enabled flag
07634    E08F  4C 7D C7           JMP   LAB_16E8          ; go do rest of RETURN
07635    
07636    ; MAX() MIN() pre process
07637    
07638    LAB_MMPP
07639    E092  20 EF CB           JSR   LAB_EVEZ          ; process expression
07640    E095  4C D6 CB           JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
07641    
07642    ; perform MAX()
07643    
07644    LAB_MAX
07645    E098  20 C6 E0           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
07646                                  ; pull FAC2 and compare with FAC1
07647    E09B  10 FB              BPL   LAB_MAX           ; branch if no swap to do
07648    
07649    E09D  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
07650    E09F  09 80              ORA   #$80              ; set top bit (clear sign from compare)
07651    E0A1  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
07652    E0A3  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1
07653    E0A6  F0 F0              BEQ   LAB_MAX           ; go do next (branch always)
07654    
07655    ; perform MIN()
07656    
07657    LAB_MIN
07658    E0A8  20 C6 E0           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
07659                                  ; pull FAC2 and compare with FAC1
07660    E0AB  30 FB              BMI   LAB_MIN           ; branch if no swap to do
07661    
07662    E0AD  F0 F9              BEQ   LAB_MIN           ; branch if no swap to do
07663    
07664    E0AF  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
07665    E0B1  09 80              ORA   #$80              ; set top bit (clear sign from compare)
07666    E0B3  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
07667    E0B5  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1
07668    E0B8  F0 EE              BEQ   LAB_MIN           ; go do next (branch always)
07669    
07670    ; exit routine. don't bother returning to the loop code
07671    ; check for correct exit, else so syntax error
07672    
07673    LAB_MMEC
07674    E0BA  C9 29              CMP   #')'              ; is it end of function?
07675    E0BC  D0 05              BNE   LAB_MMSE          ; if not do MAX MIN syntax error
07676    
07677    E0BE  68                 PLA                     ; dump return address low byte
07678    E0BF  68                 PLA                     ; dump return address high byte
07679    E0C0  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
07680    
07681    LAB_MMSE
07682    E0C3  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
07683    
07684    ; check for next, evaluate and return or exit
07685    ; this is the routine that does most of the work
07686    
07687    LAB_PHFA
07688    E0C6  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
07689    E0C9  C9 2C              CMP   #','              ; is there more ?
07690    E0CB  D0 ED              BNE   LAB_MMEC          ; if not go do end check
07691    
07692                                  ; push FAC1
07693    E0CD  20 EC D9           JSR   LAB_27BA          ; round FAC1
07694    E0D0  A5 B0              LDA   FAC1_s            ; get FAC1 sign
07695    E0D2  09 7F              ORA   #$7F              ; set all non sign bits
07696    E0D4  25 AD              AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
07697    E0D6  48                 PHA                     ; push on stack
07698    E0D7  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
07699    E0D9  48                 PHA                     ; push on stack
07700    E0DA  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
07701    E0DC  48                 PHA                     ; push on stack
07702    E0DD  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07703    E0DF  48                 PHA                     ; push on stack
07704    
07705    E0E0  20 BC 00           JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
07706    E0E3  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
07707                                  ; else do type mismatch
07708    
07709                                  ; pop FAC2 (MAX/MIN expression so far)
07710    E0E6  68                 PLA                     ; pop exponent
07711    E0E7  85 B3              STA   FAC2_e            ; save FAC2 exponent
07712    E0E9  68                 PLA                     ; pop mantissa3
07713    E0EA  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
07714    E0EC  68                 PLA                     ; pop mantissa1
07715    E0ED  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
07716    E0EF  68                 PLA                     ; pop sign/mantissa1
07717    E0F0  85 B4              STA   FAC2_1            ; save FAC2 sign/mantissa1
07718    E0F2  85 B7              STA   FAC2_s            ; save FAC2 sign
07719    
07720                                  ; compare FAC1 with (packed) FAC2
07721    E0F4  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
07722    E0F6  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
07723    E0F8  4C 2A DA           JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
07724                                  ; returns A=$00 if FAC1 = (AY)
07725                                  ; returns A=$01 if FAC1 > (AY)
07726                                  ; returns A=$FF if FAC1 < (AY)
07727    
07728    ; perform WIDTH
07729    
07730    LAB_WDTH
07731    E0FB  C9 2C              CMP   #','              ; is next byte ","
07732    E0FD  F0 1B              BEQ   LAB_TBSZ          ; if so do tab size
07733    
07734    E0FF  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
07735    E102  8A                 TXA                     ; copy width to A
07736    E103  F0 0A              BEQ   LAB_NSTT          ; branch if set for infinite line
07737    
07738    E105  E0 10              CPX   #$10              ; else make min width = 16d
07739    E107  90 45              BCC   TabErr            ; if less do function call error and exit
07740    
07741    ; this next compare ensures that we can't exit WIDTH via an error leaving the
07742    ; tab size greater than the line length.
07743    
07744    E109  E4 64              CPX   TabSiz            ; compare with tab size
07745    E10B  B0 02              BCS   LAB_NSTT          ; branch if >= tab size
07746    
07747    E10D  86 64              STX   TabSiz            ; else make tab size = terminal width
07748    LAB_NSTT
07749    E10F  86 0F              STX   TWidth            ; set the terminal width
07750    E111  20 C2 00           JSR   LAB_GBYT          ; get BASIC byte back
07751    E114  F0 1A              BEQ   WExit             ; exit if no following
07752    
07753    E116  C9 2C              CMP   #','              ; else is it ","
07754    E118  D0 A9              BNE   LAB_MMSE          ; if not do syntax error
07755    
07756    LAB_TBSZ
07757    E11A  20 A3 D5           JSR   LAB_SGBY          ; scan and get byte parameter
07758    E11D  8A                 TXA                     ; copy TAB size
07759    E11E  30 2E              BMI   TabErr            ; if >127 do function call error and exit
07760    
07761    E120  E0 01              CPX   #$01              ; compare with min-1
07762    E122  90 2A              BCC   TabErr            ; if <=1 do function call error and exit
07763    
07764    E124  A5 0F              LDA   TWidth            ; set flags for width
07765    E126  F0 06              BEQ   LAB_SVTB          ; skip check if infinite line
07766    
07767    E128  E4 0F              CPX   TWidth            ; compare TAB with width
07768    E12A  F0 02              BEQ   LAB_SVTB          ; ok if =
07769    
07770    E12C  B0 20              BCS   TabErr            ; branch if too big
07771    
07772    LAB_SVTB
07773    E12E  86 64              STX   TabSiz            ; save TAB size
07774    
07775    ; calculate tab column limit from TAB size. The Iclim is set to the last tab
07776    ; position on a line that still has at least one whole tab width between it
07777    ; and the end of the line.
07778    
07779    WExit
07780    E130  A5 0F              LDA   TWidth            ; get width
07781    E132  F0 06              BEQ   LAB_SULP          ; branch if infinite line
07782    
07783    E134  C5 64              CMP   TabSiz            ; compare with tab size
07784    E136  B0 03              BCS   LAB_WDLP          ; branch if >= tab size
07785    
07786    E138  85 64              STA   TabSiz            ; else make tab size = terminal width
07787    LAB_SULP
07788    E13A  38                 SEC                     ; set carry for subtract
07789    LAB_WDLP
07790    E13B  E5 64              SBC   TabSiz            ; subtract tab size
07791    E13D  B0 FC              BCS   LAB_WDLP          ; loop while no borrow
07792    
07793    E13F  65 64              ADC   TabSiz            ; add tab size back
07794    E141  18                 CLC                     ; clear carry for add
07795    E142  65 64              ADC   TabSiz            ; add tab size back again
07796    E144  85 10              STA   Iclim             ; save for now
07797    E146  A5 0F              LDA   TWidth            ; get width back
07798    E148  38                 SEC                     ; set carry for subtract
07799    E149  E5 10              SBC   Iclim             ; subtract remainder
07800    E14B  85 10              STA   Iclim             ; save tab column limit
07801    LAB_NOSQ
07802    E14D  60                 RTS
07803    
07804    TabErr
07805    E14E  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
07806    
07807    ; perform SQR()
07808    
07809    LAB_SQR
07810    E151  A5 B0              LDA   FAC1_s            ; get FAC1 sign
07811    E153  30 F9              BMI   TabErr            ; if -ve do function call error
07812    
07813    E155  A5 AC              LDA   FAC1_e            ; get exponent
07814    E157  F0 F4              BEQ   LAB_NOSQ          ; if zero just return
07815    
07816                                  ; else do root
07817    E159  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
07818    E15C  A9 00              LDA   #$00              ; clear A
07819    
07820    E15E  85 77              STA   FACt_3            ; clear remainder
07821    E160  85 76              STA   FACt_2            ; ..
07822    E162  85 75              STA   FACt_1            ; ..
07823    E164  85 78              STA   TempB             ; ..
07824    
07825    E166  85 AF              STA   FAC1_3            ; clear root
07826    E168  85 AE              STA   FAC1_2            ; ..
07827    E16A  85 AD              STA   FAC1_1            ; ..
07828    
07829    E16C  A2 18              LDX   #$18              ; 24 pairs of bits to do
07830    E16E  A5 B3              LDA   FAC2_e            ; get exponent
07831    E170  4A                 LSR                     ; check odd/even
07832    E171  B0 0E              BCS   LAB_SQE2          ; if odd only 1 shift first time
07833    
07834    LAB_SQE1
07835    E173  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
07836    E175  26 B5              ROL   FAC2_2            ; ..
07837    E177  26 B4              ROL   FAC2_1            ; ..
07838    E179  26 77              ROL   FACt_3            ; .. into remainder
07839    E17B  26 76              ROL   FACt_2            ; ..
07840    E17D  26 75              ROL   FACt_1            ; ..
07841    E17F  26 78              ROL   TempB             ; .. never overflows
07842    LAB_SQE2
07843    E181  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
07844    E183  26 B5              ROL   FAC2_2            ; ..
07845    E185  26 B4              ROL   FAC2_1            ; ..
07846    E187  26 77              ROL   FACt_3            ; .. into remainder
07847    E189  26 76              ROL   FACt_2            ; ..
07848    E18B  26 75              ROL   FACt_1            ; ..
07849    E18D  26 78              ROL   TempB             ; .. never overflows
07850    
07851    E18F  06 AF              ASL   FAC1_3            ; root = root * 2
07852    E191  26 AE              ROL   FAC1_2            ; ..
07853    E193  26 AD              ROL   FAC1_1            ; .. never overflows
07854    
07855    E195  A5 AF              LDA   FAC1_3            ; get root low byte
07856    E197  2A                 ROL                     ; *2
07857    E198  85 5B              STA   Temp3             ; save partial low byte
07858    E19A  A5 AE              LDA   FAC1_2            ; get root low mid byte
07859    E19C  2A                 ROL                     ; *2
07860    E19D  85 5C              STA   Temp3+1           ; save partial low mid byte
07861    E19F  A5 AD              LDA   FAC1_1            ; get root high mid byte
07862    E1A1  2A                 ROL                     ; *2
07863    E1A2  85 5D              STA   Temp3+2           ; save partial high mid byte
07864    E1A4  A9 00              LDA   #$00              ; get root high byte (always $00)
07865    E1A6  2A                 ROL                     ; *2
07866    E1A7  85 5E              STA   Temp3+3           ; save partial high byte
07867    
07868                                  ; carry clear for subtract +1
07869    E1A9  A5 77              LDA   FACt_3            ; get remainder low byte
07870    E1AB  E5 5B              SBC   Temp3             ; subtract partial low byte
07871    E1AD  85 5B              STA   Temp3             ; save partial low byte
07872    
07873    E1AF  A5 76              LDA   FACt_2            ; get remainder low mid byte
07874    E1B1  E5 5C              SBC   Temp3+1           ; subtract partial low mid byte
07875    E1B3  85 5C              STA   Temp3+1           ; save partial low mid byte
07876    
07877    E1B5  A5 75              LDA   FACt_1            ; get remainder high mid byte
07878    E1B7  E5 5D              SBC   Temp3+2           ; subtract partial high mid byte
07879    E1B9  A8                 TAY                     ; copy partial high mid byte
07880    
07881    E1BA  A5 78              LDA   TempB             ; get remainder high byte
07882    E1BC  E5 5E              SBC   Temp3+3           ; subtract partial high byte
07883    E1BE  90 0E              BCC   LAB_SQNS          ; skip sub if remainder smaller
07884    
07885    E1C0  85 78              STA   TempB             ; save remainder high byte
07886    
07887    E1C2  84 75              STY   FACt_1            ; save remainder high mid byte
07888    
07889    E1C4  A5 5C              LDA   Temp3+1           ; get remainder low mid byte
07890    E1C6  85 76              STA   FACt_2            ; save remainder low mid byte
07891    
07892    E1C8  A5 5B              LDA   Temp3             ; get partial low byte
07893    E1CA  85 77              STA   FACt_3            ; save remainder low byte
07894    
07895    E1CC  E6 AF              INC   FAC1_3            ; increment root low byte (never any rollover)
07896    LAB_SQNS
07897    E1CE  CA                 DEX                     ; decrement bit pair count
07898    E1CF  D0 A2              BNE   LAB_SQE1          ; loop if not all done
07899    
07900    E1D1  38                 SEC                     ; set carry for subtract
07901    E1D2  A5 B3              LDA   FAC2_e            ; get exponent
07902    E1D4  E9 80              SBC   #$80              ; normalise
07903    E1D6  6A                 ROR                     ; /2 and re-bias to $80
07904    E1D7  69 00              ADC   #$00              ; add bit zero back in (allow for half shift)
07905    E1D9  85 AC              STA   FAC1_e            ; save it
07906    E1DB  4C 47 D7           JMP   LAB_24D5          ; normalise FAC1 and return
07907    
07908    ; perform VARPTR()
07909    
07910    LAB_VARPTR
07911    E1DE  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
07912    E1E1  20 BE CE           JSR   LAB_GVAR          ; get var address
07913    E1E4  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
07914    E1E7  A4 95              LDY   Cvaral            ; get var address low byte
07915    E1E9  A5 96              LDA   Cvarah            ; get var address high byte
07916    E1EB  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
07917    
07918    ; perform PI
07919    
07920    LAB_PI
07921    E1EE  A9 DC              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
07922    E1F0  A0 E2              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
07923    E1F2  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
07924    E1F5  C6 AC              DEC   FAC1_e            ; make result = PI
07925    E1F7  60                 RTS
07926    
07927    ; perform TWOPI
07928    
07929    LAB_TWOPI
07930    E1F8  A9 DC              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
07931    E1FA  A0 E2              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
07932    E1FC  4C 90 D9           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
07933    
07934    ; system dependant i/o vectors
07935    ; these are in RAM and are set by the monitor at start-up
07936    
07937    V_INPT
07938    E1FF  6C 05 02           JMP   (VEC_IN)          ; non halting scan input device
07939    V_OUTP
07940    E202  6C 07 02           JMP   (VEC_OUT)         ; send byte to output device
07941    V_LOAD
07942    E205  6C 09 02           JMP   (VEC_LD)          ; load tape file
07943    V_SAVE
07944    E208  6C 0B 02           JMP   (VEC_SV)          ; save tape file
07945    V_VERIFY
07946    E20B  6C 0D 02           JMP   (VEC_VERIFY)      ; verify tape file
07947    V_CAT 
07948    E20E  6C 0F 02           JMP   (VEC_CAT)         ; catalogue tape files
07949    
07950    ; The rest are tables messages and code for RAM
07951    
07952    ; the rest of the code is tables and BASIC start-up code
07953    
07954    PG2_TABS
07955          .byte $00               ; ctrl-c flag           -     $00 = enabled
07956          .byte $00               ; ctrl-c byte           -     GET needs this
07957          .byte $00               ; ctrl-c byte timeout   -     GET needs this
07958          .word CTRLC             ; ctrl c check vector
07959    ;     .word xxxx              ; non halting key input -     monitor to set this
07960    ;     .word xxxx              ; output vector         -     monitor to set this
07961    ;     .word xxxx              ; load vector           -     monitor to set this
07962    ;     .word xxxx              ; save vector           -     monitor to set this
07963    PG2_TABE
07964    
07965    ; character get subroutine for zero page
07966    
07967    ; For a 1.8432MHz 6502 including the JSR and RTS
07968    ; fastest (>=":") =  29 cycles =  15.7uS
07969    ; slowest (<":")  =  40 cycles =  21.7uS
07970    ; space skip      = +21 cycles = +11.4uS
07971    ; inc across page =  +4 cycles =  +2.2uS
07972    
07973    ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
07974    ; block is copied to it's destination, any non zero page address will do at assembly
07975    ; time, to assemble a three byte instruction.
07976    
07977    ; page 0 initialisation table from $BC
07978    ; increment and scan memory
07979    
07980    LAB_2CEE
07981    E216  E6 C3              INC   Bpntrl            ; increment BASIC execute pointer low byte
07982    E218  D0 02              BNE   LAB_2CF4          ; branch if no carry
07983                                  ; else
07984    E21A  E6 C4              INC   Bpntrh            ; increment BASIC execute pointer high byte
07985    
07986    ; page 0 initialisation table from $C2
07987    ; scan memory
07988    
07989    LAB_2CF4
07990    E21C  AD FF FF           LDA   $FFFF             ; get byte to scan (addr set by call routine)
07991    E21F  C9 B3              CMP   #TK_ELSE          ; compare with the token for ELSE
07992    E221  F0 0E              BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
07993    
07994    E223  C9 3A              CMP   #':'              ; compare with ":"
07995    E225  B0 0A              BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
07996    
07997    E227  C9 20              CMP   #' '              ; compare with " "
07998    E229  F0 EB              BEQ   LAB_2CEE          ; if " " go do next
07999    
08000    E22B  38                 SEC                     ; set carry for SBC
08001    E22C  E9 30              SBC   #'0'              ; subtract "0"
08002    E22E  38                 SEC                     ; set carry for SBC
08003    E22F  E9 D0              SBC   #$D0              ; subtract -"0"
08004                                  ; clear carry if byte = "0"-"9"
08005    LAB_2D05
08006    E231  60                 RTS
08007    
08008    ; page zero initialisation table $00-$12 inclusive
08009    
08010    StrTab
08011          .byte $4C               ; JMP opcode
08012          .word LAB_COLD          ; initial warm start vector (cold start)
08013    
08014          .byte $00               ; these bytes are not used by BASIC
08015          .word $0000             ; 
08016          .word $0000             ; 
08017          .word $0000             ; 
08018    
08019          .byte $4C               ; JMP opcode
08020          .word LAB_FCER          ; initial user function vector ("Function call" error)
08021          .byte $00               ; default NULL count
08022          .byte $00               ; clear terminal position
08023          .byte $00               ; default terminal width byte
08024          .byte $F2               ; default limit for TAB = 14
08025          .word Ram_base          ; start of user RAM
08026    EndTab
08027    
08028    LAB_MSZM
08029          .byte $0D,$0A,"Memory size ",$00
08030    
08031    LAB_SMSG
08032          .byte " Bytes free",$0D,$0A,$0A
08033          .byte "Enhanced BASIC 2.22p5 EL2",$0A,$00
08034    
08035    ; numeric constants and series
08036    
08037                                  ; constants and series for LOG(n)
08038    LAB_25A0
08039          .byte $02               ; counter
08040          .byte $80,$19,$56,$62   ; 0.59898
08041          .byte $80,$76,$22,$F3   ; 0.96147
08042    ;##   .byte $80,$76,$22,$F1   ; 0.96147
08043          .byte $82,$38,$AA,$40   ; 2.88539
08044    ;##   .byte $82,$38,$AA,$45   ; 2.88539
08045    
08046    LAB_25AD
08047          .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
08048    LAB_25B1
08049          .byte $81,$35,$04,$F3   ; 1.41421   root 2
08050    LAB_25B5
08051          .byte $80,$80,$00,$00   ; -0.5
08052    LAB_25B9
08053          .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
08054    
08055                                  ; numeric PRINT constants
08056    LAB_2947
08057          .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
08058    LAB_294B
08059          .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
08060    LAB_294F
08061          .byte $94,$74,$24,$00   ; 1000000
08062    
08063                                  ; EXP(n) constants and series
08064    LAB_2AFA
08065          .byte $81,$38,$AA,$3B   ; 1.4427    (1/LOG base 2 e)
08066    LAB_2AFE
08067          .byte $06               ; counter
08068          .byte $74,$63,$90,$8C   ; 2.17023e-4
08069          .byte $77,$23,$0C,$AB   ; 0.00124
08070          .byte $7A,$1E,$94,$00   ; 0.00968
08071          .byte $7C,$63,$42,$80   ; 0.05548
08072          .byte $7E,$75,$FE,$D0   ; 0.24023
08073          .byte $80,$31,$72,$15   ; 0.69315
08074          .byte $81,$00,$00,$00   ; 1.00000
08075    
08076    ;##   .byte $07               ; counter
08077    ;##   .byte $74,$94,$2E,$40   ; -1/7! (-1/5040)
08078    ;##   .byte $77,$2E,$4F,$70   ;  1/6! ( 1/720)
08079    ;##   .byte $7A,$88,$02,$6E   ; -1/5! (-1/120)
08080    ;##   .byte $7C,$2A,$A0,$E6   ;  1/4! ( 1/24)
08081    ;##   .byte $7E,$AA,$AA,$50   ; -1/3! (-1/6)
08082    ;##   .byte $7F,$7F,$FF,$FF   ;  1/2! ( 1/2)
08083    ;##   .byte $81,$80,$00,$00   ; -1/1! (-1/1)
08084    ;##   .byte $81,$00,$00,$00   ;  1/0! ( 1/1)
08085    
08086                                  ; trigonometric constants and series
08087    LAB_2C78
08088          .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
08089    LAB_2C84
08090          .byte $04               ; counter
08091          .byte $86,$1E,$D7,$FB   ; 39.7109
08092    ;##   .byte $86,$1E,$D7,$BA   ; 39.7109
08093          .byte $87,$99,$26,$65   ;-76.575
08094    ;##   .byte $87,$99,$26,$64   ;-76.575
08095          .byte $87,$23,$34,$58   ; 81.6022
08096          .byte $86,$A5,$5D,$E1   ;-41.3417
08097    ;##   .byte $86,$A5,$5D,$E0   ;-41.3417
08098    LAB_2C7C
08099          .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
08100    ;##   .byte $83,$49,$0F,$DA   ; 6.28319 (2*pi) as floating #
08101    
08102    LAB_2CC9
08103          .byte $08               ; counter
08104          .byte $78,$3A,$C5,$37   ; 0.00285
08105          .byte $7B,$83,$A2,$5C   ;-0.0160686
08106          .byte $7C,$2E,$DD,$4D   ; 0.0426915
08107          .byte $7D,$99,$B0,$1E   ;-0.0750429
08108          .byte $7D,$59,$ED,$24   ; 0.106409
08109          .byte $7E,$91,$72,$00   ;-0.142036
08110          .byte $7E,$4C,$B9,$73   ; 0.199926
08111          .byte $7F,$AA,$AA,$53   ;-0.333331
08112    
08113    ;##   .byte $08               ; counter
08114    ;##   .byte $78,$3B,$D7,$4A   ; 1/17
08115    ;##   .byte $7B,$84,$6E,$02   ;-1/15
08116    ;##   .byte $7C,$2F,$C1,$FE   ; 1/13
08117    ;##   .byte $7D,$9A,$31,$74   ;-1/11
08118    ;##   .byte $7D,$5A,$3D,$84   ; 1/9
08119    ;##   .byte $7E,$91,$7F,$C8   ;-1/7
08120    ;##   .byte $7E,$4C,$BB,$E4   ; 1/5
08121    ;##   .byte $7F,$AA,$AA,$6C   ;-1/3
08122    
08123      E302             LAB_1D96    = *+1             ; $00,$00 used for undefined variables
08124    LAB_259C
08125          .byte $81,$00,$00,$00   ; 1.000000, used for INC
08126    LAB_2AFD
08127          .byte $81,$80,$00,$00   ; -1.00000, used for DEC. must be on the same page as +1.00
08128    
08129                                  ; misc constants
08130    LAB_1DF7
08131          .byte $90               ;-32768 (uses first three bytes from 0.5)
08132    LAB_2A96
08133          .byte $80,$00,$00,$00   ; 0.5
08134    LAB_2C80
08135          .byte $7F,$00,$00,$00   ; 0.25
08136    LAB_26B5
08137          .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
08138    
08139    ; This table is used in converting numbers to ASCII.
08140    
08141    LAB_2A9A
08142      E317             LAB_2A9B = LAB_2A9A+1
08143      E318             LAB_2A9C = LAB_2A9B+1
08144          .byte $FE,$79,$60       ; -100000
08145          .byte $00,$27,$10       ; 10000
08146          .byte $FF,$FC,$18       ; -1000
08147          .byte $00,$00,$64       ; 100
08148          .byte $FF,$FF,$F6       ; -10
08149          .byte $00,$00,$01       ; 1
08150    
08151    LAB_CTBL
08152          .word LAB_END-1         ; END
08153          .word LAB_FOR-1         ; FOR
08154          .word LAB_NEXT-1        ; NEXT
08155          .word LAB_DATA-1        ; DATA
08156          .word LAB_INPUT-1       ; INPUT
08157          .word LAB_DIM-1         ; DIM
08158          .word LAB_READ-1        ; READ
08159          .word LAB_LET-1         ; LET
08160          .word LAB_DEC-1         ; DEC             new command
08161          .word LAB_GOTO-1        ; GOTO
08162          .word LAB_RUN-1         ; RUN
08163          .word LAB_IF-1          ; IF
08164          .word LAB_RESTORE-1     ; RESTORE         modified command
08165          .word LAB_GOSUB-1       ; GOSUB
08166          .word LAB_RETIRQ-1      ; RETIRQ          new command
08167          .word LAB_RETNMI-1      ; RETNMI          new command
08168          .word LAB_RETURN-1      ; RETURN
08169          .word LAB_REM-1         ; REM
08170          .word LAB_STOP-1        ; STOP
08171          .word LAB_ON-1          ; ON              modified command
08172          .word LAB_NULL-1        ; NULL            modified command
08173          .word LAB_INC-1         ; INC             new command
08174          .word LAB_WAIT-1        ; WAIT
08175          .word V_LOAD-1          ; LOAD
08176          .word V_SAVE-1          ; SAVE
08177          .word LAB_DEF-1         ; DEF
08178          .word LAB_POKE-1        ; POKE
08179          .word LAB_DOKE-1        ; DOKE            new command
08180          .word LAB_CALL-1        ; CALL            new command
08181          .word LAB_DO-1          ; DO              new command
08182          .word LAB_LOOP-1        ; LOOP            new command
08183          .word LAB_PRINT-1       ; PRINT
08184          .word LAB_CONT-1        ; CONT
08185          .word LAB_LIST-1        ; LIST
08186          .word LAB_CLEAR-1       ; CLEAR
08187          .word LAB_NEW-1         ; NEW
08188          .word LAB_WDTH-1        ; WIDTH           new command
08189          .word LAB_GET-1         ; GET             new command
08190          .word LAB_SWAP-1        ; SWAP            new command
08191          .word LAB_BITSET-1      ; BITSET          new command
08192          .word LAB_BITCLR-1      ; BITCLR          new command
08193          .word LAB_IRQ-1         ; IRQ             new command
08194          .word LAB_NMI-1         ; NMI             new command
08195          .word V_VERIFY-1        ; VERIFY          new command
08196          .word V_CAT-1           ; CAT             new command
08197          .word MON_CLS-1         ; CLS             new command
08198          .word XTRA_LOCATE_F-1   ; LOCATE          new command
08199          .word XTRA_PLOT_F-1     ; PLOT            new command
08200          .word AY_SOUND-1        ; SOUND           new command
08201          .word AY_ENVELOPE-1     ; ENVELOPE        new command
08202          
08203    
08204    ; function pre process routine table
08205    
08206    LAB_FTPL
08207      E38D             LAB_FTPM    = LAB_FTPL+$01
08208          .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
08209          .word LAB_PPFN-1        ; INT(n)          "
08210          .word LAB_PPFN-1        ; ABS(n)          "
08211          .word LAB_EVEZ-1        ; USR(x)    process any expression
08212          .word LAB_1BF7-1        ; FRE(x)          "
08213          .word LAB_1BF7-1        ; POS(x)          "
08214          .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
08215          .word LAB_PPFN-1        ; RND(n)          "
08216          .word LAB_PPFN-1        ; LOG(n)          "
08217          .word LAB_PPFN-1        ; EXP(n)          "
08218          .word LAB_PPFN-1        ; COS(n)          "
08219          .word LAB_PPFN-1        ; SIN(n)          "
08220          .word LAB_PPFN-1        ; TAN(n)          "
08221          .word LAB_PPFN-1        ; ATN(n)          "
08222          .word LAB_PPFN-1        ; PEEK(n)         "
08223          .word LAB_PPFN-1        ; DEEK(n)         "
08224          .word $0000             ; SADD()    none
08225          .word LAB_PPFS-1        ; LEN($)    process string expression in ()
08226          .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
08227          .word LAB_PPFS-1        ; VAL($)    process string expression in ()
08228          .word LAB_PPFS-1        ; ASC($)          "
08229          .word LAB_PPFS-1        ; UCASE$($)       "
08230          .word LAB_PPFS-1        ; LCASE$($)       "
08231          .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
08232          .word LAB_BHSS-1        ; HEX$(n)         "
08233          .word LAB_BHSS-1        ; BIN$(n)         "
08234          .word $0000             ; BITTST()  none
08235          .word LAB_MMPP-1        ; MAX()     process numeric expression
08236          .word LAB_MMPP-1        ; MIN()           "
08237          .word LAB_PPBI-1        ; PI        advance pointer
08238          .word LAB_PPBI-1        ; TWOPI           "
08239          .word $0000             ; VARPTR()  none
08240          .word LAB_LRMS-1        ; LEFT$()   process string expression
08241          .word LAB_LRMS-1        ; RIGHT$()        "
08242          .word LAB_LRMS-1        ; MID$()          "
08243    
08244    ; action addresses for functions
08245    
08246    LAB_FTBL
08247      E3D3             LAB_FTBM    = LAB_FTBL+$01
08248          .word LAB_SGN-1         ; SGN()
08249          .word LAB_INT-1         ; INT()
08250          .word LAB_ABS-1         ; ABS()
08251          .word LAB_USR-1         ; USR()
08252          .word LAB_FRE-1         ; FRE()
08253          .word LAB_POS-1         ; POS()
08254          .word LAB_SQR-1         ; SQR()
08255          .word LAB_RND-1         ; RND()           modified function
08256          .word LAB_LOG-1         ; LOG()
08257          .word LAB_EXP-1         ; EXP()
08258          .word LAB_COS-1         ; COS()
08259          .word LAB_SIN-1         ; SIN()
08260          .word LAB_TAN-1         ; TAN()
08261          .word LAB_ATN-1         ; ATN()
08262          .word LAB_PEEK-1        ; PEEK()
08263          .word LAB_DEEK-1        ; DEEK()          new function
08264          .word LAB_SADD-1        ; SADD()          new function
08265          .word LAB_LENS-1        ; LEN()
08266          .word LAB_STRS-1        ; STR$()
08267          .word LAB_VAL-1         ; VAL()
08268          .word LAB_ASC-1         ; ASC()
08269          .word LAB_UCASE-1       ; UCASE$()        new function
08270          .word LAB_LCASE-1       ; LCASE$()        new function
08271          .word LAB_CHRS-1        ; CHR$()
08272          .word LAB_HEXS-1        ; HEX$()          new function
08273          .word LAB_BINS-1        ; BIN$()          new function
08274          .word LAB_BTST-1        ; BITTST()        new function
08275          .word LAB_MAX-1         ; MAX()           new function
08276          .word LAB_MIN-1         ; MIN()           new function
08277          .word LAB_PI-1          ; PI              new function
08278          .word LAB_TWOPI-1       ; TWOPI           new function
08279          .word LAB_VARPTR-1      ; VARPTR()        new function
08280          .word LAB_LEFT-1        ; LEFT$()
08281          .word LAB_RIGHT-1       ; RIGHT$()
08282          .word LAB_MIDS-1        ; MID$()
08283    
08284    ; hierarchy and action addresses for operator
08285    
08286    LAB_OPPT
08287          .byte $79               ; +
08288          .word LAB_ADD-1
08289          .byte $79               ; -
08290          .word LAB_SUBTRACT-1
08291          .byte $7B               ; *
08292          .word LAB_MULTIPLY-1
08293          .byte $7B               ; /
08294          .word LAB_DIVIDE-1
08295          .byte $7F               ; ^
08296          .word LAB_POWER-1
08297          .byte $50               ; AND
08298          .word LAB_AND-1
08299          .byte $46               ; EOR             new operator
08300          .word LAB_EOR-1
08301          .byte $46               ; OR
08302          .word LAB_OR-1
08303          .byte $56               ; >>              new operator
08304          .word LAB_RSHIFT-1
08305          .byte $56               ; <<              new operator
08306          .word LAB_LSHIFT-1
08307          .byte $7D               ; >
08308          .word LAB_GTHAN-1
08309          .byte $5A               ; =
08310          .word LAB_EQUAL-1
08311          .byte $64               ; <
08312          .word LAB_LTHAN-1
08313    
08314    ; keywords start with ..
08315    ; this is the first character table and must be in alphabetic order
08316    
08317    TAB_1STC
08318          .byte "*"
08319          .byte "+"
08320          .byte "-"
08321          .byte "/"
08322          .byte "<"
08323          .byte "="
08324          .byte ">"
08325          .byte "?"
08326          .byte "A"
08327          .byte "B"
08328          .byte "C"
08329          .byte "D"
08330          .byte "E"
08331          .byte "F"
08332          .byte "G"
08333          .byte "H"
08334          .byte "I"
08335          .byte "L"
08336          .byte "M"
08337          .byte "N"
08338          .byte "O"
08339          .byte "P"
08340          .byte "R"
08341          .byte "S"
08342          .byte "T"
08343          .byte "U"
08344          .byte "V"
08345          .byte "W"
08346          .byte "^"
08347          .byte $00               ; table terminator
08348    
08349    ; pointers to keyword tables
08350    
08351    TAB_CHRT
08352          .word TAB_STAR          ; table for "*"
08353          .word TAB_PLUS          ; table for "+"
08354          .word TAB_MNUS          ; table for "-"
08355          .word TAB_SLAS          ; table for "/"
08356          .word TAB_LESS          ; table for "<"
08357          .word TAB_EQUL          ; table for "="
08358          .word TAB_MORE          ; table for ">"
08359          .word TAB_QEST          ; table for "?"
08360          .word TAB_ASCA          ; table for "A"
08361          .word TAB_ASCB          ; table for "B"
08362          .word TAB_ASCC          ; table for "C"
08363          .word TAB_ASCD          ; table for "D"
08364          .word TAB_ASCE          ; table for "E"
08365          .word TAB_ASCF          ; table for "F"
08366          .word TAB_ASCG          ; table for "G"
08367          .word TAB_ASCH          ; table for "H"
08368          .word TAB_ASCI          ; table for "I"
08369          .word TAB_ASCL          ; table for "L"
08370          .word TAB_ASCM          ; table for "M"
08371          .word TAB_ASCN          ; table for "N"
08372          .word TAB_ASCO          ; table for "O"
08373          .word TAB_ASCP          ; table for "P"
08374          .word TAB_ASCR          ; table for "R"
08375          .word TAB_ASCS          ; table for "S"
08376          .word TAB_ASCT          ; table for "T"
08377          .word TAB_ASCU          ; table for "U"
08378          .word TAB_ASCV          ; table for "V"
08379          .word TAB_ASCW          ; table for "W"
08380          .word TAB_POWR          ; table for "^"
08381    
08382    ; tables for each start character, note if a longer keyword with the same start
08383    ; letters as a shorter one exists then it must come first, else the list is in
08384    ; alphabetical order as follows ..
08385    
08386    ; [keyword,token
08387    ; [keyword,token]]
08388    ; end marker (#$00)
08389    
08390    TAB_STAR
08391          .byte TK_MUL,$00        ; *
08392    TAB_PLUS
08393          .byte TK_PLUS,$00       ; +
08394    TAB_MNUS
08395          .byte TK_MINUS,$00      ; -
08396    TAB_SLAS
08397          .byte TK_DIV,$00        ; /
08398    TAB_LESS
08399    LBB_LSHIFT
08400          .byte "<",TK_LSHIFT     ; <<  note - "<<" must come before "<"
08401          .byte TK_LT             ; <
08402          .byte $00
08403    TAB_EQUL
08404          .byte TK_EQUAL,$00      ; =
08405    TAB_MORE
08406    LBB_RSHIFT
08407          .byte ">",TK_RSHIFT     ; >>  note - ">>" must come before ">"
08408          .byte TK_GT             ; >
08409          .byte $00
08410    TAB_QEST
08411          .byte TK_PRINT,$00      ; ?
08412    TAB_ASCA
08413    LBB_ABS
08414          .byte "BS(",TK_ABS      ; ABS(
08415    LBB_AND
08416          .byte "ND",TK_AND       ; AND
08417    LBB_ASC
08418          .byte "SC(",TK_ASC      ; ASC(
08419    LBB_ATN
08420          .byte "TN(",TK_ATN      ; ATN(
08421          .byte $00
08422    TAB_ASCB
08423    LBB_BINS
08424          .byte "IN$(",TK_BINS    ; BIN$(
08425    LBB_BITCLR
08426          .byte "ITCLR",TK_BITCLR ; BITCLR
08427    LBB_BITSET
08428          .byte "ITSET",TK_BITSET ; BITSET
08429    LBB_BITTST
08430          .byte "ITTST(",TK_BITTST
08431                                  ; BITTST(
08432          .byte $00
08433    TAB_ASCC
08434    LBB_CAT
08435          .byte "AT",TK_CAT       ; CAT
08436    LBB_CALL
08437          .byte "ALL",TK_CALL     ; CALL
08438    LBB_CHRS
08439          .byte "HR$(",TK_CHRS    ; CHR$(
08440    LBB_CLS
08441          .byte "LS",TK_CLS       ; CLS
08442    LBB_CLEAR
08443          .byte "LEAR",TK_CLEAR   ; CLEAR
08444    LBB_CONT
08445          .byte "ONT",TK_CONT     ; CONT
08446    LBB_COS
08447          .byte "OS(",TK_COS      ; COS(
08448          .byte $00
08449    TAB_ASCD
08450    LBB_DATA
08451          .byte "ATA",TK_DATA     ; DATA
08452    LBB_DEC
08453          .byte "EC",TK_DEC       ; DEC
08454    LBB_DEEK
08455          .byte "EEK(",TK_DEEK    ; DEEK(
08456    LBB_DEF
08457          .byte "EF",TK_DEF       ; DEF
08458    LBB_DIM
08459          .byte "IM",TK_DIM       ; DIM
08460    LBB_DOKE
08461          .byte "OKE",TK_DOKE     ; DOKE note - "DOKE" must come before "DO"
08462    LBB_DO
08463          .byte "O",TK_DO         ; DO
08464          .byte $00
08465    TAB_ASCE
08466    LBB_ELSE
08467          .byte "LSE",TK_ELSE     ; ELSE
08468    LBB_END
08469          .byte "ND",TK_END       ; END
08470    LBB_ENVELOPE
08471          .byte "NVELOPE", TK_ENVELOPE ; ENVELOPE
08472    LBB_EOR
08473          .byte "OR",TK_EOR       ; EOR
08474    LBB_EXP
08475          .byte "XP(",TK_EXP      ; EXP(
08476          .byte $00
08477    TAB_ASCF
08478    LBB_FN
08479          .byte "N",TK_FN         ; FN
08480    LBB_FOR
08481          .byte "OR",TK_FOR       ; FOR
08482    LBB_FRE
08483          .byte "RE(",TK_FRE      ; FRE(
08484          .byte $00
08485    TAB_ASCG
08486    LBB_GET
08487          .byte "ET",TK_GET       ; GET
08488    LBB_GOSUB
08489          .byte "OSUB",TK_GOSUB   ; GOSUB
08490    LBB_GOTO
08491          .byte "OTO",TK_GOTO     ; GOTO
08492          .byte $00
08493    TAB_ASCH
08494    LBB_HEXS
08495          .byte "EX$(",TK_HEXS    ; HEX$(
08496          .byte $00
08497    TAB_ASCI
08498    LBB_IF
08499          .byte "F",TK_IF         ; IF
08500    LBB_INC
08501          .byte "NC",TK_INC       ; INC
08502    LBB_INPUT
08503          .byte "NPUT",TK_INPUT   ; INPUT
08504    LBB_INT
08505          .byte "NT(",TK_INT      ; INT(
08506    LBB_IRQ
08507          .byte "RQ",TK_IRQ       ; IRQ
08508          .byte $00
08509    TAB_ASCL
08510    LBB_LCASES
08511          .byte "CASE$(",TK_LCASES
08512                                  ; LCASE$(
08513    LBB_LEFTS
08514          .byte "EFT$(",TK_LEFTS  ; LEFT$(
08515    LBB_LEN
08516          .byte "EN(",TK_LEN      ; LEN(
08517    LBB_LET
08518          .byte "ET",TK_LET       ; LET
08519    LBB_LIST
08520          .byte "IST",TK_LIST     ; LIST
08521    LBB_LOAD
08522          .byte "OAD",TK_LOAD     ; LOAD
08523    ; FINDME:-      
08524    LBB_LOCATE
08525          .byte "OCATE",TK_LOCATE ; LOCATE
08526          
08527    LBB_LOG
08528          .byte "OG(",TK_LOG      ; LOG(
08529    LBB_LOOP
08530          .byte "OOP",TK_LOOP     ; LOOP
08531          .byte $00
08532    TAB_ASCM
08533    LBB_MAX
08534          .byte "AX(",TK_MAX      ; MAX(
08535    LBB_MIDS
08536          .byte "ID$(",TK_MIDS    ; MID$(
08537    LBB_MIN
08538          .byte "IN(",TK_MIN      ; MIN(
08539          .byte $00
08540    TAB_ASCN
08541    LBB_NEW
08542          .byte "EW",TK_NEW       ; NEW
08543    LBB_NEXT
08544          .byte "EXT",TK_NEXT     ; NEXT
08545    LBB_NMI
08546          .byte "MI",TK_NMI       ; NMI
08547    LBB_NOT
08548          .byte "OT",TK_NOT       ; NOT
08549    LBB_NULL
08550          .byte "ULL",TK_NULL     ; NULL
08551          .byte $00
08552    TAB_ASCO
08553    LBB_OFF
08554          .byte "FF",TK_OFF       ; OFF
08555    LBB_ON
08556          .byte "N",TK_ON         ; ON
08557    LBB_OR
08558          .byte "R",TK_OR         ; OR
08559          .byte $00
08560    TAB_ASCP
08561    LBB_PEEK
08562          .byte "EEK(",TK_PEEK    ; PEEK(
08563    LBB_PI
08564          .byte "I",TK_PI         ; PI
08565    
08566    LBB_PLOT
08567          .byte "LOT",TK_PLOT     ; PLOT      
08568          
08569    LBB_POKE
08570          .byte "OKE",TK_POKE     ; POKE
08571    LBB_POS
08572          .byte "OS(",TK_POS      ; POS(
08573    LBB_PRINT
08574          .byte "RINT",TK_PRINT   ; PRINT
08575          .byte $00
08576    TAB_ASCR
08577    LBB_READ
08578          .byte "EAD",TK_READ     ; READ
08579    LBB_REM
08580          .byte "EM",TK_REM       ; REM
08581    LBB_RESTORE
08582          .byte "ESTORE",TK_RESTORE
08583                                  ; RESTORE
08584    LBB_RETIRQ
08585          .byte "ETIRQ",TK_RETIRQ ; RETIRQ
08586    LBB_RETNMI
08587          .byte "ETNMI",TK_RETNMI ; RETNMI
08588    LBB_RETURN
08589          .byte "ETURN",TK_RETURN ; RETURN
08590    LBB_RIGHTS
08591          .byte "IGHT$(",TK_RIGHTS
08592                                  ; RIGHT$(
08593    LBB_RND
08594          .byte "ND(",TK_RND      ; RND(
08595    LBB_RUN
08596          .byte "UN",TK_RUN       ; RUN
08597          .byte $00
08598    TAB_ASCS
08599    LBB_SADD
08600          .byte "ADD(",TK_SADD    ; SADD(
08601    LBB_SAVE
08602          .byte "AVE",TK_SAVE     ; SAVE
08603    LBB_SGN
08604          .byte "GN(",TK_SGN      ; SGN(
08605    LBB_SIN
08606          .byte "IN(",TK_SIN      ; SIN(
08607    LBB_SOUND
08608          .byte "OUND",TK_SOUND   ; SOUND
08609    LBB_SPC
08610          .byte "PC(",TK_SPC      ; SPC(
08611    LBB_SQR
08612          .byte "QR(",TK_SQR      ; SQR(
08613    LBB_STEP
08614          .byte "TEP",TK_STEP     ; STEP
08615    LBB_STOP
08616          .byte "TOP",TK_STOP     ; STOP
08617    LBB_STRS
08618          .byte "TR$(",TK_STRS    ; STR$(
08619    LBB_SWAP
08620          .byte "WAP",TK_SWAP     ; SWAP
08621          .byte $00
08622    TAB_ASCT
08623    LBB_TAB
08624          .byte "AB(",TK_TAB      ; TAB(
08625    LBB_TAN
08626          .byte "AN(",TK_TAN      ; TAN(
08627    LBB_THEN
08628          .byte "HEN",TK_THEN     ; THEN
08629    LBB_TO
08630          .byte "O",TK_TO         ; TO
08631    LBB_TWOPI
08632          .byte "WOPI",TK_TWOPI   ; TWOPI
08633          .byte $00
08634    TAB_ASCU
08635    LBB_UCASES
08636          .byte "CASE$(",TK_UCASES
08637                                  ; UCASE$(
08638    LBB_UNTIL
08639          .byte "NTIL",TK_UNTIL   ; UNTIL
08640    LBB_USR
08641          .byte "SR(",TK_USR      ; USR(
08642          .byte $00
08643    TAB_ASCV
08644    LBB_VAL
08645          .BYTE "AL(",TK_VAL      ; VAL(
08646    LBB_VPTR
08647          .byte "ARPTR(",TK_VPTR  ; VARPTR(
08648    LBB_VERIFY
08649          .BYTE "ERIFY",TK_VERIFY ; VERIFY
08650          .byte $00
08651    TAB_ASCW
08652    LBB_WAIT
08653          .byte "AIT",TK_WAIT     ; WAIT
08654    LBB_WHILE
08655          .byte "HILE",TK_WHILE   ; WHILE
08656    LBB_WIDTH
08657          .byte "IDTH",TK_WIDTH   ; WIDTH
08658          .byte $00
08659    TAB_POWR
08660          .byte TK_POWER,$00      ; ^
08661    
08662    ; new decode table for LIST
08663    ; Table is ..
08664    ; byte - keyword length, keyword first character
08665    ; word - pointer to rest of keyword from dictionary
08666    
08667    ; note if length is 1 then the pointer is ignored
08668    
08669    LAB_KEYT
08670          .byte 3,'E'
08671          .word LBB_END           ; END
08672          .byte 3,'F'
08673          .word LBB_FOR           ; FOR
08674          .byte 4,'N'
08675          .word LBB_NEXT          ; NEXT
08676          .byte 4,'D'
08677          .word LBB_DATA          ; DATA
08678          .byte 5,'I'
08679          .word LBB_INPUT         ; INPUT
08680          .byte 3,'D'
08681          .word LBB_DIM           ; DIM
08682          .byte 4,'R'
08683          .word LBB_READ          ; READ
08684          .byte 3,'L'
08685          .word LBB_LET           ; LET
08686          .byte 3,'D'
08687          .word LBB_DEC           ; DEC
08688          .byte 4,'G'
08689          .word LBB_GOTO          ; GOTO
08690          .byte 3,'R'
08691          .word LBB_RUN           ; RUN
08692          .byte 2,'I'
08693          .word LBB_IF            ; IF
08694          .byte 7,'R'
08695          .word LBB_RESTORE       ; RESTORE
08696          .byte 5,'G'
08697          .word LBB_GOSUB         ; GOSUB
08698          .byte 6,'R'
08699          .word LBB_RETIRQ        ; RETIRQ
08700          .byte 6,'R'
08701          .word LBB_RETNMI        ; RETNMI
08702          .byte 6,'R'
08703          .word LBB_RETURN        ; RETURN
08704          .byte 3,'R'
08705          .word LBB_REM           ; REM
08706          .byte 4,'S'
08707          .word LBB_STOP          ; STOP
08708          .byte 2,'O'
08709          .word LBB_ON            ; ON
08710          .byte 4,'N'
08711          .word LBB_NULL          ; NULL
08712          .byte 3,'I'
08713          .word LBB_INC           ; INC
08714          .byte 4,'W'
08715          .word LBB_WAIT          ; WAIT
08716          .byte 4,'L'
08717          .word LBB_LOAD          ; LOAD
08718          .byte 4,'S'
08719          .word LBB_SAVE          ; SAVE
08720          .byte 3,'D'
08721          .word LBB_DEF           ; DEF
08722          .byte 4,'P'
08723          .word LBB_POKE          ; POKE
08724          .byte 4,'D'
08725          .word LBB_DOKE          ; DOKE
08726          .byte 4,'C'
08727          .word LBB_CALL          ; CALL
08728          .byte 2,'D'
08729          .word LBB_DO            ; DO
08730          .byte 4,'L'
08731          .word LBB_LOOP          ; LOOP
08732          .byte 5,'P'
08733          .word LBB_PRINT         ; PRINT
08734          .byte 4,'C'
08735          .word LBB_CONT          ; CONT
08736          .byte 4,'L'
08737          .word LBB_LIST          ; LIST
08738          .byte 5,'C'
08739          .word LBB_CLEAR         ; CLEAR
08740          .byte 3,'N'
08741          .word LBB_NEW           ; NEW
08742          .byte 5,'W'
08743          .word LBB_WIDTH         ; WIDTH
08744          .byte 3,'G'
08745          .word LBB_GET           ; GET
08746          .byte 4,'S'
08747          .word LBB_SWAP          ; SWAP
08748          .byte 6,'B'
08749          .word LBB_BITSET        ; BITSET
08750          .byte 6,'B'
08751          .word LBB_BITCLR        ; BITCLR
08752          .byte 3,'I'
08753          .word LBB_IRQ           ; IRQ
08754          .byte 3,'N'
08755          .word LBB_NMI           ; NMI
08756          .byte 6,'V'
08757          .word LBB_VERIFY        ; VERIFY
08758          .byte 3,'C'
08759          .word LBB_CAT           ; CAT
08760          .byte 3,'C'
08761          .word LBB_CLS           ; CLS
08762          .byte 6,'L'
08763          .word LBB_LOCATE        ; LOCATE
08764          .byte 4,'P'
08765          .word LBB_PLOT          ; PLOT
08766          .byte 5,'S'
08767          .word LBB_SOUND         ; SOUND
08768          .byte 8,'E'
08769          .word LBB_ENVELOPE      ; ENVELOPE
08770    
08771    
08772    ; secondary commands (can't start a statement)
08773    
08774          .byte 4,'T'
08775          .word LBB_TAB           ; TAB
08776          .byte 4,'E'
08777          .word LBB_ELSE          ; ELSE
08778          .byte 2,'T'
08779          .word LBB_TO            ; TO
08780          .byte 2,'F'
08781          .word LBB_FN            ; FN
08782          .byte 4,'S'
08783          .word LBB_SPC           ; SPC
08784          .byte 4,'T'
08785          .word LBB_THEN          ; THEN
08786          .byte 3,'N'
08787          .word LBB_NOT           ; NOT
08788          .byte 4,'S'
08789          .word LBB_STEP          ; STEP
08790          .byte 5,'U'
08791          .word LBB_UNTIL         ; UNTIL
08792          .byte 5,'W'
08793          .word LBB_WHILE         ; WHILE
08794          .byte 3,'O'
08795          .word LBB_OFF           ; OFF
08796    
08797    ; operators
08798    
08799          .byte 1,'+'
08800          .word $0000             ; +
08801          .byte 1,'-'
08802          .word $0000             ; -
08803          .byte 1,'*'
08804          .word $0000             ; *
08805          .byte 1,'/'
08806          .word $0000             ; /
08807          .byte 1,'^'
08808          .word $0000             ; ^
08809          .byte 3,'A'
08810          .word LBB_AND           ; AND
08811          .byte 3,'E'
08812          .word LBB_EOR           ; EOR
08813          .byte 2,'O'
08814          .word LBB_OR            ; OR
08815          .byte 2,'>'
08816          .word LBB_RSHIFT        ; >>
08817          .byte 2,'<'
08818          .word LBB_LSHIFT        ; <<
08819          .byte 1,'>'
08820          .word $0000             ; >
08821          .byte 1,'='
08822          .word $0000             ; =
08823          .byte 1,'<'
08824          .word $0000             ; <
08825    
08826    ; functions
08827    
08828          .byte 4,'S'             ;
08829          .word LBB_SGN           ; SGN
08830          .byte 4,'I'             ;
08831          .word LBB_INT           ; INT
08832          .byte 4,'A'             ;
08833          .word LBB_ABS           ; ABS
08834          .byte 4,'U'             ;
08835          .word LBB_USR           ; USR
08836          .byte 4,'F'             ;
08837          .word LBB_FRE           ; FRE
08838          .byte 4,'P'             ;
08839          .word LBB_POS           ; POS
08840          .byte 4,'S'             ;
08841          .word LBB_SQR           ; SQR
08842          .byte 4,'R'             ;
08843          .word LBB_RND           ; RND
08844          .byte 4,'L'             ;
08845          .word LBB_LOG           ; LOG
08846          .byte 4,'E'             ;
08847          .word LBB_EXP           ; EXP
08848          .byte 4,'C'             ;
08849          .word LBB_COS           ; COS
08850          .byte 4,'S'             ;
08851          .word LBB_SIN           ; SIN
08852          .byte 4,'T'             ;
08853          .word LBB_TAN           ; TAN
08854          .byte 4,'A'             ;
08855          .word LBB_ATN           ; ATN
08856          .byte 5,'P'             ;
08857          .word LBB_PEEK          ; PEEK
08858          .byte 5,'D'             ;
08859          .word LBB_DEEK          ; DEEK
08860          .byte 5,'S'             ;
08861          .word LBB_SADD          ; SADD
08862          .byte 4,'L'             ;
08863          .word LBB_LEN           ; LEN
08864          .byte 5,'S'             ;
08865          .word LBB_STRS          ; STR$
08866          .byte 4,'V'             ;
08867          .word LBB_VAL           ; VAL
08868          .byte 4,'A'             ;
08869          .word LBB_ASC           ; ASC
08870          .byte 7,'U'             ;
08871          .word LBB_UCASES        ; UCASE$
08872          .byte 7,'L'             ;
08873          .word LBB_LCASES        ; LCASE$
08874          .byte 5,'C'             ;
08875          .word LBB_CHRS          ; CHR$
08876          .byte 5,'H'             ;
08877          .word LBB_HEXS          ; HEX$
08878          .byte 5,'B'             ;
08879          .word LBB_BINS          ; BIN$
08880          .byte 7,'B'             ;
08881          .word LBB_BITTST        ; BITTST
08882          .byte 4,'M'             ;
08883          .word LBB_MAX           ; MAX
08884          .byte 4,'M'             ;
08885          .word LBB_MIN           ; MIN
08886          .byte 2,'P'             ;
08887          .word LBB_PI            ; PI
08888          .byte 5,'T'             ;
08889          .word LBB_TWOPI         ; TWOPI
08890          .byte 7,'V'             ;
08891          .word LBB_VPTR          ; VARPTR
08892          .byte 6,'L'             ;
08893          .word LBB_LEFTS         ; LEFT$
08894          .byte 7,'R'             ;
08895          .word LBB_RIGHTS        ; RIGHT$
08896          .byte 5,'M'             ;
08897          .word LBB_MIDS          ; MID$
08898    
08899    ; BASIC messages, mostly error messages
08900    
08901    LAB_BAER
08902          .word ERR_NF            ;$00 NEXT without FOR
08903          .word ERR_SN            ;$02 syntax
08904          .word ERR_RG            ;$04 RETURN without GOSUB
08905          .word ERR_OD            ;$06 out of data
08906          .word ERR_FC            ;$08 function call
08907          .word ERR_OV            ;$0A overflow
08908          .word ERR_OM            ;$0C out of memory
08909          .word ERR_US            ;$0E undefined statement
08910          .word ERR_BS            ;$10 array bounds
08911          .word ERR_DD            ;$12 double dimension array
08912          .word ERR_D0            ;$14 divide by 0
08913          .word ERR_ID            ;$16 illegal direct
08914          .word ERR_TM            ;$18 type mismatch
08915          .word ERR_LS            ;$1A long string
08916          .word ERR_ST            ;$1C string too complex
08917          .word ERR_CN            ;$1E continue error
08918          .word ERR_UF            ;$20 undefined function
08919          .word ERR_LD            ;$22 LOOP without DO
08920          .word ERR_BF            ;$24 Filename too long
08921    
08922    ; I may implement these two errors to force definition of variables and
08923    ; dimensioning of arrays before use.
08924    
08925    ;     .word ERR_UV            ;$24 undefined variable
08926    
08927    ; the above error has been tested and works (see code and comments below LAB_1D8B)
08928    
08929    ;     .word ERR_UA            ;$26 undimensioned array
08930    
08931    ERR_NF      .byte "NEXT without FOR",$00
08932    ERR_SN      .byte "Syntax",$00
08933    ERR_RG      .byte "RETURN without GOSUB",$00
08934    ERR_OD      .byte "Out of DATA",$00
08935    ERR_FC      .byte "Function call",$00
08936    ERR_OV      .byte "Overflow",$00
08937    ERR_OM      .byte "Out of memory",$00
08938    ERR_US      .byte "Undefined statement",$00
08939    ERR_BS      .byte "Array bounds",$00
08940    ERR_DD      .byte "Double dimension",$00
08941    ERR_D0      .byte "Divide by zero",$00
08942    ERR_ID      .byte "Illegal direct",$00
08943    ERR_TM      .byte "Type mismatch",$00
08944    ERR_LS      .byte "String too long",$00
08945    ERR_ST      .byte "String too complex",$00
08946    ERR_CN      .byte "Can't continue",$00
08947    ERR_UF      .byte "Undefined function",$00
08948    ERR_LD      .byte "LOOP without DO",$00
08949    ERR_BF      .byte "Filename too long",$00
08950    
08951    ;ERR_UV     .byte "Undefined variable",$00
08952    
08953    ; the above error has been tested and works (see code and comments below LAB_1D8B)
08954    
08955    ;ERR_UA     .byte "Undimensioned array",$00
08956    
08957    LAB_BMSG    .byte $0D,$0A,"Break",$00
08958    LAB_EMSG    .byte " Error",$00
08959    LAB_LMSG    .byte " in line ",$00
08960    LAB_RMSG    .byte $0D,$0A,"Ready",$0D,$0A,$00
08961    
08962    LAB_IMSG    .byte " Extra ignored",$0D,$0A,$00
08963    LAB_REDO    .byte " Redo from start",$0D,$0A,$00
08964    
08965    AA_end_basic
08966    AA_end_basic
08967    ; put the IRQ and MNI code in RAM so that it can be changed
08968    
08969    ; IRQ_vec	= VEC_SV+2              ; Previous IRQ code vector
08970      F9AD             IRQ_vec		= IRQH_ProcessIRQs	; IRQ code vector
08971      F9B7             NMI_vec		= IRQ_vec+$0A           ; NMI code vector
08972    
08973    
08974    ; OS System variables live here
08975    
08976      05E0             MON_sysvars	= $5E0			; base address of the 16 bytes of memory reserved
08977      05E0             os_outsel	= MON_sysvars		; output selection variable
08978      05E1             os_infilt	= os_outsel+1		; Filter switches for character input filtering.
08979      05E2             os_insel	= os_infilt+1		; Input source for BASIC inputs.
08980    
08981      00E7             TOE_MemptrLo  = $E7			; General purpose memory pointer low byte
08982      00E8             TOE_MemptrHi  = $E8			; General purpose memory pointer high byte
08983    
08984    
08985    ; OS Bit Definitions
08986    
08987      0001             ACIA1_out_sw	= @00000001
08988      0002             ANSI_out_sw	= @00000010
08989      0004             TPB_out_sw	= @00000100
08990      0008             ACIA2_out_sw	= @00001000
08991      0010             TAPE_out_sw	= @00010000
08992      0001             OS_input_ACIA1  = @00000001
08993      0008             OS_input_ACIA2  = @00001000
08994      0010             OS_input_TAPE   = @00010000
08995    
08996    
08997    ; OS Constants
08998    
08999      1000             MON_CR_Delay_C  = $1000
09000    
09001    
09002    ; now the code. This sets up the vectors, interrupt code,
09003    ; and waits for the user to select [C]old or [W]arm start.
09004    ;
09005    ; Also, during the running phase, the extra OS features are hosted here.
09006    
09007      .ROM_AREA $C100,$FFFF
09008      
09009    EC00                 *= $EC00                              ; Give ourselves room for the OS. Formerly F000
09010      .INCLUDE "ACIA.asm"
09011    ; Duncan's 6551 ACIA Library
09012    ;
09013    
09014    ; This is the configuration section for the ACIA.
09015    ;
09016    ; Make changes to setup here.
09017    ;
09018      001E             ACIA_CTRL_IDLE = ACIA_WL8 | ACIA_RCS_BRG | ACIA_9600 | ACIA_TIC_10
09019      001E             ACIA_CTRL_LISTEN = ACIA_WL8 | ACIA_RCS_BRG | ACIA_9600 | ACIA_TIC_00
09020      008B             ACIA_CMD_SETUP  = ACIA_PMC_DIS | ACIA_PME_DIS | ACIA_REM_OFF | ACIA_TIC_10 | ACIA_INT_DIS | ACIA_DTR_RDY
09021    
09022    
09023    ; ACIA1 Registers
09024    
09025      C010             ACIA1_base     = $C010                 ; Change as needed later.
09026      C010             ACIA1_tx       = ACIA1_base
09027      C010             ACIA1_rx       = ACIA1_base
09028      C011             ACIA1_sts      = ACIA1_base + 1
09029      C012             ACIA1_cmd      = ACIA1_base + 2
09030      C013             ACIA1_ctrl     = ACIA1_base + 3
09031    
09032    
09033    ; ACIA2 Registers
09034    
09035      C014             ACIA2_base     = $C014                 ; Change as needed later.
09036      C014             ACIA2_tx       = ACIA2_base
09037      C014             ACIA2_rx       = ACIA2_base
09038      C015             ACIA2_sts      = ACIA2_base + 1
09039      C016             ACIA2_cmd      = ACIA2_base + 2
09040      C017             ACIA2_ctrl     = ACIA2_base + 3
09041    
09042    
09043    
09044    ; ACIA Speeds
09045    
09046      0000             ACIA_16x      = 0
09047      0001             ACIA_50       = @0001
09048      0002             ACIA_75       = @0010
09049      0003             ACIA_109p92   = @0011
09050      0004             ACIA_134p51   = @0100
09051      0005             ACIA_150      = @0101
09052      0006             ACIA_300      = @0110
09053      0007             ACIA_600      = @0111
09054      0008             ACIA_1200     = @1000
09055      0009             ACIA_1800     = @1001
09056      000A             ACIA_2400     = @1010
09057      000B             ACIA_3600     = @1011
09058      000C             ACIA_4800     = @1100
09059      000D             ACIA_7200     = @1101
09060      000E             ACIA_9600     = @1110
09061      000F             ACIA_19200    = @1111
09062    
09063    
09064    ; ACIA Word lengths
09065    
09066      0000             ACIA_WL8            = @00000000
09067      0020             ACIA_WL7            = @00100000
09068      0040             ACIA_WL6            = @01000000
09069      0060             ACIA_WL5            = @01100000
09070    
09071    
09072    ; ACIA Command bits
09073    
09074      0000             ACIA_PMC_ODD        = @00000000        ; Parity Mode Control bits
09075      0040             ACIA_PMC_EVN        = @01000000
09076      0080             ACIA_PMC_DIS        = @10000000
09077    
09078      0000             ACIA_PME_DIS        = @00000000        ; Parity Mode Enable bit
09079      0020             ACIA_PME_ENA        = @00100000
09080    
09081      0000             ACIA_REM_OFF        = @00000000        ; Receiver Echo Mode bit
09082      0010             ACIA_REM_ON         = @00010000
09083    
09084      0000             ACIA_TIC_00         = @00000000        ; RTSB High, Transmit Int disabled
09085      0004             ACIA_TIC_01         = @00000100        ; RTSB Low, Transmit Int enabled
09086      0008             ACIA_TIC_10         = @00001000        ; RTSB Low, Transmit Int disabled
09087      000C             ACIA_TIC_11         = @00001100        ; RTSB Low, Transmit Int disabled & Transmit break on TxD
09088      0002             ACIA_INT_DIS        = @00000010
09089      0000             ACIA_INT_ENA        = @00000000
09090      0000             ACIA_DTR_NRDY       = @00000000
09091      0001             ACIA_DTR_RDY        = @00000001
09092    
09093    
09094    ; ACIA Clock Source
09095    
09096      0000             ACIA_RCS_EXT	= @00000000
09097      0010             ACIA_RCS_BRG	= @00010000
09098    
09099    
09100    ; Status Flags
09101    
09102      0001             ACIA_PER	= @00000001
09103      0002             ACIA_FER	= @00000010
09104      0004             ACIA_OVR	= @00000100
09105      0008             ACIA_RBF	= @00001000
09106      0010             ACIA_TXE	= @00010000
09107      0020             ACIA_DCD	= @00100000
09108      0040             ACIA_DSR	= @01000000
09109      0080             ACIA_INT	= @10000000
09110    
09111    
09112    ; Filter Switch
09113    
09114      0001             LF_filt_sw1	= @00000001
09115      0002             LF_filt_sw2	= @00000010
09116    
09117    
09118    
09119    ; Tower of Eightness Specific serial routines.
09120    	
09121    INI_ACIA1                         ; As required for a 6551 ACIA
09122    EC00  A9 8B          LDA #ACIA_CMD_SETUP
09123    EC02  8D 12 C0       STA ACIA1_cmd                    ; Set the command reg for specified baud rate
09124    EC05  A9 1E          LDA #ACIA_CTRL_LISTEN
09125    EC07  8D 13 C0       STA ACIA1_ctrl                   ; Set the control reg for correct operation
09126    EC0A  20 3A EC       JSR ACIA1in                      ; Swallow the first byte (experimental fix)
09127    EC0D  60             RTS
09128      
09129      
09130    INI_ACIA2                         ; As required for a 6551 ACIA
09131    EC0E  A9 8B          LDA #ACIA_CMD_SETUP
09132    EC10  8D 16 C0       STA ACIA2_cmd                    ; Set the command reg for specified baud rate
09133    EC13  A9 1E          LDA #ACIA_CTRL_LISTEN
09134    EC15  8D 17 C0       STA ACIA2_ctrl                   ; Set the control reg for correct operation
09135    EC18  20 4F EC       JSR ACIA2in                      ; Swallow the first byte (experimental fix)
09136    EC1B  60             RTS
09137    
09138    
09139    ; byte out to 6551 ACIA1
09140    
09141    ACIA1out
09142    EC1C  08             PHP                             ; Save registers as we aren't allowed to change them
09143    EC1D  48             PHA
09144    	
09145    EC1E  8D 10 C0       STA ACIA1_tx                     ; write to ACIA TX buffer
09146    EC21  A9 10          LDA #ACIA_TXE
09147    
09148    ACIA1_wr_wait
09149    EC23  2C 11 C0       BIT ACIA1_sts
09150    EC26  F0 FB          BEQ ACIA1_wr_wait                ; Wait until written.
09151    	
09152    EC28  68             PLA                             ; Restore registers. We're all good.
09153    EC29  28             PLP
09154    	
09155    EC2A  60             RTS                             ; Done... Hopefully.
09156      
09157      
09158      
09159    ; byte out to 6551 ACIA2
09160    
09161    ACIA2out
09162    EC2B  08             PHP                             ; Save registers as we aren't allowed to change them
09163    EC2C  48             PHA
09164    	
09165    EC2D  8D 14 C0       STA ACIA2_tx                     ; write to ACIA TX buffer
09166    EC30  A9 10          LDA #ACIA_TXE
09167    
09168    ACIA2_wr_wait
09169    EC32  2C 15 C0       BIT ACIA2_sts
09170    EC35  F0 FB          BEQ ACIA2_wr_wait                ; Wait until written.
09171    	
09172    EC37  68             PLA                             ; Restore registers. We're all good.
09173    EC38  28             PLP
09174    	
09175    EC39  60             RTS                             ; Done... Hopefully.
09176    
09177    
09178    ; byte in from 6551 ACIA 1
09179    
09180    ACIA1in
09181    EC3A  A9 08          LDA #ACIA_RBF
09182    EC3C  2C 11 C0       BIT ACIA1_sts				; do we have a byte?
09183    EC3F  F0 2A          BEQ LAB_nobyw				; branch if no byte waiting
09184    
09185    EC41  AD 10 C0       LDA ACIA1_rx				; Get byte sent.
09186    EC44  38             SEC					; flag byte received
09187      
09188    EC45  48             PHA
09189    EC46  A9 01          LDA #LF_filt_sw1
09190    EC48  2C E1 05       BIT os_infilt
09191    EC4B  F0 17          BEQ filter_inp
09192    EC4D  68             PLA
09193    EC4E  60             RTS
09194    
09195    
09196    ; byte in from 6551 ACIA 2
09197      
09198    ACIA2in
09199    EC4F  A9 08          LDA #ACIA_RBF
09200    EC51  2C 15 C0       BIT ACIA2_sts				; do we have a byte?
09201    EC54  F0 15          BEQ LAB_nobyw				; branch if no byte waiting
09202    
09203    EC56  AD 14 C0       LDA ACIA2_rx				; Get byte sent.
09204    EC59  38             SEC					; flag byte received
09205      
09206    EC5A  48             PHA
09207    EC5B  A9 02          LDA #LF_filt_sw2
09208    EC5D  2C E1 05       BIT os_infilt
09209    EC60  F0 02          BEQ filter_inp
09210    EC62  68             PLA
09211    EC63  60             RTS
09212    
09213    ; Byte filter feature.  Applicable to both ACIAs.
09214    
09215    
09216    filter_inp  
09217    EC64  68             PLA
09218    EC65  C9 0A          CMP #$A
09219    EC67  F0 02          BEQ LAB_nobyw
09220    EC69  38             SEC
09221    EC6A  60             RTS
09222      
09223    LAB_nobyw
09224    EC6B  A9 00          LDA #0
09225    EC6D  18             CLC
09226    EC6E  60             RTS                             ; flag no byte received
09227      RTS                             ; flag no byte received
09228      .INCLUDE "ANSICARD.asm"
09229    ; Duncan's ANSI Video card library
09230    ;
09231    ; This card is based on a 6522 VIA chip.
09232    
09233    
09234    ; Register addresses
09235    
09236      C000             ANSI_base	= $C000
09237      C000             ANSI_reg_b	= ANSI_base
09238      C001             ANSI_reg_a	= ANSI_base+1
09239      C002             ANSI_ddr_b	= ANSI_base+2
09240      C003             ANSI_ddr_a	= ANSI_base+3
09241    
09242    ; Control Bits
09243    
09244      0040             ANSI_AVAIL	= @01000000
09245      0080             ANSI_ACK	= @10000000
09246    
09247    
09248    ; Memory allocations
09249    
09250      05F0             ANSI_area	= $5F0
09251      05F0             ANSI_LastACK	= ANSI_area
09252      05F1             ANSI_LastAVL	= ANSI_area+1
09253    
09254    
09255    ; Initialisation Routine
09256    
09257    ANSI_INIT
09258    EC6F  A9 0C          LDA #12
09259    EC71  8D 00 C0       STA ANSI_reg_b
09260    EC74  A9 40          LDA #ANSI_AVAIL
09261    EC76  8D 03 C0       STA ANSI_ddr_a
09262    EC79  A9 FF          LDA #$FF
09263    EC7B  8D 02 C0       STA ANSI_ddr_b
09264    EC7E  AD 01 C0       LDA ANSI_reg_a
09265    EC81  25 80          AND ANSI_ACK
09266    EC83  8D F0 05       STA ANSI_LastACK
09267    EC86  0A             ASL
09268    EC87  8D F1 05       STA ANSI_LastAVL
09269    EC8A  0D F0 05       ORA ANSI_LastACK
09270    EC8D  8D 01 C0       STA ANSI_reg_a
09271    EC90  60             RTS
09272      
09273    
09274    ; ANSI Write.
09275    ; *================================*
09276    ; *                                *
09277    ; *  ENTRY: A=char                 *
09278    ; *  EXIT: As found                *
09279    ; *                                *
09280    ; **********************************
09281    
09282    ANSI_write
09283    
09284    EC91  08             PHP			; Save Register States
09285    EC92  48             PHA
09286      
09287    EC93  20 A7 EC       JSR ANSI_wait		; Wait until AVAIL and ACK agree
09288      
09289    EC96  8D 00 C0       STA ANSI_reg_b	; Write the char to output
09290    EC99  AD F1 05       LDA ANSI_LastAVL	; Flip and re-write avail bit to tell
09291    EC9C  49 40          EOR #ANSI_AVAIL	; the ANSI processor of new data
09292    EC9E  8D 01 C0       STA ANSI_reg_a
09293    ECA1  8D F1 05       STA ANSI_LastAVL
09294      
09295    ECA4  68             PLA
09296    ECA5  28             PLP
09297    ECA6  60             RTS
09298      
09299    ANSI_wait
09300    ECA7  48             PHA
09301      
09302    ANSI_w_loop
09303    ECA8  AD 01 C0       LDA ANSI_reg_a	; Check ACK against AVAIL
09304    ECAB  29 80          AND #ANSI_ACK
09305    ECAD  4A             LSR
09306    ECAE  CD F1 05       CMP ANSI_LastAVL
09307    ECB1  D0 F5          BNE ANSI_w_loop	; Until they match
09308      
09309    ECB3  68             PLA
09310    ECB4  60             RTS
09311     
09312    
09313    
09314      .INCLUDE "TPBCARD.asm"
09315    ; Duncan's TPB Card driver
09316    ;
09317    ; This card is based on a 6522 VIA chip.
09318    
09319    
09320    ; Register addresses
09321    
09322      C020             TPB_base        = $C020
09323      C020             TPB_reg_b       = TPB_base
09324      C021             TPB_reg_a       = TPB_base+1
09325      C022             TPB_ddr_b       = TPB_base+2
09326      C023             TPB_ddr_a       = TPB_base+3
09327      C02C             TPB_pcr         = TPB_base+$C
09328      C02D             TPB_ifr         = TPB_base+$D
09329    
09330    
09331    ; LPT Control Bits
09332    
09333      0002             TPB_LPT_stb_b   = @00000010
09334      0001             TPB_LPT_ack_b   = @00000001
09335      0002             TPB_ACK_CA1_b   = @00000010
09336      0001             TPB_CA1_pe_b    = @00000001
09337    
09338    
09339    ; TPB Bus Control Bits
09340    
09341      0010             TPB_BUS_clkout  = @00010000       ; Clock line output (Port B, out)
09342      0040             TPB_BUS_clkin   = @01000000       ; Clock line readback (Port B, in)
09343      0020             TPB_BUS_datout  = @00100000       ; Data line output (Port B, out)
09344      0080             TPB_BUS_datin   = @10000000       ; Data line readback (Port B, in)
09345      0008             TPB_BUS_select  = @00001000       ; TPB bus select (Port B, out) signals bus selection.
09346      0004             TPB_BUS_atnin   = @00000100       ; ATN signal readback (Port B, in) indicates a peripheral needs attention or select signal
09347      0001             TPB_BUS_atnout  = @00000001       ; ATN signal output.  When used, tells a device that the data is a select signal.
09348    
09349    
09350    ; TPB Configuration parameters
09351    
09352      00FF             TPB_BUS_lim_c   = 255             ; Number of samples before giving up on device
09353      000F             TPB_BUS_dev_max = 15              ; Highest device address permitted, host being 0.
09354    
09355    ; *****************************************************************************
09356    ; *                           TABLE 1: BLOCK TYPES                            *
09357    ; *                           --------------------                            *
09358    ; * 1.  Command Block (Always the same size 4 bytes at current).              *
09359    ; * 2.  Response Block (Same size as the command block).                      *
09360    ; * 3.  Data Block.  Upto 65535 bytes. It is not reccomended to go that big,  *
09361    ; *     you would touch registers that way!                                   *
09362    ; * 4.  Broadcast Block (4 bytes long).                                       *
09363    ; *                                                                           *
09364    ; *****************************************************************************
09365    
09366      0001             TPB_BLK_cmd        = 1
09367      0002             TPB_BLK_rsp        = 2
09368      0003             TPB_BLK_dat        = 3
09369      0004             TPB_BLK_brd        = 4
09370    
09371    
09372    ; *****************************************************************************
09373    ; *                                                                           *
09374    ; *                          TABLE 2: DEVICE TYPES                            *
09375    ; *                          ---------------------                            *
09376    ; * 1.  DEVType_BlkStorage.  Block storage device.                            *
09377    ; * 2.  DEVType_IOStream.    Input/Output Stream device.                      *
09378    ; * 15. DEVType_User.        User defined device.  Must use own code.         *
09379    ; *                                                                           *
09380    ; *                                                                           *
09381    ; *                                                                           *
09382    ; *                                                                           *
09383    ; *****************************************************************************
09384    
09385      0001             DEVType_blkstorage = 1
09386      0002             DEVType_IOstream   = 2
09387      000F             DEVType_User       = 15
09388    
09389    
09390    ; Memory allocations
09391    
09392      05F2             TPB_worksp         = $5F2                 ; Start of TPB card memory allocation
09393      05F2             TPB_curr_dev       = TPB_worksp           ; Currently selected TPB devce ID
09394      05F3             TPB_dev_type       = TPB_worksp+1         ; Device class of selected device
09395      05F4             TPB_last_rd        = TPB_worksp+2         ; last byte read from TPB device
09396      05F5             TPB_BUS_status     = TPB_worksp+3         ; Status word from TPB engine (subject to change)
09397      05F6             TPB_BUS_tries      = TPB_worksp+4         ; Bus device counter.  This ensures fewer hangs.
09398      05F7             TPB_BUS_lim        = TPB_worksp+5         ; Bus countdown timer limit. (Reload value).
09399      05F8             TPB_BUS_blk_lenlo  = TPB_worksp+6         ; Length of block in or out
09400      05F9             TPB_BUS_blk_lenhi  = TPB_worksp+7         ; Length of block in or out
09401      05F8             TPB_BUS_blk_len    = TPB_BUS_blk_lenlo    ; Convenience pointer to TPB_BUS_blk_lenlo
09402      05FA             TPB_BUS_blk_stlo   = TPB_worksp+8         ; Start address low byte of block
09403      05FB             TPB_BUS_blk_sthi   = TPB_worksp+9         ; Start address high byte of block
09404      05FA             TPB_BUS_blk_st     = TPB_BUS_blk_stlo     ; Convenience pointer to TPB_BUS_BLK_stlo
09405      05FC             TPB_BUS_blk_type   = TPB_worksp+$A        ; Type of block transfer. See table 1
09406      00E2             TPB_Temp1          = $E2                  ; Temporary memory location 1
09407      00E3             TPB_Temp2          = $E3                  ; Temporary memory location 2
09408      00E4             TPB_Temp3          = $E4                  ; Temporary memory location 3
09409    
09410    ; 3 spaces remain between the system variables and the buffer block.
09411    ; This means we end up with $5FD to $5FF unused.
09412    
09413    ; Last TPB workspace allocation @ $5FC before buffers.
09414    
09415    
09416    ; TPB Command Codes
09417    
09418      0000             PRESENCE           = 0                  ; Check for device presence by ID   <DONE>
09419      0001             ATN_CHK            = 1                  ; Check if device is asserting ATN   <DONE>
09420      0002             REQ_DEV_TYPE       = 2                  ; Request device type-code.
09421      0003             CTRL_BLK_WR        = 3                  ; Write to control block
09422      0004             CTRL_BLK_RD        = 4                  ; Read from control block
09423      0005             BUFF_BLK_WR        = 5                  ; Write to device buffer
09424      0006             BUFF_BLK_RD        = 6                  ; Read from device buffer
09425      0007             BUFF_PROCESS       = 7                  ; Process buffer contents
09426      0008             STREAM_OUT         = 8                  ; Stream out (each char requires an ACK or NACK after)
09427      0009             STREAM_IN          = 9                  ; Stream in (for each char in, you must send an ACK or NACK)
09428    
09429    
09430    ; ACK and NACK codes
09431    
09432      00F1             TPB_ACK            = $F1                ; Acknowledge code (Continuance signal)
09433      00F5             TPB_NACK           = $F5                ; Not Acknoledge code. (Terminator)
09434    
09435    
09436      0600             TPB_BUS_RAMBASE    = $600
09437      0600             TPB_Dev_table      = TPB_BUS_RAMBASE                     ; Start of the TPB bus device table.
09438      0610             TPB_BUS_IO_buff    = TPB_Dev_table + TPB_BUS_dev_max + 1 ; Page of buffer for TPB transfers
09439      0700             TPB_BUFFER         = $700                                ; Block transfers go here. Max 1 page.
09440    
09441    
09442    ; Control Block Structure and Location.
09443    
09444      0610             TPB_ctrl_blk       = TPB_BUS_IO_buff
09445      0610             DEV_ID             = TPB_ctrl_blk
09446      0611             DEV_BLK_TYPE       = TPB_ctrl_blk + 1
09447      0612             DEV_CMD_RSP        = TPB_ctrl_blk + 2
09448      0613             CHECKSUM           = TPB_ctrl_blk + 3
09449    
09450    ; Initialisation Routine
09451    
09452      0002             TPB_PbInitial   = TPB_LPT_stb_b
09453      003B             TPB_PbOutputs   = TPB_LPT_stb_b | TPB_BUS_clkout | TPB_BUS_datout | TPB_BUS_atnout | TPB_BUS_select
09454    
09455    
09456    TPB_INIT
09457    ;  This first part initialises the on-card 6522 VIA pins for both features.
09458    
09459    ECB5  A9 00          LDA #0                          ; Set our registers to defaults
09460    ECB7  8D 21 C0       STA TPB_reg_a
09461    ECBA  A9 02          LDA #TPB_PbInitial
09462    ECBC  8D 20 C0       STA TPB_reg_b
09463      
09464    ECBF  A9 FF          LDA #$FF
09465    ECC1  8D 23 C0       STA TPB_ddr_a                   ; Setup port a as outputs to our LPT
09466    ECC4  A9 3B          LDA #TPB_PbOutputs
09467    ECC6  8D 22 C0       STA TPB_ddr_b                   ; Setup port B for both LPT and TPB initial state.
09468    ECC9  A9 01          LDA #TPB_CA1_pe_b               ; Configure for positive edge interrupt trigger.
09469    ECCB  8D 2C C0       STA TPB_pcr                     ; on CA1
09470      
09471      ;  This second part initialises the Tower Peripheral Bus engine.
09472      
09473    ECCE  A9 00          LDA #0
09474    ECD0  8D F5 05       STA TPB_BUS_status              ; Set the bus to listening.
09475    
09476    ECD3  A9 FF          LDA #TPB_BUS_lim_c
09477    ECD5  8D F7 05       STA TPB_BUS_lim                 ; Set the bus response tries limit (variable for latency)
09478    ECD8  60             RTS
09479    
09480    
09481    ; TPB Write to remote device control block
09482    ; *******************************************************
09483    ; *                                                     *
09484    ; *  ENTRY:                                             *
09485    ; *  EXIT:                                              *
09486    ; *         Affects, A,X,Y,P.                           *
09487    ; *         C = 0: Fail                                 *
09488    ; *         C = 1: Success.                             *
09489    ; *                                                     *
09490    ; *******************************************************
09491    
09492    TPB_Ctrl_Blk_Wr
09493    ECD9  AD F2 05       LDA TPB_curr_dev                ; Setup Command Block
09494    ECDC  8D 10 06       STA DEV_ID
09495    ECDF  A9 01          LDA #TPB_BLK_cmd
09496    ECE1  8D 11 06       STA DEV_BLK_TYPE
09497    ECE4  A9 03          LDA #CTRL_BLK_WR
09498    ECE6  8D 12 06       STA DEV_CMD_RSP
09499    ECE9  20 2F EE       JSR TPB_calc_ctrl_csum
09500    
09501    ECEC  20 9E ED       JSR TPB_Tx_CMD                  ; Issue write to remote control block command.
09502        
09503    ECEF  20 B6 ED       JSR TPB_WaitATN                 ; Wait for Attention signal
09504    ECF2  90 19          BCC CBW_Fail                    ; If no device then quit with carry clear.
09505      
09506    ECF4  A9 00          LDA #<TPB_BUFFER                ; Setup for device control block transmit.
09507    ECF6  8D FA 05       STA TPB_BUS_blk_stlo
09508    ECF9  A9 07          LDA #>TPB_BUFFER
09509    ECFB  8D FB 05       STA TPB_BUS_blk_sthi
09510    ECFE  A9 10          LDA #16                         ; Control blocks are 16 bytes in length
09511    ED00  8D F8 05       STA TPB_BUS_blk_lenlo           ; at present.  I may change this...
09512    ED03  A9 00          LDA #0
09513    ED05  8D F9 05       STA TPB_BUS_blk_lenhi
09514      
09515    ED08  20 DA EE       JSR TPB_tx_block                ; Transmit the control block.
09516      
09517    ED0B  38             SEC                             ; Exit signalling success.
09518    ED0C  60             RTS
09519      
09520    CBW_Fail  
09521    ED0D  18             CLC                             ; Exit signalling fail.
09522    ED0E  60             RTS
09523      
09524      
09525      ; TPB Read from remote device control block
09526    ; *******************************************************
09527    ; *                                                     *
09528    ; *  ENTRY:                                             *
09529    ; *  EXIT:                                              *
09530    ; *         Affects, A,X,Y,P.                           *
09531    ; *         C = 0: Fail                                 *
09532    ; *         C = 1: Success.                             *
09533    ; *                                                     *
09534    ; *******************************************************
09535    
09536    TPB_Ctrl_Blk_Rd
09537    ED0F  AD F2 05       LDA TPB_curr_dev                ; Setup Command Block
09538    ED12  8D 10 06       STA DEV_ID
09539    ED15  A9 01          LDA #TPB_BLK_cmd
09540    ED17  8D 11 06       STA DEV_BLK_TYPE
09541    ED1A  A9 04          LDA #CTRL_BLK_RD
09542    ED1C  8D 12 06       STA DEV_CMD_RSP
09543    ED1F  20 2F EE       JSR TPB_calc_ctrl_csum
09544    
09545    ED22  20 9E ED       JSR TPB_Tx_CMD                  ; Issue write to remote control block command.
09546     
09547    ED25  20 B6 ED       JSR TPB_WaitATN                 ; Wait for Attention signal
09548    ED28  90 1A          BCC CBR_Fail                    ; If no device then quit with carry clear.
09549      
09550    ED2A  A9 00          LDA #<TPB_BUFFER                ; Setup for device control block receive.
09551    ED2C  8D FA 05       STA TPB_BUS_blk_stlo
09552    ED2F  A9 07          LDA #>TPB_BUFFER
09553    ED31  8D FB 05       STA TPB_BUS_blk_sthi
09554    ED34  A9 10          LDA #16                         ; Control blocks are 16 bytes in length
09555    ED36  8D F8 05       STA TPB_BUS_blk_lenlo           ; at present.  I may change this...
09556    ED39  A9 00          LDA #0
09557    ED3B  8D F9 05       STA TPB_BUS_blk_lenhi
09558      
09559    ED3E  20 1E EF       JSR TPB_rx_block                ; Receive the control block.
09560    ED41  90 01          BCC CBR_Fail
09561        
09562    ED43  60             RTS                             ; Exit successfully.
09563      
09564    CBR_Fail  
09565    ED44  18             CLC                             ; Exit signalling fail.
09566    ED45  60             RTS
09567      
09568      
09569      
09570    
09571    ; TPB Request device type code
09572    ; *******************************************************
09573    ; *                                                     *
09574    ; *  ENTRY: A=Device ID                                 *
09575    ; *  EXIT:  A=Device Type                               *
09576    ; *         Affects, A,X,Y,P.                           *
09577    ; *         C = 0: Fail                                 *
09578    ; *         C = 1: Success.                             *
09579    ; *                                                     *
09580    ; *******************************************************
09581      
09582    TPB_Req_Dev_Type
09583    ED46  8D 10 06       STA DEV_ID                      ; Setup Command Block
09584    ED49  A9 01          LDA #TPB_BLK_cmd
09585    ED4B  8D 11 06       STA DEV_BLK_TYPE
09586    ED4E  A9 02          LDA #REQ_DEV_TYPE
09587    ED50  8D 12 06       STA DEV_CMD_RSP
09588    ED53  20 2F EE       JSR TPB_calc_ctrl_csum
09589      
09590    ED56  20 9E ED       JSR TPB_Tx_CMD                  ; Issue Req_Dev_Type command
09591        
09592    ED59  20 B6 ED       JSR TPB_WaitATN                 ; Wait for Attention signal
09593    ED5C  90 34          BCC DevType_Fail                ; If no device then quit with carry clear.
09594    
09595    ED5E  A9 10          LDA #<TPB_ctrl_blk              ; Setup for device reply to the control block
09596    ED60  8D FA 05       STA TPB_BUS_blk_stlo
09597    ED63  A9 06          LDA #>TPB_ctrl_blk
09598    ED65  8D FB 05       STA TPB_BUS_blk_sthi
09599    ED68  A9 04          LDA #4
09600    ED6A  8D F8 05       STA TPB_BUS_blk_lenlo
09601    ED6D  A9 00          LDA #0
09602    ED6F  8D F9 05       STA TPB_BUS_blk_lenhi
09603      
09604    ED72  20 1E EF       JSR TPB_rx_block                ; Get our reply block.
09605    ED75  90 1B          BCC DevType_Fail                ; Error if TPB_rx_block fails.
09606      
09607    ED77  18             CLC                            ; Calculate Checksum
09608    ED78  AD 10 06       LDA DEV_ID
09609    ED7B  6D 11 06       ADC DEV_BLK_TYPE
09610    ED7E  6D 12 06       ADC DEV_CMD_RSP
09611      
09612    ED81  CD 13 06       CMP CHECKSUM                   ; Compare with received checksum
09613    ED84  D0 0C          BNE DevType_Fail               ; Signal appropriately with the carry bit.
09614      
09615    ED86  AD 11 06       LDA DEV_BLK_TYPE               ; Check for the appropriate response.
09616    ED89  C9 02          CMP #TPB_BLK_rsp
09617    ED8B  D0 05          BNE DevType_Fail               ; ...and fail if incorrect.
09618      
09619    ED8D  AD 12 06       LDA DEV_CMD_RSP                ; Reply with device type.
09620      
09621    ED90  38             SEC
09622    ED91  60             RTS
09623    
09624    DevType_Fail
09625    ED92  18             CLC                            ; General failiure exit point.
09626    ED93  60             RTS
09627      
09628      
09629    ; TPB Check ATN state.
09630    ; *******************************************************
09631    ; *                                                     *
09632    ; *  ENTRY:                                             *
09633    ; *  EXIT: A, P, carry is set when asserted, otherwise  *
09634    ; *           cleared.                                  *
09635    ; *                                                     *
09636    ; *******************************************************
09637    
09638    
09639    TPB_Check_ATN
09640    ED94  AD 20 C0       LDA TPB_reg_b                   ; Check if ATN is asserted
09641    ED97  29 04          AND #TPB_BUS_atnin
09642    ED99  38             SEC
09643    ED9A  F0 01          BEQ ATN_asserted                ; Skip clearing C if ATN is asserted.
09644    ED9C  18             CLC                             ; Carry is cleared as ATN isn't asserted.
09645    ATN_asserted
09646    ED9D  60             RTS 
09647                       
09648    
09649    ; TPB Transmit Command
09650    ; ****************************************************
09651    ; *                                                  *
09652    ; *  ENTRY:                                          *
09653    ; *  EXIT:  A, X, Y, P affected                      *
09654    ; *                                                  *
09655    ; ****************************************************
09656    
09657    
09658    TPB_Tx_CMD
09659    ED9E  A9 10          LDA #<DEV_ID                   ; Setup pointers and transmit control block.
09660    EDA0  8D FA 05       STA TPB_BUS_blk_stlo
09661    EDA3  A9 06          LDA #>DEV_ID
09662    EDA5  8D FB 05       STA TPB_BUS_blk_sthi
09663    EDA8  A9 04          LDA #4
09664    EDAA  8D F8 05       STA TPB_BUS_blk_lenlo
09665    EDAD  A9 00          LDA #0
09666    EDAF  8D F9 05       STA TPB_BUS_blk_lenhi
09667      
09668    EDB2  20 DA EE       JSR TPB_tx_block
09669      
09670    EDB5  60             RTS
09671    
09672    
09673    ; TPB Attention Signal handler with wait.
09674    ; ****************************************************
09675    ; *                                                  *
09676    ; *  ENTRY:                                          *
09677    ; *  EXIT:  A,X,P                                    *
09678    ; *         C=0 ATN line not asserted or timeout.    *
09679    ; *         C=1 ATN line asserted                    *
09680    ; *                                                  *
09681    ; ****************************************************
09682    
09683    TPB_WaitATN
09684    EDB6  A2 FF          LDX #TPB_BUS_lim_c                ; Set number of tries
09685      
09686    TPB_WaitATN_try
09687    EDB8  20 A5 EF       JSR TPB_delay                     ; Wait and check
09688    EDBB  20 94 ED       JSR TPB_Check_ATN
09689    EDBE  B0 04          BCS FinWaitATN
09690    EDC0  CA             DEX                               ; Reduce counter and try again
09691    EDC1  D0 F5          BNE TPB_WaitATN_try
09692    EDC3  18             CLC  
09693    FinWaitATN
09694    EDC4  60             RTS
09695    
09696    
09697    ; TPB DEVICE_PRESENCE handler (Currently broken)
09698    ; ****************************************************
09699    ; *                                                  *
09700    ; *  ENTRY: A=ID                                     *
09701    ; *  EXIT:  TPB_BUS_IO_buff = reply block            *
09702    ; *         C=0 (No device or block fail),           *
09703    ; *         C=1 Success.                             *
09704    ; *                                                  *
09705    ; ****************************************************
09706    
09707    
09708    ; Setup Command Block 
09709    
09710    TPB_Dev_Presence
09711      ; Command Setup
09712    EDC5  8D 10 06       STA DEV_ID                     ; Store device ID
09713    EDC8  A9 01          LDA #TPB_BLK_cmd
09714    EDCA  8D 11 06       STA DEV_BLK_TYPE
09715    EDCD  A9 00          LDA #PRESENCE                  ; Command: PRESENCE check.
09716    EDCF  8D 12 06       STA DEV_CMD_RSP  
09717    EDD2  20 2F EE       JSR TPB_calc_ctrl_csum         ; Calculate checksum
09718      ; Command Issue
09719    EDD5  20 9E ED       JSR TPB_Tx_CMD                 ; Transmit Command
09720      ; Process Outcome
09721    EDD8  20 B6 ED       JSR TPB_WaitATN                ; Wait for Attention signal
09722    EDDB  90 2A          BCC PRESENCE_NoRESP            ; If no device then skip RESP fetch
09723    
09724    EDDD  A9 10          LDA #<DEV_ID                   ; Setup pointers for RESP block.
09725    EDDF  8D FA 05       STA TPB_BUS_blk_stlo
09726    EDE2  A9 06          LDA #>DEV_ID
09727    EDE4  8D FB 05       STA TPB_BUS_blk_sthi
09728    EDE7  A9 04          LDA #4
09729    EDE9  8D F8 05       STA TPB_BUS_blk_lenlo
09730    EDEC  A9 00          LDA #0
09731    EDEE  8D F9 05       STA TPB_BUS_blk_lenhi
09732      
09733    EDF1  20 1E EF       JSR TPB_rx_block               ; Get RESPonse block
09734      
09735    EDF4  90 11          BCC PRESENCE_NoRESP            ; If failed or no response fall through.
09736      
09737    EDF6  18             CLC                            ; Calculate Checksum
09738    EDF7  AD 10 06       LDA DEV_ID
09739    EDFA  6D 11 06       ADC DEV_BLK_TYPE
09740    EDFD  6D 12 06       ADC DEV_CMD_RSP
09741      
09742    EE00  CD 13 06       CMP CHECKSUM                   ; Compare with received checksum
09743    EE03  D0 02          BNE PRESENCE_NoRESP            ; Signal appropriately with the carry bit.
09744    EE05  38             SEC
09745    EE06  60             RTS                            ; Return with positive response
09746      
09747    PRESENCE_NoRESP
09748    EE07  18             CLC
09749    EE08  60             RTS                            ; ...Else return negative.
09750    
09751    
09752    ; TPB Attention handler (Needs work, do not use)
09753    ; ****************************************************
09754    ; *                                                  *
09755    ; *  ENTRY:                                          *
09756    ; *  EXIT:                                           *
09757    ; *                                                  *
09758    ; *                                                  *
09759    ; *                                                  *
09760    ; ****************************************************
09761    
09762    TPB_ATN_handler
09763      
09764    EE09  A0 00          LDY #0
09765    ATN_next                          ; Work our way through the device table
09766    EE0B  B9 00 06       LDA TPB_Dev_table,Y           
09767      
09768    EE0E  F0 1E          BEQ TPB_EOT                     ; Check for end of table marker (0).
09769                                      ; Initialise our control block for attention check
09770    EE10  8D 10 06       STA DEV_ID                      ; Store device ID.
09771    EE13  98             TYA
09772    EE14  48             PHA                             ; Stack our table pointer for later.
09773    EE15  A9 01          LDA #TPB_BLK_cmd
09774    EE17  8D 11 06       STA DEV_BLK_TYPE
09775    EE1A  A9 01          LDA #ATN_CHK
09776    EE1C  8D 12 06       STA DEV_CMD_RSP
09777      
09778    EE1F  20 2F EE       JSR TPB_calc_ctrl_csum
09779      
09780    EE22  20 9E ED       JSR TPB_Tx_CMD                  ; Transmit Command
09781      
09782    EE25  20 DA EE       JSR TPB_tx_block
09783      
09784      ;JSR TPB_ctrl_rd
09785      
09786    EE28  68             PLA                             ; Get our id table pointer back.
09787    EE29  A8             TAY
09788    EE2A  C8             INY                             ; Advance to next table entry  
09789    EE2B  4C 0B EE       JMP ATN_next
09790    TPB_EOT
09791    EE2E  60             RTS
09792      
09793    TPB_calc_ctrl_csum
09794    EE2F  18             CLC
09795    EE30  A9 00          LDA #0                          ; Calculate and store checksum for block.
09796    EE32  6D 10 06       ADC DEV_ID
09797    EE35  6D 11 06       ADC DEV_BLK_TYPE
09798    EE38  6D 12 06       ADC DEV_CMD_RSP
09799    EE3B  8D 13 06       STA CHECKSUM
09800    EE3E  60             RTS
09801     
09802     
09803    ; TPB transmit byte
09804    ; *================================*
09805    ; *                                *
09806    ; *  ENTRY: A=byte                 *
09807    ; *  EXIT: Affects X, P            *
09808    ; *                                *
09809    ; *================================*
09810    
09811    TPB_tx_byte
09812    EE3F  A2 0A          LDX #10                   ; 1 start bit, 8 data bits and 1 stop bit.
09813    EE41  38             SEC                       ; We want a start bit.
09814    EE42  48             PHA
09815    TPB_bit_out  
09816    EE43  90 0F          BCC TPB_out_zero          ; Determine whether a 1 or 0 to be sent.
09817      
09818    ; output 1 on TPB data
09819    EE45  AD 20 C0       LDA TPB_reg_b
09820    EE48  09 20          ORA #TPB_BUS_datout
09821    EE4A  8D 20 C0       STA TPB_reg_b
09822    EE4D  EA             NOP                       ; This NOP compensates for the branch timing.
09823    EE4E  20 62 EE       JSR TPB_pulseclk
09824      
09825    EE51  4C 79 EE       JMP TPB_shiftbit
09826       
09827    ; output 0 on TPB data  
09828    TPB_out_zero
09829    EE54  AD 20 C0       LDA TPB_reg_b
09830    EE57  29 DF          AND #~TPB_BUS_datout
09831    EE59  8D 20 C0       STA TPB_reg_b
09832    EE5C  20 62 EE       JSR TPB_pulseclk 
09833      
09834    EE5F  4C 79 EE       JMP TPB_shiftbit
09835    
09836    
09837    ; Clock line Pulse function
09838    ; **********************************
09839    ; *                                *
09840    ; *   ENTRY: None                  *
09841    ; *   EXIT: A,P Affected           *
09842    ; *   USES: TPB_delay              *
09843    ; *                                *
09844    ; **********************************
09845    
09846    TPB_pulseclk  
09847    EE62  AD 20 C0       LDA TPB_reg_b
09848    EE65  09 10          ORA #TPB_BUS_clkout       ; Set the clock line output
09849    EE67  8D 20 C0       STA TPB_reg_b
09850      
09851    EE6A  20 A5 EF       JSR TPB_delay
09852    
09853    EE6D  AD 20 C0       LDA TPB_reg_b
09854    EE70  29 EF          AND #~TPB_BUS_clkout      ; Clear the clock line output
09855    EE72  8D 20 C0       STA TPB_reg_b
09856      
09857    EE75  20 A5 EF       JSR TPB_delay
09858    EE78  60             RTS
09859    
09860          
09861    TPB_shiftbit  
09862    EE79  CA             DEX
09863    EE7A  F0 06          BEQ TPB_wr_done
09864    EE7C  68             PLA
09865    EE7D  0A             ASL
09866    EE7E  48             PHA
09867    EE7F  4C 43 EE       JMP TPB_bit_out
09868      
09869    TPB_wr_done
09870    EE82  68             PLA
09871    EE83  60             RTS
09872    
09873    
09874    ; TPB recieve byte
09875    ; *======================================*
09876    ; *                                      *
09877    ; *  ENTRY:                              *
09878    ; *  EXIT: Affects A,X,Y,P               *
09879    ; *        A = byte                      *
09880    ; *        C = 1 Sucess, 0 Fail          *
09881    ; *                                      *
09882    ; *======================================*
09883    
09884    TPB_rx_byte                       ; Read one byte
09885    EE84  A9 00          LDA #0                          ; This is our starting value
09886    EE86  85 E4          STA TPB_Temp3                   ; Keep it safe in Temp3
09887      
09888    EE88  AD 20 C0       LDA TPB_reg_b                   ; Signal start bit required.
09889    EE8B  09 10          ORA #TPB_BUS_clkout             ; Set the clock line output
09890    EE8D  8D 20 C0       STA TPB_reg_b
09891      
09892    EE90  18             CLC
09893    EE91  A0 FF          LDY #TPB_BUS_lim_c              ; Load our limit (preventing bus hangs)
09894    TPB_chk_databit
09895    EE93  20 A5 EF       JSR TPB_delay                   ; Small delay.  This may change later.
09896    EE96  AD 20 C0       LDA TPB_reg_b
09897    EE99  29 80          AND #TPB_BUS_datin
09898    EE9B  F0 12          BEQ TPB_sbit_asserted
09899      
09900    EE9D  88             DEY                             ; Check for timeout & branch if still waiting.
09901    EE9E  D0 F3          BNE TPB_chk_databit
09902      
09903    TPB_rx_fail
09904    EEA0  AD 20 C0       LDA TPB_reg_b                   ; Clear clock line output
09905    EEA3  29 EF          AND #~TPB_BUS_clkout
09906    EEA5  8D 20 C0       STA TPB_reg_b
09907    EEA8  20 A5 EF       JSR TPB_delay                   ; ...and include a small delay
09908    
09909    EEAB  A9 00          LDA #0                          ; We timed out so let's signal that
09910    EEAD  18             CLC
09911    EEAE  60             RTS
09912      
09913    TPB_sbit_asserted
09914    EEAF  AD 20 C0       LDA TPB_reg_b                   ; Clear clock line output
09915    EEB2  29 EF          AND #~TPB_BUS_clkout
09916    EEB4  8D 20 C0       STA TPB_reg_b
09917    EEB7  20 A5 EF       JSR TPB_delay                   ; ...and include a small delay
09918      
09919    
09920    EEBA  A2 08          LDX #8                          ; Receive and store 8 bits.
09921    TPB_rcv_nextbit  
09922    EEBC  20 CD EE       JSR TPB_Takebit
09923    EEBF  26 E4          ROL TPB_Temp3                   ; Push our sampled bit into our output.
09924    
09925    EEC1  CA             DEX
09926    EEC2  D0 F8          BNE TPB_rcv_nextbit
09927      
09928    EEC4  20 CD EE       JSR TPB_Takebit                 ; Receive the stop bit.  
09929    EEC7  B0 D7          BCS TPB_rx_fail
09930      
09931    EEC9  A5 E4          LDA TPB_Temp3                   ; Retrieve our finished byte
09932    EECB  38             SEC                             ; and signal that we were successful
09933    EECC  60             RTS
09934      
09935    TPB_Takebit  
09936    EECD  20 62 EE       JSR TPB_pulseclk                ; Sample the bus and set or clear carry as required.
09937    EED0  AD 20 C0       LDA TPB_reg_b
09938    EED3  29 80          AND #TPB_BUS_datin
09939    EED5  18             CLC
09940    EED6  D0 01          BNE TPB_skip_setbit
09941    EED8  38             SEC
09942    TPB_skip_setbit
09943    EED9  60             RTS
09944      
09945    
09946    ; TPB transmit block
09947    ; *==================================================*
09948    ; *                                                  *
09949    ; *  ENTRY: TPB_BUS_blk_lenlo = length of block (LO) *
09950    ; *         TPB_BUS_blk_lenhi = length of block (HI) *
09951    ; *                                                  *
09952    ; *         TPB_BUS_blk_st  = start of block         *
09953    ; *                                                  *
09954    ; *  EXIT:  TPB_BUS_blk_len = unchanged              *
09955    ; *         TPB_BUS_blk_st  = st+len                 *
09956    ; *         A,X,Y,P affected.                        *
09957    ; *                                                  *
09958    ; *                                                  *
09959    ; *==================================================*
09960    
09961    TPB_tx_block
09962    EEDA  AD FA 05       LDA TPB_BUS_blk_stlo             ; Copy block address to temp1/2
09963    EEDD  85 E2          STA TPB_Temp1
09964    EEDF  AD FB 05       LDA TPB_BUS_blk_sthi
09965    EEE2  85 E3          STA TPB_Temp2
09966      
09967    TPB_BUS_tx_next                    ; Transmitter inside loop
09968    EEE4  AD F8 05       LDA TPB_BUS_blk_lenlo            ; Finish when TPB_blk_len(lo and hi) = 0
09969    EEE7  0D F9 05       ORA TPB_BUS_blk_lenhi
09970    EEEA  F0 31          BEQ TPB_tx_block_done
09971      
09972    EEEC  A0 00          LDY #0                           ; Get and transmit byte.
09973    EEEE  B1 E2          LDA (TPB_Temp1),Y
09974    EEF0  20 3F EE       JSR TPB_tx_byte
09975    
09976    EEF3  AD F8 05       LDA TPB_BUS_blk_lenlo            ; Decrement our length counter
09977    EEF6  38             SEC
09978    EEF7  E9 01          SBC #1
09979    EEF9  8D F8 05       STA TPB_BUS_blk_lenlo
09980    EEFC  AD F9 05       LDA TPB_BUS_blk_lenhi
09981    EEFF  E9 00          SBC #0
09982    EF01  8D F9 05       STA TPB_BUS_blk_lenhi
09983      
09984    EF04  18             CLC                              ; Increment TPB_BUS_blk_len copy in TPB_Temp1/2
09985    EF05  A5 E2          LDA TPB_Temp1
09986    EF07  69 01          ADC #1
09987    EF09  85 E2          STA TPB_Temp1
09988    EF0B  A5 E3          LDA TPB_Temp2
09989    EF0D  69 00          ADC #0
09990    EF0F  85 E3          STA TPB_Temp2
09991      
09992    EF11  20 A5 EF       JSR TPB_delay                    ; Add a little delay between bytes.
09993    EF14  20 A5 EF       JSR TPB_delay                    ; thereby allowing the receiver to do something useful.
09994    EF17  20 A5 EF       JSR TPB_delay
09995      
09996    EF1A  4C E4 EE       JMP TPB_BUS_tx_next
09997      
09998    TPB_tx_block_done
09999    EF1D  60             RTS
10000     
10001    
10002    ; TPB receive block
10003    ; *==================================================*
10004    ; *                                                  *
10005    ; *  ENTRY: TPB_BUS_blk_lenlo = length of block (LO) *
10006    ; *         TPB_BUS_blk_lenhi = length of block (HI) *
10007    ; *                                                  *
10008    ; *         TPB_BUS_blk_st  = start of block         *
10009    ; *                                                  *
10010    ; *  EXIT:  TPB_BUS_blk_len = unchanged              *
10011    ; *         TPB_BUS_blk_st  = st+len                 *
10012    ; *         Temp1, Temp2 Corrupted                   *
10013    ; *         A,X,Y,P all affected.                    *
10014    ; *         C=0 Fail, C=1 Success                    *
10015    ; *                                                  *
10016    ; *==================================================*
10017     
10018    TPB_rx_block
10019    EF1E  AD FA 05       LDA TPB_BUS_blk_stlo             ; Copy block address to temp1/2
10020    EF21  85 E2          STA TPB_Temp1
10021    EF23  AD FB 05       LDA TPB_BUS_blk_sthi
10022    EF26  85 E3          STA TPB_Temp2
10023      
10024    TPB_BUS_rx_next
10025    EF28  AD F8 05       LDA TPB_BUS_blk_lenlo            ; While block length > 0.
10026    EF2B  0D F9 05       ORA TPB_BUS_blk_lenhi
10027    EF2E  F0 2B          BEQ TPB_rx_block_done
10028      
10029    EF30  20 84 EE       JSR TPB_rx_byte                  ; Get byte.
10030      
10031    EF33  B0 01          BCS TPB_rx_continue              ; Continue unless TPB_rx_byte signals failiure.
10032    EF35  60             RTS
10033      
10034    TPB_rx_continue
10035    EF36  A0 00          LDY #0                           
10036    EF38  91 E2          STA (TPB_Temp1),Y                ; Store our successfully received byte.
10037      
10038    EF3A  AD F8 05       LDA TPB_BUS_blk_lenlo            ; Decrement our length counter
10039    EF3D  38             SEC
10040    EF3E  E9 01          SBC #1
10041    EF40  8D F8 05       STA TPB_BUS_blk_lenlo
10042    EF43  AD F9 05       LDA TPB_BUS_blk_lenhi
10043    EF46  E9 00          SBC #0
10044    EF48  8D F9 05       STA TPB_BUS_blk_lenhi
10045      
10046    EF4B  18             CLC                              ; Increment TPB_BUS_blk_len copy in TPB_Temp1/2
10047    EF4C  A5 E2          LDA TPB_Temp1
10048    EF4E  69 01          ADC #1
10049    EF50  85 E2          STA TPB_Temp1
10050    EF52  A5 E3          LDA TPB_Temp2
10051    EF54  69 00          ADC #0
10052    EF56  85 E3          STA TPB_Temp2
10053      
10054    EF58  4C 28 EF       JMP TPB_BUS_rx_next
10055      
10056    TPB_rx_block_done
10057    EF5B  38             SEC
10058    EF5C  60             RTS
10059      
10060      
10061    ; TPB Device Select
10062    ; *==================================================*
10063    ; *                                                  *
10064    ; *   ENTRY:   A = Device to select                  *
10065    ; *   EXIT:    None                                  *
10066    ; *   AFFECTS: A,X,Y,P                               *
10067    ; *                                                  *
10068    ; *                                                  *
10069    ; *==================================================*
10070    
10071    TPB_dev_select
10072    EF5D  A8             TAY                       ; Save our device ID
10073      
10074      
10075    EF5E  A9 08          LDA #TPB_BUS_select       ; Assert SELECT signal
10076    EF60  8D 20 C0       STA TPB_reg_b
10077    
10078    EF63  A2 00          LDX #$0                   ; Give device time to act
10079    ATN_Resp_Dwell
10080    EF65  CA             DEX
10081    EF66  EA             NOP
10082    EF67  EA             NOP
10083    EF68  D0 FB          BNE ATN_Resp_Dwell
10084      
10085    EF6A  98             TYA                       ; Get our ID from Y
10086    EF6B  20 3F EE       JSR TPB_tx_byte           ; Transmit our device ID
10087      
10088    EF6E  A9 F7          LDA #~TPB_BUS_select      ; Deassert SELECT
10089    EF70  8D 20 C0       STA TPB_reg_b
10090      
10091    EF73  8C F2 05       STY TPB_curr_dev          ; Update current dev variable
10092      
10093    EF76  60             RTS
10094      
10095    
10096    
10097        
10098    FINDME:
10099    
10100    ; TPB LPT Write.
10101    ; *================================*
10102    ; *                                *
10103    ; *  ENTRY: A=char                 *
10104    ; *  EXIT: As found                *
10105    ; *                                *
10106    ; **********************************
10107    
10108    TPB_LPT_write
10109    
10110    EF77  08             PHP                             ; Save Register States
10111    EF78  48             PHA
10112      
10113    EF79  20 9B EF       JSR STB_ack_wait                ; Wait until Ack=1
10114      
10115    EF7C  20 A5 EF       JSR TPB_delay
10116      
10117    EF7F  8D 21 C0       STA TPB_reg_a                   ; Write the char to output
10118      
10119    EF82  20 A5 EF       JSR TPB_delay
10120      
10121    EF85  AD 20 C0       LDA TPB_reg_b                   ; Set the strobe bit low (Active)
10122    EF88  29 FD          AND #~TPB_LPT_stb_b             ; and only the strobe bit.
10123    EF8A  8D 20 C0       STA TPB_reg_b
10124      
10125    EF8D  20 A5 EF       JSR TPB_delay
10126      
10127    EF90  AD 20 C0       LDA TPB_reg_b                   ; Now we return the strobe bit to it's
10128    EF93  09 02          ORA #TPB_LPT_stb_b              ; 'idle' state.
10129    EF95  8D 20 C0       STA TPB_reg_b
10130      
10131    EF98  68             PLA
10132    EF99  28             PLP
10133    EF9A  60             RTS  
10134      
10135    STB_ack_wait
10136    EF9B  48             PHA
10137      
10138    TPB_w_loop
10139    EF9C  AD 2D C0       LDA TPB_ifr                     ; Check IFR for interrupt flag on CB1 set
10140    EF9F  29 02          AND #TPB_ACK_CA1_b
10141    EFA1  F0 F9          BEQ TPB_w_loop                  ; Until they match
10142      
10143    EFA3  68             PLA
10144    EFA4  60             RTS
10145     
10146     
10147    ; Delay routine for TPB, there are better ways but this will do for now.
10148      
10149    TPB_delay
10150    EFA5  48             PHA
10151      
10152    EFA6  A9 06          LDA #6
10153    EFA8  38             SEC
10154      
10155    TPB_delay_loop
10156    EFA9  E9 01          SBC #1
10157    EFAB  D0 FC          BNE TPB_delay_loop
10158      
10159    EFAD  68             PLA
10160    EFAE  60             RTS
10161    
10162    ; *****************************************************************
10163    ;
10164    ;                       END OF TPBCARD.asm
10165    ;
10166    ; *****************************************************************
10167    ; *****************************************************************
10168      .INCLUDE "TAPE_IO.asm"
10169    ; Tape Interface Functions for ToE Tape and Joystick interface.
10170    
10171    ; Compatible with versions 1 and 1.1 of the interface as of 30/12/2020
10172    
10173    
10174    ; Tape interface bitfield definitions
10175    
10176      0080             TAPE_out		= @10000000			; This is the bit to toggle for tape writing.
10177      0040             TAPE_in			= @01000000			; This is the bit to sample for tape reading.
10178      003F             JOYSTICK_bits		= @00111111			; These bits are used by the joystick interface.
10179      0001             JOYSTICK_sel		= @00000001			; 0 selects Joystick 0, 1 selects joystick 2. Easy.
10180    
10181      0001             TAPE_Stat_overrun	= @00000001			; Stop bit was a one!
10182      0002             TAPE_Stat_par_err	= @00000010			; Parity error.  It remains to be seen if this gets implemented.
10183      0004             TAPE_Stat_RXFull	= @00000100			; Byte received
10184      0008             TAPE_Stat_Escape	= @00001000			; Indication that the escape key has been pressed
10185    
10186      0001             TAPE_BlockIn_Complete	= @00000001
10187      0002             TAPE_BlockIn_Escape	= @00000010
10188      0004             TAPE_BlockIn_Error	= @00000100
10189    
10190      0001             TAPE_Verify_Good	= @00000001
10191      0002             TAPE_Verify_Escape	= @00000010
10192      0004             TAPE_Verify_Error	= @00000100
10193    
10194    ; Tape interface port addresses
10195    
10196      C040             TAPE_IOBASE		= $C040				; Base address for our tape port.  This is normally set to whatever the GPIO card is.
10197      C040             TAPE_IOP		= TAPE_IOBASE			; We are currently using PORT B on the user port card for IO.
10198      C042             TAPE_DDRB		= TAPE_IOBASE + 2
10199    
10200    
10201    ; Tape system storage zeropage addresses
10202      00E4             TAPE_temp		= $E4				; Let's use one of the zero page addresses
10203      00E5             TAPE_BlockLo		= $E5
10204      00E6             TAPE_BlockHi		= $E6
10205    
10206    ; Tape timing values.
10207    
10208    ; Please note that all this is subject to changes as and when needed because I'm in uncharted territory
10209    ; and don't quite know what I'm doing yet.
10210    
10211    
10212      0008             C_TAPE_Phasetime	= 8				; How long to wait between phases.  Bigger is slower
10213      0014             C_TAPE_Sample_Offset	= 20				; How far is the middle of the bit. Note: timing errors will cause this to stretch
10214      0036             C_TAPE_Bitlength	= 54				; How many passes for a full bit
10215      0008             C_TAPE_bitcycles	= 8				; Number of cycles to a bit
10216      000A             C_TAPE_BitsPerFrame	= 10				; Total number of bits per frame including start and stop bits.
10217      00AA             C_TAPE_LeaderByte	= $AA				; Leader byte
10218      0055             C_TAPE_EndOfLeaderByte  = $55				; End of leader signal byte
10219      AFC8             C_TAPE_Interblock_pause = 45000				; How long between blocks to wait before starting the next one.
10220    
10221      0064             TAPE_Leader_Bytes	= 100				; Set leader length in bits.
10222    
10223    ; File type constants
10224    
10225      0000             C_TAPE_FType_BASIC	= 0				; BASIC program
10226      0001             C_TAPE_FType_BINARY	= 1				; Binary Data
10227      0002             C_TAPE_FType_TEXT	= 2				; Pure text.  NOTE: Good for merging snippets of code.
10228    
10229    
10230    ; System variables for tape routines.
10231    
10232    
10233    ; +================================+
10234    ; !                                !
10235    ; ! TAPE SPACE FROM $900 TO $AFF   !
10236    ; !                                !
10237    ; !                                !
10238    ; !                                !
10239    ; +================================+
10240    
10241      0900             TAPE_RAM_Start			= $900				; Base address of the tape filing system main memory
10242    
10243      0900             V_TAPE_BlockSize		= TAPE_RAM_Start		; 2 Byte address for block size
10244      0902             TAPE_temp2			= TAPE_RAM_Start + 2		; Second temporary store for tape functions.
10245      0903             TAPE_temp3			= TAPE_RAM_Start + 3		; Third temporary store for tape functions.
10246      0904             TAPE_temp4			= TAPE_RAM_Start + 4		; Fourth temporary store for tape functions.
10247      0905             TAPE_LineUptime			= TAPE_RAM_Start + 5		; How many passes of the superloop the line has been up.
10248      0906             TAPE_Demod_Status		= TAPE_RAM_Start + 6		; Demodulated bit status.
10249      0907             TAPE_Demod_Last			= TAPE_RAM_Start + 7		; Our previous demod status.  Used for edge detection etc.
10250      0908             TAPE_StartDet			= TAPE_RAM_Start + 8		; Start bit detected is 1, 0 otherwise
10251      0909             TAPE_RX_Status			= TAPE_RAM_Start + 9		; Receive engine status bitfield.
10252      090A             TAPE_BitsToDecode		= TAPE_RAM_Start + 10		; Bit countdown counter when decoding
10253      090B             TAPE_ByteReceived		= TAPE_RAM_Start + 11		; Last byte received
10254      090C             TAPE_Sample_Position		= TAPE_RAM_Start + 12		; Countdown timer for bit engine sample synchronization
10255      090D             TAPE_BlockIn_Status		= TAPE_RAM_Start + 13		; Status register for the F_TAPE_BlockIn function.
10256    
10257      090E             TAPE_Header_Buffer		= TAPE_BlockIn_Status + 1	; This is where the tape header data starts
10258      090E             TAPE_HeaderID			= TAPE_Header_Buffer		; Just stores 'HEAD'.  Used to identify headers from other stuff.
10259      0912             TAPE_FileType			= TAPE_HeaderID + 4		; This is the file type ID goes. 0 is for BASIC, otherwise ignored by LOAD.
10260      0913             TAPE_FileSizeLo			= TAPE_FileType + 1		; Low byte of the file size
10261      0914             TAPE_FileSizeHi			= TAPE_FileSizeLo + 1		; High byte of the file size
10262      0915             TAPE_LoadAddrLo			= TAPE_FileSizeHi + 1		; Low byte of the file load address
10263      0916             TAPE_LoadAddrHi			= TAPE_LoadAddrLo + 1		; High byte of the file load address
10264      0917             TAPE_FileName			= TAPE_LoadAddrHi + 1		; Null terminated filename field 17 bytes long.
10265      0928             TAPE_ChecksumLo			= TAPE_FileName + C_TAPE_Fname_BufferSize	; Checksum Low byte
10266      0929             TAPE_ChecksumHi			= TAPE_ChecksumLo + 1		; Checksum High byte
10267      0929             TAPE_Header_End			= TAPE_ChecksumHi		; End of header space
10268    
10269      092A             TAPE_CS_AccLo			= TAPE_Header_End + 1		; Tape checksum Accumulator low byte
10270      092B             TAPE_CS_AccHi			= TAPE_CS_AccLo + 1		; Tape checksum Accumulator high byte
10271    
10272      092C             V_TAPE_Phasetime		= TAPE_CS_AccHi + 1		; Tape phasetime variable
10273      092D             V_TAPE_Sample_Offset		= V_TAPE_Phasetime + 1		; Sample offset variable
10274      092E             V_TAPE_Bitlength		= V_TAPE_Sample_Offset + 1	; How long a bit is in passes variable
10275      092F             V_TAPE_bitcycles		= V_TAPE_Bitlength + 1		; Number of cycles to a bit variable
10276    
10277      0930             V_TAPE_Verify_Status		= V_TAPE_bitcycles + 1		; Status register for the F_TAPE_Verify function.
10278      0931             V_TAPE_Fname_Buffer		= V_TAPE_Verify_Status + 1	; Filename Buffer for null terminated filename.
10279      0943             V_TAPE_LOADSAVE_Type		= V_TAPE_Fname_Buffer + 18	; LOAD or SAVE type being currently handled.
10280      0944             V_TAPE_Address_Buff		= V_TAPE_LOADSAVE_Type + 1	; Address for LOAD and SAVE operations.
10281      0946             V_TAPE_Size_Buff		= V_TAPE_Address_Buff + 2
10282    
10283    ; Some more handy constants
10284    
10285      0011             C_TAPE_Fname_BufferSize		= 17
10286      0942             C_TAPE_Fname_BuffEnd		= V_TAPE_Fname_Buffer + C_TAPE_Fname_BufferSize 
10287      001C             C_TAPE_HeaderSize		= TAPE_Header_End - TAPE_Header_Buffer + 1
10288    
10289    
10290    
10291    
10292    
10293    ; Next is $947.
10294    
10295    ; +-------------------------------------------------------------------------------------------+
10296    ; +                                                                                           +
10297    ; +                              TAPE FILING SYSTEM MESSAGE STRINGS.                          +
10298    ; +                                                                                           +
10299    ; +-------------------------------------------------------------------------------------------+
10300    
10301    
10302    TMSG_init_msg						; Filing System initialisation string.
10303     
10304      .BYTE $0C,1,$18,$03,$0D,$0A
10305      .BYTE "TowerTAPE Filing System",$0D,$0A
10306      .BYTE "V2.36",$0D,$0A,$0D,$0A,$00
10307      
10308    
10309    TMSG_Ready
10310    
10311      .BYTE "Ready",$D,$A,0
10312      
10313      
10314    TMSG_Saving
10315    
10316      .BYTE $D,$A
10317      .BYTE "Saving ",0
10318      
10319      
10320    TMSG_Searching
10321    
10322      .BYTE $D,$A
10323      .BYTE "Searching...",$D,$A,$A,0
10324    
10325    
10326    TMSG_Found
10327      .BYTE "Found ",0 
10328    
10329    TMSG_Loading
10330    
10331      .BYTE $D,$A
10332      .BYTE "Loading...",$D,$A,0
10333      
10334    TMSG_Verifying
10335    
10336      .BYTE $D,$A
10337      .BYTE "Verifying.",$D,$A,0
10338      
10339    TMSG_Verified
10340    
10341      .BYTE $D,$A
10342      .BYTE "Verified OK.",$D,$A,0
10343      
10344    TMSG_VerifyError
10345    
10346      .BYTE $D,$A
10347      .BYTE "Verify Error.",$D,$A,0
10348    
10349    TMSG_TapeError
10350    
10351      .BYTE $D,$A
10352      .BYTE "Tape loading Error.",$D,$A,0
10353      
10354      
10355    TMSG_HeaderError  
10356    
10357      .BYTE $D,$A
10358      .BYTE "Header error. Retrying.",$D,$A,0
10359      
10360    TMSG_TypeBASIC
10361    
10362      .BYTE "BASIC: ",0
10363      
10364    TMSG_TypeBINARY
10365    
10366      .BYTE "binary: ",0
10367      
10368    TMSG_TypeTEXT
10369    
10370      .BYTE "text: ",0
10371      
10372    TMSG_TypeOTHER
10373      .BYTE "other: ",0
10374      
10375    
10376    
10377    ; +-------------------------------------------------------------------------------------------------+
10378    ; +                                                                                                 +
10379    ; +                        Functions for tape loading and saving start here.                        +
10380    ; +                        =================================================                        +
10381    ; +                                                                                                 +
10382    ; +                                                                                                 +
10383    ; +-------------------------------------------------------------------------------------------------+
10384    
10385    
10386    ;*****************************************************************************************
10387    ;**                                                                                     **
10388    ;**                                                                                     **
10389    ;**                HOUSEKEEPING AND INITIALISATION FUNCTIONS GO HERE.                   **
10390    ;**                                                                                     **
10391    ;**                                                                                     **
10392    ;*****************************************************************************************
10393    
10394    F_TAPE_Init
10395    F098  A9 81          LDA #TAPE_out | JOYSTICK_sel				; Setup tape and joystick 6522 DDR Bits.
10396    F09A  8D 42 C0       STA TAPE_DDRB
10397    
10398    F09D  A0 00          LDY #0						; Setup our index to the start of the string
10399      
10400    L_TAPE_init_msg  
10401    F09F  B9 AF EF       LDA TMSG_init_msg,Y					; Get the character
10402    F0A2  F0 07          BEQ TAPE_msg_done					; Break out of the loop when we're done.
10403      
10404    F0A4  20 02 E2       JSR V_OUTP						; output character
10405      
10406    F0A7  C8             INY							; Do the next character
10407    F0A8  4C 9F F0       JMP L_TAPE_init_msg
10408    
10409    TAPE_msg_done  
10410    F0AB  60             RTS
10411        
10412    
10413      
10414    
10415    
10416    ;*****************************************************************************************
10417    ;**                                                                                     **
10418    ;**                                                                                     **
10419    ;**          Helper and high level functions for tape loading and saving.               **
10420    ;**                                                                                     **
10421    ;**                                                                                     **
10422    ;*****************************************************************************************
10423    
10424    
10425    ; Compares the filename in the buffer to the one in the header and returns C=1 on equality, otherwise C=0
10426    ;
10427    
10428    F_TAPE_CompareFileNames
10429    F0AC  A0 00          LDY #0						; Setup our index
10430      
10431    F0AE  AD 31 09       LDA V_TAPE_Fname_Buffer				; Short circuit to match on null filename specified.
10432    F0B1  C9 00          CMP #0
10433    F0B3  F0 10          BEQ TAPE_CompareByte_Match_B
10434      
10435    TAPE_CompareByte_L
10436    F0B5  B9 31 09       LDA V_TAPE_Fname_Buffer,Y				; Get our byte to compare
10437    
10438    F0B8  D9 17 09       CMP TAPE_FileName,Y					; Branch on mismatch.
10439    F0BB  D0 0A          BNE TAPE_CompareMismatch_B
10440      
10441    F0BD  98             TYA							; Decrement index and branch when done
10442    F0BE  C8             INY
10443    F0BF  C9 10          CMP #16
10444    F0C1  F0 02          BEQ TAPE_CompareByte_Match_B
10445    F0C3  80 F0          BRA TAPE_CompareByte_L
10446      
10447    TAPE_CompareByte_Match_B				; Signal match and exit
10448    F0C5  38             SEC
10449    F0C6  60             RTS 
10450      
10451    TAPE_CompareMismatch_B
10452    F0C7  18             CLC							; Signal mismatch and exit
10453    F0C8  60             RTS
10454    
10455    ; Just prints 'Found ', followed by the filename.  That's all.
10456    
10457    F_TAPE_PrintFound
10458    F0C9  A9 FC          LDA #<TMSG_Found					; Print 'Found '
10459    F0CB  85 E7          STA TOE_MemptrLo
10460    F0CD  A9 EF          LDA #>TMSG_Found 
10461    F0CF  85 E8          STA TOE_MemptrHi
10462    F0D1  20 60 FF       JSR TOE_PrintStr_vec
10463      
10464    
10465    F0D4  AD 12 09       LDA TAPE_FileType					; Check and print BASIC if necessary.
10466    F0D7  C9 00          CMP #C_TAPE_FType_BASIC
10467    F0D9  D0 0D          BNE TAPE_Skip_RepBASIC_B
10468      
10469    F0DB  A9 78          LDA #<TMSG_TypeBASIC
10470    F0DD  85 E7          STA TOE_MemptrLo
10471    F0DF  A9 F0          LDA #>TMSG_TypeBASIC
10472    F0E1  85 E8          STA TOE_MemptrHi
10473    F0E3  20 60 FF       JSR TOE_PrintStr_vec
10474      
10475    F0E6  80 33          BRA TAPE_DoPrintFname_B
10476       
10477    TAPE_Skip_RepBASIC_B
10478    
10479    F0E8  AD 12 09       LDA TAPE_FileType					; Check and print BASIC if necessary.
10480    F0EB  C9 01          CMP #C_TAPE_FType_BINARY
10481    F0ED  D0 0D          BNE TAPE_Skip_RepBinary_B
10482      
10483    F0EF  A9 80          LDA #<TMSG_TypeBINARY
10484    F0F1  85 E7          STA TOE_MemptrLo
10485    F0F3  A9 F0          LDA #>TMSG_TypeBINARY
10486    F0F5  85 E8          STA TOE_MemptrHi
10487    F0F7  20 60 FF       JSR TOE_PrintStr_vec
10488      
10489    F0FA  80 1F          BRA TAPE_DoPrintFname_B
10490      
10491    TAPE_Skip_RepBinary_B
10492    
10493    F0FC  AD 12 09       LDA TAPE_FileType					; Check and print BASIC if necessary.
10494    F0FF  C9 02          CMP #C_TAPE_FType_TEXT
10495    F101  D0 0D          BNE TAPE_Skip_RepText_B
10496      
10497    F103  A9 89          LDA #<TMSG_TypeTEXT
10498    F105  85 E7          STA TOE_MemptrLo
10499    F107  A9 F0          LDA #>TMSG_TypeTEXT
10500    F109  85 E8          STA TOE_MemptrHi
10501    F10B  20 60 FF       JSR TOE_PrintStr_vec
10502    
10503    F10E  80 0B          BRA TAPE_DoPrintFname_B
10504      
10505    TAPE_Skip_RepText_B
10506    
10507    F110  A9 90          LDA #<TMSG_TypeOTHER
10508    F112  85 E7          STA TOE_MemptrLo
10509    F114  A9 F0          LDA #>TMSG_TypeOTHER
10510    F116  85 E8          STA TOE_MemptrHi
10511    F118  20 60 FF       JSR TOE_PrintStr_vec
10512    
10513    TAPE_DoPrintFname_B
10514    F11B  20 BD F1       JSR F_TAPE_PrintFname_in_Header			; Print our filename.
10515    F11E  20 99 C9       JSR   LAB_CRLF					; print CR/LF. 
10516    F121  60             RTS
10517      
10518    
10519    ; Write HEAD to the header ID field.  Yes, it's primitive but it really is the easiest way.
10520    ;  
10521    F_TAPE_WriteHeaderID
10522    F122  A9 48          LDA #'H'
10523    F124  8D 0E 09       STA TAPE_HeaderID
10524    F127  A9 45          LDA #'E'
10525    F129  8D 0F 09       STA TAPE_HeaderID + 1
10526    F12C  A9 41          LDA #'A'
10527    F12E  8D 10 09       STA TAPE_HeaderID + 2
10528    F131  A9 44          LDA #'D'
10529    F133  8D 11 09       STA TAPE_HeaderID + 3
10530    F136  60             RTS
10531    
10532    
10533    ; Check to see if our header block IS a header block.
10534    ;
10535    F_TAPE_CheckHeaderID
10536    F137  AD 0E 09       LDA TAPE_HeaderID
10537    F13A  C9 48          CMP #'H'
10538    F13C  D0 17          BNE TAPE_NotAHeader_B
10539      
10540    F13E  AD 0F 09       LDA TAPE_HeaderID + 1
10541    F141  C9 45          CMP #'E'
10542    F143  D0 10          BNE TAPE_NotAHeader_B
10543      
10544    F145  AD 10 09       LDA TAPE_HeaderID + 2
10545    F148  C9 41          CMP #'A'
10546    F14A  D0 09          BNE TAPE_NotAHeader_B
10547      
10548    F14C  AD 11 09       LDA TAPE_HeaderID + 3
10549    F14F  C9 44          CMP #'D'
10550    F151  D0 02          BNE TAPE_NotAHeader_B
10551      
10552    F153  38             SEC					; Is a confirmed header
10553    F154  60             RTS
10554      
10555    TAPE_NotAHeader_B  
10556    F155  18             CLC					; Is not a header or is a bad header.
10557    F156  60             RTS
10558      
10559    
10560    ; Fill out V_TAPE_Fname_buffer with filename.
10561    ; TOE_MemptrLo and Hi contain the address bytes for the source.  A contains the length.
10562    ; This function also null terminates the string.
10563    
10564    F_TAPE_Fill_Fname
10565    F157  A0 00          LDY #0						; Clear our index so we point to the start of the string.
10566      
10567    F159  C9 00          CMP #0						; Handle null string swiftly
10568    F15B  F0 0B          BEQ TAPE_Fill_Null_L
10569      
10570    F15D  AA             TAX							; Set up our byte counter
10571      
10572    TAPE_Fill_Fname_L					; Fill_Fname loop start
10573    F15E  B1 E7          LDA (TOE_MemptrLo),Y					; Get our byte
10574    F160  99 31 09       STA V_TAPE_Fname_Buffer,Y				; Save our byte in our buffer.
10575    
10576    F163  C8             INY							; Increment our index
10577    F164  CA             DEX							; Decrement our counter
10578    F165  8A             TXA
10579    F166  D0 F6          BNE TAPE_Fill_Fname_L					; Repeat while counter not zero
10580    
10581    TAPE_Fill_Null_L					; At this point, we're putting the null characters in
10582    F168  A9 00          LDA #0
10583      
10584    F16A  99 31 09       STA V_TAPE_Fname_Buffer,Y
10585    F16D  98             TYA
10586    F16E  C8             INY
10587    F16F  C9 10          CMP #C_TAPE_Fname_BufferSize-1
10588    F171  D0 F5          BNE TAPE_Fill_Null_L
10589      
10590    F173  60             RTS							; End of F_TAPE_Fill_Fname routine.
10591      
10592      
10593    ; Copies V_TAPE_Fname_Buffer to the header
10594      
10595    F_TAPE_Fname_Buf_to_Header
10596    F174  A0 00          LDY #0						; Set our index
10597    
10598    TAPE_Fname_Buf_to_Header_L
10599    
10600    F176  B9 31 09       LDA V_TAPE_Fname_Buffer,Y				; Get our first byte
10601    F179  99 17 09       STA TAPE_FileName,Y					; And transfer it to the header.
10602      
10603    F17C  C8             INY							; Increment and repeat until done.
10604    F17D  C9 00          CMP #0
10605    F17F  D0 F5          BNE TAPE_Fname_Buf_to_Header_L
10606      
10607    TAPE_Fname_BlankRest_B					; Fill out rest of header with zero's for checksum purposes.
10608    F181  A9 00          LDA #0
10609    F183  99 17 09       STA TAPE_FileName,Y
10610    F186  98             TYA
10611    F187  C9 11          CMP #C_TAPE_Fname_BufferSize
10612    F189  F0 03          BEQ TAPE_Done_BlankRest_B
10613    F18B  C8             INY
10614    F18C  80 F3          BRA TAPE_Fname_BlankRest_B
10615      
10616    TAPE_Done_BlankRest_B
10617    F18E  60             RTS							; Done
10618    
10619    
10620    ; Get filename from command line into buffer.  Also handle errors.  This may not be the final thing.
10621    
10622    F_TAPE_GetName
10623    F18F  20 E7 CB       JSR LAB_EVEX						; evaluate string
10624    F192  20 55 D4       JSR LAB_EVST						; test it is a string
10625    F195  8D 02 09       STA TAPE_temp2					; Store our string length for later
10626      
10627    F198  A5 5F          LDA Dtypef						; Find out if it is a string and error if it isn't.  $FF=Str, $0=Numeric
10628    F19A  F0 10          BEQ TAPE_SYN_ERR
10629      
10630    F19C  AD 02 09       LDA TAPE_temp2					; Recover our string length
10631    F19F  38             SEC
10632    F1A0  E9 11          SBC #17
10633    F1A2  30 0E          BMI TAPE_NameToBuffer_B
10634    F1A4  80 00          BRA TAPE_LEN_ERR
10635    
10636    TAPE_LEN_ERR  
10637    F1A6  A2 24          LDX #$24 ;ERR_BF					; Issue a Bad filename Error
10638    F1A8  20 3F C2       JSR LAB_XERR
10639    F1AB  60             RTS							; Does LAB_XERR really return??
10640      
10641    TAPE_SYN_ERR
10642    ; Syntax Error output
10643    F1AC  A2 02          LDX #$2 ;ERR_SN					; Issue a Syntax Error.  
10644    F1AE  20 3F C2       JSR LAB_XERR
10645    F1B1  60             RTS							; Does LAB_XERR really return??							
10646    
10647    TAPE_NameToBuffer_B
10648    
10649    F1B2  86 E7          STX TOE_MemptrLo					; Copy our String to the 
10650    F1B4  84 E8          STY TOE_MemptrHi					; TOE_Memptr contains starting location
10651    F1B6  AD 02 09       LDA TAPE_temp2					; and A contains size.
10652    F1B9  20 57 F1       JSR F_TAPE_Fill_Fname
10653    F1BC  60             RTS
10654    
10655    
10656    ; Print Filename in header
10657    
10658    F_TAPE_PrintFname_in_Header
10659    F1BD  A9 22          LDA #34
10660    F1BF  20 02 E2       JSR V_OUTP
10661    F1C2  A9 17          LDA #<TAPE_FileName				; Print our Filename in the header space
10662    F1C4  85 E7          STA TOE_MemptrLo
10663    F1C6  A9 09          LDA #>TAPE_FileName 
10664    F1C8  85 E8          STA TOE_MemptrHi
10665    F1CA  20 60 FF       JSR TOE_PrintStr_vec
10666    F1CD  A9 22          LDA #34
10667    F1CF  20 02 E2       JSR V_OUTP
10668    F1D2  60             RTS
10669      
10670    
10671    ; Saves A BASIC program or binary block.  Meant to be called from within BASIC
10672    ;
10673    
10674    F_TAPE_SAVE_BASIC
10675    
10676    F1D3  20 8F F1       JSR F_TAPE_GetName					; Get the filename from the command stream
10677    F1D6  20 74 F1       JSR F_TAPE_Fname_Buf_to_Header			; and put it in the header.
10678      
10679    F1D9  20 22 F1       JSR F_TAPE_WriteHeaderID				; Include the Header ID 'HEAD'
10680    
10681    F1DC  A9 00          LDA #C_TAPE_FType_BASIC				; Initially set the type to BASIC.  Depending on following params, this may get changed.
10682    F1DE  8D 43 09       STA V_TAPE_LOADSAVE_Type
10683      
10684    F1E1  A9 00          LDA #<Ram_base					; Store the BASIC load address to our buffer too.
10685    F1E3  8D 44 09       STA V_TAPE_Address_Buff				; This also might get changed.
10686    F1E6  A9 0C          LDA #>Ram_base
10687    F1E8  8D 45 09       STA V_TAPE_Address_Buff + 1
10688      
10689    F1EB  20 50 F5       JSR F_TAPE_GetBASIC_Size				; Find out how big our BASIC program is.
10690      
10691    F1EE  AD 00 09       LDA V_TAPE_BlockSize					; Transfer it to the size buffer.
10692    F1F1  8D 46 09       STA V_TAPE_Size_Buff
10693    F1F4  AD 01 09       LDA V_TAPE_BlockSize + 1
10694    F1F7  8D 47 09       STA V_TAPE_Size_Buff + 1
10695      
10696      
10697      
10698    F1FA  20 C2 00       JSR LAB_GBYT						; Find out if we have extra parameters or not,
10699      							; firstly checking if we have a null.
10700    F1FD  F0 2B          BEQ B_TAPE_SAVE					; If we have null, we can continue as SAVEing BASIC otherwise it's binary.
10701      
10702    
10703    ; BINARY case.
10704      
10705    F1FF  20 D3 CB       JSR LAB_EVNM						; evaluate expression and check is numeric,
10706    							; else do type mismatch
10707    F202  20 04 D6       JSR LAB_F2FX						; save integer part of FAC1 in temporary integer
10708    
10709    F205  20 04 CD       JSR LAB_1C01						; scan for "," , else do syntax error then warm start
10710          							
10711    F208  A5 11          LDA Itempl						; save our specified base address
10712    F20A  8D 44 09       STA V_TAPE_Address_Buff
10713    F20D  A5 12          LDA   Itemph
10714    F20F  8D 45 09       STA V_TAPE_Address_Buff + 1
10715      
10716    F212  20 D3 CB       JSR LAB_EVNM						; Get and store our binary file size
10717      							; If this parameter is missing you will get a Syntax Error.
10718    F215  20 04 D6       JSR LAB_F2FX						; save integer part of FAC1 in temporary integer
10719      
10720    F218  20 C2 00       JSR LAB_GBYT						; FINDME:- Loose the comma ready for the next paramter.
10721      							; This may not be necessary or right.
10722      
10723    F21B  A5 11          LDA Itempl						; Replace the size in the buffer with the one from BASIC
10724    F21D  8D 46 09       STA V_TAPE_Size_Buff
10725    F220  A5 12          LDA Itemph
10726    F222  8D 47 09       STA V_TAPE_Size_Buff + 1
10727      
10728    F225  A9 01          LDA #C_TAPE_FType_BINARY				; Set the type to BINARY
10729    F227  8D 43 09       STA V_TAPE_LOADSAVE_Type
10730      
10731      ; NOTE:- By this point, the address and size buffers should contain correct parameters alongside the file type info.
10732      
10733      
10734    ; Now do the SAVE
10735    
10736    ; By this point the Address and size are stored in their relevant buffers.
10737    
10738    B_TAPE_SAVE
10739    
10740    F22A  A9 E0          LDA #<TMSG_Saving					; Tell the user that we are saving.
10741    F22C  85 E7          STA TOE_MemptrLo
10742    F22E  A9 EF          LDA #>TMSG_Saving
10743    F230  85 E8          STA TOE_MemptrHi
10744    F232  20 60 FF       JSR TOE_PrintStr_vec
10745      
10746    F235  20 BD F1       JSR F_TAPE_PrintFname_in_Header			; Print our "Filename".
10747    
10748    
10749    ; Provide the necessary parameters for the F_TAPE_CalcChecksum to work
10750      
10751    F238  AD 46 09       LDA V_TAPE_Size_Buff					; Save our program size to the header and to V_TAPE_BlockSize
10752    F23B  8D 13 09       STA TAPE_FileSizeLo
10753    F23E  8D 00 09       STA V_TAPE_BlockSize
10754    F241  AD 47 09       LDA V_TAPE_Size_Buff + 1
10755    F244  8D 14 09       STA TAPE_FileSizeHi  
10756    F247  8D 01 09       STA V_TAPE_BlockSize + 1
10757      
10758    F24A  AD 44 09       LDA V_TAPE_Address_Buff				; Get our starting pointer for calculating our checksum loaded.
10759    F24D  85 E5          STA TAPE_BlockLo
10760    F24F  AD 45 09       LDA V_TAPE_Address_Buff + 1
10761    F252  85 E6          STA TAPE_BlockHi
10762      
10763    F254  20 15 F5       JSR F_TAPE_CalcChecksum				; Get our checksum value
10764    
10765    F257  AD 2A 09       LDA TAPE_CS_AccLo					; Store our calculated Checksum in the header structure.
10766    F25A  8D 28 09       STA TAPE_ChecksumLo
10767    F25D  AD 2B 09       LDA TAPE_CS_AccHi
10768    F260  8D 29 09       STA TAPE_ChecksumHi
10769      
10770    F263  AD 44 09       LDA V_TAPE_Address_Buff				; Include the LOAD address in the header.  It remains to be seen how we establish
10771    F266  8D 15 09       STA TAPE_LoadAddrLo					; Load to SAVE'd address implied by the header.
10772    F269  AD 45 09       LDA V_TAPE_Address_Buff + 1
10773    F26C  8D 16 09       STA TAPE_LoadAddrHi
10774      
10775    F26F  AD 43 09       LDA V_TAPE_LOADSAVE_Type				; Setup the file type in the header too.
10776    F272  8D 12 09       STA TAPE_FileType
10777      
10778      
10779      ; Setup for F_TAPE_BlockOut to write the header to tape and then write it out.
10780      
10781    F275  A9 0E          LDA #<TAPE_Header_Buffer				; Setup our block pointer to the start of the header
10782    F277  85 E5          STA TAPE_BlockLo
10783    F279  A9 09          LDA #>TAPE_Header_Buffer
10784    F27B  85 E6          STA TAPE_BlockHi
10785      
10786    F27D  A9 1C          LDA #<C_TAPE_HeaderSize				; Load our blocksize with the size of our header buffer
10787    F27F  8D 00 09       STA V_TAPE_BlockSize
10788    F282  A9 00          LDA #>C_TAPE_HeaderSize
10789    F284  8D 01 09       STA V_TAPE_BlockSize + 1
10790      
10791    F287  20 EA F5       JSR F_TAPE_BlockOut					; Write our block to tape
10792      
10793      
10794      ; Include a decent pause between the header and the main block.
10795      
10796    F28A  A2 C8          LDX #<C_TAPE_Interblock_pause				; Wait a little before writing the actual program data block.
10797    F28C  A0 AF          LDY #>C_TAPE_Interblock_pause
10798    F28E  20 02 F5       JSR F_TAPE_Pause
10799      
10800      
10801    F291  AD 15 09       LDA TAPE_LoadAddrLo					; Transfer our start address to our Block pointer
10802    F294  85 E5          STA TAPE_BlockLo
10803    F296  AD 16 09       LDA TAPE_LoadAddrHi
10804    F299  85 E6          STA TAPE_BlockHi
10805      
10806    F29B  AD 13 09       LDA TAPE_FileSizeLo					; Setup our blocksize counter
10807    F29E  8D 00 09       STA V_TAPE_BlockSize
10808    F2A1  AD 14 09       LDA TAPE_FileSizeHi
10809    F2A4  8D 01 09       STA V_TAPE_BlockSize + 1
10810      
10811    F2A7  20 EA F5       JSR F_TAPE_BlockOut					; Write our file
10812        
10813    F2AA  60             RTS							; We're done for now.
10814      
10815      
10816    
10817    ; Tape VERIFY routine.
10818    ; --------------------
10819    
10820    F_TAPE_VERIFY_BASIC
10821    
10822    F2AB  20 8F F1       JSR F_TAPE_GetName					; Get the filename string into our buffer
10823    
10824      ; Initial BASIC case.
10825    
10826    F2AE  A9 00          LDA #<Ram_base					; Store the BASIC load address to our buffer too.
10827    F2B0  8D 44 09       STA V_TAPE_Address_Buff				; This also might get changed.
10828    F2B3  A9 0C          LDA #>Ram_base
10829    F2B5  8D 45 09       STA V_TAPE_Address_Buff + 1
10830      
10831    F2B8  20 50 F5       JSR F_TAPE_GetBASIC_Size				; Get our BASIC size.
10832      
10833    F2BB  AD 00 09       LDA V_TAPE_BlockSize					; Transfer it to the size buffer.
10834    F2BE  8D 46 09       STA V_TAPE_Size_Buff
10835    F2C1  AD 01 09       LDA V_TAPE_BlockSize + 1
10836    F2C4  8D 47 09       STA V_TAPE_Size_Buff + 1
10837      
10838    F2C7  A9 00          LDA #C_TAPE_FType_BASIC				; Set the type to BASIC
10839    F2C9  8D 43 09       STA V_TAPE_LOADSAVE_Type
10840    
10841    
10842      ; Identify if we are dealing with binary by it's extra parameters.
10843       
10844    F2CC  20 C2 00       JSR LAB_GBYT						; Find out if we have extra parameters or not,
10845      							; firstly checking if we have a null.
10846    F2CF  F0 15          BEQ TAPE_VERIFY_Searching_B				; If we have null, we can continue as SAVEing BASIC otherwise it's binary.
10847      
10848      ; BINARY case.
10849      
10850    F2D1  20 D3 CB       JSR LAB_EVNM						; evaluate expression and check is numeric,
10851    							; else do type mismatch
10852    F2D4  20 04 D6       JSR LAB_F2FX						; save integer part of FAC1 in temporary integer
10853        							
10854    F2D7  A5 11          LDA Itempl						; save our specified base address
10855    F2D9  8D 44 09       STA V_TAPE_Address_Buff
10856    F2DC  A5 12          LDA Itemph
10857    F2DE  8D 45 09       STA V_TAPE_Address_Buff + 1
10858      
10859    F2E1  A9 01          LDA #C_TAPE_FType_BINARY				; Set the type to BINARY
10860    F2E3  8D 43 09       STA V_TAPE_LOADSAVE_Type
10861      
10862      
10863      ; Now go verify!
10864      
10865    TAPE_VERIFY_Searching_B
10866    
10867    F2E6  A9 EA          LDA #<TMSG_Searching					; Tell the user that we are searching.
10868    F2E8  85 E7          STA TOE_MemptrLo
10869    F2EA  A9 EF          LDA #>TMSG_Searching
10870    F2EC  85 E8          STA TOE_MemptrHi
10871    F2EE  20 60 FF       JSR TOE_PrintStr_vec
10872    
10873    TAPE_VERIFY_Header_B
10874    
10875    F2F1  A9 0E          LDA #<TAPE_Header_Buffer				; Point to start of header buffer
10876    F2F3  85 E5          STA TAPE_BlockLo
10877    F2F5  A9 09          LDA #>TAPE_Header_Buffer
10878    F2F7  85 E6          STA TAPE_BlockHi
10879      
10880    F2F9  A9 1C          LDA #<C_TAPE_HeaderSize				; Specify how big our header is.
10881    F2FB  8D 00 09       STA V_TAPE_BlockSize
10882    F2FE  A9 00          LDA #>C_TAPE_HeaderSize
10883    F300  8D 01 09       STA V_TAPE_BlockSize + 1
10884      
10885    F303  20 C8 F6       JSR F_TAPE_BlockIn					; Load the header block.
10886      
10887    F306  C9 02          CMP #TAPE_BlockIn_Escape
10888    F308  D0 03          BNE TAPE_BlockIn_EscNotPressed_B
10889    F30A  4C F7 F3       JMP TAPE_BlockIn_EscHandler				; If escaping jump to the escape handler
10890    
10891    TAPE_BlockIn_EscNotPressed_B
10892    
10893    F30D  20 37 F1       JSR F_TAPE_CheckHeaderID				; try again if not a valid header
10894    F310  90 DF          BCC TAPE_VERIFY_Header_B
10895    
10896    F312  C9 04          CMP #TAPE_Verify_Error
10897    F314  D0 0E          BNE TAPE_VERIFY_Fname_Check
10898    
10899    F316  A9 5C          LDA #<TMSG_HeaderError				; Tell the user of the header error and retry
10900    F318  85 E7          STA TOE_MemptrLo
10901    F31A  A9 F0          LDA #>TMSG_HeaderError
10902    F31C  85 E8          STA TOE_MemptrHi
10903    F31E  20 60 FF       JSR TOE_PrintStr_vec
10904      
10905    F321  4C F1 F2       JMP TAPE_VERIFY_Header_B				; Keep coming back until the header is read valid or the user presses escape
10906    
10907    
10908    TAPE_VERIFY_Fname_Check
10909    F324  20 C9 F0       JSR F_TAPE_PrintFound
10910      
10911    F327  20 AC F0       JSR F_TAPE_CompareFileNames
10912    F32A  90 C5          BCC TAPE_VERIFY_Header_B
10913      
10914    F32C  AD 12 09       LDA TAPE_FileType					; We're only interested in verifying the right type of file.
10915    F32F  CD 43 09       CMP V_TAPE_LOADSAVE_Type
10916    F332  D0 BD          BNE TAPE_VERIFY_Header_B
10917      
10918    TAPE_Verify_Stage
10919    
10920    F334  AD 13 09       LDA TAPE_FileSizeLo					; Put our file size into V_TAPE_BlockSize.
10921    F337  8D 00 09       STA V_TAPE_BlockSize
10922    F33A  AD 14 09       LDA TAPE_FileSizeHi
10923    F33D  8D 01 09       STA V_TAPE_BlockSize + 1
10924    
10925    F340  AD 43 09       LDA V_TAPE_LOADSAVE_Type
10926    F343  C9 01          CMP #C_TAPE_FType_BINARY
10927      
10928    F345  F0 0C          BEQ B_TAPE_Verify_SkipBASIC_Sizing
10929    
10930    F347  AD 46 09       LDA V_TAPE_Size_Buff					; Put our measured BASIC size into V_TAPE_BlockSize
10931    F34A  8D 00 09       STA V_TAPE_BlockSize
10932    F34D  AD 47 09       LDA V_TAPE_Size_Buff + 1
10933    F350  8D 01 09       STA V_TAPE_BlockSize + 1
10934    
10935    B_TAPE_Verify_SkipBASIC_Sizing
10936    
10937    F353  AD 13 09       LDA TAPE_FileSizeLo					; Check our file is the same size as our stored program.
10938    F356  CD 00 09       CMP V_TAPE_BlockSize
10939    F359  D0 37          BNE TAPE_Verify_Error_B
10940    F35B  AD 14 09       LDA TAPE_FileSizeHi
10941    F35E  CD 01 09       CMP V_TAPE_BlockSize + 1
10942    F361  D0 2F          BNE TAPE_Verify_Error_B
10943       
10944    F363  AD 13 09       LDA TAPE_FileSizeLo					; Tell the system how big the file to verify is.
10945    F366  8D 00 09       STA V_TAPE_BlockSize
10946    F369  AD 14 09       LDA TAPE_FileSizeHi
10947    F36C  8D 01 09       STA V_TAPE_BlockSize + 1
10948      
10949    F36F  AD 44 09       LDA V_TAPE_Address_Buff				; Tell the system where to start verifying the data,
10950    F372  85 E5          STA TAPE_BlockLo					; this should point to Ram_base for BASIC or as specified for binary.
10951    F374  AD 45 09       LDA V_TAPE_Address_Buff + 1
10952    F377  85 E6          STA TAPE_BlockHi
10953      
10954    F379  A9 12          LDA #<TMSG_Verifying					; Tell the user that we are verifying.
10955    F37B  85 E7          STA TOE_MemptrLo
10956    F37D  A9 F0          LDA #>TMSG_Verifying
10957    F37F  85 E8          STA TOE_MemptrHi
10958    F381  20 60 FF       JSR TOE_PrintStr_vec 
10959        
10960    F384  20 21 F7       JSR F_TAPE_VerifyBlock				; Verify the data in memory against the block on tape.
10961    
10962    F387  AD 30 09       LDA V_TAPE_Verify_Status				; Check our status
10963    F38A  C9 02          CMP #TAPE_Verify_Escape
10964    F38C  F0 69          BEQ TAPE_BlockIn_EscHandler				; If escaping jump to the escape handler
10965      
10966    F38E  C9 04          CMP #TAPE_Verify_Error				; Check if verify passed or not.
10967    F390  D0 0C          BNE TAPE_Verify_OK
10968      
10969    TAPE_Verify_Error_B  
10970    F392  A9 32          LDA #<TMSG_VerifyError				; Inform the user of the verification error.
10971    F394  85 E7          STA TOE_MemptrLo
10972    F396  A9 F0          LDA #>TMSG_VerifyError
10973    F398  85 E8          STA TOE_MemptrHi
10974    F39A  20 60 FF       JSR TOE_PrintStr_vec
10975    F39D  60             RTS
10976      
10977    TAPE_Verify_OK
10978    F39E  A9 21          LDA #<TMSG_Verified					; Inform the user of verification success.
10979    F3A0  85 E7          STA TOE_MemptrLo
10980    F3A2  A9 F0          LDA #>TMSG_Verified
10981    F3A4  85 E8          STA TOE_MemptrHi
10982    F3A6  20 60 FF       JSR TOE_PrintStr_vec
10983    
10984    TAPE_Verify_Done  
10985    F3A9  60             RTS
10986      
10987    F_TAPE_CAT
10988    
10989    F3AA  A9 EA          LDA #<TMSG_Searching					; Tell the user that we are searching.
10990    F3AC  85 E7          STA TOE_MemptrLo
10991    F3AE  A9 EF          LDA #>TMSG_Searching
10992    F3B0  85 E8          STA TOE_MemptrHi
10993    F3B2  20 60 FF       JSR TOE_PrintStr_vec
10994    
10995    TAPE_CAT_Header_B
10996    
10997    F3B5  A9 0E          LDA #<TAPE_Header_Buffer				; Point to start of header buffer
10998    F3B7  85 E5          STA TAPE_BlockLo
10999    F3B9  A9 09          LDA #>TAPE_Header_Buffer
11000    F3BB  85 E6          STA TAPE_BlockHi
11001      
11002    F3BD  A9 1C          LDA #<C_TAPE_HeaderSize				; Specify how big our header is.
11003    F3BF  8D 00 09       STA V_TAPE_BlockSize
11004    F3C2  A9 00          LDA #>C_TAPE_HeaderSize
11005    F3C4  8D 01 09       STA V_TAPE_BlockSize + 1
11006      
11007    F3C7  20 C8 F6       JSR F_TAPE_BlockIn
11008    F3CA  C9 02          CMP #TAPE_BlockIn_Escape
11009    F3CC  F0 1C          BEQ TAPE_CAT_Exit_B
11010      
11011    F3CE  20 37 F1       JSR F_TAPE_CheckHeaderID				; try again if not a valid header
11012    F3D1  90 E2          BCC TAPE_CAT_Header_B
11013    
11014    F3D3  C9 04          CMP #TAPE_BlockIn_Error
11015    F3D5  D0 0D          BNE TAPE_CAT_Fname_Report
11016      
11017    F3D7  A9 5C          LDA #<TMSG_HeaderError				; Tell the user of the header error and retry
11018    F3D9  85 E7          STA TOE_MemptrLo
11019    F3DB  A9 F0          LDA #>TMSG_HeaderError
11020    F3DD  85 E8          STA TOE_MemptrHi
11021    F3DF  20 60 FF       JSR TOE_PrintStr_vec
11022      
11023    F3E2  80 D1          BRA TAPE_CAT_Header_B
11024      
11025    
11026    TAPE_CAT_Fname_Report
11027    F3E4  20 C9 F0       JSR F_TAPE_PrintFound					; Tell the user what we found.
11028      ;FINDMEFINDME
11029    F3E7  60             RTS
11030    F3E8  80 CB          BRA TAPE_CAT_Header_B
11031      
11032    TAPE_CAT_Exit_B
11033    F3EA  60             RTS
11034    
11035    
11036    
11037    
11038    
11039    ; Tape Reporting routines.
11040    ; ------------------------
11041    
11042    TAPE_BlockIn_LoadErr
11043    F3EB  A9 44          LDA #<TMSG_TapeError					; Tell the user that we are have encountered an error.
11044    F3ED  85 E7          STA TOE_MemptrLo
11045    F3EF  A9 F0          LDA #>TMSG_TapeError
11046    F3F1  85 E8          STA TOE_MemptrHi
11047    F3F3  20 60 FF       JSR TOE_PrintStr_vec
11048    F3F6  60             RTS
11049      
11050    TAPE_BlockIn_EscHandler
11051    F3F7  A9 60          LDA #<LAB_BMSG					; Tell the user that we are have pressed Escape.
11052    F3F9  85 E7          STA TOE_MemptrLo
11053    F3FB  A9 E9          LDA #>LAB_BMSG
11054    F3FD  85 E8          STA TOE_MemptrHi
11055    F3FF  20 60 FF       JSR TOE_PrintStr_vec
11056    F402  60             RTS
11057      
11058      
11059    ;To BASIC 'LOAD' entry point.
11060      
11061    F_TAPE_LOAD_BASIC
11062    
11063    F403  20 8F F1       JSR F_TAPE_GetName					; Get the filename string into our buffer
11064      
11065    F406  A9 00          LDA #C_TAPE_FType_BASIC				; Initially set the type to BASIC
11066    F408  8D 43 09       STA V_TAPE_LOADSAVE_Type
11067      
11068    F40B  A9 00          LDA #<Ram_base					; Store the BASIC load address to our buffer too.
11069    F40D  8D 44 09       STA V_TAPE_Address_Buff
11070    F410  A9 0C          LDA #>Ram_base
11071    F412  8D 45 09       STA V_TAPE_Address_Buff + 1
11072    
11073    
11074    F415  20 C2 00       JSR LAB_GBYT						; Find out if we have extra parameters or not.						; Firstly checking if we have a null.
11075    F418  F0 15          BEQ TAPE_LOAD_Header_B				; Since we have nothing, we can continue as LOADing BASIC
11076      
11077    
11078    ; Handle BINARY case.
11079      
11080    F41A  20 D3 CB       JSR LAB_EVNM						; evaluate expression and check is numeric,
11081    							; else do type mismatch
11082    F41D  20 04 D6       JSR LAB_F2FX						; save integer part of FAC1 in temporary integer
11083    
11084    ; These next two lines are not needed for LOADs to memory, only SAVEs from memory.
11085    
11086    							; scan for "," and get byte, else do Syntax error then warm start
11087    
11088          							; JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
11089          							
11090    
11091    ; Setup for a binary LOAD
11092          							
11093    F420  A5 11          LDA Itempl						; save our specified base address
11094    F422  8D 44 09       STA V_TAPE_Address_Buff
11095    F425  A5 12          LDA Itemph
11096    F427  8D 45 09       STA V_TAPE_Address_Buff + 1
11097      
11098    F42A  A9 01          LDA #C_TAPE_FType_BINARY				; Set the type to BINARY
11099    F42C  8D 43 09       STA V_TAPE_LOADSAVE_Type
11100    
11101    
11102    ; Handle the Header
11103    
11104    TAPE_LOAD_Header_B  
11105    
11106    F42F  A9 EA          LDA #<TMSG_Searching					; Tell the user that we are searching.
11107    F431  85 E7          STA TOE_MemptrLo
11108    F433  A9 EF          LDA #>TMSG_Searching
11109    F435  85 E8          STA TOE_MemptrHi
11110    F437  20 60 FF       JSR TOE_PrintStr_vec
11111    
11112    TAPE_LOAD_Header_Silent_B
11113    
11114    F43A  A9 0E          LDA #<TAPE_Header_Buffer				; Point to start of header buffer
11115    F43C  85 E5          STA TAPE_BlockLo
11116    F43E  A9 09          LDA #>TAPE_Header_Buffer
11117    F440  85 E6          STA TAPE_BlockHi
11118      
11119    F442  A9 1C          LDA #<C_TAPE_HeaderSize				; Specify how big our header is.
11120    F444  8D 00 09       STA V_TAPE_BlockSize
11121    F447  A9 00          LDA #>C_TAPE_HeaderSize
11122    F449  8D 01 09       STA V_TAPE_BlockSize + 1
11123    
11124    F44C  20 C8 F6       JSR F_TAPE_BlockIn					; Load the header block.
11125      
11126    F44F  AD 0D 09       LDA TAPE_BlockIn_Status				; Branch on non load conditions
11127    F452  C9 02          CMP #TAPE_BlockIn_Escape
11128    F454  F0 A1          BEQ TAPE_BlockIn_EscHandler				; If escaping jump to the escape handler
11129      
11130    F456  20 37 F1       JSR F_TAPE_CheckHeaderID				; try again if not a valid header
11131    F459  90 DF          BCC TAPE_LOAD_Header_Silent_B
11132    
11133    F45B  C9 04          CMP #TAPE_BlockIn_Error
11134    F45D  D0 0E          BNE TAPE_BASLOAD_Fname_Check
11135    
11136    F45F  A9 5C          LDA #<TMSG_HeaderError				; Tell the user of the header error and retry
11137    F461  85 E7          STA TOE_MemptrLo
11138    F463  A9 F0          LDA #>TMSG_HeaderError
11139    F465  85 E8          STA TOE_MemptrHi
11140    F467  20 60 FF       JSR TOE_PrintStr_vec
11141    F46A  4C 2F F4       JMP TAPE_LOAD_Header_B
11142      
11143    
11144    TAPE_BASLOAD_Fname_Check
11145    F46D  20 C9 F0       JSR F_TAPE_PrintFound					; Tell the user what we found.
11146      
11147    F470  20 AC F0       JSR F_TAPE_CompareFileNames				; Check if our file is the right name
11148    F473  90 BA          BCC TAPE_LOAD_Header_B
11149      
11150    F475  AD 12 09       LDA TAPE_FileType					; We're only interested in loading the appropriate file type.
11151    F478  CD 43 09       CMP V_TAPE_LOADSAVE_Type
11152    F47B  D0 B2          BNE TAPE_LOAD_Header_B
11153    
11154    TAPE_BASIC_Load_Stage
11155    F47D  AD 13 09       LDA TAPE_FileSizeLo					; Tell the system how big the file to load is.
11156    F480  8D 00 09       STA V_TAPE_BlockSize
11157    F483  AD 14 09       LDA TAPE_FileSizeHi
11158    F486  8D 01 09       STA V_TAPE_BlockSize + 1
11159      
11160    F489  AD 44 09       LDA V_TAPE_Address_Buff				; Tell the system where to load to. This should point to Ram_base for BASIC
11161    F48C  85 E5          STA TAPE_BlockLo
11162    F48E  AD 45 09       LDA V_TAPE_Address_Buff + 1
11163    F491  85 E6          STA TAPE_BlockHi
11164      
11165    F493  A9 03          LDA #<TMSG_Loading					; Tell the user that we are loading.
11166    F495  85 E7          STA TOE_MemptrLo
11167    F497  A9 F0          LDA #>TMSG_Loading
11168    F499  85 E8          STA TOE_MemptrHi
11169    F49B  20 60 FF       JSR TOE_PrintStr_vec
11170      
11171    F49E  20 C8 F6       JSR F_TAPE_BlockIn					; Load the code block that follows
11172      
11173    F4A1  AD 0D 09       LDA TAPE_BlockIn_Status				; Branch on non load conditions
11174    F4A4  C9 02          CMP #TAPE_BlockIn_Escape
11175    F4A6  D0 03          BNE TAPE_Skip_EscHandler_B
11176    F4A8  4C F7 F3       JMP TAPE_BlockIn_EscHandler				; If escaping jump to the escape handler
11177      
11178    TAPE_Skip_EscHandler_B  
11179    
11180    F4AB  C9 01          CMP #TAPE_BlockIn_Complete
11181    F4AD  F0 03          BEQ TAPE_BASIC_LoadingDone
11182    
11183    F4AF  4C EB F3       JMP TAPE_BlockIn_LoadErr
11184      
11185    TAPE_BASIC_LoadingDone  
11186    F4B2  AD 44 09       LDA V_TAPE_Address_Buff				; Setup our pointer to the start of our LOADed memory
11187    F4B5  85 E5          STA TAPE_BlockLo
11188    F4B7  AD 45 09       LDA V_TAPE_Address_Buff + 1
11189    F4BA  85 E6          STA TAPE_BlockHi
11190    
11191    F4BC  20 15 F5       JSR F_TAPE_CalcChecksum				; Get our checksum value into TAPE_CS_Acc_Lo and Hi
11192      
11193    F4BF  AD 28 09       LDA TAPE_ChecksumLo					; First we check the low byte.
11194    F4C2  CD 2A 09       CMP TAPE_CS_AccLo
11195    F4C5  D0 2E          BNE TAPE_CS_Fail
11196      
11197    F4C7  AD 29 09       LDA TAPE_ChecksumHi					; And then if necessary, we check the high byte.
11198    F4CA  CD 2B 09       CMP TAPE_CS_AccHi
11199    F4CD  D0 26          BNE TAPE_CS_Fail
11200    
11201    TAPE_BASICload_exit
11202    
11203    F4CF  AD 43 09       LDA V_TAPE_LOADSAVE_Type
11204    F4D2  C9 00          CMP #C_TAPE_FType_BASIC
11205    F4D4  F0 01          BEQ B_Setup_NEWBASIC_Prog
11206    F4D6  60             RTS
11207      
11208    B_Setup_NEWBASIC_Prog
11209    
11210    F4D7  A9 D8          LDA #<TMSG_Ready					; Tell the user that we are saving.
11211    F4D9  85 E7          STA TOE_MemptrLo
11212    F4DB  A9 EF          LDA #>TMSG_Ready
11213    F4DD  85 E8          STA TOE_MemptrHi
11214    F4DF  20 60 FF       JSR TOE_PrintStr_vec
11215        
11216    F4E2  A5 E5          LDA TAPE_BlockLo					; Return the system to a useable state
11217    F4E4  85 7B          STA Svarl
11218    F4E6  85 7D          STA Sarryl
11219    F4E8  85 7F          STA Earryl
11220    F4EA  A5 E6          LDA TAPE_BlockHi
11221    F4EC  85 7C          STA Svarh
11222    F4EE  85 7E          STA Sarryh
11223    F4F0  85 80          STA Earryh
11224    F4F2  4C 17 C3       JMP LAB_1319						; Tidy up system.
11225      
11226    TAPE_CS_Fail
11227    F4F5  A9 44          LDA #<TMSG_TapeError					; Inform the user of their loading error.
11228    F4F7  85 E7          STA TOE_MemptrLo
11229    F4F9  A9 F0          LDA #>TMSG_TapeError
11230    F4FB  85 E8          STA TOE_MemptrHi
11231    F4FD  20 60 FF       JSR TOE_PrintStr_vec
11232    F500  80 CD          BRA TAPE_BASICload_exit
11233      
11234      
11235    F_TAPE_Pause
11236    
11237    F502  EA             NOP
11238    F503  EA             NOP
11239    F504  EA             NOP
11240    F505  EA             NOP
11241    F506  EA             NOP
11242    F507  EA             NOP
11243    F508  EA             NOP
11244    F509  EA             NOP
11245      
11246    F50A  CA             DEX
11247    F50B  E0 FF          CPX #$FF
11248    F50D  D0 F3          BNE F_TAPE_Pause
11249      
11250    F50F  88             DEY
11251    F510  C0 00          CPY #0
11252    F512  D0 EE          BNE F_TAPE_Pause
11253      
11254    F514  60             RTS
11255    
11256    
11257    F_TAPE_CalcChecksum
11258    
11259    F515  AE 00 09       LDX V_TAPE_BlockSize					; Set up our block counter
11260    F518  AC 01 09       LDY V_TAPE_BlockSize + 1
11261        
11262    F51B  A9 00          LDA #0						; Clear the checksum accumulator
11263    F51D  8D 2A 09       STA TAPE_CS_AccLo
11264    F520  8D 2B 09       STA TAPE_CS_AccHi
11265    
11266    L_TAPE_CS_NEXT  
11267    F523  AD 2A 09       LDA TAPE_CS_AccLo					; Add our byte to the checksum
11268    F526  18             CLC
11269    F527  72 E5          ADC (TAPE_BlockLo)
11270    F529  8D 2A 09       STA TAPE_CS_AccLo
11271    F52C  AD 2B 09       LDA TAPE_CS_AccHi
11272    F52F  69 00          ADC #0
11273    F531  8D 2B 09       STA TAPE_CS_AccHi
11274      
11275    F534  A5 E5          LDA TAPE_BlockLo					; Advance our pointer.
11276    F536  18             CLC
11277    F537  69 01          ADC #1
11278    F539  85 E5          STA TAPE_BlockLo
11279    F53B  A5 E6          LDA TAPE_BlockHi
11280    F53D  69 00          ADC #0
11281    F53F  85 E6          STA TAPE_BlockHi
11282      
11283    F541  CA             DEX							; Repeat until 0
11284    F542  E0 FF          CPX #$FF
11285    F544  D0 01          BNE CS_No_Y_update  
11286    F546  88             DEY
11287    CS_No_Y_update
11288    F547  C0 00          CPY #0
11289    F549  D0 D8          BNE L_TAPE_CS_NEXT
11290    F54B  E0 00          CPX #0
11291    F54D  D0 D4          BNE L_TAPE_CS_NEXT
11292      
11293    F54F  60             RTS
11294    
11295    
11296    ; Calculate the size of the BASIC program and store it in V_TAPE_BlockSize
11297    
11298    F_TAPE_GetBASIC_Size
11299    
11300    F550  38             SEC
11301    F551  A5 7B          LDA Svarl
11302    F553  E9 00          SBC #<Ram_base
11303    F555  8D 00 09       STA V_TAPE_BlockSize
11304    F558  A5 7C          LDA Svarh
11305    F55A  E9 0C          SBC #>Ram_base
11306    F55C  8D 01 09       STA V_TAPE_BlockSize + 1
11307      
11308    F55F  60             RTS
11309    
11310    
11311    ;*****************************************************************************************
11312    ;**                                                                                     **
11313    ;**                Timing and Synchronization functions go here.                        **
11314    ;**                ---------------------------------------------                        **
11315    ;**                                                                                     **
11316    ;*****************************************************************************************
11317    
11318    
11319    ; Wait for 50uS.  Note that JSR's cost 6 cycles
11320    
11321    F_TAPE_Phasetime_pause
11322    ; Each pass takes 10 cycles unless across a page boundary then it's 11 for an error of 10%!!
11323    
11324    ; Also, we need to make up the loss of 12 Cycles in calling it and in theory also the variable loading
11325    ; at the time of the call.
11326    
11327    ; First we disregard 20 cycles, then we burn them at 10 cycles a pass.
11328    
11329    F560  A2 08          LDX #C_TAPE_Phasetime					; 2 Cycles
11330    F562  CA             DEX							; 2 Cycles saving 10
11331    F563  CA             DEX							; 2 Cycles saving 10
11332    F564  EA             NOP							; 2 Cycles
11333    F565  EA             NOP							; 2 Cycles
11334    F566  EA             NOP							; 2 Cycles
11335    F567  EA             NOP							; 2 Cycles
11336      
11337    TAPE_Phasetime_loop
11338    F568  CA             DEX							; 2 Cycles
11339    F569  EA             NOP							; 2 Cycles
11340    F56A  EA             NOP							; 2 Cycles
11341    F56B  EA             NOP							; 2 Cycles
11342    F56C  D0 FA          BNE TAPE_Phasetime_loop				; 2 Cycles unless across pages.
11343      
11344    F56E  60             RTS							; 6 Cycles
11345      
11346      
11347      
11348      
11349    ;*****************************************************************************************
11350    ;**                                                                                     **
11351    ;**             Output Generating Functions.  Spoiler, It's all bitbashed!              **
11352    ;**             ----------------------------------------------------------              **
11353    ;**                                                                                     **
11354    ;*****************************************************************************************
11355      
11356        
11357    ;===============================================================================================
11358    ; TAPE Bit pulse generator  Takes the Z bit into consideration.
11359    
11360    
11361    F_TAPE_BitGen
11362    
11363    F56F  A0 08          LDY #C_TAPE_bitcycles					; Setup bitcycles loop
11364      
11365    TAPE_bitcycles_loop
11366    F571  48             PHA
11367    F572  C9 00          CMP #0
11368    F574  F0 05          BEQ TAPE_No_Pulse
11369      
11370    
11371    F576  A9 80          LDA #TAPE_out						; Set high phase
11372    F578  8D 40 C0       STA TAPE_IOP
11373    TAPE_No_Pulse
11374    F57B  20 60 F5       JSR F_TAPE_Phasetime_pause				; Wait hightone time which is eight times phase time.
11375    F57E  20 60 F5       JSR F_TAPE_Phasetime_pause				; This is so that the same loop can be used to capture the data for serial input
11376    F581  20 60 F5       JSR F_TAPE_Phasetime_pause
11377    F584  20 60 F5       JSR F_TAPE_Phasetime_pause
11378    F587  20 60 F5       JSR F_TAPE_Phasetime_pause
11379    F58A  20 60 F5       JSR F_TAPE_Phasetime_pause
11380    F58D  20 60 F5       JSR F_TAPE_Phasetime_pause
11381    F590  20 60 F5       JSR F_TAPE_Phasetime_pause
11382      
11383    
11384      
11385    
11386    F593  A9 00          LDA #0
11387    F595  8D 40 C0       STA TAPE_IOP						; Set low phase
11388    F598  20 60 F5       JSR F_TAPE_Phasetime_pause				; Wait hightone time
11389    F59B  20 60 F5       JSR F_TAPE_Phasetime_pause
11390    F59E  20 60 F5       JSR F_TAPE_Phasetime_pause
11391    F5A1  20 60 F5       JSR F_TAPE_Phasetime_pause
11392    F5A4  20 60 F5       JSR F_TAPE_Phasetime_pause
11393    F5A7  20 60 F5       JSR F_TAPE_Phasetime_pause
11394    F5AA  20 60 F5       JSR F_TAPE_Phasetime_pause
11395    F5AD  20 60 F5       JSR F_TAPE_Phasetime_pause
11396      
11397    F5B0  68             PLA
11398    F5B1  88             DEY
11399    F5B2  D0 BD          BNE TAPE_bitcycles_loop
11400    
11401    F5B4  60             RTS
11402      
11403      
11404    ;===============================================================================================  
11405    ; Tape byte output routine LSb first.  Accumulator holds the current byte.
11406    
11407    F_TAPE_ByteOut
11408    F5B5  08             PHP								; Save and disable IRQ status.
11409    F5B6  78             SEI
11410      
11411    F5B7  48             PHA								; Generate start bit.
11412    F5B8  A9 01          LDA #1
11413    F5BA  20 6F F5       JSR F_TAPE_BitGen
11414    F5BD  68             PLA
11415    
11416    F5BE  A2 08          LDX #8							; Set our bit counter for 8 bits.
11417      
11418    TAPE_Nextbit
11419    F5C0  48             PHA								; Save the byte for later use.
11420    F5C1  DA             PHX								; Save our counter
11421      
11422    F5C2  29 01          AND #1							; Keep just the bit of interest.
11423    F5C4  20 6F F5       JSR F_TAPE_BitGen						; Output our bit.
11424    
11425    F5C7  FA             PLX								; Recover our counter
11426    F5C8  68             PLA								; Recover our working byte out
11427      
11428    F5C9  4A             LSR								; Move on to the next bit
11429    F5CA  CA             DEX								; Decrement our counter
11430      
11431    F5CB  D0 F3          BNE TAPE_Nextbit						; Keep going until completed.
11432      
11433    F5CD  48             PHA								; Generate stop bit
11434    F5CE  A9 00          LDA #0
11435    F5D0  20 6F F5       JSR F_TAPE_BitGen
11436    F5D3  A9 00          LDA #0							; Generate first guard bit
11437    F5D5  20 6F F5       JSR F_TAPE_BitGen
11438    F5D8  A9 00          LDA #0							; Generate second guard bit
11439    F5DA  20 6F F5       JSR F_TAPE_BitGen
11440    F5DD  A9 00          LDA #0							; Generate third guard bit!
11441    F5DF  20 6F F5       JSR F_TAPE_BitGen
11442    F5E2  A9 00          LDA #0							; Generate fourth guard bit!
11443    F5E4  20 6F F5       JSR F_TAPE_BitGen
11444    
11445    F5E7  68             PLA
11446      
11447    F5E8  28             PLP								; Restore IRQ status
11448      
11449    F5E9  60             RTS
11450    
11451    
11452    ;===============================================================================================  
11453    ; Block output routine
11454    ;
11455    ; This requires the starting address and number of bytes output to operate.
11456    ; X contains the low byte of the count, Y contains the high byte and a two byte zero page variable
11457    ; holds the starting address, which is incremented as used.
11458    
11459    F_TAPE_BlockOut
11460    
11461    F5EA  20 1A F6       JSR F_TAPE_Leader						; Generate block leader
11462    
11463    F5ED  AE 00 09       LDX V_TAPE_BlockSize						; Get the low byte of BlockStart
11464    F5F0  AC 01 09       LDY V_TAPE_BlockSize+1					; Get the high byte of BlockStart
11465      
11466    L_TAPE_BlockOut
11467      
11468    F5F3  B2 E5          LDA (TAPE_BlockLo)						; Get the byte to output to tape
11469      
11470    F5F5  DA             PHX
11471    F5F6  5A             PHY
11472    F5F7  20 B5 F5       JSR F_TAPE_ByteOut						; Transmit the byte.
11473    F5FA  7A             PLY
11474    F5FB  FA             PLX
11475      
11476    F5FC  A5 E5          LDA TAPE_BlockLo						; Increment our byte pointer
11477    F5FE  18             CLC
11478    F5FF  69 01          ADC #1
11479    F601  85 E5          STA TAPE_BlockLo
11480    F603  A5 E6          LDA TAPE_BlockHi
11481    F605  69 00          ADC #0
11482    F607  85 E6          STA TAPE_BlockHi  
11483    
11484      
11485    TAPE_BlockOut_CheckZero_B
11486    F609  C0 00          CPY #0
11487    F60B  D0 05          BNE B_TAPE_BlockOut_Decrement
11488    F60D  E0 00          CPX #0
11489    F60F  D0 01          BNE B_TAPE_BlockOut_Decrement
11490    
11491    F611  60             RTS
11492    
11493    B_TAPE_BlockOut_Decrement
11494    F612  CA             DEX
11495    F613  E0 FF          CPX #$FF
11496    F615  D0 DC          BNE L_TAPE_BlockOut
11497    F617  88             DEY
11498    F618  80 D9          BRA L_TAPE_BlockOut
11499      
11500    
11501    ;===============================================================================================  
11502    ; Tape leader_tone  
11503    
11504    F_TAPE_Leader
11505    F61A  A2 64          LDX #TAPE_Leader_Bytes				; Put the leader cycles low byte into X
11506    
11507    TAPE_leader_lp
11508    F61C  DA             PHX							; Save our cycle counter for later
11509      
11510    F61D  A9 AA          LDA #C_TAPE_LeaderByte
11511    F61F  20 B5 F5       JSR F_TAPE_ByteOut					; Send leader byte
11512    
11513    
11514    F622  FA             PLX							; Retrieve our counter
11515    
11516    F623  CA             DEX							; Decrement our counter
11517    F624  D0 F6          BNE TAPE_leader_lp					; and loopback as necessary
11518    F626  A9 55          LDA #C_TAPE_EndOfLeaderByte
11519    F628  20 B5 F5       JSR F_TAPE_ByteOut					; Send Terminating byte
11520    
11521    F62B  60             RTS
11522    
11523    
11524    ;*****************************************************************************************
11525    ;**                                                                                     **
11526    ;**              Input Generating Functions.  Spoiler, It's all bitbashed!              **
11527    ;**              ---------------------------------------------------------              **
11528    ;**                                                                                     **
11529    ;*****************************************************************************************
11530    
11531    
11532    ;===============================================================================================  
11533    ; Tape line status sampler, temporarily flipped  
11534    
11535    
11536    F_TAPE_Sample_Tapeline
11537    F62C  AD 40 C0       LDA TAPE_IOP						; Get sample
11538    F62F  29 40          AND #TAPE_in
11539      
11540    F631  F0 02          BEQ TAPE_line_low					; Set or clear carry as needed.
11541    F633  38             SEC
11542    F634  60             RTS
11543      
11544    TAPE_line_low
11545    F635  18             CLC
11546    F636  60             RTS
11547    
11548    
11549    ;===============================================================================================
11550    ; Pulse Decoding engine.  This is where deserialisation happens.
11551    
11552    TAPE_PulseDecoder
11553    F637  AD 08 09       LDA TAPE_StartDet					; If the start bit has been detected
11554    F63A  D0 1A          BNE TAPE_SamplePos_Check				; Seek rising edge and end otherwise
11555      
11556    F63C  AD 06 09       LDA TAPE_Demod_Status					; Detect rising edge
11557    F63F  F0 14          BEQ TAPE_NotRising
11558    F641  AD 07 09       LDA TAPE_Demod_Last
11559    F644  D0 0F          BNE TAPE_NotRising
11560    
11561    F646  A9 01          LDA #1						; Store rising edge signal
11562    F648  8D 08 09       STA TAPE_StartDet
11563    F64B  A9 14          LDA #C_TAPE_Sample_Offset				; Start the counter for mid-bit
11564    F64D  8D 0C 09       STA TAPE_Sample_Position
11565    F650  A9 0A          LDA #C_TAPE_BitsPerFrame
11566    F652  8D 0A 09       STA TAPE_BitsToDecode
11567    
11568    TAPE_NotRising
11569    F655  60             RTS
11570    
11571    TAPE_SamplePos_Check
11572    F656  A9 00          LDA #0						; Are we at the bit sample position
11573    F658  CD 0C 09       CMP TAPE_Sample_Position
11574    F65B  F0 04          BEQ TAPE_AtStartBit
11575      
11576    F65D  CE 0C 09       DEC TAPE_Sample_Position				; Decrement sample position end.
11577    F660  60             RTS
11578      
11579    TAPE_AtStartBit						; At start bit?
11580    F661  AD 0A 09       LDA TAPE_BitsToDecode
11581    F664  C9 0A          CMP #C_TAPE_BitsPerFrame
11582    F666  D0 17          BNE TAPE_AtStopBit
11583      
11584    F668  AD 06 09       LDA TAPE_Demod_Status					; Branch on start bit state.
11585    F66B  D0 09          BNE TAPE_AdjustCountersStart
11586      
11587    F66D  A9 00          LDA #0						; Path of invalid start bit.
11588    F66F  8D 08 09       STA TAPE_StartDet					; Clear start condition
11589    F672  8D 09 09       STA TAPE_RX_Status					; and status register.
11590    F675  60             RTS
11591      
11592    TAPE_AdjustCountersStart
11593    F676  A9 36          LDA #C_TAPE_Bitlength					; Start the counter for the next bit to sample
11594    F678  8D 0C 09       STA TAPE_Sample_Position
11595    F67B  CE 0A 09       DEC TAPE_BitsToDecode
11596    F67E  60             RTS
11597      
11598    TAPE_AtStopBit						; Stop bit?
11599    F67F  AD 0A 09       LDA TAPE_BitsToDecode
11600    F682  C9 01          CMP #1
11601    F684  D0 1B          BNE TAPE_AtDataBit
11602    
11603    F686  AD 06 09       LDA TAPE_Demod_Status
11604    F689  D0 0B          BNE TAPE_Overrun
11605      
11606    F68B  A9 00          LDA #0						; Clear Start detect bit
11607    F68D  8D 08 09       STA TAPE_StartDet
11608    F690  A9 04          LDA #TAPE_Stat_RXFull					; Indicate byte received
11609    F692  8D 09 09       STA TAPE_RX_Status
11610    F695  60             RTS
11611      
11612    TAPE_Overrun
11613    F696  A9 00          LDA #0						; Clear Start detect bit
11614    F698  8D 08 09       STA TAPE_StartDet
11615    F69B  A9 01          LDA #TAPE_Stat_overrun				; Indicate byte received
11616    F69D  8D 09 09       STA TAPE_RX_Status
11617    F6A0  60             RTS
11618    
11619    TAPE_AtDataBit
11620    F6A1  AD 06 09       LDA TAPE_Demod_Status					; Shift our bit into the byte received LSb when not a stop bit
11621    F6A4  6A             ROR
11622    F6A5  6E 0B 09       ROR TAPE_ByteReceived
11623      
11624    
11625    F6A8  CE 0A 09       DEC TAPE_BitsToDecode					; Adjust counters accordingly
11626    F6AB  A9 36          LDA #C_TAPE_Bitlength
11627    F6AD  8D 0C 09       STA TAPE_Sample_Position
11628     
11629    F6B0  60             RTS
11630      
11631      
11632    
11633    
11634    ;*****************************************************************************************
11635    ;**                                                                                     **
11636    ;**           Tape Input Functions.  These are all hand calibrated so take care.        **
11637    ;**           ------------------------------------------------------------------        **
11638    ;**                                                                                     **
11639    ;*****************************************************************************************
11640    
11641    
11642    
11643    
11644    
11645    F_TAPE_FindStart
11646    F6B1  20 7C F7       JSR F_TAPE_GetByte
11647    F6B4  AD 09 09       LDA TAPE_RX_Status
11648      
11649    F6B7  C9 08          CMP #TAPE_Stat_Escape						; Break on Escape condition
11650    F6B9  D0 01          BNE TAPE_LeaderNoBreak
11651      
11652    F6BB  60             RTS
11653      
11654    TAPE_LeaderNoBreak
11655    F6BC  C9 01          CMP #TAPE_Stat_overrun
11656    F6BE  F0 F1          BEQ F_TAPE_FindStart
11657      
11658    F6C0  AD 0B 09       LDA TAPE_ByteReceived
11659    F6C3  C9 55          CMP #C_TAPE_EndOfLeaderByte					; Keep trying until end of leader byte is received
11660    F6C5  D0 EA          BNE F_TAPE_FindStart
11661      
11662    F6C7  60             RTS
11663    
11664    
11665    
11666    
11667    ;===============================================================================================  
11668    ; Block read routine
11669    ;
11670    ; This requires the starting address and number of bytes output to operate.
11671    ; X contains the low byte of the count, Y contains the high byte and a two byte zero page variable
11672    ; holds the starting address, which is incremented as used.
11673    
11674    F_TAPE_BlockIn
11675    
11676    F6C8  20 B1 F6       JSR F_TAPE_FindStart						; Follow the leader signal
11677      
11678    F6CB  AD 09 09       LDA TAPE_RX_Status
11679    F6CE  C9 08          CMP #TAPE_Stat_Escape
11680    F6D0  F0 1D          BEQ TAPE_BlockIn_Sig_Escape
11681      
11682    F6D2  AE 00 09       LDX V_TAPE_BlockSize						; Get the low byte of BlockStart
11683    F6D5  AC 01 09       LDY V_TAPE_BlockSize+1					; Get the high byte of BlockStart
11684      
11685    F6D8  A9 00          LDA #0							; Initialise BlockIn's status register
11686    F6DA  8D 0D 09       STA TAPE_BlockIn_Status
11687      
11688    L_TAPE_BlockIn
11689    
11690    F6DD  DA             PHX								; Get a byte from the tape interface
11691    F6DE  5A             PHY
11692    F6DF  20 7C F7       JSR F_TAPE_GetByte
11693    F6E2  7A             PLY
11694    F6E3  FA             PLX
11695      
11696    F6E4  AD 09 09       LDA TAPE_RX_Status						; failing gracefully upon bad events.
11697    F6E7  C9 04          CMP #TAPE_Stat_RXFull
11698    F6E9  F0 10          BEQ TAPE_BlockIn_Store
11699      
11700    F6EB  C9 08          CMP #TAPE_Stat_Escape
11701    F6ED  D0 06          BNE TAPE_BlockIn_CheckError
11702      
11703    TAPE_BlockIn_Sig_Escape  
11704    F6EF  A9 02          LDA #TAPE_BlockIn_Escape
11705    F6F1  8D 0D 09       STA TAPE_BlockIn_Status
11706    F6F4  60             RTS								; Escape
11707      
11708    TAPE_BlockIn_CheckError  
11709    F6F5  A9 04          LDA #TAPE_BlockIn_Error
11710    F6F7  8D 0D 09       STA TAPE_BlockIn_Status
11711    F6FA  60             RTS								; Failed  
11712      
11713    TAPE_BlockIn_Store
11714    F6FB  AD 0B 09       LDA TAPE_ByteReceived						; Store our received byte to our current pointer address.
11715    F6FE  92 E5          STA (TAPE_BlockLo)
11716    
11717    F700  A5 E5          LDA TAPE_BlockLo						; Increment our byte pointer
11718    F702  18             CLC
11719    F703  69 01          ADC #1
11720    F705  85 E5          STA TAPE_BlockLo
11721    F707  A5 E6          LDA TAPE_BlockHi
11722    F709  69 00          ADC #0
11723    F70B  85 E6          STA TAPE_BlockHi
11724    
11725    TAPE_BlockIn_DecCounter
11726    F70D  CA             DEX
11727    F70E  E0 FF          CPX #$FF
11728    F710  D0 01          BNE TAPE_CheckBlockInCounterZero_B
11729    F712  88             DEY
11730    
11731    TAPE_CheckBlockInCounterZero_B  
11732    F713  C0 00          CPY #0
11733    F715  D0 C6          BNE L_TAPE_BlockIn
11734    F717  E0 00          CPX #0
11735    F719  D0 C2          BNE L_TAPE_BlockIn
11736    
11737    TAPE_BlockIn_Finish
11738    F71B  A9 01          LDA #TAPE_BlockIn_Complete					; Indicate tast completion
11739    F71D  8D 0D 09       STA TAPE_BlockIn_Status
11740    F720  60             RTS
11741       
11742      
11743    F_TAPE_VerifyBlock
11744    
11745    F721  20 B1 F6       JSR F_TAPE_FindStart						; Follow the leader signal
11746      
11747    F724  AD 09 09       LDA TAPE_RX_Status
11748    F727  C9 08          CMP #TAPE_Stat_Escape
11749    F729  F0 1D          BEQ TAPE_Verify_Sig_Escape
11750      
11751    F72B  AE 00 09       LDX V_TAPE_BlockSize						; Get the low byte of BlockStart
11752    F72E  AC 01 09       LDY V_TAPE_BlockSize+1					; Get the high byte of BlockStart
11753      
11754    F731  A9 01          LDA #TAPE_Verify_Good						; Initialise Verify's status register
11755    F733  8D 30 09       STA V_TAPE_Verify_Status
11756      
11757    L_TAPE_BlockVerify
11758    
11759    F736  DA             PHX								; Get a byte from the tape interface
11760    F737  5A             PHY
11761    F738  20 7C F7       JSR F_TAPE_GetByte
11762    F73B  7A             PLY
11763    F73C  FA             PLX
11764      
11765    F73D  AD 09 09       LDA TAPE_RX_Status						; did we capture a good byte?
11766    F740  C9 04          CMP #TAPE_Stat_RXFull
11767    F742  F0 10          BEQ TAPE_Verify_Check
11768      
11769    F744  C9 08          CMP #TAPE_Stat_Escape						; Did we press escape?
11770    F746  D0 06          BNE TAPE_Verify_CheckError
11771      
11772    TAPE_Verify_Sig_Escape  
11773    F748  A9 02          LDA #TAPE_Verify_Escape					; Signal that we pressed escape and return.
11774    F74A  8D 30 09       STA V_TAPE_Verify_Status
11775    F74D  60             RTS
11776      
11777    TAPE_Verify_CheckError						; Signal the encountered error and return.
11778    F74E  A9 04          LDA #TAPE_Verify_Error
11779    F750  8D 30 09       STA V_TAPE_Verify_Status
11780    F753  60             RTS  
11781      
11782    TAPE_Verify_Check
11783    F754  AD 0B 09       LDA TAPE_ByteReceived						; Compare our fectched byte with the one in BASIC memory.
11784    F757  D2 E5          CMP (TAPE_BlockLo)
11785    F759  D0 F3          BNE TAPE_Verify_CheckError					; Signal inconsistency as an error.
11786      
11787    F75B  A5 E5          LDA TAPE_BlockLo						; Increment our byte pointer
11788    F75D  18             CLC
11789    F75E  69 01          ADC #1
11790    F760  85 E5          STA TAPE_BlockLo
11791    F762  A5 E6          LDA TAPE_BlockHi
11792    F764  69 00          ADC #0
11793    F766  85 E6          STA TAPE_BlockHi
11794    
11795    TAPE_Verify_DecCounter
11796    F768  CA             DEX
11797    F769  E0 FF          CPX #$FF
11798    F76B  D0 01          BNE TAPE_CheckCounterZero_B
11799    F76D  88             DEY
11800      
11801    TAPE_CheckCounterZero_B
11802    F76E  C0 00          CPY #0							; Check to see if we have done yet.
11803    F770  D0 C4          BNE L_TAPE_BlockVerify
11804    F772  E0 00          CPX #0
11805    F774  D0 C0          BNE L_TAPE_BlockVerify
11806      
11807    TAPE_Verify_Finish
11808    F776  A9 01          LDA #TAPE_Verify_Good						; Indicate test completion
11809    F778  8D 30 09       STA V_TAPE_Verify_Status
11810    F77B  60             RTS
11811    
11812    
11813    ;===============================================================================================
11814    ; Byte Reader.
11815    
11816    F_TAPE_GetByte
11817    
11818    ; First some initial housekeeping
11819    
11820    F77C  08             PHP							; Save and disable IRQ status
11821    F77D  78             SEI
11822    
11823    F77E  A9 00          LDA #0
11824    F780  8D 06 09       STA TAPE_Demod_Status					; Start our bit demod with zero.
11825    F783  8D 07 09       STA TAPE_Demod_Last					; Set our initial demod status too.
11826    F786  8D 05 09       STA TAPE_LineUptime					; Set our initial uptime counter to zero.
11827    F789  8D 09 09       STA TAPE_RX_Status					; Clear our Status register
11828      
11829    TAPE_pulselatch
11830      
11831    F78C  AD 09 09       LDA TAPE_RX_Status
11832    F78F  D0 0A          BNE TAPE_ByteCaptured					; Check status for received byte.
11833      
11834    F791  20 3A EC       JSR ACIA1in						; Just in case the user needs to get out of this loop
11835    F794  90 07          BCC TAPE_ContLoop					; Caught in a landsliiiide, no escape TO re-al-ih-teeeee!
11836    F796  A9 08          LDA #TAPE_Stat_Escape
11837    F798  8D 09 09       STA TAPE_RX_Status
11838      
11839    
11840    TAPE_ByteCaptured
11841    F79B  28             PLP							; Restore IRQ status
11842      
11843    F79C  60             RTS							; Done
11844    
11845    
11846    ; Services that use the pulse decoded go here.
11847    
11848    TAPE_ContLoop
11849    F79D  20 37 F6       JSR TAPE_PulseDecoder					; We gotta do something with these pulses right...?
11850    
11851    F7A0  AD 06 09       LDA TAPE_Demod_Status					; Update some variables
11852    F7A3  8D 07 09       STA TAPE_Demod_Last
11853    
11854    ; =-=-=-=-=-=-=-=-----------------=-=-=-=-=-=-=-=---------=-=-=-=-=-=-=-=-
11855    ;
11856    ; The actual pulse demodulation code starts here
11857    ;
11858    ; =-=-=-=-=-=-=-=-----------------=-=-=-=-=-=-=-=---------=-=-=-=-=-=-=-=-
11859      
11860    F7A6  20 60 F5       JSR F_TAPE_Phasetime_pause				; and delay for our respective looptime
11861      
11862    F7A9  20 2C F6       JSR F_TAPE_Sample_Tapeline				; Update status
11863    F7AC  90 0A          BCC TAPE_DontSet
11864      
11865    F7AE  A9 01          LDA #1
11866    F7B0  8D 06 09       STA TAPE_Demod_Status					; Set our line status to up
11867    F7B3  A9 0A          LDA #10						; THIS WAS WORKING AT 7
11868    F7B5  8D 05 09       STA TAPE_LineUptime					; Reset our latch counter
11869      
11870    TAPE_DontSet
11871    F7B8  AD 05 09       LDA TAPE_LineUptime
11872    F7BB  F0 06          BEQ TAPE_AtMinimum
11873      
11874    F7BD  CE 05 09       DEC TAPE_LineUptime
11875    F7C0  4C 8C F7       JMP TAPE_pulselatch
11876        
11877    TAPE_AtMinimum
11878    F7C3  A9 00          LDA #0						; Clear our line status
11879    F7C5  8D 06 09       STA TAPE_Demod_Status
11880    F7C8  4C 8C F7       JMP TAPE_pulselatch
11881    
11882    
11883      .INCLUDE "AY_DRIVER.asm"
11884    ; AY-3-891x Register Driver
11885    ;
11886    ; By Duncan Gunn.
11887    
11888    
11889    ; AY_6522 Registers
11890    
11891      C0E0             AY_6522_Base	 	=	$C0E0
11892      C0E0             AY_6522_ORB		=	AY_6522_Base
11893      C0E1             AY_6522_ORA		=	AY_6522_Base + $01
11894      C0E2             AY_6522_DDRB		=	AY_6522_Base + $02
11895      C0E3             AY_6522_DDRA		=	AY_6522_Base + $03
11896      C0E4             AY_6522_T1C_L		=	AY_6522_Base + $04
11897      C0E5             AY_6522_T1C_H		=	AY_6522_Base + $05
11898      C0E6             AY_6522_L1L_L		=	AY_6522_Base + $06
11899      C0E7             AY_6522_L1L_H		=	AY_6522_Base + $07
11900      C0E8             AY_6522_T2C_L		=	AY_6522_Base + $08
11901      C0E9             AY_6522_T2C_H		=	AY_6522_Base + $09
11902      C0EA             AY_6522_SR		=	AY_6522_Base + $0A
11903      C0EB             AY_6522_ACR		=	AY_6522_Base + $0B
11904      C0EC             AY_6522_PCR		=	AY_6522_Base + $0C
11905      C0ED             AY_6522_IFR		=	AY_6522_Base + $0D
11906      C0EE             AY_6522_IER		=	AY_6522_Base + $0E
11907      C0EF             AY_6522_ORA_IRA		=	AY_6522_Base + $0F
11908    
11909    
11910    ; AY_6522 HW Mappings.
11911    
11912      C0E0             AY_DATAPORT		=	AY_6522_ORB
11913      C0E2             AY_DDR_DATA		=	AY_6522_DDRB
11914    
11915      C0E1             AY_CTRLPORT		=	AY_6522_ORA
11916      C0E3             AY_DDR_CTRL		=	AY_6522_DDRA
11917    
11918      0001             AY_CTRL_bit_BC1		= 	@00000001
11919      0002             AY_CTRL_bit_BDIR	=	@00000010
11920    
11921      0003             AY_CTRL_dir		=	AY_CTRL_bit_BC1 | AY_CTRL_bit_BDIR	; Set relevant port bits as outputs
11922      00FF             AY_DATA_out		=	$FF
11923      0000             AY_DATA_in		=	$0
11924    
11925    
11926    
11927    ; AY Registers
11928    
11929      0000             AY_CH_A_TP_FINE		= $0
11930      0001             AY_CH_A_TP_COARSE	= $1	; Bottom four bits only
11931      0002             AY_CH_B_TP_FINE		= $2
11932      0003             AY_CH_B_TP_COARSE	= $3	; Bottom four bits only
11933      0004             AY_CH_C_TP_FINE		= $4
11934      0005             AY_CH_C_TP_COARSE	= $5
11935      0006             AY_NOISE_PERIOD		= $6	; Bottom five bits only
11936      0007             AY_NOT_ENABLE		= $7	; Bitfield: See table 1 below
11937      0008             AY_CH_A_AMP		= $8	; M (Bit 5) when set uses the Envelope gen, otherwise B3-B0 sets the volume
11938      0009             AY_CH_B_AMP		= $9	; See channel A
11939      000A             AY_CH_C_AMP		= $A	; See channel A
11940      000B             AY_ENV_P_FINE		= $B	
11941      000C             AY_ENV_P_COARSE		= $C
11942      000D             AY_ENV_SH_CYC		= $D	; See table 2 below
11943      000E             AY_PORTA_REG		= $E	; Not implemented for the AY-3-8912
11944      000F             AY_PORTB_REG		= $F	; Not implemented for the AY-3-8912
11945    
11946    
11947    ; Table 1.  AY_NOT_ENABLE bitfield.
11948    ;
11949    ; +---------+-----------+-----------+
11950    ; | IN/nOUT |   nNOISE  |   nTONE   |
11951    ; +----+----+---+---+---+---+---+---+
11952    ; |IOB |IOA | C | B | A | C | B | A |
11953    ; +----+----+---+---+---+---+---+---+
11954    
11955      0080             AY_bit_nIOB		= @10000000
11956      0040             AY_bit_nIOA		= @01000000
11957      0020             AY_bit_nNOISE_C		= @00100000
11958      0010             AY_bit_nNOISE_B		= @00010000
11959      0008             AY_bit_nNOISE_A		= @00001000
11960      0004             AY_bit_nTONE_C		= @00000100
11961      0002             AY_bit_nTONE_B		= @00000010
11962      0001             AY_bit_nTONE_A		= @00000001
11963      00FF             AY_AllOff		= @11111111
11964    
11965    
11966    ; Table 2.  Envelope shape/cycle bitfield.
11967    ;
11968    ; +--------+--------+--------+--------+--------+--------+--------+--------+
11969    ; |   B7   |   B6   |   B5   |   B4   |   B3   |   B2   |   B1   |   B0   |
11970    ; +--------+--------+--------+--------+--------+--------+--------+--------+
11971    ; |          B7-B4 Not used.          | Cont   | Attack | Alt    | Hold   |
11972    ; +--------+--------+--------+--------+--------+--------+--------+--------+
11973    ;
11974    ; CONTinue causes the pattern to cycle when set.
11975    ; Setting Attack makes the envelope counter count up, but when cleared causes a count down instead.
11976    ; Setting ALTernate causes the counter to reverse direction at the end of each cycle.
11977    ; Setting HOLD limits the envelope generator to one cycle
11978    
11979      0008             AY_bit_CONT		= @00001000
11980      0004             AY_bit_ATTACK		= @00000100
11981      0002             AY_bit_ALT		= @00000010
11982      0001             AY_bit_HOLD		= @00000001
11983    
11984    
11985    ; AY control modes
11986    
11987      0000             AY_INACK		= 0
11988      0001             AY_READ			= AY_CTRL_bit_BC1
11989      0002             AY_WRITE		= AY_CTRL_bit_BDIR
11990      0003             AY_LAT_ADDR		= AY_CTRL_bit_BC1 | AY_CTRL_bit_BDIR
11991    
11992    
11993    ; AY Soundcard memory allocations.
11994    
11995      0A00             AY_Memstart		= $A00
11996      0A00             AY_Reg			= AY_Memstart
11997      0A01             AY_Data			= AY_Reg             + 1		; 16-bit reg for purposes of including double register accesses.
11998      0A03             AY_Mask			= AY_Data            + 2
11999      0A04             AY_Channel		= AY_Mask            + 1
12000      0A05             AY_Period		= AY_Channel         + 1
12001      0A07             AY_Volume		= AY_Period          + 2
12002      0A08             AY_Envelope_Period	= AY_Volume          + 1
12003      0A0A             AY_Envelope_Mode 	= AY_Envelope_Period + 2
12004    
12005    
12006    
12007    ; AY_Initialisation routine.
12008    
12009    AY_Init
12010    F7CB  A9 00          LDA #0
12011    F7CD  8D E1 C0       STA AY_CTRLPORT	; Let's make our control port inactive first.
12012    F7D0  A9 03          LDA #AY_CTRL_dir
12013    F7D2  8D E3 C0       STA AY_DDR_CTRL  
12014    
12015    F7D5  A2 0F          LDX #$F		; Clear all the registers
12016    AY_Init_Loop
12017    
12018    F7D7  A9 00          LDA #0
12019    F7D9  20 60 F8       JSR AY_wr_to_reg
12020    F7DC  CA             DEX
12021    F7DD  D0 F8          BNE AY_Init_Loop
12022    
12023    F7DF  A9 07          LDA #AY_NOT_ENABLE
12024    F7E1  20 60 F8       JSR AY_wr_to_reg
12025    
12026    F7E4  A9 FF          LDA #AY_AllOff	; Set all our enable bits to disabled. Blissful quiet!
12027    F7E6  8D 03 0A       STA AY_Mask
12028    F7E9  A2 07          LDX #AY_NOT_ENABLE
12029    F7EB  20 60 F8       JSR AY_wr_to_reg
12030        
12031    F7EE  60             RTS
12032    
12033    
12034    ; Channel enable function (VERIFIED)
12035    
12036    AY_EnableCh
12037    F7EF  29 07          AND #7		; Get our channel selection, this includes noise.
12038      
12039    F7F1  AA             TAX			; Put our shift counter in X
12040    F7F2  A9 01          LDA #1		; and set our enable bit to 1
12041      
12042    F7F4  18             CLC
12043    AY_Enable_L		; Loop while X > 0
12044    F7F5  E0 00          CPX #0
12045    F7F7  F0 04          BEQ AY_Enable_B	; including 0 times for channel A (0)
12046      
12047    F7F9  CA             DEX			; Moving the 0
12048    F7FA  0A             ASL
12049    F7FB  80 F8          BRA AY_Enable_L
12050    
12051    AY_Enable_B
12052    F7FD  49 FF          EOR #$FF		; Make sure our enable bit is 0
12053    F7FF  2D 03 0A       AND AY_Mask
12054    F802  8D 03 0A       STA AY_Mask
12055      
12056    F805  A2 07          LDX #AY_NOT_ENABLE
12057    F807  20 60 F8       JSR AY_wr_to_reg
12058    F80A  60             RTS
12059      
12060      
12061    ; Channel disable function (VERIFIED)
12062    
12063    AY_DisableCh
12064    F80B  29 07          AND #7		; Get our channel selection, this includes noise.
12065      
12066    F80D  AA             TAX			; Put our shift counter in X
12067    F80E  A9 01          LDA #1		; and set our enable bit to 1
12068      
12069    F810  18             CLC
12070    AY_Disable_L		; Loop while X > 0
12071    F811  E0 00          CPX #0
12072    F813  F0 04          BEQ AY_Disable_B	; including 0 times for channel A (0)
12073      
12074    F815  CA             DEX			; Moving the 0
12075    F816  0A             ASL
12076    F817  80 F8          BRA AY_Disable_L
12077    
12078    AY_Disable_B
12079    F819  0D 03 0A       ORA AY_Mask
12080    F81C  8D 03 0A       STA AY_Mask
12081      
12082    F81F  A2 07          LDX #AY_NOT_ENABLE
12083    F821  20 60 F8       JSR AY_wr_to_reg
12084    F824  60             RTS
12085    
12086    
12087    
12088    ; AY register read-write primitives
12089    ;
12090    
12091    ; Writes the register address to the AY
12092    ;
12093    ; Takes A as the register parameter. Corrupts A
12094    AY_wr_reg
12095    F825  8D E0 C0       STA AY_DATAPORT	; Place our register value on the AY bus
12096      
12097    F828  A9 FF          LDA #AY_DATA_out
12098    F82A  8D E2 C0       STA AY_DDR_DATA	; And ensure the bus is an output.
12099      
12100    F82D  A9 03          LDA #AY_LAT_ADDR	; Latch our data to the AY
12101    F82F  8D E1 C0       STA AY_CTRLPORT
12102      ;NOP
12103      ;NOP
12104    F832  A9 00          LDA #AY_INACK		; And ensure out bus goes inactive again.
12105    F834  8D E1 C0       STA AY_CTRLPORT
12106    F837  60             RTS
12107    
12108    ; Writes data to the currently selected register
12109    ;
12110    ; Takes A as the register parameter. Corrupts A
12111    AY_wr_data
12112    F838  8D E0 C0       STA AY_DATAPORT	; Place our data on the AY bus
12113    
12114    F83B  A9 FF          LDA #AY_DATA_out
12115    F83D  8D E2 C0       STA AY_DDR_DATA
12116        
12117    F840  A9 02          LDA #AY_WRITE
12118    F842  8D E1 C0       STA AY_CTRLPORT
12119    
12120    F845  A9 00          LDA #AY_INACK		; And ensure the bus is an output.
12121    F847  8D E1 C0       STA AY_CTRLPORT
12122    F84A  60             RTS
12123    
12124    ; Read register		; Corrupts Y, returns the result in A.
12125    AY_rd_data
12126    F84B  A9 00          LDA #AY_DATA_in	; Make our bus an input so that the AY can drive it.
12127    F84D  8D E2 C0       STA AY_DDR_DATA
12128      
12129    F850  A9 01          LDA #AY_READ		; Set our AY to output it's register contents
12130    F852  8D E1 C0       STA AY_CTRLPORT
12131      
12132    F855  AD E0 C0       LDA AY_DATAPORT	; Grab those contents and put them in Y
12133    F858  A8             TAY
12134      
12135    F859  A9 00          LDA #AY_INACK		; Put our AY but back inactive.
12136    F85B  8D E1 C0       STA AY_CTRLPORT
12137      
12138    F85E  98             TYA			; Put our result back into A
12139      
12140    F85F  60             RTS			; Were finished.
12141      
12142      
12143    ; The 'All in one' function.
12144    ;
12145    AY_wr_to_reg
12146    F860  48             PHA
12147    F861  8A             TXA
12148      
12149    F862  20 25 F8       JSR AY_wr_reg
12150    F865  68             PLA
12151    F866  20 38 F8       JSR AY_wr_data
12152    F869  60             RTS
12153      
12154    
12155    ; For the users of BASIC, here's the easier read/write functions. 
12156    
12157    AY_Userwrite
12158    F86A  AD 01 0A       LDA AY_Data
12159    F86D  AE 00 0A       LDX AY_Reg
12160    F870  20 60 F8       JSR AY_wr_to_reg
12161    F873  60             RTS
12162      
12163    AY_Userread
12164    F874  AD 00 0A       LDA AY_Reg		; Select our register of interest.
12165    F877  20 25 F8       JSR AY_wr_reg
12166      
12167    F87A  20 4B F8       JSR AY_rd_data	; Get the contents of the register of interest.
12168    F87D  8D 01 0A       STA AY_Data
12169    F880  60             RTS
12170      
12171    AY_Userwrite_16
12172    F881  AD 01 0A       LDA AY_Data
12173    F884  AE 00 0A       LDX AY_Reg
12174    F887  20 60 F8       JSR AY_wr_to_reg
12175    F88A  E8             INX
12176    F88B  AD 02 0A       LDA AY_Data + 1
12177    F88E  20 60 F8       JSR AY_wr_to_reg
12178    F891  60             RTS
12179      
12180    AY_Userread_16
12181    F892  AD 00 0A       LDA AY_Reg		; Select our register of interest.
12182    F895  20 25 F8       JSR AY_wr_reg
12183      
12184    F898  20 4B F8       JSR AY_rd_data	; Get the contents of the register of interest.
12185    F89B  8D 01 0A       STA AY_Data
12186    F89E  AD 00 0A       LDA AY_Reg		; Select our register of interest.
12187    
12188    F8A1  38             SEC
12189    F8A2  69 00          ADC #0
12190      
12191    F8A4  20 25 F8       JSR AY_wr_reg
12192      
12193    F8A7  20 4B F8       JSR AY_rd_data	; Get the contents of the register of interest.
12194    F8AA  8D 02 0A       STA AY_Data + 1
12195    F8AD  60             RTS
12196      
12197    
12198    ; *********************************************************************
12199    ;
12200    ;                       BASIC Extension commands
12201    ;
12202    ; *********************************************************************
12203    
12204    ; Sound command for BASIC
12205    ;
12206    ; Format: SOUND channel,period,vol
12207    
12208    AY_SOUND
12209    
12210    ; Get channel.
12211    
12212    F8AE  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12213    						; else do type mismatch
12214    F8B1  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12215      
12216    F8B4  A5 11          LDA Itempl					; Get our channel parameter.
12217    F8B6  8D 04 0A       STA AY_Channel				; And save them for the future.
12218    
12219    F8B9  20 04 CD       JSR LAB_1C01					; scan for "," , else do syntax error then warm start
12220      
12221    F8BC  AD 04 0A       LDA AY_Channel				; Mug trap channel for over range values.
12222    F8BF  89 F8          BIT #@11111000
12223    F8C1  D0 59          BNE AY_Parameter_FCER_B
12224    F8C3  38             SEC
12225    F8C4  E9 06          SBC #6
12226    F8C6  10 54          BPL AY_Parameter_FCER_B
12227        
12228    
12229    ; Get period.
12230    
12231    F8C8  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12232    						; else do type mismatch
12233    F8CB  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12234      
12235    F8CE  A5 11          LDA Itempl
12236    F8D0  8D 05 0A       STA AY_Period
12237    F8D3  A5 12          LDA Itemph
12238    F8D5  8D 06 0A       STA AY_Period + 1
12239      
12240    F8D8  20 04 CD       JSR LAB_1C01					; scan for "," , else do syntax error then warm start  
12241      
12242      
12243    ; Get volume
12244      
12245    F8DB  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12246    						; else do type mismatch
12247    F8DE  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12248      
12249    F8E1  A5 11          LDA Itempl
12250    F8E3  8D 07 0A       STA AY_Volume
12251      
12252      
12253    ; Enact upon sound parameters
12254      
12255    F8E6  AD 04 0A       LDA AY_Channel				; Set our period
12256    F8E9  29 07          AND #7
12257    F8EB  18             CLC
12258    F8EC  0A             ASL
12259    F8ED  AA             TAX
12260      
12261    F8EE  AD 05 0A       LDA AY_Period
12262    F8F1  20 60 F8       JSR AY_wr_to_reg
12263    F8F4  E8             INX
12264    F8F5  AD 06 0A       LDA AY_Period + 1
12265    F8F8  20 60 F8       JSR AY_wr_to_reg
12266      
12267    F8FB  AD 04 0A       LDA AY_Channel				; Set our volume
12268    F8FE  29 07          AND #7
12269    F900  18             CLC
12270    F901  69 08          ADC #8
12271    F903  AA             TAX
12272    F904  AD 07 0A       LDA AY_Volume
12273    F907  20 60 F8       JSR AY_wr_to_reg
12274      
12275    F90A  AD 04 0A       LDA AY_Channel
12276    F90D  AE 07 0A       LDX AY_Volume
12277    F910  E0 00          CPX #0
12278    F912  D0 04          BNE AY_EnableCh_B
12279    F914  20 0B F8       JSR AY_DisableCh
12280      
12281    F917  60             RTS
12282      
12283    AY_EnableCh_B
12284    F918  20 EF F7       JSR AY_EnableCh
12285    F91B  60             RTS
12286     
12287    AY_Parameter_FCER_B
12288    F91C  4C 3D D0       JMP LAB_FCER  
12289        
12290    
12291    ; ENVELOPE command.
12292    ;
12293    ; Format ENVELOPE period, mode  
12294    
12295    
12296    AY_ENVELOPE
12297    
12298    ; Get period.
12299    
12300    F91F  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12301    						; else do type mismatch
12302    F922  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12303      
12304    F925  A5 11          LDA Itempl
12305    F927  8D 08 0A       STA AY_Envelope_Period
12306    F92A  A5 12          LDA Itemph
12307    F92C  8D 09 0A       STA AY_Envelope_Period + 1
12308      
12309    F92F  20 04 CD       JSR LAB_1C01					; scan for "," , else do syntax error then warm start
12310    
12311    ; Get mode
12312      
12313    F932  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12314    						; else do type mismatch
12315    F935  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12316      
12317    F938  A5 11          LDA Itempl
12318    F93A  8D 0A 0A       STA AY_Envelope_Mode
12319      
12320    F93D  A2 0B          LDX #AY_ENV_P_FINE
12321    F93F  AD 08 0A       LDA AY_Envelope_Period
12322    F942  20 60 F8       JSR AY_wr_to_reg
12323    F945  E8             INX
12324    F946  AD 09 0A       LDA AY_Envelope_Period + 1
12325    F949  20 60 F8       JSR AY_wr_to_reg
12326      
12327    F94C  AD 0A 0A       LDA AY_Envelope_Mode
12328    F94F  A2 0D          LDX #AY_ENV_SH_CYC
12329    F951  20 60 F8       JSR AY_wr_to_reg
12330    F954  60             RTS
12331      .INCLUDE "IRQ_Handler.asm"
12332    ; IRQ Manager.
12333    ;
12334    ; Interrupt request handling and masking on per device basis.
12335    
12336    
12337    ; System constants
12338    
12339      0000             IRQH_Version_C		= 0					; Version 0 (Pre-release)
12340    
12341    
12342    ; IRQ Handler command codes
12343    ;
12344      0000             IRQH_Service_CMD	= 0					; Request IRQ Service
12345      0001             IRQH_Shutdown_CMD	= 1					; Shutdown IRQ gracefully
12346      0002             IRQH_Reset_CMD		= 2					; Reset the IRQ handler.
12347    
12348    
12349    ; IRQ Memory table
12350    ;
12351      0A20             IRQH_Table_Base		= $A20 					; Beginning of IRQ Handler Memory.
12352      0A20             IRQH_CallList		= IRQH_Table_Base			; All sixteen bytes for eight addresses.
12353      0A30             IRQH_CallReg		= IRQH_CallList + 16			; Two bytes containing an address being transferred.
12354      0A32             IRQH_ClaimsList		= IRQH_CallReg + 2			; Byte with list of calls that returned and IRQ Claim
12355      0A33             IRQH_MaskByte		= IRQH_ClaimsList + 1			; Byte containing IRQ Table entry mask bits. IRQ entry LSb is IRQ entry 0.
12356      0A34             IRQH_WorkingMask	= IRQH_MaskByte + 1			; Walking bit for masking and setting purposes.
12357      0A35             IRQH_CurrentEntry	= IRQH_WorkingMask + 1			; Pointer for IRQ Table entries.
12358      0A36             IRQH_CMD_Table		= IRQH_CurrentEntry + 1			; Table of IRQ handler commands with parameter space.  16 bytes.
12359    
12360      0016             IRQH_zero_range_C	= IRQH_CurrentEntry+17-IRQH_CallReg	; Amount to zero after IRQH_CallList.
12361    
12362    ; Table current size is 21 bytes.
12363    
12364    
12365    ; IRQ Handler Initialisation Call
12366    
12367    IRQH_Handler_Init_F
12368    F955  78             SEI						; Disable IRQ's so we don't break anything already happening.
12369      
12370    F956  A9 7D          LDA #<IRQH_Null_F				; Put the null IRQ Function address into IRQ_CallReg
12371    F958  8D 30 0A       STA IRQH_CallReg
12372    F95B  A9 F9          LDA #>IRQH_Null_F
12373    F95D  8D 31 0A       STA IRQH_CallReg + 1
12374      
12375    F960  A9 07          LDA #7					; Point at the last table entry
12376    F962  A8             TAY
12377    
12378    IRQH_FillTable_L
12379    F963  20 89 F9       JSR IRQH_SetIRQ_F				; Iterate copy to whole table
12380      
12381    F966  98             TYA
12382    F967  38             SEC
12383    F968  E9 01          SBC #1
12384    F96A  A8             TAY
12385      
12386    F96B  B0 F6          BCS IRQH_FillTable_L
12387      
12388    F96D  A9 00          LDA #0					; Clear rest of the IRQ Handler's structure.
12389    F96F  A2 00          LDX #0
12390      
12391    IRQH_FillRemaining_L
12392    F971  A9 00          LDA #0
12393    F973  9D 30 0A       STA IRQH_CallReg,X
12394    F976  E8             INX
12395      
12396    F977  8A             TXA						; Stop when the table is full.
12397    F978  C9 16          CMP #IRQH_zero_range_C
12398    F97A  D0 F5          BNE IRQH_FillRemaining_L
12399      
12400    F97C  60             RTS						; Return to caller.
12401      
12402      
12403    ; IRQ Null function
12404    
12405    IRQH_Null_F
12406    F97D  AD 34 0A       LDA IRQH_WorkingMask				; Get our Working position
12407      
12408    F980  49 FF          EOR #$FF					; Unset our Claim bit.
12409    F982  2D 32 0A       AND IRQH_ClaimsList
12410    F985  8D 32 0A       STA IRQH_ClaimsList
12411      
12412    F988  60             RTS
12413      
12414    
12415    ; Function to atomically add an IRQ to the IRQ Table.
12416    
12417    IRQH_SetIRQ_F
12418    
12419    F989  08             PHP						; Assure atomic
12420    F98A  78             SEI
12421      
12422    F98B  0A             ASL						; Multiply our pointer by two as the table uses words not bytes.
12423      
12424    F98C  AA             TAX						; Transfer our table reference to index X
12425      
12426    F98D  AD 30 0A       LDA IRQH_CallReg				; Get our call low-byte
12427    F990  9D 20 0A       STA IRQH_CallList,X				; Store our low byte
12428      
12429    F993  AD 31 0A       LDA IRQH_CallReg + 1				; Get our call high-byte
12430    F996  E8             INX
12431    F997  9D 20 0A       STA IRQH_CallList,X				; Store our high byte.
12432      
12433    F99A  28             PLP						; End atomic operation
12434    F99B  60             RTS
12435      
12436      
12437    ; Function to atomically clear an IRQ from the table
12438    
12439    IRQH_ClrIRQ_F
12440    F99C  08             PHP						; Assure atomic
12441    F99D  78             SEI
12442    
12443    F99E  0A             ASL						; Multiply our pointer by two
12444    F99F  AA             TAX						; and place it in X
12445    
12446    F9A0  A9 7D          LDA #<IRQH_Null_F				; Transfer our Null function address to the table
12447    F9A2  9D 20 0A       STA IRQH_CallList,X
12448    F9A5  A9 F9          LDA #>IRQH_Null_F
12449    F9A7  E8             INX
12450    F9A8  9D 20 0A       STA IRQH_CallList,X
12451      
12452    F9AB  28             PLP						; End atomic operation
12453    F9AC  60             RTS
12454      
12455      
12456    ; IRQ Handler function.
12457    
12458    IRQH_ProcessIRQs
12459    F9AD  48             PHA						; Save processor registers
12460    F9AE  DA             PHX
12461    F9AF  5A             PHY
12462      
12463    F9B0  D8             CLD						; We have no idea what mode the processor was in when this was called so let's clear it.
12464      
12465    F9B1  AD 33 0A       LDA IRQH_MaskByte				; Get IRQ mask
12466    F9B4  F0 29          BEQ IRQH_FinishIRQs_B				; and quit early if all disabled.
12467      
12468    F9B6  A9 01          LDA #1					; Put 1 into our working mask
12469    F9B8  8D 34 0A       STA IRQH_WorkingMask				
12470    
12471    F9BB  A2 00          LDX #0					; Start with X at table entry 0
12472      
12473    IRQH_CheckCall_B  
12474    F9BD  AD 33 0A       LDA IRQH_MaskByte				; Check if we need to call that table entry or not
12475    F9C0  2D 34 0A       AND IRQH_WorkingMask
12476    F9C3  F0 0A          BEQ IRQH_SkipCall_B
12477      
12478    
12479    F9C5  A9 F9          LDA #>IRQH_Return_B				; Place our return address-1 on the stack for the ensuing RTS (which adds 1)
12480    F9C7  48             PHA
12481    F9C8  A9 CE          LDA #<IRQH_Return_B
12482    F9CA  48             PHA
12483      
12484    F9CB  7C 20 0A       JMP (IRQH_CallList,X)				; Make the call, including the table offset
12485      
12486    IRQH_Return_B					; Since the 65C02 won't JSR to our chosen address, this is the return address
12487    F9CE  EA             NOP						; non executed packer.  It's cheaper than the arithmetic approach.
12488    
12489    IRQH_SkipCall_B
12490    F9CF  EE 35 0A       INC IRQH_CurrentEntry				; Advance to the next table entry
12491    F9D2  E8             INX
12492    F9D3  E8             INX
12493      
12494    F9D4  8A             TXA						; Have we processed them all?
12495    F9D5  C9 10          CMP #16					; If so, we shall go to the finish-line.
12496    F9D7  F0 06          BEQ IRQH_FinishIRQs_B
12497      
12498    F9D9  18             CLC						; Move our working mask to the next IRQ
12499    F9DA  2E 34 0A       ROL IRQH_WorkingMask
12500      
12501    F9DD  80 DE          BRA IRQH_CheckCall_B				; Check the next call.
12502      
12503    IRQH_FinishIRQs_B
12504    F9DF  7A             PLY						; Retrieve processor registers
12505    F9E0  FA             PLX
12506    F9E1  68             PLA
12507      
12508    F9E2  40             RTI
12509      
12510      
12511    ; Function to return table base address and version number.
12512    ; Used for keeping programs compatible over generational changes.
12513    
12514    IRQH_SystemReport_F
12515    
12516    F9E3  A9 00          LDA #IRQH_Version_C
12517    F9E5  A2 20          LDX #<IRQH_Table_Base
12518    F9E7  A0 0A          LDY #>IRQH_Table_Base
12519    F9E9  60             RTS
12520      .INCLUDE "COUNTDOWN_IRQ.asm"
12521    ; Countdown IRQ.
12522    
12523    ; Adds a system countdown timer.  This is to be driven from the timer on the GPIO card.
12524    
12525    
12526    ; Variables
12527    
12528      0A46             CTR_V			= IRQH_CMD_Table+16		; This is our counter variable base address.
12529      0A48             CTR_LOAD_VAL_V		= CTR_V + 2			; This is the interval between counts in PHI2 ticks
12530    
12531    
12532    ; Constants
12533    
12534      9C3F             TIM_DELAY_C		= 39999		; This is the value we are going to use to set the timer. 10ms @4MHz
12535    
12536    
12537    ; Hardware constants
12538    
12539      C044             TIM_T1L			= TAPE_IOBASE + 4
12540      C045             TIM_T1H			= TAPE_IOBASE + 5
12541    
12542      C04B             TIM_ACR			= TAPE_IOBASE + $B
12543      C04D             TIM_IFR			= TAPE_IOBASE + $D
12544      C04E             TIM_IER			= TAPE_IOBASE + $E
12545    
12546      0080             IFR_IRQ_FLAG		= @10000000
12547      0040             IFR_TIM1_FLAG		= @01000000
12548    
12549    
12550    INIT_COUNTDOWN_IRQ
12551      
12552    F9EA  08             PHP					; Add our interrupt guard
12553    F9EB  78             SEI
12554      
12555    F9EC  0D 33 0A       ORA IRQH_MaskByte			; Mark our IRQ as active.
12556    F9EF  8D 33 0A       STA IRQH_MaskByte
12557      
12558    F9F2  A9 3F          LDA #<TIM_DELAY_C			; Load timer value to our variable
12559    F9F4  8D 48 0A       STA CTR_LOAD_VAL_V
12560    F9F7  A9 9C          LDA #>TIM_DELAY_C
12561    F9F9  8D 49 0A       STA CTR_LOAD_VAL_V + 1
12562      
12563    F9FC  AD 4B C0       LDA TIM_ACR
12564    F9FF  09 40          ORA #@01000000			; Load Auxilliary Control Register with continuous interrupts on T1 with latching
12565    FA01  8D 4B C0       STA TIM_ACR
12566      
12567    FA04  AD 4E C0       LDA TIM_IER				; Start our interrupts running
12568    FA07  09 C0          ORA #@11000000
12569    FA09  8D 4E C0       STA TIM_IER
12570      
12571    FA0C  20 63 FA       JSR TIM_Update_T1_F
12572      
12573    FA0F  28             PLP					; Restore our IRQ status
12574    
12575    FA10  60             RTS
12576      
12577      
12578    
12579    COUNTDOWN_IRQ
12580    
12581    FA11  BD 36 0A       LDA IRQH_CMD_Table,X			; Process command shutdown command when asked.
12582    FA14  C9 01          CMP #IRQH_Shutdown_CMD
12583    FA16  F0 2F          BEQ COUNTDOWN_IRQ_SHUTDOWN
12584      
12585    FA18  AD 4D C0       LDA TIM_IFR				; Check whether this is our interrupt to claim
12586    FA1B  29 C0          AND #IFR_IRQ_FLAG | IFR_TIM1_FLAG
12587    FA1D  C9 C0          CMP #IFR_IRQ_FLAG | IFR_TIM1_FLAG
12588      
12589    FA1F  D0 25          BNE TIM_NOT_OUR_IRQ_B			; Branch politely if it isn't ours.
12590      
12591    FA21  AD 46 0A       LDA CTR_V				; When we reach zero, shutdown.
12592    FA24  0D 47 0A       ORA CTR_V + 1
12593    FA27  F0 1E          BEQ COUNTDOWN_IRQ_SHUTDOWN
12594    
12595    FA29  38             SEC					; Update our countdown counter.
12596    FA2A  AD 46 0A       LDA CTR_V
12597    FA2D  E9 01          SBC #1
12598    FA2F  8D 46 0A       STA CTR_V
12599    FA32  AD 47 0A       LDA CTR_V + 1
12600    FA35  E9 00          SBC #0
12601    FA37  8D 47 0A       STA CTR_V + 1
12602      
12603    FA3A  AD 44 C0       LDA TIM_T1L				; Read to this register to clear the interrupt.
12604      
12605    FA3D  AD 34 0A       LDA IRQH_WorkingMask			; Set our claims bit.
12606    FA40  0D 32 0A       ORA IRQH_ClaimsList
12607    FA43  8D 32 0A       STA IRQH_ClaimsList
12608    
12609    TIM_NOT_OUR_IRQ_B
12610    FA46  60             RTS					; IRQ Handler done
12611    
12612        
12613    COUNTDOWN_IRQ_SHUTDOWN
12614    
12615    FA47  AD 44 C0       LDA TIM_T1L				; Read this register to clear the interrupt
12616    
12617    FA4A  AD 4B C0       LDA TIM_ACR				; Disable Timer 1
12618    FA4D  29 3F          AND #@00111111			; only affecting our specific hardware
12619    FA4F  8D 4B C0       STA TIM_ACR
12620      
12621    FA52  A9 40          LDA #IFR_TIM1_FLAG			; Disable Our interrupt
12622    FA54  8D 4E C0       STA TIM_IER
12623      
12624    FA57  AD 34 0A       LDA IRQH_WorkingMask			; Unset our IRQ from the handler
12625    FA5A  49 FF          EOR #$FF
12626    FA5C  2D 33 0A       AND IRQH_MaskByte
12627    FA5F  8D 33 0A       STA IRQH_MaskByte
12628        
12629    FA62  60             RTS					; IRQ Handler done.
12630      
12631      
12632      
12633    TIM_Update_T1_F
12634    
12635    FA63  08             PHP					; Save IRQ state and disable interrupts
12636    FA64  78             SEI
12637      
12638    FA65  AD 48 0A       LDA CTR_LOAD_VAL_V			; Load timer
12639    FA68  8D 44 C0       STA TIM_T1L
12640    FA6B  AD 49 0A       LDA CTR_LOAD_VAL_V + 1
12641    FA6E  8D 45 C0       STA TIM_T1H				; Count commences from here (if running)
12642      
12643    FA71  28             PLP					; Restore IRQ status
12644      
12645    FA72  60             RTS
12646      .INCLUDE "XTRA_BASIC.asm"             ; Extra's for EhBASIC.
12647    ; Extra functions for EhBASIC
12648    
12649    
12650    ; Variables for use in Extra functions.
12651    
12652      0A10             V_XTRA_BASE   = $A10
12653    
12654      0A10             V_XTRA_PlotMode  = V_XTRA_BASE
12655      0A11             V_XTRA_Xcoord    = V_XTRA_PlotMode + 1
12656      0A12             V_XTRA_Ycoord    = V_XTRA_Xcoord   + 1
12657    
12658    
12659    ; Function to set the cursor location.
12660    
12661    XTRA_LOCATE_F
12662    
12663    FA73  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12664    						; else do type mismatch
12665    FA76  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12666      
12667    FA79  A9 0E          LDA #14					; Set our column
12668    FA7B  20 02 E2       JSR V_OUTP  
12669    FA7E  A5 11          LDA   Itempl
12670    FA80  20 02 E2       jsr V_OUTP
12671      
12672    FA83  20 04 CD       JSR   LAB_1C01				; scan for "," , else do syntax error then warm start
12673     
12674    FA86  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12675    						; else do type mismatch
12676    FA89  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12677      
12678    FA8C  A9 0F          LDA #15					; Set our row
12679    FA8E  20 02 E2       JSR V_OUTP  
12680    FA91  A5 11          LDA   Itempl
12681    FA93  20 02 E2       jsr V_OUTP
12682      
12683    FA96  60             RTS
12684    
12685    
12686    ; Function to PLOT or UNPLOT a pixel
12687      
12688    XTRA_PLOT_F
12689    
12690    FA97  A9 05          LDA #5					; Start with plot mode
12691    FA99  8D 10 0A       STA V_XTRA_PlotMode
12692      
12693    FA9C  20 D3 CB       JSR LAB_EVNM					; evaluate expression and check is numeric,
12694    						; else do type mismatch
12695    FA9F  20 04 D6       JSR LAB_F2FX					; save integer part of FAC1 in temporary integer
12696      
12697    FAA2  A5 11          LDA Itempl					; Get our plot/unplot value
12698    
12699    FAA4  89 01          BIT #1
12700    FAA6  D0 05          BNE XTRA_NOT_Plotting_B
12701      
12702    FAA8  A9 06          LDA #6					; Set for unplot mode.
12703    FAAA  8D 10 0A       STA V_XTRA_PlotMode
12704     
12705    XTRA_NOT_Plotting_B
12706      
12707      
12708    FAAD  20 04 CD       JSR   LAB_1C01				; scan for "," , else do syntax error then warm start
12709     
12710    FAB0  20 D3 CB       JSR   LAB_EVNM				; evaluate expression and check is numeric,
12711    						; else do type mismatch
12712    FAB3  20 04 D6       JSR   LAB_F2FX				; save integer part of FAC1 in temporary integer
12713      
12714    FAB6  A5 11          LDA Itempl					; Save our X coordinate
12715    FAB8  8D 11 0A       STA V_XTRA_Xcoord
12716      
12717    FABB  20 04 CD       JSR   LAB_1C01				; scan for "," , else do syntax error then warm start
12718     
12719    FABE  20 D3 CB       JSR   LAB_EVNM				; evaluate expression and check is numeric,
12720    						; else do type mismatch
12721    FAC1  20 04 D6       JSR   LAB_F2FX				; save integer part of FAC1 in temporary integer
12722      
12723    FAC4  A5 11          LDA Itempl					; Save our Y coordinate
12724    FAC6  8D 12 0A       STA V_XTRA_Ycoord
12725    
12726    ; Function to actually PLOT/UNPLOT.
12727    XTRA_SystemPlot_F
12728    FAC9  AD 10 0A       LDA V_XTRA_PlotMode				; Write our plot command
12729    FACC  20 02 E2       JSR V_OUTP
12730        
12731    FACF  AD 11 0A       LDA V_XTRA_Xcoord				; Write our X co-ordinate
12732    FAD2  20 02 E2       jsr V_OUTP
12733      
12734    FAD5  AD 12 0A       LDA V_XTRA_Ycoord				; Write our Y co-ordinate
12735    FAD8  20 02 E2       JSR V_OUTP
12736      
12737    FADB  60             RTS
12738      .INCLUDE "I2C_Lib.asm"		; I2C Support
12739    ; I2C (Inter Integrated Circuit) Bus Engine.
12740    ;
12741    
12742    ; Special considerations for this I2C implementation.
12743    ; ---------------------------------------------------
12744    ;
12745    ; 1) I2C is a MSb first protocol.
12746    ; 2) We are not implementing a slave mode here.
12747    ; 3) Multi-master support will *maybe* be added later. Will it be practical?
12748    ; 4) We ain't gonna be particularly fast, that's for sure.
12749    
12750    
12751    ; Pin Bit spec
12752    ;
12753      0001             I2C_SDA_Pin	= @00000001
12754      0002             I2C_SCL_Pin	= @00000010
12755    
12756    
12757    ; Useful addresses
12758    ;
12759      C043             I2C_DDR		= $C043
12760      C041             I2C_PORT	= $C041
12761    
12762      05D0             I2C_Base	= $5D0				; NOT the Final location.
12763      05D0             I2C_Status	= I2C_Base
12764      05D1             I2C_Byte	= I2C_Status+1
12765      05D2             I2C_Timeout_V	= I2C_Byte + 1			; Timeout counter variable.
12766    
12767    
12768    ; I2C State machine bitfield
12769    ;
12770      0001             I2C_STA_NAK	= @00000001
12771      0002             I2C_STA_Timeout	= @00000010
12772      0004             I2C_STA_Rd_nWr	= @00000100
12773      0008             I2C_STA_Master	= @00001000
12774    
12775    
12776    ; I2C handy constants
12777    ;
12778      04FF             I2C_Timeout_C	= $4FF				; Attempts to make before timeout
12779      0001             I2C_Float	= 1
12780      0000             I2C_Assert	= 0				; Note that any non zero vslue will float, which we will exploit.
12781    
12782    
12783    
12784    ; ----------------------------------------------
12785    ; ********  I2C Pin driving functions.  ********
12786    ; ----------------------------------------------
12787    ;
12788    
12789    I2C_SetSDA
12790    FADC  D0 09          BNE I2C_SDA_Float
12791      
12792    ; Asserting case
12793    FADE  A9 01          LDA #I2C_SDA_Pin
12794    FAE0  0D 43 C0       ORA I2C_DDR
12795    FAE3  8D 43 C0       STA I2C_DDR
12796    FAE6  60             RTS
12797      
12798    ; Floating case
12799    I2C_SDA_Float
12800    FAE7  A9 FE          LDA #~I2C_SDA_Pin
12801    FAE9  2D 43 C0       AND I2C_DDR
12802    FAEC  8D 43 C0       STA I2C_DDR
12803    FAEF  60             RTS  
12804    
12805    
12806    
12807    I2C_SetSCL
12808    FAF0  D0 09          BNE I2C_SCL_Float
12809      
12810    ; Asserting case
12811    FAF2  A9 02          LDA #I2C_SCL_Pin
12812    FAF4  0D 43 C0       ORA I2C_DDR
12813    FAF7  8D 43 C0       STA I2C_DDR
12814    FAFA  60             RTS
12815      
12816    ; Floating case
12817    I2C_SCL_Float
12818    FAFB  A9 FD          LDA #~I2C_SCL_Pin
12819    FAFD  2D 43 C0       AND I2C_DDR
12820    FB00  8D 43 C0       STA I2C_DDR
12821    FB03  60             RTS
12822    
12823    
12824    
12825    ; ---------------------------------------------
12826    ; ********    Pin reading functions    ********
12827    ; ---------------------------------------------
12828    ;
12829    
12830    
12831    ; Wait for SCL Release and return when done or timed out.
12832    ;
12833    ; This is done to support clock-stretching, which is not very useful at these speeds but... who knows!?
12834    ;
12835    I2C_WaitSCL_Release
12836    FB04  DA             PHX
12837    FB05  5A             PHY
12838    FB06  A2 D2          LDX #<I2C_Timeout_V			; Setup our timeout attempt counter low
12839    FB08  A0 05          LDY #>I2C_Timeout_V			; ...and high.
12840      
12841    
12842    FB0A  A9 02          LDA #I2C_SCL_Pin			; Check if SCL has been released
12843      
12844    I2C_WaitSCL_retry_L
12845    FB0C  2C 41 C0       BIT I2C_PORT
12846    FB0F  D0 11          BNE I2C_SCL_Freed			; Are you free, Are you free!?
12847      
12848    FB11  CA             DEX
12849    FB12  D0 F8          BNE I2C_WaitSCL_retry_L		; Repeat until we reach 0 or the line is freed
12850    FB14  88             DEY
12851    FB15  D0 F5          BNE I2C_WaitSCL_retry_L
12852      
12853    FB17  AD D0 05       LDA I2C_Status			; Update status bit to reflect line timeout.
12854    FB1A  09 02          ORA #I2C_STA_Timeout
12855    FB1C  8D D0 05       STA I2C_Status
12856    FB1F  7A             PLY
12857    FB20  FA             PLX
12858    FB21  60             RTS
12859    
12860    I2C_SCL_Freed
12861    FB22  AD D0 05       LDA I2C_Status			; Update status bit to reflect line freed.
12862    FB25  29 FD          AND #~I2C_STA_Timeout
12863    FB27  8D D0 05       STA I2C_Status
12864    FB2A  7A             PLY
12865    FB2B  FA             PLX
12866    FB2C  60             RTS
12867      
12868      
12869    I2C_GetSDA
12870    FB2D  AD 41 C0       LDA I2C_PORT
12871    FB30  29 01          AND #I2C_SDA_Pin
12872    FB32  60             RTS
12873      
12874    
12875    
12876    ; ---------------------------------------------
12877    ; ********       Bus Functions.        ********
12878    ; ---------------------------------------------
12879    
12880    I2C_Init
12881    
12882    ; Set initial timeout variable
12883    
12884    FB33  A9 FF          LDA #<I2C_Timeout_C
12885    FB35  8D D2 05       STA I2C_Timeout_V
12886    FB38  A9 04          LDA #>I2C_Timeout_C
12887    FB3A  8D D3 05       STA I2C_Timeout_V+1
12888    
12889    
12890    ;  Set initial state of port
12891    
12892    FB3D  A9 01          LDA #I2C_Float
12893    FB3F  20 F0 FA       JSR I2C_SetSCL
12894      
12895    FB42  A9 01          LDA #I2C_Float
12896    FB44  20 DC FA       JSR I2C_SetSDA
12897        
12898    FB47  AD 41 C0       LDA I2C_PORT
12899    FB4A  29 FC          AND #~[I2C_SDA_Pin | I2C_SCL_Pin]
12900    FB4C  8D 41 C0       STA I2C_PORT
12901    
12902    
12903    ; Set initial status register value
12904      
12905    FB4F  A9 08          LDA #I2C_STA_Master
12906    FB51  8D D0 05       STA I2C_Status
12907    
12908    
12909    ; Clear engine state
12910      
12911    FB54  A9 00          LDA #0
12912    FB56  8D D1 05       STA I2C_Byte
12913    
12914    FB59  60             RTS
12915    
12916    
12917    ; I2C Bus commands
12918    
12919    I2C_Start
12920    
12921    FB5A  A9 00          LDA #I2C_Assert
12922    FB5C  20 DC FA       JSR I2C_SetSDA
12923      
12924    FB5F  A9 00          LDA #I2C_Assert
12925    FB61  20 F0 FA       JSR I2C_SetSCL
12926      
12927    FB64  60             RTS
12928    
12929      
12930    I2C_Stop
12931    
12932    FB65  A9 01          LDA #I2C_Float
12933    FB67  20 F0 FA       JSR I2C_SetSCL
12934    
12935      ; JSR I2C_WaitSCL_Release ; I don't think we need this line.
12936      
12937    FB6A  A9 01          LDA #I2C_Float
12938    FB6C  20 DC FA       JSR I2C_SetSDA
12939    
12940    
12941    FB6F  60             RTS
12942    
12943      
12944    I2C_Out
12945    FB70  A0 80          LDY #$80			; Set our bit mask
12946    
12947    
12948    ; ** This part sends out the 8 bit word MSb first. **
12949    
12950    I2C_Out_L
12951    FB72  A9 00          LDA #I2C_Assert		; Transmit selected bit
12952    FB74  20 F0 FA       JSR I2C_SetSCL		; Clock line low first
12953    
12954    FB77  98             TYA
12955    FB78  2D D1 05       AND I2C_Byte			; Set data bit appropriately
12956    FB7B  20 DC FA       JSR I2C_SetSDA
12957      
12958    FB7E  A9 01          LDA #I2C_Float		; Latch it to slave
12959    FB80  20 F0 FA       JSR I2C_SetSCL
12960      
12961    FB83  98             TYA				; Proceed to next bit until zero
12962    FB84  6A             ROR
12963    FB85  A8             TAY
12964    FB86  D0 EA          BNE I2C_Out_L
12965    
12966    
12967    ; ** This part handles the ACK or NAK appropriately **
12968      
12969    FB88  A9 00          LDA #I2C_Assert		; ACK/NAK clock pulse low
12970    FB8A  20 F0 FA       JSR I2C_SetSCL
12971      
12972    FB8D  A9 01          LDA #I2C_Float		; Float SDA so the slave can pull it for ACK
12973    FB8F  20 DC FA       JSR I2C_SetSDA
12974      
12975    FB92  A9 01          LDA #I2C_Float		; ACK/NAK clock pulse high with stretching
12976    FB94  20 F0 FA       JSR I2C_SetSCL   
12977    FB97  20 04 FB       JSR I2C_WaitSCL_Release
12978      
12979    FB9A  20 2D FB       JSR I2C_GetSDA		; Read ACK/NAK state
12980      
12981    FB9D  F0 0A          BEQ I2C_Out_ACKin		; Set the status word accordingly.
12982      
12983    FB9F  A9 01          LDA #I2C_STA_NAK		; Case NAK
12984    FBA1  0D D0 05       ORA I2C_Status
12985    FBA4  8D D0 05       STA I2C_Status
12986    FBA7  80 08          BRA I2C_FinishWrite
12987      
12988    I2C_Out_ACKin			; Case ACK
12989    FBA9  A9 FE          LDA #~I2C_STA_NAK
12990    FBAB  2D D0 05       AND I2C_Status
12991    FBAE  8D D0 05       STA I2C_Status
12992      
12993    I2C_FinishWrite
12994    FBB1  A9 00          LDA #I2C_Assert		; Finish clock cycle for ACK/NAK
12995    FBB3  20 F0 FA       JSR I2C_SetSCL
12996      
12997    FBB6  A9 01          LDA #I2C_Float		; Float SDA or we can't do a repeat start FINDME
12998    FBB8  20 DC FA       JSR I2C_SetSDA  
12999    FBBB  60             RTS
13000        
13001    I2C_WriteFail  
13002    FBBC  20 65 FB       JSR I2C_Stop
13003    FBBF  60             RTS
13004      
13005      
13006    I2C_In
13007    
13008    FBC0  A9 01          LDA #I2C_Float		; Ensure the SDA line is floating.
13009    FBC2  20 DC FA       JSR I2C_SetSDA
13010      
13011    FBC5  A0 80          LDY #$80			; Setup initial state
13012    FBC7  A9 00          LDA #0
13013    FBC9  8D D1 05       STA I2C_Byte
13014    
13015    I2C_In_L
13016    
13017    FBCC  A9 00          LDA #I2C_Assert		; Start clock pulse
13018    FBCE  20 F0 FA       JSR I2C_SetSCL  
13019    FBD1  A9 01          LDA #I2C_Float		; Finish clock pulse
13020    FBD3  20 F0 FA       JSR I2C_SetSCL  
13021    FBD6  20 2D FB       JSR I2C_GetSDA		; Get bit
13022    FBD9  F0 07          BEQ I2C_In_SkipSet
13023      
13024    FBDB  98             TYA				; Set relevant bit of I2C_Byte to 1
13025    FBDC  0D D1 05       ORA I2C_Byte
13026    FBDF  8D D1 05       STA I2C_Byte
13027    
13028    I2C_In_SkipSet
13029      
13030    FBE2  98             TYA				; Move walking one across
13031    FBE3  4A             LSR
13032    FBE4  A8             TAY
13033    
13034    FBE5  D0 E5          BNE I2C_In_L			; Keep reading until all bits read
13035      
13036    FBE7  A9 00          LDA #I2C_Assert
13037    FBE9  20 F0 FA       JSR I2C_SetSCL
13038      
13039    FBEC  A9 01          LDA #I2C_STA_NAK		; Check whether to send ACK or NAK
13040    FBEE  2C D0 05       BIT I2C_Status
13041    FBF1  D0 05          BNE I2C_In_SendNAK
13042      
13043    FBF3  A9 00          LDA #I2C_Assert		; Set for ACK
13044    FBF5  20 DC FA       JSR I2C_SetSDA
13045      
13046    I2C_In_SendNAK
13047    FBF8  A9 01          LDA #I2C_Float		; Send ACK/NAK
13048    FBFA  20 F0 FA       JSR I2C_SetSCL
13049    FBFD  A9 00          LDA #I2C_Assert
13050    FBFF  20 F0 FA       JSR I2C_SetSCL
13051    
13052    FC02  A9 01          LDA #I2C_Float		; Restore SDA to floating. 
13053    FC04  20 DC FA       JSR I2C_SetSDA
13054    FC07  60             RTS
13055    
13056    
13057    ; reset vector points here
13058    
13059    RES_vec
13060    FC08  78             SEI					; Ensure IRQ's are turned off.
13061    FC09  D8             CLD					; clear decimal mode
13062    FC0A  A2 FF          LDX #$FF				; empty stack
13063    FC0C  9A             TXS					; set the stack
13064    
13065    ; Set up system timing function
13066    
13067    FC0D  20 DB FF       JSR IRQH_Handler_Init_vec		; Initialise the IRQ Handler
13068    
13069    FC10  A9 11          LDA #<COUNTDOWN_IRQ			; Put the test IRQ address into the table at IRQ Location 0
13070    FC12  8D 30 0A       STA IRQH_CallReg
13071    FC15  A9 FA          LDA #>COUNTDOWN_IRQ
13072    FC17  8D 31 0A       STA IRQH_CallReg + 1
13073    FC1A  A9 00          LDA #0
13074    FC1C  20 DE FF       JSR IRQH_SetIRQ_vec
13075       
13076    FC1F  58             CLI					; Enable IRQs globally.
13077    
13078    FC20  20 A5 EF       JSR TPB_delay
13079      
13080    FC23  A9 02          LDA #ANSI_out_sw                    ; Set our default output options for ANSI output mode.
13081    ;  LDA #ACIA1_out_sw                   ; Set our default output options for ACIA output mode.
13082    FC25  8D E0 05       STA os_outsel                       ; to the ANSI card only.
13083    FC28  A9 01          LDA #LF_filt_sw1
13084    FC2A  8D E1 05       STA os_infilt                       ; Switch on $A filtering on the ACIA.
13085      
13086    FC2D  A9 01          LDA #OS_input_ACIA1                 ; Specify input source as ACIA1
13087    FC2F  8D E2 05       STA os_insel
13088      
13089    FC32  20 00 EC       JSR INI_ACIA1                       ; Init ACIA1. We currently need this for the keyboard.
13090    FC35  20 0E EC       JSR INI_ACIA2                       ; Init ACIA2. Just in case.
13091    FC38  20 90 FF       JSR ANSI_init_vec                   ; Initialise the ANSI text video card.
13092    FC3B  20 96 FF       JSR TPB_init_vec                    ; Init Tower Peripheral Bus
13093    FC3E  20 CB F7       JSR AY_Init                         ; Initialise the AY sound system.
13094      
13095    ; set up vectors and interrupt code, copy them to page 2
13096    
13097    FC41  A0 D2          LDY #END_CODE-LAB_vec               ; set index/count
13098    LAB_stlp
13099    FC43  B9 70 FC       LDA LAB_vec-1,Y                     ; get byte from interrupt code
13100    FC46  99 04 02       STA VEC_IN-1,Y                      ; save to RAM
13101    FC49  88             DEY                                 ; decrement index/count
13102    FC4A  D0 F7          BNE LAB_stlp                        ; loop if more to do
13103    
13104      
13105    ; Initialise filing system
13106    
13107    FC4C  20 72 FF       JSR TAPE_init_vec                   ; Initialise TowerTAPE filing system.
13108        
13109    ; now do the signon message
13110    
13111    FC4F  A0 00          LDY #0
13112    LAB_signon
13113    
13114    FC51  B9 43 FD       LDA LAB_mess,Y                      ; get byte from sign on message
13115    FC54  F0 06          BEQ LAB_nokey                       ; exit loop if done
13116    
13117    FC56  20 02 E2       JSR V_OUTP                          ; output character
13118    FC59  C8             INY                                 ; increment index
13119    FC5A  D0 F5          BNE LAB_signon                      ; loop, branch always
13120    
13121    LAB_nokey
13122    FC5C  20 FF E1       JSR V_INPT                          ; call scan input device
13123    FC5F  90 FB          BCC LAB_nokey                       ; loop if no key
13124    
13125    FC61  29 DF          AND #$DF                            ; mask xx0x xxxx, ensure upper case
13126    FC63  C9 57          CMP #'W'                            ; compare with [W]arm start
13127    FC65  F0 07          BEQ LAB_dowarm                      ; branch if [W]arm start
13128    
13129    FC67  C9 43          CMP #'C'                            ; compare with [C]old start.
13130    FC69  D0 E6          BNE LAB_signon                      ; loop if not [C]old start
13131    
13132    FC6B  4C 00 C1       JMP LAB_COLD                        ; do EhBASIC cold start
13133    
13134    LAB_dowarm
13135    FC6E  4C 00 00       JMP LAB_WARM                        ; do EhBASIC warm start
13136    
13137    
13138    ; EhBASIC vector tables
13139    
13140    LAB_vec
13141      .word RD_char                       ; byte in from Selected source
13142      .word WR_char                       ; byte out to ACIA1
13143      .word TAPE_LOAD_BASIC_vec           ; null load vector for EhBASIC
13144      .word TAPE_SAVE_BASIC_vec           ; save vector for EhBASIC
13145      .word TAPE_VERIFY_BASIC_vec         ; verify vector for EhBASIC
13146      .word TAPE_CAT_vec                  ; cat vector for EhBASIC
13147      
13148    
13149    ; EhBASIC IRQ support
13150    
13151    IRQ_CODE
13152    FC7D  48             PHA                                 ; save A
13153    FC7E  A5 DF          LDA IrqBase                         ; get the IRQ flag byte
13154    FC80  4A             LSR                                 ; shift the set b7 to b6, and on down ...
13155    FC81  05 DF          ORA IrqBase                         ; OR the original back in
13156    FC83  85 DF          STA IrqBase                         ; save the new IRQ flag byte
13157    FC85  68             PLA                                 ; restore A
13158    FC86  40             RTI
13159    
13160    
13161    ; EhBASIC NMI support
13162    
13163    NMI_CODE
13164    FC87  48             PHA                                 ; save A
13165    FC88  A5 DC          LDA NmiBase                         ; get the NMI flag byte
13166    FC8A  4A             LSR                                 ; shift the set b7 to b6, and on down ...
13167    FC8B  05 DC          ORA NmiBase                         ; OR the original back in
13168    FC8D  85 DC          STA NmiBase                         ; save the new NMI flag byte
13169    FC8F  68             PLA                                 ; restore A
13170    FC90  40             RTI
13171    
13172    
13173    ; ToE input BASIC stream support.
13174    
13175    RD_char
13176    
13177    FC91  AD E2 05       LDA os_insel                        ; Handle TAPE selected
13178    FC94  89 10          BIT #OS_input_TAPE
13179    FC96  F0 0F          BEQ INSEL_Check_ACIA1
13180    
13181    FC98  20 6F FF       JSR TAPE_ByteIn_vec                 ; Get a byte
13182      
13183    FC9B  AD 09 09       LDA TAPE_RX_Status                  ; Check if escape was pressed
13184    FC9E  89 08          BIT #TAPE_Stat_Escape
13185    FCA0  D0 1B          BNE INSEL_ResetSource
13186      
13187    FCA2  AD 0B 09       LDA TAPE_ByteReceived
13188    FCA5  38             SEC
13189    FCA6  60             RTS
13190      
13191    
13192    INSEL_Check_ACIA1
13193    FCA7  AD E2 05       LDA os_insel                        ; Handle ACIA1 selected
13194    FCAA  89 01          BIT #OS_input_ACIA1
13195    FCAC  F0 04          BEQ INSEL_Check_ACIA2
13196    FCAE  20 3A EC       JSR ACIA1in
13197    FCB1  60             RTS
13198    
13199    INSEL_Check_ACIA2
13200    FCB2  AD E2 05       LDA os_insel  
13201    FCB5  89 08          BIT #OS_input_ACIA2                 ; Handle ACIA2 selected
13202    FCB7  F0 04          BEQ INSEL_ResetSource
13203    FCB9  20 4F EC       JSR ACIA2in
13204    FCBC  60             RTS
13205    
13206    INSEL_ResetSource
13207    FCBD  A9 01          LDA #OS_input_ACIA1                 ; Reset source
13208    FCBF  8D E2 05       STA os_insel
13209      
13210    FCC2  A9 0C          LDA #$C                             ; and send a ^C to interrupt program flow.
13211    FCC4  38             SEC
13212    FCC5  60             RTS
13213      
13214    
13215    ; OS output stream management support.
13216    
13217    WR_char
13218    FCC6  08             PHP                                 ; Save our registers in case we need 'em
13219    FCC7  DA             PHX
13220    FCC8  5A             PHY
13221    FCC9  48             PHA
13222    FCCA  48             PHA
13223       
13224    FCCB  A9 01          LDA #ACIA1_out_sw
13225    FCCD  2C E0 05       BIT os_outsel
13226    FCD0  F0 05          BEQ no_ACIA1
13227    FCD2  68             PLA
13228    FCD3  20 1C EC       JSR ACIA1out                         ; Print to ACIA1
13229    
13230    FCD6  48             PHA
13231    no_ACIA1  
13232    FCD7  A9 08          LDA #ACIA2_out_sw
13233    FCD9  2C E0 05       BIT os_outsel
13234    FCDC  F0 05          BEQ no_ACIA2
13235    FCDE  68             PLA
13236    FCDF  20 2B EC       JSR ACIA2out                         ; Print to ACIA2
13237      
13238    FCE2  48             PHA
13239    no_ACIA2
13240    FCE3  A9 02          LDA #ANSI_out_sw
13241    FCE5  2C E0 05       BIT os_outsel
13242    FCE8  F0 05          BEQ no_ANSI
13243    FCEA  68             PLA
13244    FCEB  20 93 FF       JSR ANSI_write_vec                  ; Print to ANSI video card
13245        
13246    FCEE  48             PHA
13247    no_ANSI
13248    FCEF  A9 04          LDA #TPB_out_sw
13249    FCF1  2C E0 05       BIT os_outsel
13250    FCF4  F0 05          BEQ no_TPB_LPT
13251    FCF6  68             PLA
13252    FCF7  20 99 FF       JSR TPB_LPT_write_vec               ; Print to TPB LPT card
13253    
13254    FCFA  48             PHA  
13255    no_TPB_LPT                            ; "Print" to the TAPE interface
13256    FCFB  A9 10          LDA #TAPE_out_sw
13257    FCFD  2C E0 05       BIT os_outsel
13258    FD00  F0 0F          BEQ MON_EndWRITE_B                  ; Dont write to tape unless selected.
13259    FD02  68             PLA
13260    FD03  48             PHA
13261    FD04  20 69 FF       JSR TAPE_ByteOut_vec
13262    FD07  68             PLA
13263    FD08  C9 0D          CMP #13                             ; Do a little delay if CR is detected to allow the system to catch up on read.
13264    FD0A  D0 03          BNE MON_SkipTapeDelay
13265      
13266    FD0C  20 24 FD       JSR MON_Do_CR_Delay
13267      
13268      
13269      
13270    MON_SkipTapeDelay
13271      
13272    FD0F  80 01          BRA MON_EndWRITE_B2
13273    
13274    MON_EndWRITE_B
13275    FD11  68             PLA                                   ; Clean up stack including restoring P and return.
13276    MON_EndWRITE_B2
13277    FD12  68             PLA
13278    FD13  7A             PLY
13279    FD14  FA             PLX
13280    FD15  28             PLP
13281    FD16  60             RTS
13282    
13283      
13284    ; Tower string printing routine.
13285    TOE_PrintStr
13286    FD17  A0 00          LDY #0					; Initialise loop index.
13287    TOE_PrintStr_L
13288    FD19  B1 E7          LDA (TOE_MemptrLo),Y				; Print character.
13289    FD1B  F0 06          BEQ TOE_DonePrinting
13290    FD1D  20 02 E2       JSR V_OUTP
13291    FD20  C8             INY
13292    FD21  80 F6          BRA TOE_PrintStr_L
13293    
13294    TOE_DonePrinting
13295    FD23  60             RTS
13296    
13297    ; Tower CR delay for spooling routine.  
13298    MON_Do_CR_Delay
13299    FD24  A0 10          LDY #>MON_CR_Delay_C                          ; Get our delay value
13300    FD26  A2 00          LDX #<MON_CR_Delay_C
13301      
13302    MON_CR_Delay_L                                  ; Iterate our delay on the counter.
13303    FD28  EA             NOP
13304    FD29  EA             NOP
13305    FD2A  EA             NOP
13306    FD2B  EA             NOP
13307    FD2C  CA             DEX
13308    FD2D  D0 F9          BNE MON_CR_Delay_L                            ; Keep counting X down until 0
13309    FD2F  88             DEY
13310    FD30  D0 F6          BNE MON_CR_Delay_L
13311      
13312    FD32  60             RTS
13313      
13314      
13315    MON_CLS
13316    FD33  A9 18          LDA #24					; Clear the screen to bold, 80 columns and text
13317    FD35  20 02 E2       JSR V_OUTP
13318    FD38  A9 03          LDA #3
13319    FD3A  20 02 E2       JSR V_OUTP
13320    FD3D  A9 0C          LDA #12
13321    FD3F  20 02 E2       JSR V_OUTP
13322    FD42  60             RTS 
13323      
13324    END_CODE
13325    
13326    LAB_mess
13327                                          ; sign on string
13328    
13329      .byte "Tower of Eightness OS 3.15.2023.1",$0D,$0A,$0D,$0A
13330      .byte $0D,$0A,"6502 EhBASIC [C]old/[W]arm ?",$00
13331    
13332    
13333    ; ToE OS Vectors
13334    
13335    FF60                 *= $FF60
13336    ; Stream output vector.  
13337    
13338    TOE_PrintStr_vec
13339    FF60  4C 17 FD       JMP TOE_PrintStr         ; FF60
13340      
13341      
13342    ; TAPE subsystem vectors
13343    
13344    TAPE_Leader_vec
13345    FF63  4C 1A F6       JMP F_TAPE_Leader        ; FF63
13346    TAPE_BlockOut_vec
13347    FF66  4C EA F5       JMP F_TAPE_BlockOut      ; FF66
13348    TAPE_ByteOut_vec
13349    FF69  4C B5 F5       JMP F_TAPE_ByteOut       ; FF69
13350    TAPE_BlockIn_vec
13351    FF6C  4C C8 F6       JMP F_TAPE_BlockIn       ; FF6C
13352    TAPE_ByteIn_vec
13353    FF6F  4C 7C F7       JMP F_TAPE_GetByte       ; FF6F
13354    TAPE_init_vec
13355    FF72  4C 98 F0       JMP F_TAPE_Init          ; FF72
13356    TAPE_CAT_vec  
13357    FF75  4C AA F3       JMP F_TAPE_CAT           ; FF75
13358    TAPE_SAVE_BASIC_vec
13359    FF78  4C D3 F1       JMP F_TAPE_SAVE_BASIC    ; FF78
13360    TAPE_LOAD_BASIC_vec  
13361    FF7B  4C 03 F4       JMP F_TAPE_LOAD_BASIC    ; FF7B
13362    TAPE_VERIFY_BASIC_vec
13363    FF7E  4C AB F2       JMP F_TAPE_VERIFY_BASIC  ; FF7E
13364    
13365    
13366    ; I2C subsystem vectors
13367    
13368    I2C_Init_vec               ; FF81
13369    FF81  4C 33 FB       JMP I2C_Init
13370    I2C_Start_vec              ; FF84
13371    FF84  4C 5A FB       JMP I2C_Start
13372    I2C_Stop_vec               ; FF87
13373    FF87  4C 65 FB       JMP I2C_Stop
13374    I2C_Out_vec                ; FF8A
13375    FF8A  4C 70 FB       JMP I2C_Out
13376    I2C_In_vec                 ; FF8D
13377    FF8D  4C C0 FB       JMP I2C_In
13378    ; No gap between this and the next lot.
13379    
13380    ; ANSI Card vectors
13381    
13382    FF90                 *= $FF90
13383    
13384    ANSI_init_vec
13385    FF90  4C 6F EC       JMP ANSI_INIT            ; FF90
13386    ANSI_write_vec
13387    FF93  4C 91 EC       JMP ANSI_write           ; FF93
13388      
13389    
13390    ; Tower Peripheral Bus vectors
13391    
13392    TPB_init_vec
13393    FF96  4C B5 EC       JMP TPB_INIT             ; FF96
13394    TPB_LPT_write_vec
13395    FF99  4C 77 EF       JMP TPB_LPT_write        ; FF99
13396    TPB_tx_byte_vec
13397    FF9C  4C 3F EE       JMP TPB_tx_byte          ; FF9C
13398    TPB_tx_block_vec
13399    FF9F  4C DA EE       JMP TPB_tx_block         ; FF9F
13400    TPB_ATN_handler_vec
13401    FFA2  4C 09 EE       JMP TPB_ATN_handler      ; FFA2
13402    TPB_rx_byte_vec  
13403    FFA5  4C 84 EE       JMP TPB_rx_byte          ; FFA5
13404    TPB_rx_block_vec
13405    FFA8  4C 1E EF       JMP TPB_rx_block         ; FFA8
13406    TPB_Dev_Presence_vec
13407    FFAB  4C C5 ED       JMP TPB_Dev_Presence     ; FFAB
13408    TPB_Req_Dev_Type_vec
13409    FFAE  4C 46 ED       JMP TPB_Req_Dev_Type     ; FFAE
13410    TPB_dev_select_vec
13411    FFB1  4C 5D EF       JMP TPB_dev_select       ; FFB1
13412    TPB_Ctrl_Blk_Wr_vec
13413    FFB4  4C D9 EC       JMP TPB_Ctrl_Blk_Wr      ; FFB4
13414    TPB_Ctrl_Blk_Rd_vec
13415    FFB7  4C 0F ED       JMP TPB_Ctrl_Blk_Rd      ; FFB7
13416      
13417    
13418    FFCF                 *= $FFCF
13419    ; AY Soundcard vectors.
13420    
13421    AY_Userwrite_16_vec        ; FFCF
13422    FFCF  4C 81 F8       JMP AY_Userwrite_16
13423    AY_Userread_16_vec         ; FFD2
13424    FFD2  4C 92 F8       JMP AY_Userread_16
13425    AY_Userwrite_vec           ; FFD5
13426    FFD5  4C 6A F8       JMP AY_Userwrite
13427    AY_Userread_vec            ; FFD8
13428    FFD8  4C 74 F8       JMP AY_Userread
13429    
13430    
13431    ; IRQ Handler Subsystem vectors
13432      
13433    IRQH_Handler_Init_vec	   ; FFDB
13434    FFDB  4C 55 F9       JMP IRQH_Handler_Init_F
13435    IRQH_SetIRQ_vec		   ; FFDE
13436    FFDE  4C 89 F9       JMP IRQH_SetIRQ_F
13437    IRQH_ClrIRQ_vec		   ; FFE1
13438    FFE1  4C 9C F9       JMP IRQH_ClrIRQ_F
13439    IRQH_SystemReport_vec	   ; FFE4
13440    FFE4  4C E3 F9       JMP IRQH_SystemReport_F
13441      
13442    ; Timer System vectors
13443    
13444    INIT_COUNTDOWN_IRQ_vec	   ; FFE7
13445    FFE7  4C EA F9       JMP INIT_COUNTDOWN_IRQ
13446      
13447    
13448    ; Processor hardware vectors.  These are fixed in hardware and cannot be moved.
13449    
13450    FFFA                 *= $FFFA
13451    
13452      .word NMI_vec                ; NMI vector
13453      .word RES_vec                ; RESET vector
13454      .word IRQ_vec                ; IRQ vector
13455    
13456    
13457    
