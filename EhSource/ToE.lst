00001    ; Tower of Eightness OS
00002    
00003    
00004      .include "basic_ToE.asm"
00005    
00006    ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22p5
00007    
00008    ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
00009    
00010    ; 2.00      new revision numbers start here
00011    ; 2.01      fixed LCASE$() and UCASE$()
00012    ; 2.02      new get value routine done
00013    ; 2.03      changed RND() to galoise method
00014    ; 2.04      fixed SPC()
00015    ; 2.05      new get value routine fixed
00016    ; 2.06      changed USR() code
00017    ; 2.07      fixed STR$()
00018    ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
00019    ; 2.09      fixed RND()
00020    ; 2.10      integrated missed changes from an earlier version
00021    ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
00022    ; 2.21      fixed IF .. THEN RETURN to not cause error
00023    ; 2.22      fixed RND() breaking the get byte routine
00024    ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
00025    ;              (bugsnquirks.txt notes 2, 4 and 5)
00026    ;              tabs converted to spaces, tabwidth=6
00027    ; 2.22p2    fixed can't continue error on 1st statement after direct mode
00028    ;              changed INPUT to throw "break in line ##" on empty line input
00029    ; 2.22p3    fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
00030    ;              fix provided by github user mgcaret
00031    ; 2.22p4    fixed string compare of equal strings in direct mode returns FALSE
00032    ;              fixed FALSE stored to a variable after a string compare 
00033    ;                 is > 0 and < 1E-16
00034    ;              added additional stack floor protection for background interrupts
00035    ;              fixed conditional LOOP & NEXT cannot find their data strucure on stack
00036    ; 2.22p5    fixes issues reported by users Ruud and dclxvi on the 6502.org forum
00037    ;      5.0     http://forum.6502.org/viewtopic.php?f=5&t=5500
00038    ;              sanity check for RAM top allows values below RAM base
00039    ;      5.1-7   http://forum.6502.org/viewtopic.php?f=5&t=5606
00040    ;              1-7 coresponds to the bug# in the thread
00041    ;      5.1     TO expression with a subtract may evaluate with the sign bit flipped
00042    ;      5.3     call to LAB_1B5B may return to an address -$100 (page not incremented)
00043    ;      5.4     string concatenate followed by MINUS or NOT() crashes EhBASIC
00044    ;      5.5     garbage collection may cause an overlap with temporary strings
00045    ;      5.6     floating point multiply rounding bug
00046    ;      5.7     VAL() may cause string variables to be trashed
00047    
00048    ; zero page use ..
00049    
00050    ; the following locations are bulk initialized from StrTab at LAB_GMEM
00051      0000             LAB_WARM          = $00       ; BASIC warm start entry point
00052      0001             Wrmjpl            = LAB_WARM+1; BASIC warm start vector jump low byte
00053      0002             Wrmjph            = LAB_WARM+2; BASIC warm start vector jump high byte
00054    
00055      000A             Usrjmp            = $0A       ; USR function JMP address
00056      000B             Usrjpl            = Usrjmp+1  ; USR function JMP vector low byte
00057      000C             Usrjph            = Usrjmp+2  ; USR function JMP vector high byte
00058      000D             Nullct            = $0D       ; nulls output after each line
00059      000E             TPos              = $0E       ; BASIC terminal position byte
00060      000F             TWidth            = $0F       ; BASIC terminal width byte
00061      0010             Iclim             = $10       ; input column limit
00062      0011             Itempl            = $11       ; temporary integer low byte
00063      0012             Itemph            = Itempl+1  ; temporary integer high byte
00064    ; end bulk initialize from StrTab at LAB_GMEM
00065    
00066      0011             nums_1            = Itempl    ; number to bin/hex string convert MSB
00067      0012             nums_2            = nums_1+1  ; number to bin/hex string convert
00068      0013             nums_3            = nums_1+2  ; number to bin/hex string convert LSB
00069    
00070      005B             Srchc             = $5B       ; search character
00071      005B             Temp3             = Srchc     ; temp byte used in number routines
00072      005C             Scnquo            = $5C       ; scan-between-quotes flag
00073      005C             Asrch             = Scnquo    ; alt search character
00074    
00075      005B             XOAw_l            = Srchc     ; eXclusive OR, OR and AND word low byte
00076      005C             XOAw_h            = Scnquo    ; eXclusive OR, OR and AND word high byte
00077    
00078      005D             Ibptr             = $5D       ; input buffer pointer
00079      005D             Dimcnt            = Ibptr     ; # of dimensions
00080      005D             Tindx             = Ibptr     ; token index
00081    
00082      005E             Defdim            = $5E       ; default DIM flag
00083      005F             Dtypef            = $5F       ; data type flag, $FF=string, $00=numeric
00084      0060             Oquote            = $60       ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
00085      0060             Gclctd            = $60       ; garbage collected flag
00086      0061             Sufnxf            = $61       ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
00087      0062             Imode             = $62       ; input mode flag, $00=INPUT, $80=READ
00088    
00089      0063             Cflag             = $63       ; comparison evaluation flag
00090    
00091      0064             TabSiz            = $64       ; TAB step size (was input flag)
00092    
00093      0065             next_s            = $65       ; next descriptor stack address
00094    
00095                                  ; these two bytes form a word pointer to the item
00096                                  ; currently on top of the descriptor stack
00097      0066             last_sl           = $66       ; last descriptor stack address low byte
00098      0067             last_sh           = $67       ; last descriptor stack address high byte (always $00)
00099    
00100      0068             des_sk            = $68       ; descriptor stack start address (temp strings)
00101    
00102    ;                 = $70       ; End of descriptor stack
00103    
00104      0071             ut1_pl            = $71       ; utility pointer 1 low byte
00105      0072             ut1_ph            = ut1_pl+1  ; utility pointer 1 high byte
00106      0073             ut2_pl            = $73       ; utility pointer 2 low byte
00107      0074             ut2_ph            = ut2_pl+1  ; utility pointer 2 high byte
00108    
00109      0071             Temp_2            = ut1_pl    ; temp byte for block move    
00110    
00111      0075             FACt_1            = $75       ; FAC temp mantissa1
00112      0076             FACt_2            = FACt_1+1  ; FAC temp mantissa2
00113      0077             FACt_3            = FACt_2+1  ; FAC temp mantissa3
00114    
00115      0076             dims_l            = FACt_2    ; array dimension size low byte
00116      0077             dims_h            = FACt_3    ; array dimension size high byte
00117    
00118      0078             TempB             = $78       ; temp page 0 byte
00119    
00120      0079             Smeml             = $79       ; start of mem low byte       (Start-of-Basic)
00121      007A             Smemh             = Smeml+1   ; start of mem high byte      (Start-of-Basic)
00122      007B             Svarl             = $7B       ; start of vars low byte      (Start-of-Variables)
00123      007C             Svarh             = Svarl+1   ; start of vars high byte     (Start-of-Variables)
00124      007D             Sarryl            = $7D       ; var mem end low byte        (Start-of-Arrays)
00125      007E             Sarryh            = Sarryl+1  ; var mem end high byte       (Start-of-Arrays)
00126      007F             Earryl            = $7F       ; array mem end low byte      (End-of-Arrays)
00127      0080             Earryh            = Earryl+1  ; array mem end high byte     (End-of-Arrays)
00128      0081             Sstorl            = $81       ; string storage low byte     (String storage (moving down))
00129      0082             Sstorh            = Sstorl+1  ; string storage high byte    (String storage (moving down))
00130      0083             Sutill            = $83       ; string utility ptr low byte
00131      0084             Sutilh            = Sutill+1  ; string utility ptr high byte
00132      0085             Ememl             = $85       ; end of mem low byte         (Limit-of-memory)
00133      0086             Ememh             = Ememl+1   ; end of mem high byte        (Limit-of-memory)
00134      0087             Clinel            = $87       ; current line low byte       (Basic line number)
00135      0088             Clineh            = Clinel+1  ; current line high byte      (Basic line number)
00136      0089             Blinel            = $89       ; break line low byte         (Previous Basic line number)
00137      008A             Blineh            = Blinel+1  ; break line high byte        (Previous Basic line number)
00138    
00139      008B             Cpntrl            = $8B       ; continue pointer low byte
00140      008C             Cpntrh            = Cpntrl+1  ; continue pointer high byte
00141    
00142      008D             Dlinel            = $8D       ; current DATA line low byte
00143      008E             Dlineh            = Dlinel+1  ; current DATA line high byte
00144    
00145      008F             Dptrl             = $8F       ; DATA pointer low byte
00146      0090             Dptrh             = Dptrl+1   ; DATA pointer high byte
00147    
00148      0091             Rdptrl            = $91       ; read pointer low byte
00149      0092             Rdptrh            = Rdptrl+1  ; read pointer high byte
00150    
00151      0093             Varnm1            = $93       ; current var name 1st byte
00152      0094             Varnm2            = Varnm1+1  ; current var name 2nd byte
00153    
00154      0095             Cvaral            = $95       ; current var address low byte
00155      0096             Cvarah            = Cvaral+1  ; current var address high byte
00156    
00157      0097             Frnxtl            = $97       ; var pointer for FOR/NEXT low byte
00158      0098             Frnxth            = Frnxtl+1  ; var pointer for FOR/NEXT high byte
00159    
00160      0097             Tidx1             = Frnxtl    ; temp line index
00161    
00162      0097             Lvarpl            = Frnxtl    ; let var pointer low byte
00163      0098             Lvarph            = Frnxth    ; let var pointer high byte
00164    
00165      0099             prstk             = $99       ; precedence stacked flag
00166    
00167      009B             comp_f            = $9B       ; compare function flag, bits 0,1 and 2 used
00168                                  ; bit 2 set if >
00169                                  ; bit 1 set if =
00170                                  ; bit 0 set if <
00171    
00172      009C             func_l            = $9C       ; function pointer low byte
00173      009D             func_h            = func_l+1  ; function pointer high byte
00174    
00175      009C             garb_l            = func_l    ; garbage collection working pointer low byte
00176      009D             garb_h            = func_h    ; garbage collection working pointer high byte
00177    
00178      009E             des_2l            = $9E       ; string descriptor_2 pointer low byte
00179      009F             des_2h            = des_2l+1  ; string descriptor_2 pointer high byte
00180    
00181      00A0             g_step            = $A0       ; garbage collect step size
00182    
00183      00A1             Fnxjmp            = $A1       ; jump vector for functions
00184      00A2             Fnxjpl            = Fnxjmp+1  ; functions jump vector low byte
00185      00A3             Fnxjph            = Fnxjmp+2  ; functions jump vector high byte
00186    
00187      00A2             g_indx            = Fnxjpl    ; garbage collect temp index
00188    
00189      00A3             FAC2_r            = $A3       ; FAC2 rounding byte
00190    
00191      00A4             Adatal            = $A4       ; array data pointer low byte
00192      00A5             Adatah            = Adatal+1  ; array data pointer high  byte
00193    
00194      00A4             Nbendl            = Adatal    ; new block end pointer low byte
00195      00A5             Nbendh            = Adatah    ; new block end pointer high  byte
00196    
00197      00A6             Obendl            = $A6       ; old block end pointer low byte
00198      00A7             Obendh            = Obendl+1  ; old block end pointer high  byte
00199    
00200      00A8             numexp            = $A8       ; string to float number exponent count
00201      00A9             expcnt            = $A9       ; string to float exponent count
00202    
00203      00A8             numbit            = numexp    ; bit count for array element calculations
00204    
00205      00AA             numdpf            = $AA       ; string to float decimal point flag
00206      00AB             expneg            = $AB       ; string to float eval exponent -ve flag
00207    
00208      00AA             Astrtl            = numdpf    ; array start pointer low byte
00209      00AB             Astrth            = expneg    ; array start pointer high  byte
00210    
00211      00AA             Histrl            = numdpf    ; highest string low byte
00212      00AB             Histrh            = expneg    ; highest string high  byte
00213    
00214      00AA             Baslnl            = numdpf    ; BASIC search line pointer low byte
00215      00AB             Baslnh            = expneg    ; BASIC search line pointer high  byte
00216    
00217      00AA             Fvar_l            = numdpf    ; find/found variable pointer low byte
00218      00AB             Fvar_h            = expneg    ; find/found variable pointer high  byte
00219    
00220      00AA             Ostrtl            = numdpf    ; old block start pointer low byte
00221      00AB             Ostrth            = expneg    ; old block start pointer high  byte
00222    
00223      00AA             Vrschl            = numdpf    ; variable search pointer low byte
00224      00AB             Vrschh            = expneg    ; variable search pointer high  byte
00225    
00226      00AC             FAC1_e            = $AC       ; FAC1 exponent
00227      00AD             FAC1_1            = FAC1_e+1  ; FAC1 mantissa1
00228      00AE             FAC1_2            = FAC1_e+2  ; FAC1 mantissa2
00229      00AF             FAC1_3            = FAC1_e+3  ; FAC1 mantissa3
00230      00B0             FAC1_s            = FAC1_e+4  ; FAC1 sign (b7)
00231    
00232      00AC             str_ln            = FAC1_e    ; string length
00233      00AD             str_pl            = FAC1_1    ; string pointer low byte
00234      00AE             str_ph            = FAC1_2    ; string pointer high byte
00235    
00236      00AE             des_pl            = FAC1_2    ; string descriptor pointer low byte
00237      00AF             des_ph            = FAC1_3    ; string descriptor pointer high byte
00238    
00239      00AF             mids_l            = FAC1_3    ; MID$ string temp length byte
00240    
00241      00B1             negnum            = $B1       ; string to float eval -ve flag
00242      00B1             numcon            = $B1       ; series evaluation constant count
00243    
00244      00B2             FAC1_o            = $B2       ; FAC1 overflow byte
00245    
00246      00B3             FAC2_e            = $B3       ; FAC2 exponent
00247      00B4             FAC2_1            = FAC2_e+1  ; FAC2 mantissa1
00248      00B5             FAC2_2            = FAC2_e+2  ; FAC2 mantissa2
00249      00B6             FAC2_3            = FAC2_e+3  ; FAC2 mantissa3
00250      00B7             FAC2_s            = FAC2_e+4  ; FAC2 sign (b7)
00251    
00252      00B8             FAC_sc            = $B8       ; FAC sign comparison, Acc#1 vs #2
00253      00B9             FAC1_r            = $B9       ; FAC1 rounding byte
00254    
00255      00B8             ssptr_l           = FAC_sc    ; string start pointer low byte
00256      00B9             ssptr_h           = FAC1_r    ; string start pointer high byte
00257    
00258      00B8             sdescr            = FAC_sc    ; string descriptor pointer
00259    
00260      00BA             csidx             = $BA       ; line crunch save index
00261      00BA             Asptl             = csidx     ; array size/pointer low byte
00262      00BB             Aspth             = $BB       ; array size/pointer high byte
00263    
00264      00BA             Btmpl             = Asptl     ; BASIC pointer temp low byte
00265      00BB             Btmph             = Aspth     ; BASIC pointer temp low byte
00266    
00267      00BA             Cptrl             = Asptl     ; BASIC pointer temp low byte
00268      00BB             Cptrh             = Aspth     ; BASIC pointer temp low byte
00269    
00270      00BA             Sendl             = Asptl     ; BASIC pointer temp low byte
00271      00BB             Sendh             = Aspth     ; BASIC pointer temp low byte
00272    
00273    ; the following locations are bulk initialized from LAB_2CEE at LAB_2D4E
00274      00BC             LAB_IGBY          = $BC       ; get next BASIC byte subroutine
00275    
00276      00C2             LAB_GBYT          = $C2       ; get current BASIC byte subroutine
00277      00C3             Bpntrl            = $C3       ; BASIC execute (get byte) pointer low byte
00278      00C4             Bpntrh            = Bpntrl+1  ; BASIC execute (get byte) pointer high byte
00279    
00280    ;                 = $D7       ; end of get BASIC char subroutine
00281    ; end bulk initialize from LAB_2CEE at LAB_2D4E
00282    
00283      00D8             Rbyte4            = $D8       ; extra PRNG byte
00284      00D9             Rbyte1            = Rbyte4+1  ; most significant PRNG byte
00285      00DA             Rbyte2            = Rbyte4+2  ; middle PRNG byte
00286      00DB             Rbyte3            = Rbyte4+3  ; least significant PRNG byte
00287    
00288      00DC             NmiBase           = $DC       ; NMI handler enabled/setup/triggered flags
00289                                  ; bit function
00290                                  ; === ========
00291                                  ; 7   interrupt enabled
00292                                  ; 6   interrupt setup
00293                                  ; 5   interrupt happened
00294    ;                 = $DD       ; NMI handler addr low byte
00295    ;                 = $DE       ; NMI handler addr high byte
00296      00DF             IrqBase           = $DF       ; IRQ handler enabled/setup/triggered flags
00297    ;                 = $E0       ; IRQ handler addr low byte
00298    ;                 = $E1       ; IRQ handler addr high byte
00299    
00300    ; *** removed unused comments for $DE-$E1
00301    
00302    ;                 = $E2       ; TPB card temporary location
00303    ;                 = $E3       ; TPB card temporary location
00304    ;                 = $E4       ; TAPE tempoaray location.
00305    ;                 = $E5       ; TAPE BlockLo
00306    ;                 = $E6       ; TAPE blockHi
00307    ;                 = $E7       ; TOE_MemptrLo low byte general purpose pointer
00308    ;                 = $E8       ; TOE_MemptrHi high byte general purpose pointer.
00309    ;                 = $E9       ; unused
00310    ;                 = $EA       ; unused
00311    ;                 = $EB       ; unused
00312    ;                 = $EC       ; unused
00313    ;                 = $ED       ; unused
00314    ;                 = $EE       ; unused
00315    
00316      00EF             Decss             = $EF       ; number to decimal string start
00317      00F0             Decssp1           = Decss+1   ; number to decimal string start
00318    
00319    ;                 = $FF       ; decimal string end
00320    
00321    ; token values needed for BASIC
00322    
00323    ; primary command tokens (can start a statement)
00324    
00325      0080             TK_END            = $80             ; END token
00326      0081             TK_FOR            = TK_END+1        ; FOR token
00327      0082             TK_NEXT           = TK_FOR+1        ; NEXT token
00328      0083             TK_DATA           = TK_NEXT+1       ; DATA token
00329      0084             TK_INPUT          = TK_DATA+1       ; INPUT token
00330      0085             TK_DIM            = TK_INPUT+1      ; DIM token
00331      0086             TK_READ           = TK_DIM+1        ; READ token
00332      0087             TK_LET            = TK_READ+1       ; LET token
00333      0088             TK_DEC            = TK_LET+1        ; DEC token
00334      0089             TK_GOTO           = TK_DEC+1        ; GOTO token
00335      008A             TK_RUN            = TK_GOTO+1       ; RUN token
00336      008B             TK_IF             = TK_RUN+1        ; IF token
00337      008C             TK_RESTORE        = TK_IF+1         ; RESTORE token
00338      008D             TK_GOSUB          = TK_RESTORE+1    ; GOSUB token
00339      008E             TK_RETIRQ         = TK_GOSUB+1      ; RETIRQ token
00340      008F             TK_RETNMI         = TK_RETIRQ+1     ; RETNMI token
00341      0090             TK_RETURN         = TK_RETNMI+1     ; RETURN token
00342      0091             TK_REM            = TK_RETURN+1     ; REM token
00343      0092             TK_STOP           = TK_REM+1        ; STOP token
00344      0093             TK_ON             = TK_STOP+1       ; ON token
00345      0094             TK_NULL           = TK_ON+1         ; NULL token
00346      0095             TK_INC            = TK_NULL+1       ; INC token
00347      0096             TK_WAIT           = TK_INC+1        ; WAIT token
00348      0097             TK_LOAD           = TK_WAIT+1       ; LOAD token
00349      0098             TK_SAVE           = TK_LOAD+1       ; SAVE token
00350      0099             TK_DEF            = TK_SAVE+1       ; DEF token
00351      009A             TK_POKE           = TK_DEF+1        ; POKE token
00352      009B             TK_DOKE           = TK_POKE+1       ; DOKE token
00353      009C             TK_CALL           = TK_DOKE+1       ; CALL token
00354      009D             TK_DO             = TK_CALL+1       ; DO token
00355      009E             TK_LOOP           = TK_DO+1         ; LOOP token
00356      009F             TK_PRINT          = TK_LOOP+1       ; PRINT token
00357      00A0             TK_CONT           = TK_PRINT+1      ; CONT token
00358      00A1             TK_LIST           = TK_CONT+1       ; LIST token
00359      00A2             TK_CLEAR          = TK_LIST+1       ; CLEAR token
00360      00A3             TK_NEW            = TK_CLEAR+1      ; NEW token
00361      00A4             TK_WIDTH          = TK_NEW+1        ; WIDTH token
00362      00A5             TK_GET            = TK_WIDTH+1      ; GET token
00363      00A6             TK_SWAP           = TK_GET+1        ; SWAP token
00364      00A7             TK_BITSET         = TK_SWAP+1       ; BITSET token
00365      00A8             TK_BITCLR         = TK_BITSET+1     ; BITCLR token
00366      00A9             TK_IRQ            = TK_BITCLR+1     ; IRQ token
00367      00AA             TK_NMI            = TK_IRQ+1        ; NMI token
00368    
00369    ; secondary command tokens, can't start a statement
00370    
00371      00AB             TK_TAB            = TK_NMI+1        ; TAB token
00372      00AC             TK_ELSE           = TK_TAB+1        ; ELSE token
00373      00AD             TK_TO             = TK_ELSE+1       ; TO token
00374      00AE             TK_FN             = TK_TO+1         ; FN token
00375      00AF             TK_SPC            = TK_FN+1         ; SPC token
00376      00B0             TK_THEN           = TK_SPC+1        ; THEN token
00377      00B1             TK_NOT            = TK_THEN+1       ; NOT token
00378      00B2             TK_STEP           = TK_NOT+1        ; STEP token
00379      00B3             TK_UNTIL          = TK_STEP+1       ; UNTIL token
00380      00B4             TK_WHILE          = TK_UNTIL+1      ; WHILE token
00381      00B5             TK_OFF            = TK_WHILE+1      ; OFF token
00382    
00383    ; opperator tokens
00384    
00385      00B6             TK_PLUS           = TK_OFF+1        ; + token
00386      00B7             TK_MINUS          = TK_PLUS+1       ; - token
00387      00B8             TK_MUL            = TK_MINUS+1      ; * token
00388      00B9             TK_DIV            = TK_MUL+1        ; / token
00389      00BA             TK_POWER          = TK_DIV+1        ; ^ token
00390      00BB             TK_AND            = TK_POWER+1      ; AND token
00391      00BC             TK_EOR            = TK_AND+1        ; EOR token
00392      00BD             TK_OR             = TK_EOR+1        ; OR token
00393      00BE             TK_RSHIFT         = TK_OR+1         ; RSHIFT token
00394      00BF             TK_LSHIFT         = TK_RSHIFT+1     ; LSHIFT token
00395      00C0             TK_GT             = TK_LSHIFT+1     ; > token
00396      00C1             TK_EQUAL          = TK_GT+1         ; = token
00397      00C2             TK_LT             = TK_EQUAL+1      ; < token
00398    
00399    ; functions tokens
00400    
00401      00C3             TK_SGN            = TK_LT+1         ; SGN token
00402      00C4             TK_INT            = TK_SGN+1        ; INT token
00403      00C5             TK_ABS            = TK_INT+1        ; ABS token
00404      00C6             TK_USR            = TK_ABS+1        ; USR token
00405      00C7             TK_FRE            = TK_USR+1        ; FRE token
00406      00C8             TK_POS            = TK_FRE+1        ; POS token
00407      00C9             TK_SQR            = TK_POS+1        ; SQR token
00408      00CA             TK_RND            = TK_SQR+1        ; RND token
00409      00CB             TK_LOG            = TK_RND+1        ; LOG token
00410      00CC             TK_EXP            = TK_LOG+1        ; EXP token
00411      00CD             TK_COS            = TK_EXP+1        ; COS token
00412      00CE             TK_SIN            = TK_COS+1        ; SIN token
00413      00CF             TK_TAN            = TK_SIN+1        ; TAN token
00414      00D0             TK_ATN            = TK_TAN+1        ; ATN token
00415      00D1             TK_PEEK           = TK_ATN+1        ; PEEK token
00416      00D2             TK_DEEK           = TK_PEEK+1       ; DEEK token
00417      00D3             TK_SADD           = TK_DEEK+1       ; SADD token
00418      00D4             TK_LEN            = TK_SADD+1       ; LEN token
00419      00D5             TK_STRS           = TK_LEN+1        ; STR$ token
00420      00D6             TK_VAL            = TK_STRS+1       ; VAL token
00421      00D7             TK_ASC            = TK_VAL+1        ; ASC token
00422      00D8             TK_UCASES         = TK_ASC+1        ; UCASE$ token
00423      00D9             TK_LCASES         = TK_UCASES+1     ; LCASE$ token
00424      00DA             TK_CHRS           = TK_LCASES+1     ; CHR$ token
00425      00DB             TK_HEXS           = TK_CHRS+1       ; HEX$ token
00426      00DC             TK_BINS           = TK_HEXS+1       ; BIN$ token
00427      00DD             TK_BITTST         = TK_BINS+1       ; BITTST token
00428      00DE             TK_MAX            = TK_BITTST+1     ; MAX token
00429      00DF             TK_MIN            = TK_MAX+1        ; MIN token
00430      00E0             TK_PI             = TK_MIN+1        ; PI token
00431      00E1             TK_TWOPI          = TK_PI+1         ; TWOPI token
00432      00E2             TK_VPTR           = TK_TWOPI+1      ; VARPTR token
00433      00E3             TK_LEFTS          = TK_VPTR+1       ; LEFT$ token
00434      00E4             TK_RIGHTS         = TK_LEFTS+1      ; RIGHT$ token
00435      00E5             TK_MIDS           = TK_RIGHTS+1     ; MID$ token
00436    
00437    ; offsets from a base of X or Y
00438    
00439      0000             PLUS_0            = $00       ; X or Y plus 0
00440      0001             PLUS_1            = $01       ; X or Y plus 1
00441      0002             PLUS_2            = $02       ; X or Y plus 2
00442      0003             PLUS_3            = $03       ; X or Y plus 3
00443    
00444      0100             LAB_STAK          = $0100     ; stack bottom, no offset
00445    
00446      01FE             LAB_SKFE          = LAB_STAK+$FE
00447                                  ; flushed stack address
00448      01FF             LAB_SKFF          = LAB_STAK+$FF
00449                                  ; flushed stack address
00450    
00451    ; the following locations are bulk initialized from PG2_TABS at LAB_COLD
00452      0200             ccflag            = $0200     ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
00453      0201             ccbyte            = ccflag+1  ; BASIC CTRL-C byte
00454      0202             ccnull            = ccbyte+1  ; BASIC CTRL-C byte timeout
00455    
00456      0203             VEC_CC            = ccnull+1  ; ctrl c check vector
00457    ; end bulk initialize from PG2_TABS at LAB_COLD
00458    
00459    ; the following locations are bulk initialized by min_mon.asm from LAB_vec at LAB_stlp
00460      0205             VEC_IN            = VEC_CC+2  ; input vector
00461      0207             VEC_OUT           = VEC_IN+2  ; output vector
00462      0209             VEC_LD            = VEC_OUT+2 ; load vector
00463      020B             VEC_SV            = VEC_LD+2  ; save vector
00464    ; end bulk initialize by min_mon.asm from LAB_vec at LAB_stlp
00465    
00466    ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
00467    ; the input buffer must not cross a page boundary and must not overlap with
00468    ; program RAM pages!
00469    
00470    ; FINDME
00471    ; $900-$AFF Allocated to the cassette file system.  This is probably generous.
00472    
00473    ;Ibuffs            = IRQ_vec+$14
00474      0B00             Ibuffs            = $B00       ; TODO: Create a method of allocation controlled from an
00475                                   ; external file
00476                                   ; start of input buffer after IRQ/NMI code
00477      0B7F             Ibuffe            = Ibuffs+$7F ; end of input buffer
00478    
00479      0C00             Ram_base          = $0C00      ; start of user RAM (set as needed, should be page aligned)
00480      C000             Ram_top           = $C000      ; end of user RAM+1 (set as needed, should be page aligned)
00481    
00482      0010             Stack_floor       = 16         ; bytes left free on stack for background interrupts
00483    
00484    ; This start can be changed to suit your system
00485    
00486    C100                     *=    $C100
00487    
00488    ; BASIC cold start entry point
00489    
00490    ; new page 2 initialisation, copy block to ccflag on
00491    
00492    LAB_COLD
00493    C100  A0 04              LDY   #PG2_TABE-PG2_TABS-1
00494                                  ; byte count-1
00495    LAB_2D13
00496    C102  B9 0B E2           LDA   PG2_TABS,Y        ; get byte
00497    C105  99 00 02           STA   ccflag,Y          ; store in page 2
00498    C108  88                 DEY                     ; decrement count
00499    C109  10 F7              BPL   LAB_2D13          ; loop if not done
00500    
00501    C10B  A2 FF              LDX   #$FF              ; set byte
00502    C10D  86 88              STX   Clineh            ; set current line high byte (set immediate mode)
00503    C10F  9A                 TXS                     ; reset stack pointer
00504    
00505    C110  A9 4C              LDA   #$4C              ; code for JMP
00506    C112  85 A1              STA   Fnxjmp            ; save for jump vector for functions
00507    
00508    ; copy block from LAB_2CEE to $00BC - $00D7
00509    
00510    C114  A2 1C              LDX   #StrTab-LAB_2CEE  ; set byte count
00511    LAB_2D4E
00512    C116  BD 0F E2           LDA   LAB_2CEE-1,X      ; get byte from table
00513    C119  95 BB              STA   LAB_IGBY-1,X      ; save byte in page zero
00514    C11B  CA                 DEX                     ; decrement count
00515    C11C  D0 F8              BNE   LAB_2D4E          ; loop if not all done
00516    
00517    ; copy block from StrTab to $0000 - $0012
00518    
00519    LAB_GMEM
00520    C11E  A2 12              LDX   #EndTab-StrTab-1  ; set byte count-1
00521    TabLoop
00522    C120  BD 2C E2           LDA   StrTab,X          ; get byte from table
00523    C123  95 00              STA   PLUS_0,X          ; save byte in page zero
00524    C125  CA                 DEX                     ; decrement count
00525    C126  10 F8              BPL   TabLoop           ; loop if not all done
00526    
00527    ; set-up start values
00528    
00529    C128  A9 00              LDA   #$00              ; clear A
00530    C12A  85 DC              STA   NmiBase           ; clear NMI handler enabled flag
00531    C12C  85 DF              STA   IrqBase           ; clear IRQ handler enabled flag
00532    C12E  85 B2              STA   FAC1_o            ; clear FAC1 overflow byte
00533    C130  85 67              STA   last_sh           ; clear descriptor stack top item pointer high byte
00534    
00535    C132  A9 0E              LDA   #$0E              ; set default tab size
00536    C134  85 64              STA   TabSiz            ; save it
00537    C136  A9 03              LDA   #$03              ; set garbage collect step size for descriptor stack
00538    C138  85 A0              STA   g_step            ; save it
00539    C13A  A2 68              LDX   #des_sk           ; descriptor stack start
00540    C13C  86 65              STX   next_s            ; set descriptor stack pointer
00541    C13E  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
00542    C141  A9 3F              LDA   #<LAB_MSZM        ; point to memory size message (low addr)
00543    C143  A0 E2              LDY   #>LAB_MSZM        ; point to memory size message (high addr)
00544    C145  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00545    C148  20 43 C3           JSR   LAB_INLN          ; print "? " and get BASIC input
00546    C14B  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00547    C14D  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00548    C14F  20 C2 00           JSR   LAB_GBYT          ; get last byte back
00549    
00550    C152  D0 1F              BNE   LAB_2DAA          ; branch if not null (user typed something)
00551    
00552    C154  A0 00              LDY   #$00              ; else clear Y
00553                                  ; character was null so get memory size the hard way
00554                                  ; we get here with Y=0 and Itempl/h = Ram_base
00555    LAB_2D93
00556    C156  E6 11              INC   Itempl            ; increment temporary integer low byte
00557    C158  D0 08              BNE   LAB_2D99          ; branch if no overflow
00558    
00559    C15A  E6 12              INC   Itemph            ; increment temporary integer high byte
00560    C15C  A5 12              LDA   Itemph            ; get high byte
00561    C15E  C9 C0              CMP   #>Ram_top         ; compare with top of RAM+1
00562    C160  F0 1D              BEQ   LAB_2DB6          ; branch if match (end of user RAM)
00563    
00564    LAB_2D99
00565    C162  A9 55              LDA   #$55              ; set test byte
00566    C164  91 11              STA   (Itempl),Y        ; save via temporary integer
00567    C166  D1 11              CMP   (Itempl),Y        ; compare via temporary integer
00568    C168  D0 15              BNE   LAB_2DB6          ; branch if fail
00569    
00570    C16A  0A                 ASL                     ; shift test byte left (now $AA)
00571    C16B  91 11              STA   (Itempl),Y        ; save via temporary integer
00572    C16D  D1 11              CMP   (Itempl),Y        ; compare via temporary integer
00573    C16F  F0 E5              BEQ   LAB_2D93          ; if ok go do next byte
00574    
00575    C171  D0 0C              BNE   LAB_2DB6          ; branch if fail
00576    
00577    LAB_2DAA
00578    C173  20 B9 DA           JSR   LAB_2887          ; get FAC1 from string
00579    C176  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00580    C178  C9 98              CMP   #$98              ; compare with exponent = 2^24
00581    C17A  B0 A2              BCS   LAB_GMEM          ; if too large go try again
00582    
00583    C17C  20 0A D6           JSR   LAB_F2FU          ; save integer part of FAC1 in temporary integer
00584                                  ; (no range check)
00585    
00586    LAB_2DB6
00587    C17F  A5 11              LDA   Itempl            ; get temporary integer low byte
00588    C181  A4 12              LDY   Itemph            ; get temporary integer high byte
00589    ; *** begin patch  2.22p5.0 RAM top sanity check ***
00590    ; *** replace
00591    ;      CPY   #<Ram_base+1      ; compare with start of RAM+$100 high byte
00592    ; +++ with
00593    C183  C0 0D              CPY   #>Ram_base+1      ; compare with start of RAM+$100 high byte
00594    ; *** end patch    2.22p5.0 ***
00595    C185  90 97              BCC   LAB_GMEM          ; if too small go try again
00596    
00597    
00598    ; uncomment these lines if you want to check on the high limit of memory. Note if
00599    ; Ram_top is set too low then this will fail. default is ignore it and assume the
00600    ; users know what they're doing!
00601    
00602    ;     CPY   #>Ram_top         ; compare with top of RAM high byte
00603    ;     BCC   MEM_OK            ; branch if < RAM top
00604    
00605    ;     BNE   LAB_GMEM          ; if too large go try again
00606                                  ; else was = so compare low bytes
00607    ;     CMP   #<Ram_top         ; compare with top of RAM low byte
00608    ;     BEQ   MEM_OK            ; branch if = RAM top
00609    
00610    ;     BCS   LAB_GMEM          ; if too large go try again
00611    
00612    ;MEM_OK
00613    C187  85 85              STA   Ememl             ; set end of mem low byte
00614    C189  84 86              STY   Ememh             ; set end of mem high byte
00615    C18B  85 81              STA   Sstorl            ; set bottom of string space low byte
00616    C18D  84 82              STY   Sstorh            ; set bottom of string space high byte
00617    
00618    C18F  A0 00              LDY   #<Ram_base        ; set start addr low byte
00619    C191  A2 0C              LDX   #>Ram_base        ; set start addr high byte
00620    C193  84 79              STY   Smeml             ; save start of mem low byte
00621    C195  86 7A              STX   Smemh             ; save start of mem high byte
00622    
00623    ; this line is only needed if Ram_base is not $xx00
00624          .IF   Ram_base&$FF>0
00625    
00626    C197  98                 TYA                     ; clear A
00627    C198  91 79              STA   (Smeml),Y         ; clear first byte
00628    C19A  E6 79              INC   Smeml             ; increment start of mem low byte
00629    
00630    ; these two lines are only needed if Ram_base is $xxFF
00631          .IF   Ram_base&$FF==$FF
00632    
00633    C19C  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
00634    C19F  20 59 C4           JSR   LAB_1463          ; do "NEW" and "CLEAR"
00635    C1A2  A5 85              LDA   Ememl             ; get end of mem low byte
00636    C1A4  38                 SEC                     ; set carry for subtract
00637    C1A5  E5 79              SBC   Smeml             ; subtract start of mem low byte
00638    C1A7  AA                 TAX                     ; copy to X
00639    C1A8  A5 86              LDA   Ememh             ; get end of mem high byte
00640    C1AA  E5 7A              SBC   Smemh             ; subtract start of mem high byte
00641    C1AC  20 95 DB           JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
00642    C1AF  A9 4E              LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
00643    C1B1  A0 E2              LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
00644    C1B3  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00645    C1B6  A9 5D              LDA   #<LAB_1274        ; warm start vector low byte
00646    C1B8  A0 C2              LDY   #>LAB_1274        ; warm start vector high byte
00647    C1BA  85 01              STA   Wrmjpl            ; save warm start vector low byte
00648    C1BC  84 02              STY   Wrmjph            ; save warm start vector high byte
00649    C1BE  6C 01 00           JMP   (Wrmjpl)          ; go do warm start
00650    
00651    ; open up space in memory
00652    ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00653    
00654    ; Nbendl,Nbendh - new block end address (A/Y)
00655    ; Obendl,Obendh - old block end address
00656    ; Ostrtl,Ostrth - old block start address
00657    
00658    ; returns with ..
00659    
00660    ; Nbendl,Nbendh - new block start address (high byte - $100)
00661    ; Obendl,Obendh - old block start address (high byte - $100)
00662    ; Ostrtl,Ostrth - old block start address (unchanged)
00663    
00664    LAB_11CF
00665    C1C1  20 0E C2           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
00666                                  ; addr to check is in AY (low/high)
00667    C1C4  85 7F              STA   Earryl            ; save new array mem end low byte
00668    C1C6  84 80              STY   Earryh            ; save new array mem end high byte
00669    
00670    ; open up space in memory
00671    ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00672    ; don't set array end
00673    
00674    LAB_11D6
00675    C1C8  38                 SEC                     ; set carry for subtract
00676    C1C9  A5 A6              LDA   Obendl            ; get block end low byte
00677    C1CB  E5 AA              SBC   Ostrtl            ; subtract block start low byte
00678    C1CD  A8                 TAY                     ; copy MOD(block length/$100) byte to Y
00679    C1CE  A5 A7              LDA   Obendh            ; get block end high byte
00680    C1D0  E5 AB              SBC   Ostrth            ; subtract block start high byte
00681    C1D2  AA                 TAX                     ; copy block length high byte to X
00682    C1D3  E8                 INX                     ; +1 to allow for count=0 exit
00683    C1D4  98                 TYA                     ; copy block length low byte to A
00684    C1D5  F0 24              BEQ   LAB_120A          ; branch if length low byte=0
00685    
00686                                  ; block is (X-1)*256+Y bytes, do the Y bytes first
00687    
00688    C1D7  38                 SEC                     ; set carry for add + 1, two's complement
00689    C1D8  49 FF              EOR   #$FF              ; invert low byte for subtract
00690    C1DA  65 A6              ADC   Obendl            ; add block end low byte
00691    
00692    C1DC  85 A6              STA   Obendl            ; save corrected old block end low byte
00693    C1DE  B0 03              BCS   LAB_11F3          ; branch if no underflow
00694    
00695    C1E0  C6 A7              DEC   Obendh            ; else decrement block end high byte
00696    C1E2  38                 SEC                     ; set carry for add + 1, two's complement
00697    LAB_11F3
00698    C1E3  98                 TYA                     ; get MOD(block length/$100) byte
00699    C1E4  49 FF              EOR   #$FF              ; invert low byte for subtract
00700    C1E6  65 A4              ADC   Nbendl            ; add destination end low byte
00701    C1E8  85 A4              STA   Nbendl            ; save modified new block end low byte
00702    C1EA  B0 08              BCS   LAB_1203          ; branch if no underflow
00703    
00704    C1EC  C6 A5              DEC   Nbendh            ; else decrement block end high byte
00705    C1EE  90 04              BCC   LAB_1203          ; branch always
00706    
00707    LAB_11FF
00708    C1F0  B1 A6              LDA   (Obendl),Y        ; get byte from source
00709    C1F2  91 A4              STA   (Nbendl),Y        ; copy byte to destination
00710    LAB_1203
00711    C1F4  88                 DEY                     ; decrement index
00712    C1F5  D0 F9              BNE   LAB_11FF          ; loop until Y=0
00713    
00714                                  ; now do Y=0 indexed byte
00715    C1F7  B1 A6              LDA   (Obendl),Y        ; get byte from source
00716    C1F9  91 A4              STA   (Nbendl),Y        ; save byte to destination
00717    LAB_120A
00718    C1FB  C6 A7              DEC   Obendh            ; decrement source pointer high byte
00719    C1FD  C6 A5              DEC   Nbendh            ; decrement destination pointer high byte
00720    C1FF  CA                 DEX                     ; decrement block count
00721    C200  D0 F2              BNE   LAB_1203          ; loop until count = $0
00722    
00723    C202  60                 RTS
00724    
00725    ; check room on stack for A bytes
00726    ; stack too deep? do OM error
00727    
00728    LAB_1212
00729    ; *** patch - additional stack floor protection for background interrupts
00730    ; *** add
00731          .IF   Stack_floor
00732    C203  18                 CLC                     ; prep ADC
00733    C204  69 10              ADC   #Stack_floor      ; stack pointer lower limit before interrupts
00734          .ENDIF
00735    ; *** end patch
00736    C206  85 78              STA   TempB             ; save result in temp byte
00737    C208  BA                 TSX                     ; copy stack
00738    C209  E4 78              CPX   TempB             ; compare new "limit" with stack
00739    C20B  90 30              BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
00740    
00741    C20D  60                 RTS
00742    
00743    ; check available memory, "Out of memory" error if no room
00744    ; addr to check is in AY (low/high)
00745    
00746    LAB_121F
00747    C20E  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
00748    C210  90 2A              BCC   LAB_124B          ; if less then exit (is ok)
00749    
00750    C212  D0 04              BNE   LAB_1229          ; skip next test if greater (tested <)
00751    
00752                                  ; high byte was =, now do low byte
00753    C214  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
00754    C216  90 24              BCC   LAB_124B          ; if less then exit (is ok)
00755    
00756                                  ; addr is > string storage ptr (oops!)
00757    LAB_1229
00758    C218  48                 PHA                     ; push addr low byte
00759    C219  A2 08              LDX   #$08              ; set index to save Adatal to expneg inclusive
00760    C21B  98                 TYA                     ; copy addr high byte (to push on stack)
00761    
00762                                  ; save misc numeric work area
00763    LAB_122D
00764    C21C  48                 PHA                     ; push byte
00765    C21D  B5 A3              LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
00766    C21F  CA                 DEX                     ; decrement index
00767    C220  10 FA              BPL   LAB_122D          ; loop until all done
00768    
00769    C222  20 F5 D2           JSR   LAB_GARB          ; garbage collection routine
00770    
00771                                  ; restore misc numeric work area
00772    C225  A2 00              LDX   #$00              ; clear the index to restore bytes
00773    LAB_1238
00774    C227  68                 PLA                     ; pop byte
00775    C228  95 A4              STA   Adatal,X          ; save byte to Adatal to expneg
00776    C22A  E8                 INX                     ; increment index
00777    C22B  E0 08              CPX   #$08              ; compare with end + 1
00778    C22D  30 F8              BMI   LAB_1238          ; loop if more to do
00779    
00780    C22F  68                 PLA                     ; pop addr high byte
00781    C230  A8                 TAY                     ; copy back to Y
00782    C231  68                 PLA                     ; pop addr low byte
00783    C232  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
00784    C234  90 06              BCC   LAB_124B          ; if less then exit (is ok)
00785    
00786    C236  D0 05              BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
00787    
00788                                  ; high byte was =, now do low byte
00789    C238  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
00790    C23A  B0 01              BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
00791    
00792                                  ; ok exit, carry clear
00793    LAB_124B
00794    C23C  60                 RTS
00795    
00796    ; do "Out of memory" error then warm start
00797    
00798    LAB_OMER
00799    C23D  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
00800    
00801    ; do error #X, then warm start
00802    
00803    LAB_XERR
00804    C23F  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
00805    
00806    C242  BD C0 E7           LDA   LAB_BAER,X        ; get error message pointer low byte
00807    C245  BC C1 E7           LDY   LAB_BAER+1,X      ; get error message pointer high byte
00808    C248  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00809    
00810    C24B  20 92 C4           JSR   LAB_1491          ; flush stack and clear continue flag
00811    C24E  A9 FD              LDA   #<LAB_EMSG        ; point to " Error" low addr
00812    C250  A0 E8              LDY   #>LAB_EMSG        ; point to " Error" high addr
00813    LAB_1269
00814    C252  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00815    C255  A4 88              LDY   Clineh            ; get current line high byte
00816    C257  C8                 INY                     ; increment it
00817    C258  F0 03              BEQ   LAB_1274          ; go do warm start (was immediate mode)
00818    
00819                                  ; else print line number
00820    C25A  20 8A DB           JSR   LAB_2953          ; print " in line [LINE #]"
00821    
00822    ; BASIC warm start entry point
00823    ; wait for Basic command
00824    
00825    LAB_1274
00826                                  ; clear ON IRQ/NMI bytes
00827    C25D  A9 00              LDA   #$00              ; clear A
00828    C25F  85 DF              STA   IrqBase           ; clear enabled byte
00829    C261  85 DC              STA   NmiBase           ; clear enabled byte
00830    C263  A9 0E              LDA   #<LAB_RMSG        ; point to "Ready" message low byte
00831    C265  A0 E9              LDY   #>LAB_RMSG        ; point to "Ready" message high byte
00832    
00833    C267  20 DA C9           JSR   LAB_18C3          ; go do print string
00834    
00835    ; wait for Basic command (no "Ready")
00836    
00837    LAB_127D
00838    C26A  20 50 C3           JSR   LAB_1357          ; call for BASIC input
00839    LAB_1280
00840    C26D  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00841    C26F  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00842    C271  20 C2 00           JSR   LAB_GBYT          ; scan memory
00843    C274  F0 F4              BEQ   LAB_127D          ; loop while null
00844    
00845    ; got to interpret input line now ..
00846    
00847    C276  A2 FF              LDX   #$FF              ; current line to null value
00848    C278  86 88              STX   Clineh            ; set current line high byte
00849    C27A  90 06              BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
00850    
00851                                  ; no line number .. immediate mode
00852    C27C  20 81 C3           JSR   LAB_13A6          ; crunch keywords into Basic tokens
00853    C27F  4C FB C5           JMP   LAB_15F6          ; go scan and interpret code
00854    
00855    ; handle new BASIC line
00856    
00857    LAB_1295
00858    C282  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00859    C285  20 81 C3           JSR   LAB_13A6          ; crunch keywords into Basic tokens
00860    C288  84 5D              STY   Ibptr             ; save index pointer to end of crunched line
00861    C28A  20 2D C4           JSR   LAB_SSLN          ; search BASIC for temp integer line number
00862    C28D  90 44              BCC   LAB_12E6          ; branch if not found
00863    
00864                                  ; aroooogah! line # already exists! delete it
00865    C28F  A0 01              LDY   #$01              ; set index to next line pointer high byte
00866    C291  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
00867    C293  85 72              STA   ut1_ph            ; save it
00868    C295  A5 7B              LDA   Svarl             ; get start of vars low byte
00869    C297  85 71              STA   ut1_pl            ; save it
00870    C299  A5 AB              LDA   Baslnh            ; get found line pointer high byte
00871    C29B  85 74              STA   ut2_ph            ; save it
00872    C29D  A5 AA              LDA   Baslnl            ; get found line pointer low byte
00873    C29F  88                 DEY                     ; decrement index
00874    C2A0  F1 AA              SBC   (Baslnl),Y        ; subtract next line pointer low byte
00875    C2A2  18                 CLC                     ; clear carry for add
00876    C2A3  65 7B              ADC   Svarl             ; add start of vars low byte
00877    C2A5  85 7B              STA   Svarl             ; save new start of vars low byte
00878    C2A7  85 73              STA   ut2_pl            ; save destination pointer low byte
00879    C2A9  A5 7C              LDA   Svarh             ; get start of vars high byte
00880    C2AB  69 FF              ADC   #$FF              ; -1 + carry
00881    C2AD  85 7C              STA   Svarh             ; save start of vars high byte
00882    C2AF  E5 AB              SBC   Baslnh            ; subtract found line pointer high byte
00883    C2B1  AA                 TAX                     ; copy to block count
00884    C2B2  38                 SEC                     ; set carry for subtract
00885    C2B3  A5 AA              LDA   Baslnl            ; get found line pointer low byte
00886    C2B5  E5 7B              SBC   Svarl             ; subtract start of vars low byte
00887    C2B7  A8                 TAY                     ; copy to bytes in first block count
00888    C2B8  B0 03              BCS   LAB_12D0          ; branch if overflow
00889    
00890    C2BA  E8                 INX                     ; increment block count (correct for =0 loop exit)
00891    C2BB  C6 74              DEC   ut2_ph            ; decrement destination high byte
00892    LAB_12D0
00893    C2BD  18                 CLC                     ; clear carry for add
00894    C2BE  65 71              ADC   ut1_pl            ; add source pointer low byte
00895    C2C0  90 03              BCC   LAB_12D8          ; branch if no overflow
00896    
00897    C2C2  C6 72              DEC   ut1_ph            ; else decrement source pointer high byte
00898    C2C4  18                 CLC                     ; clear carry
00899    
00900                                  ; close up memory to delete old line
00901    LAB_12D8
00902    C2C5  B1 71              LDA   (ut1_pl),Y        ; get byte from source
00903    C2C7  91 73              STA   (ut2_pl),Y        ; copy to destination
00904    C2C9  C8                 INY                     ; increment index
00905    C2CA  D0 F9              BNE   LAB_12D8          ; while <> 0 do this block
00906    
00907    C2CC  E6 72              INC   ut1_ph            ; increment source pointer high byte
00908    C2CE  E6 74              INC   ut2_ph            ; increment destination pointer high byte
00909    C2D0  CA                 DEX                     ; decrement block count
00910    C2D1  D0 F2              BNE   LAB_12D8          ; loop until all done
00911    
00912                                  ; got new line in buffer and no existing same #
00913    LAB_12E6
00914    C2D3  AD 00 0B           LDA   Ibuffs            ; get byte from start of input buffer
00915    C2D6  F0 3F              BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
00916    
00917                                  ; got new line and it isn't empty line
00918    C2D8  A5 85              LDA   Ememl             ; get end of mem low byte
00919    C2DA  A4 86              LDY   Ememh             ; get end of mem high byte
00920    C2DC  85 81              STA   Sstorl            ; set bottom of string space low byte
00921    C2DE  84 82              STY   Sstorh            ; set bottom of string space high byte
00922    C2E0  A5 7B              LDA   Svarl             ; get start of vars low byte  (end of BASIC)
00923    C2E2  85 A6              STA   Obendl            ; save old block end low byte
00924    C2E4  A4 7C              LDY   Svarh             ; get start of vars high byte (end of BASIC)
00925    C2E6  84 A7              STY   Obendh            ; save old block end high byte
00926    C2E8  65 5D              ADC   Ibptr             ; add input buffer pointer    (also buffer length)
00927    C2EA  90 01              BCC   LAB_1301          ; branch if no overflow from add
00928    
00929    C2EC  C8                 INY                     ; else increment high byte
00930    LAB_1301
00931    C2ED  85 A4              STA   Nbendl            ; save new block end low byte (move to, low byte)
00932    C2EF  84 A5              STY   Nbendh            ; save new block end high byte
00933    C2F1  20 C1 C1           JSR   LAB_11CF          ; open up space in memory
00934                                  ; old start pointer Ostrtl,Ostrth set by the find line call
00935    C2F4  A5 7F              LDA   Earryl            ; get array mem end low byte
00936    C2F6  A4 80              LDY   Earryh            ; get array mem end high byte
00937    C2F8  85 7B              STA   Svarl             ; save start of vars low byte
00938    C2FA  84 7C              STY   Svarh             ; save start of vars high byte
00939    C2FC  A4 5D              LDY   Ibptr             ; get input buffer pointer    (also buffer length)
00940    C2FE  88                 DEY                     ; adjust for loop type
00941    LAB_1311
00942    C2FF  B9 FC 0A           LDA   Ibuffs-4,Y        ; get byte from crunched line
00943    C302  91 AA              STA   (Baslnl),Y        ; save it to program memory
00944    C304  88                 DEY                     ; decrement count
00945    C305  C0 03              CPY   #$03              ; compare with first byte-1
00946    C307  D0 F6              BNE   LAB_1311          ; continue while count <> 3
00947    
00948    C309  A5 12              LDA   Itemph            ; get line # high byte
00949    C30B  91 AA              STA   (Baslnl),Y        ; save it to program memory
00950    C30D  88                 DEY                     ; decrement count
00951    C30E  A5 11              LDA   Itempl            ; get line # low byte
00952    C310  91 AA              STA   (Baslnl),Y        ; save it to program memory
00953    C312  88                 DEY                     ; decrement count
00954    C313  A9 FF              LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
00955                                  ; byte then a zero already here would stop the chain rebuild
00956                                  ; as it would think it was the [EOT] marker.
00957    C315  91 AA              STA   (Baslnl),Y        ; save it to program memory
00958    
00959    LAB_1319
00960    C317  20 6E C4           JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
00961    C31A  A6 79              LDX   Smeml             ; get start of mem low byte
00962    C31C  A5 7A              LDA   Smemh             ; get start of mem high byte
00963    C31E  A0 01              LDY   #$01              ; index to high byte of next line pointer
00964    LAB_1325
00965    C320  86 71              STX   ut1_pl            ; set line start pointer low byte
00966    C322  85 72              STA   ut1_ph            ; set line start pointer high byte
00967    C324  B1 71              LDA   (ut1_pl),Y        ; get it
00968    C326  F0 18              BEQ   LAB_133E          ; exit if end of program
00969    
00970    ; rebuild chaining of Basic lines
00971    
00972    C328  A0 04              LDY   #$04              ; point to first code byte of line
00973                                  ; there is always 1 byte + [EOL] as null entries are deleted
00974    LAB_1330
00975    C32A  C8                 INY                     ; next code byte
00976    C32B  B1 71              LDA   (ut1_pl),Y        ; get byte
00977    C32D  D0 FB              BNE   LAB_1330          ; loop if not [EOL]
00978    
00979    C32F  38                 SEC                     ; set carry for add + 1
00980    C330  98                 TYA                     ; copy end index
00981    C331  65 71              ADC   ut1_pl            ; add to line start pointer low byte
00982    C333  AA                 TAX                     ; copy to X
00983    C334  A0 00              LDY   #$00              ; clear index, point to this line's next line pointer
00984    C336  91 71              STA   (ut1_pl),Y        ; set next line pointer low byte
00985    C338  98                 TYA                     ; clear A
00986    C339  65 72              ADC   ut1_ph            ; add line start pointer high byte + carry
00987    C33B  C8                 INY                     ; increment index to high byte
00988    C33C  91 71              STA   (ut1_pl),Y        ; save next line pointer low byte
00989    C33E  90 E0              BCC   LAB_1325          ; go do next line, branch always, carry clear
00990    
00991    
00992    LAB_133E
00993    C340  4C 6A C2           JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
00994    
00995    ; print "? " and get BASIC input
00996    
00997    LAB_INLN
00998    C343  20 F2 C9           JSR   LAB_18E3          ; print "?" character
00999    C346  20 EF C9           JSR   LAB_18E0          ; print " "
01000    C349  D0 05              BNE   LAB_1357          ; call for BASIC input and return
01001    
01002    ; receive line from keyboard
01003    
01004                                  ; $08 as delete key (BACKSPACE on standard keyboard)
01005    LAB_134B
01006    C34B  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01007    C34E  CA                 DEX                     ; decrement the buffer counter (delete)
01008          .byte $2C               ; make LDX into BIT abs
01009    
01010    ; call for BASIC input (main entry point)
01011    
01012    LAB_1357
01013    C350  A2 00              LDX   #$00              ; clear BASIC line buffer pointer
01014    LAB_1359
01015    C352  20 FF E1           JSR   V_INPT            ; call scan input device
01016    C355  90 FB              BCC   LAB_1359          ; loop if no byte
01017    
01018    C357  F0 F9              BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
01019    
01020    C359  C9 07              CMP   #$07              ; compare with [BELL]
01021    C35B  F0 10              BEQ   LAB_1378          ; branch if [BELL]
01022    
01023    C35D  C9 0D              CMP   #$0D              ; compare with [CR]
01024    C35F  F0 19              BEQ   LAB_1384          ; do CR/LF exit if [CR]
01025    
01026    C361  E0 00              CPX   #$00              ; compare pointer with $00
01027    C363  D0 04              BNE   LAB_1374          ; branch if not empty
01028    
01029    ; next two lines ignore any non print character and [SPACE] if input buffer empty
01030    
01031    C365  C9 21              CMP   #$21              ; compare with [SP]+1
01032    C367  90 E9              BCC   LAB_1359          ; if < ignore character
01033    
01034    LAB_1374
01035    C369  C9 08              CMP   #$08              ; compare with [BACKSPACE] (delete last character)
01036    C36B  F0 DE              BEQ   LAB_134B          ; go delete last character
01037    
01038    LAB_1378
01039    C36D  E0 7F              CPX   #Ibuffe-Ibuffs    ; compare character count with max
01040    C36F  B0 0C              BCS   LAB_138E          ; skip store and do [BELL] if buffer full
01041    
01042    C371  9D 00 0B           STA   Ibuffs,X          ; else store in buffer
01043    C374  E8                 INX                     ; increment pointer
01044    LAB_137F
01045    C375  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01046    C378  D0 D8              BNE   LAB_1359          ; always loop for next character
01047    
01048    LAB_1384
01049    C37A  4C 90 C9           JMP   LAB_1866          ; do CR/LF exit to BASIC
01050    
01051    ; announce buffer full
01052    
01053    LAB_138E
01054    C37D  A9 07              LDA   #$07              ; [BELL] character into A
01055    C37F  D0 F4              BNE   LAB_137F          ; go print the [BELL] but ignore input character
01056                                  ; branch always
01057    
01058    ; crunch keywords into Basic tokens
01059    ; position independent buffer version ..
01060    ; faster, dictionary search version ....
01061    
01062    LAB_13A6
01063    C381  A0 FF              LDY   #$FF              ; set save index (makes for easy math later)
01064    
01065    C383  38                 SEC                     ; set carry for subtract
01066    C384  A5 C3              LDA   Bpntrl            ; get basic execute pointer low byte
01067    C386  E9 00              SBC   #<Ibuffs          ; subtract input buffer start pointer
01068    C388  AA                 TAX                     ; copy result to X (index past line # if any)
01069    
01070    C389  86 60              STX   Oquote            ; clear open quote/DATA flag
01071    LAB_13AC
01072    C38B  BD 00 0B           LDA   Ibuffs,X          ; get byte from input buffer
01073    C38E  F0 51              BEQ   LAB_13EC          ; if null save byte then exit
01074    
01075    C390  C9 5F              CMP   #'_'              ; compare with "_"
01076    C392  B0 4D              BCS   LAB_13EC          ; if >= go save byte then continue crunching
01077    
01078    C394  C9 3C              CMP   #'<'              ; compare with "<"
01079    C396  B0 0E              BCS   LAB_13CC          ; if >= go crunch now
01080    
01081    C398  C9 30              CMP   #'0'              ; compare with "0"
01082    C39A  B0 45              BCS   LAB_13EC          ; if >= go save byte then continue crunching
01083    
01084    C39C  85 5C              STA   Scnquo            ; save buffer byte as search character
01085    C39E  C9 22              CMP   #$22              ; is it quote character?
01086    C3A0  F0 61              BEQ   LAB_1410          ; branch if so (copy quoted string)
01087    
01088    C3A2  C9 2A              CMP   #'*'              ; compare with "*"
01089    C3A4  90 3B              BCC   LAB_13EC          ; if < go save byte then continue crunching
01090    
01091                                  ; else crunch now
01092    LAB_13CC
01093    C3A6  24 60              BIT   Oquote            ; get open quote/DATA token flag
01094    C3A8  70 37              BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
01095                                  ; go save byte then continue crunching
01096    
01097    C3AA  86 78              STX   TempB             ; save buffer read index
01098    C3AC  84 BA              STY   csidx             ; copy buffer save index
01099    C3AE  A0 27              LDY   #<TAB_1STC        ; get keyword first character table low address
01100    C3B0  84 73              STY   ut2_pl            ; save pointer low byte
01101    C3B2  A0 E4              LDY   #>TAB_1STC        ; get keyword first character table high address
01102    C3B4  84 74              STY   ut2_ph            ; save pointer high byte
01103    C3B6  A0 00              LDY   #$00              ; clear table pointer
01104    
01105    LAB_13D0
01106    C3B8  D1 73              CMP   (ut2_pl),Y        ; compare with keyword first character table byte
01107    C3BA  F0 05              BEQ   LAB_13D1          ; go do word_table_chr if match
01108    
01109    C3BC  90 21              BCC   LAB_13EA          ; if < keyword first character table byte go restore
01110                                  ; Y and save to crunched
01111    
01112    C3BE  C8                 INY                     ; else increment pointer
01113    C3BF  D0 F7              BNE   LAB_13D0          ; and loop (branch always)
01114    
01115    ; have matched first character of some keyword
01116    
01117    LAB_13D1
01118    C3C1  98                 TYA                     ; copy matching index
01119    C3C2  0A                 ASL                     ; *2 (bytes per pointer)
01120    C3C3  AA                 TAX                     ; copy to new index
01121    C3C4  BD 45 E4           LDA   TAB_CHRT,X        ; get keyword table pointer low byte
01122    C3C7  85 73              STA   ut2_pl            ; save pointer low byte
01123    C3C9  BD 46 E4           LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
01124    C3CC  85 74              STA   ut2_ph            ; save pointer high byte
01125    
01126    C3CE  A0 FF              LDY   #$FF              ; clear table pointer (make -1 for start)
01127    
01128    C3D0  A6 78              LDX   TempB             ; restore buffer read index
01129    
01130    LAB_13D6
01131    C3D2  C8                 INY                     ; next table byte
01132    C3D3  B1 73              LDA   (ut2_pl),Y        ; get byte from table
01133    LAB_13D8
01134    C3D5  30 08              BMI   LAB_13EA          ; all bytes matched so go save token
01135    
01136    C3D7  E8                 INX                     ; next buffer byte
01137    C3D8  DD 00 0B           CMP   Ibuffs,X          ; compare with byte from input buffer
01138    C3DB  F0 F5              BEQ   LAB_13D6          ; go compare next if match
01139    
01140    C3DD  D0 2B              BNE   LAB_1417          ; branch if >< (not found keyword)
01141    
01142    LAB_13EA
01143    C3DF  A4 BA              LDY   csidx             ; restore save index
01144    
01145                                  ; save crunched to output
01146    LAB_13EC
01147    C3E1  E8                 INX                     ; increment buffer index (to next input byte)
01148    C3E2  C8                 INY                     ; increment save index (to next output byte)
01149    C3E3  99 00 0B           STA   Ibuffs,Y          ; save byte to output
01150    C3E6  C9 00              CMP   #$00              ; set the flags, set carry
01151    C3E8  F0 32              BEQ   LAB_142A          ; do exit if was null [EOL]
01152    
01153                                  ; A holds token or byte here
01154    C3EA  E9 3A              SBC   #':'              ; subtract ":" (carry set by CMP #00)
01155    C3EC  F0 04              BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
01156    
01157                                  ; A now holds token-$3A
01158    C3EE  C9 49              CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
01159    C3F0  D0 02              BNE   LAB_1401          ; branch if not DATA
01160    
01161                                  ; token was : or DATA
01162    LAB_13FF
01163    C3F2  85 60              STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
01164    LAB_1401
01165    C3F4  49 57              EOR   #TK_REM-$3A       ; effectively subtract REM token offset
01166    C3F6  D0 93              BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
01167    
01168    C3F8  85 5C              STA   Asrch             ; else was REM so set search for [EOL]
01169    
01170                                  ; loop for REM, "..." etc.
01171    LAB_1408
01172    C3FA  BD 00 0B           LDA   Ibuffs,X          ; get byte from input buffer
01173    C3FD  F0 E2              BEQ   LAB_13EC          ; branch if null [EOL]
01174    
01175    C3FF  C5 5C              CMP   Asrch             ; compare with stored character
01176    C401  F0 DE              BEQ   LAB_13EC          ; branch if match (end quote)
01177    
01178                                  ; entry for copy string in quotes, don't crunch
01179    LAB_1410
01180    C403  C8                 INY                     ; increment buffer save index
01181    C404  99 00 0B           STA   Ibuffs,Y          ; save byte to output
01182    C407  E8                 INX                     ; increment buffer read index
01183    C408  D0 F0              BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
01184    
01185                                  ; not found keyword this go
01186    LAB_1417
01187    C40A  A6 78              LDX   TempB             ; compare has failed, restore buffer index (start byte!)
01188    
01189                                  ; now find the end of this word in the table
01190    LAB_141B
01191    C40C  B1 73              LDA   (ut2_pl),Y        ; get table byte
01192    C40E  08                 PHP                     ; save status
01193    C40F  C8                 INY                     ; increment table index
01194    C410  28                 PLP                     ; restore byte status
01195    C411  10 F9              BPL   LAB_141B          ; if not end of keyword go do next
01196    
01197    C413  B1 73              LDA   (ut2_pl),Y        ; get byte from keyword table
01198    C415  D0 BE              BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
01199    
01200                                  ; reached end of table with no match
01201    C417  BD 00 0B           LDA   Ibuffs,X          ; restore byte from input buffer
01202    C41A  10 C3              BPL   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
01203                                  ; go save byte in output and continue crunching
01204    
01205                                  ; reached [EOL]
01206    LAB_142A
01207    C41C  C8                 INY                     ; increment pointer
01208    C41D  C8                 INY                     ; increment pointer (makes it next line pointer high byte)
01209    C41E  99 00 0B           STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
01210    C421  C8                 INY                     ; adjust for line copy
01211    C422  C8                 INY                     ; adjust for line copy
01212    C423  C8                 INY                     ; adjust for line copy
01213    ; *** begin patch for when Ibuffs is $xx00 - Daryl Rictor ***
01214    ; *** insert
01215          .IF   Ibuffs&$FF==0
01216    C424  A5 C3              LDA   Bpntrl            ; test for $00
01217    C426  D0 02              BNE   LAB_142P          ; not $00
01218    C428  C6 C4              DEC   Bpntrh            ; allow for increment when $xx00
01219    LAB_142P
01220          .ENDIF
01221    ; *** end   patch for when Ibuffs is $xx00 - Daryl Rictor ***
01222    ; end of patch
01223    C42A  C6 C3              DEC   Bpntrl            ; allow for increment
01224    C42C  60                 RTS
01225    
01226    ; search Basic for temp integer line number from start of mem
01227    
01228    LAB_SSLN
01229    C42D  A5 79              LDA   Smeml             ; get start of mem low byte
01230    C42F  A6 7A              LDX   Smemh             ; get start of mem high byte
01231    
01232    ; search Basic for temp integer line number from AX
01233    ; returns carry set if found
01234    ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
01235    
01236    ; old 541 new 507
01237    
01238    LAB_SHLN
01239    C431  A0 01              LDY   #$01              ; set index
01240    C433  85 AA              STA   Baslnl            ; save low byte as current
01241    C435  86 AB              STX   Baslnh            ; save high byte as current
01242    C437  B1 AA              LDA   (Baslnl),Y        ; get pointer high byte from addr
01243    C439  F0 1A              BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
01244    
01245    C43B  A0 03              LDY   #$03              ; set index to line # high byte
01246    C43D  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
01247    C43F  88                 DEY                     ; decrement index (point to low byte)
01248    C440  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01249    C442  D0 04              BNE   LAB_1455          ; if <> skip low byte check
01250    
01251    C444  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
01252    C446  C5 11              CMP   Itempl            ; compare with temporary integer low byte
01253    LAB_1455
01254    C448  B0 09              BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
01255    
01256    LAB_1456
01257    C44A  88                 DEY                     ; decrement index to next line ptr high byte
01258    C44B  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
01259    C44D  AA                 TAX                     ; copy to X
01260    C44E  88                 DEY                     ; decrement index to next line ptr low byte
01261    C44F  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
01262    C451  90 DE              BCC   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
01263                                  ; (carry always clear)
01264    
01265    LAB_145E
01266    C453  F0 01              BEQ   LAB_1460          ; exit if temp = found line #, carry is set
01267    
01268    LAB_145F
01269    C455  18                 CLC                     ; clear found flag
01270    LAB_1460
01271    C456  60                 RTS
01272    
01273    ; perform NEW
01274    
01275    LAB_NEW
01276    C457  D0 FD              BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
01277    
01278    LAB_1463
01279    C459  A9 00              LDA   #$00              ; clear A
01280    C45B  A8                 TAY                     ; clear Y
01281    C45C  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, low byte
01282    C45E  C8                 INY                     ; increment index
01283    C45F  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, high byte
01284    C461  18                 CLC                     ; clear carry
01285    C462  A5 79              LDA   Smeml             ; get start of mem low byte
01286    C464  69 02              ADC   #$02              ; calculate end of BASIC low byte
01287    C466  85 7B              STA   Svarl             ; save start of vars low byte
01288    C468  A5 7A              LDA   Smemh             ; get start of mem high byte
01289    C46A  69 00              ADC   #$00              ; add any carry
01290    C46C  85 7C              STA   Svarh             ; save start of vars high byte
01291    
01292    ; reset execution to start, clear vars and flush stack
01293    
01294    LAB_1477
01295    C46E  18                 CLC                     ; clear carry
01296    C46F  A5 79              LDA   Smeml             ; get start of mem low byte
01297    C471  69 FF              ADC   #$FF              ; -1
01298    C473  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01299    C475  A5 7A              LDA   Smemh             ; get start of mem high byte
01300    C477  69 FF              ADC   #$FF              ; -1+carry
01301    C479  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
01302    
01303    ; "CLEAR" command gets here
01304    
01305    LAB_147A
01306    C47B  A5 85              LDA   Ememl             ; get end of mem low byte
01307    C47D  A4 86              LDY   Ememh             ; get end of mem high byte
01308    C47F  85 81              STA   Sstorl            ; set bottom of string space low byte
01309    C481  84 82              STY   Sstorh            ; set bottom of string space high byte
01310    C483  A5 7B              LDA   Svarl             ; get start of vars low byte
01311    C485  A4 7C              LDY   Svarh             ; get start of vars high byte
01312    C487  85 7D              STA   Sarryl            ; save var mem end low byte
01313    C489  84 7E              STY   Sarryh            ; save var mem end high byte
01314    C48B  85 7F              STA   Earryl            ; save array mem end low byte
01315    C48D  84 80              STY   Earryh            ; save array mem end high byte
01316    C48F  20 46 C6           JSR   LAB_161A          ; perform RESTORE command
01317    
01318    ; flush stack and clear continue flag
01319    
01320    LAB_1491
01321    C492  A2 68              LDX   #des_sk           ; set descriptor stack pointer
01322    C494  86 65              STX   next_s            ; save descriptor stack pointer
01323    C496  68                 PLA                     ; pull return address low byte
01324    C497  AA                 TAX                     ; copy return address low byte
01325    C498  68                 PLA                     ; pull return address high byte
01326    C499  8E FE 01           STX   LAB_SKFE          ; save to cleared stack
01327    C49C  8D FF 01           STA   LAB_SKFF          ; save to cleared stack
01328    C49F  A2 FD              LDX   #$FD              ; new stack pointer
01329    C4A1  9A                 TXS                     ; reset stack
01330    C4A2  A9 00              LDA   #$00              ; clear byte
01331    ;*** fix p2: no longer necessary as the continue pointer is saved anyway
01332    ;      STA   Cpntrh            ; clear continue pointer high byte
01333    C4A4  85 61              STA   Sufnxf            ; clear subscript/FNX flag
01334    LAB_14A6
01335    C4A6  60                 RTS
01336    
01337    ; perform CLEAR
01338    
01339    LAB_CLEAR
01340    C4A7  F0 D2              BEQ   LAB_147A          ; if no following token go do "CLEAR"
01341    
01342                                  ; else there was a following token (go do syntax error)
01343    C4A9  60                 RTS
01344    
01345    ; perform LIST [n][-m]
01346    ; bigger, faster version (a _lot_ faster)
01347    
01348    LAB_LIST
01349    C4AA  90 06              BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
01350    
01351    C4AC  F0 04              BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
01352    
01353    C4AE  C9 B7              CMP   #TK_MINUS         ; compare with token for -
01354    C4B0  D0 F4              BNE   LAB_14A6          ; exit if not - (LIST -m)
01355    
01356                                  ; LIST [[n][-m]]
01357                                  ; this bit sets the n , if present, as the start and end
01358    LAB_14BD
01359    C4B2  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01360    C4B5  20 2D C4           JSR   LAB_SSLN          ; search BASIC for temp integer line number
01361                                  ; (pointer in Baslnl/Baslnh)
01362    C4B8  20 C2 00           JSR   LAB_GBYT          ; scan memory
01363    C4BB  F0 0C              BEQ   LAB_14D4          ; branch if no more characters
01364    
01365                                  ; this bit checks the - is present
01366    C4BD  C9 B7              CMP   #TK_MINUS         ; compare with token for -
01367    C4BF  D0 95              BNE   LAB_1460          ; return if not "-" (will be Syntax error)
01368    
01369                                  ; LIST [n]-m
01370                                  ; the - was there so set m as the end value
01371    C4C1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01372    C4C4  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01373    C4C7  D0 8D              BNE   LAB_1460          ; exit if not ok
01374    
01375    LAB_14D4
01376    C4C9  A5 11              LDA   Itempl            ; get temporary integer low byte
01377    C4CB  05 12              ORA   Itemph            ; OR temporary integer high byte
01378    C4CD  D0 06              BNE   LAB_14E2          ; branch if start set
01379    
01380    C4CF  A9 FF              LDA   #$FF              ; set for -1
01381    C4D1  85 11              STA   Itempl            ; set temporary integer low byte
01382    C4D3  85 12              STA   Itemph            ; set temporary integer high byte
01383    LAB_14E2
01384    C4D5  A0 01              LDY   #$01              ; set index for line
01385    C4D7  84 60              STY   Oquote            ; clear open quote flag
01386    C4D9  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
01387    C4DC  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
01388                                  ; pointer initially set by search at LAB_14BD
01389    C4DE  F0 3E              BEQ   LAB_152B          ; if null all done so exit
01390    C4E0  20 1C C6           JSR   LAB_1629          ; do CRTL-C check vector
01391    
01392    C4E3  C8                 INY                     ; increment index for line
01393    C4E4  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
01394    C4E6  AA                 TAX                     ; copy to X
01395    C4E7  C8                 INY                     ; increment index
01396    C4E8  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
01397    C4EA  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01398    C4EC  D0 04              BNE   LAB_14FF          ; branch if no high byte match
01399    
01400    C4EE  E4 11              CPX   Itempl            ; compare with temporary integer low byte
01401    C4F0  F0 02              BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
01402    
01403    LAB_14FF                      ; else ..
01404    C4F2  B0 2A              BCS   LAB_152B          ; if greater all done so exit
01405    
01406    LAB_1501
01407    C4F4  84 97              STY   Tidx1             ; save index for line
01408    C4F6  20 95 DB           JSR   LAB_295E          ; print XA as unsigned integer
01409    C4F9  A9 20              LDA   #$20              ; space is the next character
01410    LAB_1508
01411    C4FB  A4 97              LDY   Tidx1             ; get index for line
01412    C4FD  29 7F              AND   #$7F              ; mask top out bit of character
01413    LAB_150C
01414    C4FF  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01415    C502  C9 22              CMP   #$22              ; was it " character
01416    C504  D0 06              BNE   LAB_1519          ; branch if not
01417    
01418                                  ; we are either entering or leaving a pair of quotes
01419    C506  A5 60              LDA   Oquote            ; get open quote flag
01420    C508  49 FF              EOR   #$FF              ; toggle it
01421    C50A  85 60              STA   Oquote            ; save it back
01422    LAB_1519
01423    C50C  C8                 INY                     ; increment index
01424    C50D  B1 AA              LDA   (Baslnl),Y        ; get next byte
01425    C50F  D0 0E              BNE   LAB_152E          ; branch if not [EOL] (go print character)
01426    C511  A8                 TAY                     ; else clear index
01427    C512  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
01428    C514  AA                 TAX                     ; copy to X
01429    C515  C8                 INY                     ; increment index
01430    C516  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
01431    C518  86 AA              STX   Baslnl            ; set pointer to line low byte
01432    C51A  85 AB              STA   Baslnh            ; set pointer to line high byte
01433    C51C  D0 B7              BNE   LAB_14E2          ; go do next line if not [EOT]
01434                                  ; else ..
01435    LAB_152B
01436    C51E  60                 RTS
01437    
01438    LAB_152E
01439    C51F  10 DE              BPL   LAB_150C          ; just go print it if not token byte
01440    
01441                                  ; else was token byte so uncrunch it (maybe)
01442    C521  24 60              BIT   Oquote            ; test the open quote flag
01443    C523  30 DA              BMI   LAB_150C          ; just go print character if open quote set
01444    
01445    C525  A2 E6              LDX   #>LAB_KEYT        ; get table address high byte
01446    C527  0A                 ASL                     ; *2
01447    C528  0A                 ASL                     ; *4
01448    C529  90 02              BCC   LAB_152F          ; branch if no carry
01449    
01450    C52B  E8                 INX                     ; else increment high byte
01451    C52C  18                 CLC                     ; clear carry for add
01452    LAB_152F
01453    C52D  69 28              ADC   #<LAB_KEYT        ; add low byte
01454    C52F  90 01              BCC   LAB_1530          ; branch if no carry
01455    
01456    C531  E8                 INX                     ; else increment high byte
01457    LAB_1530
01458    C532  85 73              STA   ut2_pl            ; save table pointer low byte
01459    C534  86 74              STX   ut2_ph            ; save table pointer high byte
01460    C536  84 97              STY   Tidx1             ; save index for line
01461    C538  A0 00              LDY   #$00              ; clear index
01462    C53A  B1 73              LDA   (ut2_pl),Y        ; get length
01463    C53C  AA                 TAX                     ; copy length
01464    C53D  C8                 INY                     ; increment index
01465    C53E  B1 73              LDA   (ut2_pl),Y        ; get 1st character
01466    C540  CA                 DEX                     ; decrement length
01467    C541  F0 B8              BEQ   LAB_1508          ; if no more characters exit and print
01468    
01469    C543  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01470    C546  C8                 INY                     ; increment index
01471    C547  B1 73              LDA   (ut2_pl),Y        ; get keyword address low byte
01472    C549  48                 PHA                     ; save it for now
01473    C54A  C8                 INY                     ; increment index
01474    C54B  B1 73              LDA   (ut2_pl),Y        ; get keyword address high byte
01475    C54D  A0 00              LDY   #$00
01476    C54F  85 74              STA   ut2_ph            ; save keyword pointer high byte
01477    C551  68                 PLA                     ; pull low byte
01478    C552  85 73              STA   ut2_pl            ; save keyword pointer low byte
01479    LAB_1540
01480    C554  B1 73              LDA   (ut2_pl),Y        ; get character
01481    C556  CA                 DEX                     ; decrement character count
01482    C557  F0 A2              BEQ   LAB_1508          ; if last character exit and print
01483    
01484    C559  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01485    C55C  C8                 INY                     ; increment index
01486    C55D  D0 F5              BNE   LAB_1540          ; loop for next character
01487    
01488    ; perform FOR
01489    
01490    LAB_FOR
01491    C55F  A9 80              LDA   #$80              ; set FNX
01492    C561  85 61              STA   Sufnxf            ; set subscript/FNX flag
01493    C563  20 BB C8           JSR   LAB_LET           ; go do LET
01494    C566  68                 PLA                     ; pull return address
01495    C567  68                 PLA                     ; pull return address
01496    C568  A9 10              LDA   #$10              ; we need 16d bytes !
01497    C56A  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
01498    C56D  20 A1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
01499    C570  18                 CLC                     ; clear carry for add
01500    C571  98                 TYA                     ; copy index to A
01501    C572  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01502    C574  48                 PHA                     ; push onto stack
01503    C575  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
01504    C577  69 00              ADC   #$00              ; add carry
01505    C579  48                 PHA                     ; push onto stack
01506    C57A  A5 88              LDA   Clineh            ; get current line high byte
01507    C57C  48                 PHA                     ; push onto stack
01508    C57D  A5 87              LDA   Clinel            ; get current line low byte
01509    C57F  48                 PHA                     ; push onto stack
01510    C580  A9 AD              LDA   #TK_TO            ; get "TO" token
01511    C582  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
01512    C585  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
01513    C588  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
01514                                  ; else do type mismatch
01515    ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
01516    ; *** add
01517    C58B  20 EC D9           JSR   LAB_27BA          ; round FAC1
01518    ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
01519    C58E  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
01520    C590  09 7F              ORA   #$7F              ; set all non sign bits
01521    C592  25 AD              AND   FAC1_1            ; and FAC1 mantissa1
01522    C594  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
01523    C596  A9 A1              LDA   #<LAB_159F        ; set return address low byte
01524    C598  A0 C5              LDY   #>LAB_159F        ; set return address high byte
01525    C59A  85 71              STA   ut1_pl            ; save return address low byte
01526    C59C  84 72              STY   ut1_ph            ; save return address high byte
01527    C59E  4C 8D CC           JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
01528    
01529    LAB_159F
01530    C5A1  A9 F7              LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
01531    C5A3  A0 E2              LDY   #>LAB_259C        ; set 1 pointer high addr
01532    C5A5  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
01533    C5A8  20 C2 00           JSR   LAB_GBYT          ; scan memory
01534    C5AB  C9 B2              CMP   #TK_STEP          ; compare with STEP token
01535    C5AD  D0 06              BNE   LAB_15B3          ; jump if not "STEP"
01536    
01537                                  ;.was step so ..
01538    C5AF  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01539    C5B2  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
01540                                  ; else do type mismatch
01541    LAB_15B3
01542    C5B5  20 FC D9           JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
01543    C5B8  85 B0              STA   FAC1_s            ; set FAC1 sign (b7)
01544                                  ; this is +1 for +ve step and -1 for -ve step, in NEXT we
01545                                  ; compare the FOR value and the TO value and return +1 if
01546                                  ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
01547                                  ; here (+/-1) is then compared to that result and if they
01548                                  ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
01549                                  ; the loop is done
01550                                 
01551    ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
01552    ; *** add
01553       .IF [* & $FF] == $FD
01554    ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
01555    C5BA  20 7F CC           JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
01556    C5BD  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
01557    C5BF  48                 PHA                     ; push on stack
01558    C5C0  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
01559    C5C2  48                 PHA                     ; push on stack
01560    C5C3  A9 81              LDA   #TK_FOR           ; get FOR token
01561    C5C5  48                 PHA                     ; push on stack
01562    
01563    ; interpreter inner loop
01564    
01565    LAB_15C2
01566    C5C6  20 1C C6           JSR   LAB_1629          ; do CRTL-C check vector
01567    C5C9  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
01568    C5CB  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
01569    
01570    C5CD  A6 88              LDX   Clineh            ; continue line is $FFxx for immediate mode
01571                                  ; ($00xx for RUN from immediate mode)
01572    C5CF  E8                 INX                     ; increment it (now $00 if immediate mode)
01573    ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
01574    ;      BEQ   LAB_15D1          ; branch if null (immediate mode)
01575    
01576    C5D0  85 8B              STA   Cpntrl            ; save continue pointer low byte
01577    C5D2  84 8C              STY   Cpntrh            ; save continue pointer high byte
01578    LAB_15D1
01579    C5D4  A0 00              LDY   #$00              ; clear index
01580    C5D6  B1 C3              LDA   (Bpntrl),Y        ; get next byte
01581    C5D8  F0 07              BEQ   LAB_15DC          ; branch if null [EOL]
01582    
01583    C5DA  C9 3A              CMP   #':'              ; compare with ":"
01584    C5DC  F0 1D              BEQ   LAB_15F6          ; branch if = (statement separator)
01585    
01586    LAB_15D9
01587    C5DE  4C 08 CD           JMP   LAB_SNER          ; else syntax error then warm start
01588    
01589                                  ; have reached [EOL]
01590    LAB_15DC
01591    C5E1  A0 02              LDY   #$02              ; set index
01592    C5E3  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
01593    C5E5  18                 CLC                     ; clear carry for no "BREAK" message
01594    C5E6  F0 50              BEQ   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
01595                                  ; marker)
01596    
01597    C5E8  C8                 INY                     ; increment index
01598    C5E9  B1 C3              LDA   (Bpntrl),Y        ; get line # low byte
01599    C5EB  85 87              STA   Clinel            ; save current line low byte
01600    C5ED  C8                 INY                     ; increment index
01601    C5EE  B1 C3              LDA   (Bpntrl),Y        ; get line # high byte
01602    C5F0  85 88              STA   Clineh            ; save current line high byte
01603    C5F2  98                 TYA                     ; A now = 4
01604    C5F3  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01605    C5F5  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01606    C5F7  90 02              BCC   LAB_15F6          ; branch if no overflow
01607    
01608    C5F9  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
01609    LAB_15F6
01610    C5FB  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01611    
01612    LAB_15F9
01613    C5FE  20 04 C6           JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
01614    
01615    LAB_15FC
01616    C601  4C C6 C5           JMP   LAB_15C2          ; loop
01617    
01618    ; interpret BASIC code from (Bpntrl)
01619    
01620    LAB_15FF
01621    C604  F0 4E              BEQ   LAB_1628          ; exit if zero [EOL]
01622    
01623    LAB_1602
01624    C606  0A                 ASL                     ; *2 bytes per vector and normalise token
01625    C607  B0 03              BCS   LAB_1609          ; branch if was token
01626    
01627    C609  4C BB C8           JMP   LAB_LET           ; else go do implied LET
01628    
01629    LAB_1609
01630    C60C  C9 56              CMP   #[TK_TAB-$80]*2   ; compare normalised token * 2 with TAB
01631    C60E  B0 CE              BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
01632                                  ; only tokens before TAB can start a line
01633    C610  A8                 TAY                     ; copy to index
01634    C611  B9 1F E3           LDA   LAB_CTBL+1,Y      ; get vector high byte
01635    C614  48                 PHA                     ; onto stack
01636    C615  B9 1E E3           LDA   LAB_CTBL,Y        ; get vector low byte
01637    C618  48                 PHA                     ; onto stack
01638    C619  4C BC 00           JMP   LAB_IGBY          ; jump to increment and scan memory
01639                                  ; then "return" to vector
01640    
01641    ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
01642    ; key press is detected.
01643    
01644    LAB_1629
01645    C61C  6C 03 02           JMP   (VEC_CC)          ; ctrl c check vector
01646    
01647    ; if there was a key press it gets back here ..
01648    
01649    LAB_1636
01650    C61F  C9 03              CMP   #$03              ; compare with CTRL-C
01651    
01652    ; perform STOP
01653    
01654    LAB_STOP
01655    C621  B0 01              BCS   LAB_163B          ; branch if token follows STOP
01656                                  ; else just END
01657    ; END
01658    
01659    LAB_END
01660    C623  18                 CLC                     ; clear the carry, indicate a normal program end
01661    LAB_163B
01662    C624  D0 61              BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
01663    
01664    C626  A5 C4              LDA   Bpntrh            ; get the BASIC execute pointer high byte
01665    ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
01666    ;      EOR   #>Ibuffs          ; compare with buffer address high byte (Cb unchanged)
01667    ;      BEQ   LAB_164F          ; branch if the BASIC pointer is in the input buffer
01668    ;                              ; (can't continue in immediate mode)
01669    ;                              ; else ..
01670    ;      EOR   #>Ibuffs          ; correct the bits
01671    C628  A4 C3              LDY   Bpntrl            ; get BASIC execute pointer low byte
01672    C62A  84 8B              STY   Cpntrl            ; save continue pointer low byte
01673    C62C  85 8C              STA   Cpntrh            ; save continue pointer high byte
01674    LAB_1647
01675    C62E  A5 87              LDA   Clinel            ; get current line low byte
01676    C630  A4 88              LDY   Clineh            ; get current line high byte
01677    C632  85 89              STA   Blinel            ; save break line low byte
01678    C634  84 8A              STY   Blineh            ; save break line high byte
01679    LAB_164F
01680    C636  68                 PLA                     ; pull return address low
01681    C637  68                 PLA                     ; pull return address high
01682    LAB_1651
01683    C638  90 07              BCC   LAB_165E          ; if was program end just do warm start
01684    
01685                                  ; else ..
01686    C63A  A9 F5              LDA   #<LAB_BMSG        ; point to "Break" low byte
01687    C63C  A0 E8              LDY   #>LAB_BMSG        ; point to "Break" high byte
01688    C63E  4C 52 C2           JMP   LAB_1269          ; print "Break" and do warm start
01689    
01690    LAB_165E
01691    C641  4C 5D C2           JMP   LAB_1274          ; go do warm start
01692    
01693    ; perform RESTORE
01694    
01695    LAB_RESTORE
01696    C644  D0 0F              BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
01697    
01698    LAB_161A
01699    C646  38                 SEC                     ; set carry for subtract
01700    C647  A5 79              LDA   Smeml             ; get start of mem low byte
01701    C649  E9 01              SBC   #$01              ; -1
01702    C64B  A4 7A              LDY   Smemh             ; get start of mem high byte
01703    C64D  B0 01              BCS   LAB_1624          ; branch if no underflow
01704    
01705    LAB_uflow
01706    C64F  88                 DEY                     ; else decrement high byte
01707    LAB_1624
01708    C650  85 8F              STA   Dptrl             ; save DATA pointer low byte
01709    C652  84 90              STY   Dptrh             ; save DATA pointer high byte
01710    LAB_1628
01711    C654  60                 RTS
01712    
01713                                  ; is RESTORE n
01714    LAB_RESTOREn
01715    C655  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01716    C658  20 A4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
01717    C65B  A5 88              LDA   Clineh            ; get current line high byte
01718    C65D  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01719    C65F  B0 0B              BCS   LAB_reset_search  ; branch if >= (start search from beginning)
01720    
01721    C661  98                 TYA                     ; else copy line index to A
01722    C662  38                 SEC                     ; set carry (+1)
01723    C663  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01724    C665  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
01725    C667  90 07              BCC   LAB_go_search     ; branch if no overflow to high byte
01726    
01727    C669  E8                 INX                     ; increment high byte
01728    C66A  B0 04              BCS   LAB_go_search     ; branch always (can never be carry clear)
01729    
01730    ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
01731    
01732    LAB_reset_search
01733    C66C  A5 79              LDA   Smeml             ; get start of mem low byte
01734    C66E  A6 7A              LDX   Smemh             ; get start of mem high byte
01735    
01736    ; search for line # in temp (Itempl/Itemph) from (AX)
01737    
01738    LAB_go_search
01739    
01740    C670  20 31 C4           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
01741    C673  B0 03              BCS   LAB_line_found    ; if carry set go set pointer
01742    
01743    C675  4C 76 C7           JMP   LAB_16F7          ; else go do "Undefined statement" error
01744    
01745    LAB_line_found
01746                                  ; carry already set for subtract
01747    C678  A5 AA              LDA   Baslnl            ; get pointer low byte
01748    C67A  E9 01              SBC   #$01              ; -1
01749    C67C  A4 AB              LDY   Baslnh            ; get pointer high byte
01750    C67E  B0 D0              BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
01751    
01752    C680  90 CD              BCC   LAB_uflow         ; else decrement high byte then save DATA pointer and
01753                                  ; return (branch always)
01754    
01755    ; perform NULL
01756    
01757    LAB_NULL
01758    C682  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
01759    C685  86 0D              STX   Nullct            ; save new NULL count
01760    LAB_167A
01761    C687  60                 RTS
01762    
01763    ; perform CONT
01764    
01765    LAB_CONT
01766    C688  D0 FD              BNE   LAB_167A          ; if following byte exit to do syntax error
01767    
01768    C68A  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
01769    C68C  C0 0B              CPY   #>Ibuffs          ; *** fix p2: test direct mode
01770    C68E  D0 05              BNE   LAB_166C          ; go do continue if we can
01771    
01772    C690  A2 1E              LDX   #$1E              ; error code $1E ("Can't continue" error)
01773    C692  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
01774    
01775                                  ; we can continue so ..
01776    LAB_166C
01777    C695  A9 93              LDA   #TK_ON            ; set token for ON
01778    C697  20 29 E0           JSR   LAB_IRQ           ; set IRQ flags
01779    C69A  A9 93              LDA   #TK_ON            ; set token for ON
01780    C69C  20 2C E0           JSR   LAB_NMI           ; set NMI flags
01781    
01782    C69F  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
01783    C6A1  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
01784    C6A3  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01785    C6A5  A5 89              LDA   Blinel            ; get break line low byte
01786    C6A7  A4 8A              LDY   Blineh            ; get break line high byte
01787    C6A9  85 87              STA   Clinel            ; set current line low byte
01788    C6AB  84 88              STY   Clineh            ; set current line high byte
01789    C6AD  60                 RTS
01790    
01791    ; perform RUN
01792    
01793    LAB_RUN
01794    C6AE  D0 03              BNE   LAB_1696          ; branch if RUN n
01795    C6B0  4C 6E C4           JMP   LAB_1477          ; reset execution to start, clear variables, flush stack and
01796                                  ; return
01797    
01798    ; does RUN n
01799    
01800    LAB_1696
01801    C6B3  20 7B C4           JSR   LAB_147A          ; go do "CLEAR"
01802    C6B6  F0 2E              BEQ   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
01803    
01804    ; perform DO
01805    
01806    LAB_DO
01807    C6B8  A9 05              LDA   #$05              ; need 5 bytes for DO
01808    C6BA  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
01809    C6BD  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
01810    C6BF  48                 PHA                     ; push on stack
01811    C6C0  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
01812    C6C2  48                 PHA                     ; push on stack
01813    C6C3  A5 88              LDA   Clineh            ; get current line high byte
01814    C6C5  48                 PHA                     ; push on stack
01815    C6C6  A5 87              LDA   Clinel            ; get current line low byte
01816    C6C8  48                 PHA                     ; push on stack
01817    C6C9  A9 9D              LDA   #TK_DO            ; token for DO
01818    C6CB  48                 PHA                     ; push on stack
01819    C6CC  20 C2 00           JSR   LAB_GBYT          ; scan memory
01820    C6CF  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
01821    
01822    ; perform GOSUB
01823    
01824    LAB_GOSUB
01825    C6D2  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
01826    C6D4  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
01827    C6D7  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
01828    C6D9  48                 PHA                     ; push on stack
01829    C6DA  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
01830    C6DC  48                 PHA                     ; push on stack
01831    C6DD  A5 88              LDA   Clineh            ; get current line high byte
01832    C6DF  48                 PHA                     ; push on stack
01833    C6E0  A5 87              LDA   Clinel            ; get current line low byte
01834    C6E2  48                 PHA                     ; push on stack
01835    C6E3  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
01836    C6E5  48                 PHA                     ; push on stack
01837    LAB_16B0
01838    C6E6  20 C2 00           JSR   LAB_GBYT          ; scan memory
01839    C6E9  20 EF C6           JSR   LAB_GOTO          ; perform GOTO n
01840    C6EC  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
01841                                  ; (can't RTS, we used the stack!)
01842    
01843    ; perform GOTO
01844    
01845    LAB_GOTO
01846    C6EF  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01847    C6F2  20 A4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
01848    C6F5  A5 88              LDA   Clineh            ; get current line high byte
01849    C6F7  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01850    C6F9  B0 0B              BCS   LAB_16D0          ; branch if >= (start search from beginning)
01851    
01852    C6FB  98                 TYA                     ; else copy line index to A
01853    C6FC  38                 SEC                     ; set carry (+1)
01854    C6FD  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01855    C6FF  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
01856    C701  90 07              BCC   LAB_16D4          ; branch if no overflow to high byte
01857    
01858    C703  E8                 INX                     ; increment high byte
01859    C704  B0 04              BCS   LAB_16D4          ; branch always (can never be carry)
01860    
01861    ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
01862    
01863    LAB_16D0
01864    C706  A5 79              LDA   Smeml             ; get start of mem low byte
01865    C708  A6 7A              LDX   Smemh             ; get start of mem high byte
01866    
01867    ; search for line # in temp (Itempl/Itemph) from (AX)
01868    
01869    LAB_16D4
01870    C70A  20 31 C4           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
01871    C70D  90 67              BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
01872                                  ; (unspecified statement)
01873    
01874                                  ; carry already set for subtract
01875    C70F  A5 AA              LDA   Baslnl            ; get pointer low byte
01876    C711  E9 01              SBC   #$01              ; -1
01877    C713  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01878    C715  A5 AB              LDA   Baslnh            ; get pointer high byte
01879    C717  E9 00              SBC   #$00              ; subtract carry
01880    C719  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
01881    LAB_16E5
01882    C71B  60                 RTS
01883    
01884    LAB_DONOK
01885    C71C  A2 22              LDX   #$22              ; error code $22 ("LOOP without DO" error)
01886    C71E  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
01887    
01888    ; perform LOOP
01889    
01890    LAB_LOOP
01891    C721  A8                 TAY                     ; save following token
01892    C722  BA                 TSX                     ; copy stack pointer
01893    C723  BD 03 01           LDA   LAB_STAK+3,X      ; get token byte from stack
01894    C726  C9 9D              CMP   #TK_DO            ; compare with DO token
01895    C728  D0 F2              BNE   LAB_DONOK         ; branch if no matching DO
01896    
01897    C72A  E8                 INX                     ; dump calling routine return address
01898    C72B  E8                 INX                     ; dump calling routine return address
01899    C72C  9A                 TXS                     ; correct stack
01900    C72D  98                 TYA                     ; get saved following token back
01901    C72E  F0 20              BEQ   LoopAlways        ; if no following token loop forever
01902                                  ; (stack pointer in X)
01903    
01904    C730  C9 3A              CMP   #':'              ; could be ':'
01905    C732  F0 1C              BEQ   LoopAlways        ; if :... loop forever
01906    
01907    C734  E9 B3              SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
01908    C736  AA                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)
01909    C737  F0 04              BEQ   DoRest            ; branch if was UNTIL
01910    
01911    C739  CA                 DEX                     ; decrement result
01912    C73A  D0 62              BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
01913                                  ; only if the token was WHILE will this fail
01914    
01915    C73C  CA                 DEX                     ; set invert result byte
01916    DoRest
01917    C73D  86 98              STX   Frnxth            ; save invert result byte
01918    C73F  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01919    C742  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
01920    C745  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
01921    C747  F0 02              BEQ   DoCmp             ; if =0 go do straight compare
01922    
01923    C749  A9 FF              LDA   #$FF              ; else set all bits
01924    DoCmp
01925    C74B  BA                 TSX                     ; copy stack pointer
01926    C74C  45 98              EOR   Frnxth            ; EOR with invert byte
01927    C74E  D0 1A              BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
01928    
01929                                  ; loop condition wasn't met so do it again
01930    LoopAlways
01931    C750  BD 02 01           LDA   LAB_STAK+2,X      ; get current line low byte
01932    C753  85 87              STA   Clinel            ; save current line low byte
01933    C755  BD 03 01           LDA   LAB_STAK+3,X      ; get current line high byte
01934    C758  85 88              STA   Clineh            ; save current line high byte
01935    C75A  BD 04 01           LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
01936    C75D  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01937    C75F  BD 05 01           LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
01938    C762  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
01939    C764  20 C2 00           JSR   LAB_GBYT          ; scan memory
01940    C767  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
01941    
01942                                  ; clear stack and back to interpreter loop
01943    LoopDone
01944    C76A  E8                 INX                     ; dump DO token
01945    C76B  E8                 INX                     ; dump current line low byte
01946    C76C  E8                 INX                     ; dump current line high byte
01947    C76D  E8                 INX                     ; dump BASIC execute pointer low byte
01948    C76E  E8                 INX                     ; dump BASIC execute pointer high byte
01949    C76F  9A                 TXS                     ; correct stack
01950    C770  4C 90 C7           JMP   LAB_DATA          ; go perform DATA (find : or [EOL])
01951    
01952    ; do the return without gosub error
01953    
01954    LAB_16F4
01955    C773  A2 04              LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
01956          .byte $2C               ; makes next line BIT LAB_0EA2
01957    
01958    LAB_16F7                      ; do undefined statement error
01959    C776  A2 0E              LDX   #$0E              ; error code $0E ("Undefined statement" error)
01960    C778  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
01961    
01962    ; perform RETURN
01963    
01964    LAB_RETURN
01965    C77B  D0 9E              BNE   LAB_16E5          ; exit if following token (to allow syntax error)
01966    
01967    LAB_16E8
01968    C77D  68                 PLA                     ; dump calling routine return address
01969    C77E  68                 PLA                     ; dump calling routine return address
01970    C77F  68                 PLA                     ; pull token
01971    C780  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
01972    C782  D0 EF              BNE   LAB_16F4          ; branch if no matching GOSUB
01973    
01974    LAB_16FF
01975    C784  68                 PLA                     ; pull current line low byte
01976    C785  85 87              STA   Clinel            ; save current line low byte
01977    C787  68                 PLA                     ; pull current line high byte
01978    C788  85 88              STA   Clineh            ; save current line high byte
01979    C78A  68                 PLA                     ; pull BASIC execute pointer low byte
01980    C78B  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01981    C78D  68                 PLA                     ; pull BASIC execute pointer high byte
01982    C78E  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
01983    
01984                                  ; now do the DATA statement as we could be returning into
01985                                  ; the middle of an ON <var> GOSUB n,m,p,q line
01986                                  ; (the return address used by the DATA statement is the one
01987                                  ; pushed before the GOSUB was executed!)
01988    
01989    ; perform DATA
01990    
01991    LAB_DATA
01992    C790  20 A1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
01993    
01994                                  ; set BASIC execute pointer
01995    LAB_170F
01996    C793  98                 TYA                     ; copy index to A
01997    C794  18                 CLC                     ; clear carry for add
01998    C795  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01999    C797  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
02000    C799  90 02              BCC   LAB_1719          ; skip next if no carry
02001    
02002    C79B  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
02003    LAB_1719
02004    C79D  60                 RTS
02005    
02006    LAB_16FC
02007    C79E  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
02008    
02009    ; scan for next BASIC statement ([:] or [EOL])
02010    ; returns Y as index to [:] or [EOL]
02011    
02012    LAB_SNBS
02013    C7A1  A2 3A              LDX   #':'              ; set look for character = ":"
02014          .byte $2C               ; makes next line BIT $00A2
02015    
02016    ; scan for next BASIC line
02017    ; returns Y as index to [EOL]
02018    
02019    LAB_SNBL
02020    C7A4  A2 00              LDX   #$00              ; set alt search character = [EOL]
02021    C7A6  A0 00              LDY   #$00              ; set search character = [EOL]
02022    C7A8  84 5C              STY   Asrch             ; store search character
02023    LAB_1725
02024    C7AA  8A                 TXA                     ; get alt search character
02025    C7AB  45 5C              EOR   Asrch             ; toggle search character, effectively swap with $00
02026    C7AD  85 5C              STA   Asrch             ; save swapped search character
02027    LAB_172D
02028    C7AF  B1 C3              LDA   (Bpntrl),Y        ; get next byte
02029    C7B1  F0 EA              BEQ   LAB_1719          ; exit if null [EOL]
02030    
02031    C7B3  C5 5C              CMP   Asrch             ; compare with search character
02032    C7B5  F0 E6              BEQ   LAB_1719          ; exit if found
02033    
02034    C7B7  C8                 INY                     ; increment index
02035    C7B8  C9 22              CMP   #$22              ; compare current character with open quote
02036    C7BA  D0 F3              BNE   LAB_172D          ; if not open quote go get next character
02037    
02038    C7BC  F0 EC              BEQ   LAB_1725          ; if found go swap search character for alt search character
02039    
02040    ; perform IF
02041    
02042    LAB_IF
02043    C7BE  20 E7 CB           JSR   LAB_EVEX          ; evaluate the expression
02044    C7C1  20 C2 00           JSR   LAB_GBYT          ; scan memory
02045    C7C4  C9 B0              CMP   #TK_THEN          ; compare with THEN token
02046    C7C6  F0 11              BEQ   LAB_174B          ; if it was THEN go do IF
02047    
02048                                  ; wasn't IF .. THEN so must be IF .. GOTO
02049    C7C8  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
02050    C7CA  D0 D2              BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
02051    
02052    C7CC  A6 C3              LDX   Bpntrl            ; save the basic pointer low byte
02053    C7CE  A4 C4              LDY   Bpntrh            ; save the basic pointer high byte
02054    C7D0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02055    C7D3  B0 C9              BCS   LAB_16FC          ; if not numeric go do syntax error
02056    
02057    C7D5  86 C3              STX   Bpntrl            ; restore the basic pointer low byte
02058    C7D7  84 C4              STY   Bpntrh            ; restore the basic pointer high byte
02059    LAB_174B
02060    C7D9  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
02061    C7DB  F0 1E              BEQ   LAB_174E          ; if the result was zero go look for an ELSE
02062    
02063    C7DD  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
02064    C7E0  B0 03              BCS   LAB_174D          ; if not numeric go do var or keyword
02065    
02066    LAB_174C
02067    C7E2  4C EF C6           JMP   LAB_GOTO          ; else was numeric so do GOTO n
02068    
02069                                  ; is var or keyword
02070    LAB_174D
02071    ; *** patch       allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
02072    ; *** replace
02073    ;      CMP   #TK_RETURN        ; compare the byte with the token for RETURN
02074    ;      BNE   LAB_174G          ; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
02075    ;                              ; and return to this code to process any following code
02076    ;
02077    ;      JMP   LAB_1602          ; else it was RETURN so interpret BASIC code from (Bpntrl)
02078    ;                              ; but don't return here
02079    ;
02080    ;LAB_174G
02081    ;      JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
02082    ;
02083    ;; the IF was executed and there may be a following ELSE so the code needs to return
02084    ;; here to check and ignore the ELSE if present
02085    ;
02086    ;      LDY   #$00              ; clear the index
02087    ;      LDA   (Bpntrl),Y        ; get the next BASIC byte
02088    ;      CMP   #TK_ELSE          ; compare it with the token for ELSE
02089    ;      BEQ   LAB_DATA          ; if ELSE ignore the following statement
02090    ;
02091    ;; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
02092    ;; following ELSE will, correctly, cause a syntax error
02093    ;
02094    ;      RTS                     ; else return to the interpreter inner loop
02095    ;
02096    ; *** with
02097    C7E5  68                 PLA                     ; discard interpreter loop return address
02098    C7E6  68                 PLA                     ; so data structures are at the correct stack offset
02099    C7E7  20 C2 00           JSR   LAB_GBYT          ; restore token or variable
02100    C7EA  20 04 C6           JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
02101    
02102    ; the IF was executed and there may be a following ELSE so the code needs to return
02103    ; here to check and ignore the ELSE if present
02104    
02105    C7ED  A0 00              LDY   #$00              ; clear the index
02106    C7EF  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
02107    C7F1  C9 AC              CMP   #TK_ELSE          ; compare it with the token for ELSE
02108    C7F3  D0 03              BNE   LAB_no_ELSE       ; no - continue on this line
02109    C7F5  20 90 C7           JSR   LAB_DATA          ; yes - skip the rest of the line
02110    
02111    ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
02112    ; following ELSE will, correctly, cause a syntax error
02113    
02114    LAB_no_ELSE
02115    C7F8  4C C6 C5           JMP LAB_15C2            ; return to the interpreter inner loop
02116    ; *** end patch  allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
02117    
02118    ; perform ELSE after IF
02119    
02120    LAB_174E
02121    C7FB  A0 00              LDY   #$00              ; clear the BASIC byte index
02122    C7FD  A2 01              LDX   #$01              ; clear the nesting depth
02123    LAB_1750
02124    C7FF  C8                 INY                     ; increment the BASIC byte index
02125    C800  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
02126    C802  F0 0F              BEQ   LAB_1753          ; if EOL go add the pointer and return
02127    
02128    C804  C9 8B              CMP   #TK_IF            ; compare the byte with the token for IF
02129    C806  D0 03              BNE   LAB_1752          ; if not IF token skip the depth increment
02130    
02131    C808  E8                 INX                     ; else increment the nesting depth ..
02132    C809  D0 F4              BNE   LAB_1750          ; .. and continue looking
02133    
02134    LAB_1752
02135    C80B  C9 AC              CMP   #TK_ELSE          ; compare the byte with the token for ELSE
02136    C80D  D0 F0              BNE   LAB_1750          ; if not ELSE token continue looking
02137    
02138    C80F  CA                 DEX                     ; was ELSE so decrement the nesting depth
02139    C810  D0 ED              BNE   LAB_1750          ; loop if still nested
02140    
02141    C812  C8                 INY                     ; increment the BASIC byte index past the ELSE
02142    
02143    ; found the matching ELSE, now do <{n|statement}>
02144    
02145    LAB_1753
02146    C813  98                 TYA                     ; else copy line index to A
02147    C814  18                 CLC                     ; clear carry for add
02148    C815  65 C3              ADC   Bpntrl            ; add the BASIC execute pointer low byte
02149    C817  85 C3              STA   Bpntrl            ; save the BASIC execute pointer low byte
02150    C819  90 02              BCC   LAB_1754          ; branch if no overflow to high byte
02151    
02152    C81B  E6 C4              INC   Bpntrh            ; else increment the BASIC execute pointer high byte
02153    LAB_1754
02154    C81D  20 C2 00           JSR   LAB_GBYT          ; scan memory
02155    C820  90 C0              BCC   LAB_174C          ; if numeric do GOTO n
02156                                  ; the code will return to the interpreter loop at the
02157                                  ; tail end of the GOTO <n>
02158    
02159    C822  4C 04 C6           JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
02160                                  ; the code will return to the interpreter loop at the
02161                                  ; tail end of the <statement>
02162    
02163    ; perform REM, skip (rest of) line
02164    
02165    LAB_REM
02166    C825  20 A4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
02167    C828  4C 93 C7           JMP   LAB_170F          ; go set BASIC execute pointer and return, branch always
02168    
02169    LAB_16FD
02170    C82B  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
02171    
02172    ; perform ON
02173    
02174    LAB_ON
02175    C82E  C9 A9              CMP   #TK_IRQ           ; was it IRQ token ?
02176    C830  D0 03              BNE   LAB_NOIN          ; if not go check NMI
02177    
02178    C832  4C 4D E0           JMP   LAB_SIRQ          ; else go set-up IRQ
02179    
02180    LAB_NOIN
02181    C835  C9 AA              CMP   #TK_NMI           ; was it NMI token ?
02182    C837  D0 03              BNE   LAB_NONM          ; if not go do normal ON command
02183    
02184    C839  4C 51 E0           JMP   LAB_SNMI          ; else go set-up NMI
02185    
02186    LAB_NONM
02187    C83C  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
02188    C83F  48                 PHA                     ; push GOTO/GOSUB token
02189    C840  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
02190    C842  F0 04              BEQ   LAB_176B          ; branch if GOSUB
02191    
02192    C844  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
02193    LAB_1767
02194    C846  D0 E3              BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
02195    
02196    
02197    ; next character was GOTO or GOSUB
02198    
02199    LAB_176B
02200    C848  C6 AF              DEC   FAC1_3            ; decrement index (byte value)
02201    C84A  D0 04              BNE   LAB_1773          ; branch if not zero
02202    
02203    C84C  68                 PLA                     ; pull GOTO/GOSUB token
02204    C84D  4C 06 C6           JMP   LAB_1602          ; go execute it
02205    
02206    LAB_1773
02207    C850  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02208    C853  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
02209                                  ; (we could LDX #',' and JSR LAB_SNBL+2, then we
02210                                  ; just BNE LAB_176B for the loop. should be quicker ..
02211                                  ; no we can't, what if we meet a colon or [EOL]?)
02212    C856  C9 2C              CMP   #$2C              ; compare next character with ","
02213    C858  F0 EE              BEQ   LAB_176B          ; loop if ","
02214    
02215    LAB_177E
02216    C85A  68                 PLA                     ; else pull keyword token (run out of options)
02217                                  ; also dump +/-1 pointer low byte and exit
02218    LAB_177F
02219    C85B  60                 RTS
02220    
02221    ; takes n * 106 + 11 cycles where n is the number of digits
02222    
02223    ; get fixed-point number into temp integer
02224    
02225    LAB_GFPN
02226    C85C  A2 00              LDX   #$00              ; clear reg
02227    C85E  86 11              STX   Itempl            ; clear temporary integer low byte
02228    LAB_1785
02229    C860  86 12              STX   Itemph            ; save temporary integer high byte
02230    C862  B0 F7              BCS   LAB_177F          ; return if carry set, end of scan, character was
02231                                  ; not 0-9
02232    
02233    C864  E0 19              CPX   #$19              ; compare high byte with $19
02234    C866  A8                 TAY                     ; ensure Zb = 0 if the branch is taken
02235    C867  B0 DD              BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
02236                                  ; bit does *$0A, = 64000, compare at target will fail
02237                                  ; and do syntax error
02238    
02239    C869  E9 2F              SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
02240    C86B  A8                 TAY                     ; copy binary digit
02241    C86C  A5 11              LDA   Itempl            ; get temporary integer low byte
02242    C86E  0A                 ASL                     ; *2 low byte
02243    C86F  26 12              ROL   Itemph            ; *2 high byte
02244    C871  0A                 ASL                     ; *2 low byte
02245    C872  26 12              ROL   Itemph            ; *2 high byte, *4
02246    C874  65 11              ADC   Itempl            ; + low byte, *5
02247    C876  85 11              STA   Itempl            ; save it
02248    C878  8A                 TXA                     ; get high byte copy to A
02249    C879  65 12              ADC   Itemph            ; + high byte, *5
02250    C87B  06 11              ASL   Itempl            ; *2 low byte, *10d
02251    C87D  2A                 ROL                     ; *2 high byte, *10d
02252    C87E  AA                 TAX                     ; copy high byte back to X
02253    C87F  98                 TYA                     ; get binary digit back
02254    C880  65 11              ADC   Itempl            ; add number low byte
02255    C882  85 11              STA   Itempl            ; save number low byte
02256    C884  90 01              BCC   LAB_17B3          ; if no overflow to high byte get next character
02257    
02258    C886  E8                 INX                     ; else increment high byte
02259    LAB_17B3
02260    C887  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02261    C88A  4C 60 C8           JMP   LAB_1785          ; loop for next character
02262    
02263    ; perform DEC
02264    
02265    LAB_DEC
02266    C88D  A9 FB              LDA   #<LAB_2AFD        ; set -1 pointer low byte
02267          .byte $2C               ; BIT abs to skip the LDA below
02268    
02269    ; perform INC
02270    
02271    LAB_INC
02272    C890  A9 F7              LDA   #<LAB_259C        ; set 1 pointer low byte
02273    LAB_17B5
02274    C892  48                 PHA                     ; save +/-1 pointer low byte
02275    LAB_17B7
02276    C893  20 BE CE           JSR   LAB_GVAR          ; get var address
02277    C896  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
02278    C898  30 1E              BMI   IncrErr           ; exit if string
02279    
02280    C89A  85 97              STA   Lvarpl            ; save var address low byte
02281    C89C  84 98              STY   Lvarph            ; save var address high byte
02282    C89E  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
02283    C8A1  68                 PLA                     ; get +/-1 pointer low byte
02284    C8A2  48                 PHA                     ; save +/-1 pointer low byte
02285    C8A3  A0 E2              LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
02286    C8A5  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
02287    C8A8  20 B6 D9           JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
02288    
02289    C8AB  20 C2 00           JSR   LAB_GBYT          ; scan memory
02290    C8AE  C9 2C              CMP   #','              ; compare with ","
02291    C8B0  D0 A8              BNE   LAB_177E          ; exit if not "," (either end or error)
02292    
02293                                  ; was "," so another INCR variable to do
02294    C8B2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02295    C8B5  4C 93 C8           JMP   LAB_17B7          ; go do next var
02296    
02297    IncrErr
02298    C8B8  4C E2 CB           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
02299    
02300    ; perform LET
02301    
02302    LAB_LET
02303    C8BB  20 BE CE           JSR   LAB_GVAR          ; get var address
02304    C8BE  85 97              STA   Lvarpl            ; save var address low byte
02305    C8C0  84 98              STY   Lvarph            ; save var address high byte
02306    C8C2  A9 C1              LDA   #TK_EQUAL         ; get = token
02307    C8C4  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
02308    C8C7  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
02309    C8C9  48                 PHA                     ; push data type flag
02310    C8CA  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
02311    C8CD  68                 PLA                     ; pop data type flag
02312    C8CE  2A                 ROL                     ; set carry if type = string
02313    ; *** begin patch  result of a string compare stores string pointer to variable
02314    ;                  but should store FAC1 (true/false value)
02315    ; *** replace
02316    ;      JSR   LAB_CKTM          ; type match check, set C for string
02317    ;      BNE   LAB_17D5          ; branch if string
02318    ; *** with
02319    C8CF  20 D9 CB           JSR   LAB_CKTM          ; type match check, keep C (expected type)
02320    C8D2  B0 03              BCS   LAB_17D5          ; branch if string
02321    ; *** end patch
02322    
02323    C8D4  4C B6 D9           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
02324    
02325    ; string LET
02326    
02327    LAB_17D5
02328    C8D7  A0 02              LDY   #$02              ; set index to pointer high byte
02329    C8D9  B1 AE              LDA   (des_pl),Y        ; get string pointer high byte
02330    C8DB  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
02331    C8DD  90 17              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
02332    
02333    C8DF  D0 07              BNE   LAB_17E6          ; branch if >
02334                                  ; else was equal so compare low bytes
02335    C8E1  88                 DEY                     ; decrement index
02336    C8E2  B1 AE              LDA   (des_pl),Y        ; get pointer low byte
02337    C8E4  C5 81              CMP   Sstorl            ; compare bottom of string space low byte
02338    C8E6  90 0E              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
02339    
02340                                  ; pointer was >= to bottom of string space pointer
02341    LAB_17E6
02342    C8E8  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
02343    C8EA  C4 7C              CPY   Svarh             ; compare start of vars high byte
02344    C8EC  90 08              BCC   LAB_17F4          ; branch if less (descriptor is on stack)
02345    
02346    C8EE  D0 0D              BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
02347    
02348                                  ; else high bytes were equal so ..
02349    C8F0  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
02350    C8F2  C5 7B              CMP   Svarl             ; compare start of vars low byte
02351    C8F4  B0 07              BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
02352    
02353    LAB_17F4
02354    C8F6  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
02355    C8F8  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
02356    C8FA  4C 13 C9           JMP   LAB_1811          ; clean stack, copy descriptor to variable and return
02357    
02358                                  ; make space and copy string
02359    LAB_17FB
02360    C8FD  A0 00              LDY   #$00              ; index to length
02361    C8FF  B1 AE              LDA   (des_pl),Y        ; get string length
02362    C901  20 46 D2           JSR   LAB_209C          ; copy string
02363    C904  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
02364    C906  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
02365    C908  85 B8              STA   ssptr_l           ; save descriptor pointer low byte
02366    C90A  84 B9              STY   ssptr_h           ; save descriptor pointer high byte
02367    C90C  20 2B D4           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
02368    C90F  A9 AC              LDA   #<FAC1_e          ; set descriptor pointer low byte
02369    C911  A0 00              LDY   #>FAC1_e          ; get descriptor pointer high byte
02370    
02371                                  ; clean stack and assign value to string variable
02372    LAB_1811
02373    C913  85 9E              STA   des_2l            ; save descriptor_2 pointer low byte
02374    C915  84 9F              STY   des_2h            ; save descriptor_2 pointer high byte
02375    C917  20 8D D4           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
02376    C91A  A0 00              LDY   #$00              ; index to length
02377    C91C  B1 9E              LDA   (des_2l),Y        ; get string length
02378    C91E  91 97              STA   (Lvarpl),Y        ; copy to let string variable
02379    C920  C8                 INY                     ; index to string pointer low byte
02380    C921  B1 9E              LDA   (des_2l),Y        ; get string pointer low byte
02381    C923  91 97              STA   (Lvarpl),Y        ; copy to let string variable
02382    C925  C8                 INY                     ; index to string pointer high byte
02383    C926  B1 9E              LDA   (des_2l),Y        ; get string pointer high byte
02384    C928  91 97              STA   (Lvarpl),Y        ; copy to let string variable
02385    C92A  60                 RTS
02386    
02387    ; perform GET
02388    
02389    LAB_GET
02390    C92B  20 BE CE           JSR   LAB_GVAR          ; get var address
02391    C92E  85 97              STA   Lvarpl            ; save var address low byte
02392    C930  84 98              STY   Lvarph            ; save var address high byte
02393    C932  20 15 E0           JSR   INGET             ; get input byte
02394    C935  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
02395    C937  30 07              BMI   LAB_GETS          ; go get string character
02396    
02397                                  ; was numeric get
02398    C939  A8                 TAY                     ; copy character to Y
02399    C93A  20 7A D1           JSR   LAB_1FD0          ; convert Y to byte in FAC1
02400    C93D  4C B6 D9           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
02401    
02402    LAB_GETS
02403    C940  48                 PHA                     ; save character
02404    C941  A9 01              LDA   #$01              ; string is single byte
02405    C943  B0 01              BCS   LAB_IsByte        ; branch if byte received
02406    
02407    C945  68                 PLA                     ; string is null
02408    LAB_IsByte
02409    C946  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
02410                                  ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
02411    C949  F0 05              BEQ   LAB_NoSt          ; skip store if null string
02412    
02413    C94B  68                 PLA                     ; get character back
02414    C94C  A0 00              LDY   #$00              ; clear index
02415    C94E  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
02416    LAB_NoSt
02417    C950  20 9B D2           JSR   LAB_RTST          ; check for space on descriptor stack then put address
02418                                  ; and length on descriptor stack and update stack pointers
02419    
02420    C953  4C D7 C8           JMP   LAB_17D5          ; do string LET and return
02421    
02422    ; perform PRINT
02423    
02424    LAB_1829
02425    C956  20 DD C9           JSR   LAB_18C6          ; print string from Sutill/Sutilh
02426    LAB_182C
02427    C959  20 C2 00           JSR   LAB_GBYT          ; scan memory
02428    
02429    ; PRINT
02430    
02431    LAB_PRINT
02432    C95C  F0 3B              BEQ   LAB_CRLF          ; if nothing following just print CR/LF
02433    
02434    LAB_1831
02435    C95E  C9 AB              CMP   #TK_TAB           ; compare with TAB( token
02436    C960  F0 56              BEQ   LAB_18A2          ; go do TAB/SPC
02437    
02438    C962  C9 AF              CMP   #TK_SPC           ; compare with SPC( token
02439    C964  F0 52              BEQ   LAB_18A2          ; go do TAB/SPC
02440    
02441    C966  C9 2C              CMP   #','              ; compare with ","
02442    C968  F0 38              BEQ   LAB_188B          ; go do move to next TAB mark
02443    
02444    C96A  C9 3B              CMP   #';'              ; compare with ";"
02445    C96C  F0 66              BEQ   LAB_18BD          ; if ";" continue with PRINT processing
02446    
02447    C96E  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
02448    C971  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
02449    C973  30 E1              BMI   LAB_1829          ; branch if string
02450    
02451    C975  20 A8 DB           JSR   LAB_296E          ; convert FAC1 to string
02452    C978  20 58 D2           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
02453    C97B  A0 00              LDY   #$00              ; clear index
02454    
02455    ; don't check fit if terminal width byte is zero
02456    
02457    C97D  A5 0F              LDA   TWidth            ; get terminal width byte
02458    C97F  F0 0A              BEQ   LAB_185E          ; skip check if zero
02459    
02460    C981  38                 SEC                     ; set carry for subtract
02461    C982  E5 0E              SBC   TPos              ; subtract terminal position
02462    C984  F1 AE              SBC   (des_pl),Y        ; subtract string length
02463    C986  B0 03              BCS   LAB_185E          ; branch if less than terminal width
02464    
02465    C988  20 99 C9           JSR   LAB_CRLF          ; else print CR/LF
02466    LAB_185E
02467    C98B  20 DD C9           JSR   LAB_18C6          ; print string from Sutill/Sutilh
02468    C98E  F0 C9              BEQ   LAB_182C          ; always go continue processing line
02469    
02470    ; CR/LF return to BASIC from BASIC input handler
02471    
02472    LAB_1866
02473    C990  A9 00              LDA   #$00              ; clear byte
02474    C992  9D 00 0B           STA   Ibuffs,X          ; null terminate input
02475    C995  A2 00              LDX   #<Ibuffs          ; set X to buffer start-1 low byte
02476    C997  A0 0B              LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
02477    
02478    ; print CR/LF
02479    
02480    LAB_CRLF
02481    C999  A9 0D              LDA   #$0D              ; load [CR]
02482    C99B  20 F4 C9           JSR   LAB_PRNA          ; go print the character
02483    C99E  A9 0A              LDA   #$0A              ; load [LF]
02484    C9A0  D0 52              BNE   LAB_PRNA          ; go print the character and return, branch always
02485    
02486    LAB_188B
02487    C9A2  A5 0E              LDA   TPos              ; get terminal position
02488    C9A4  C5 10              CMP   Iclim             ; compare with input column limit
02489    C9A6  90 05              BCC   LAB_1897          ; branch if less
02490    
02491    C9A8  20 99 C9           JSR   LAB_CRLF          ; else print CR/LF (next line)
02492    C9AB  D0 27              BNE   LAB_18BD          ; continue with PRINT processing (branch always)
02493    
02494    LAB_1897
02495    C9AD  38                 SEC                     ; set carry for subtract
02496    LAB_1898
02497    C9AE  E5 64              SBC   TabSiz            ; subtract TAB size
02498    C9B0  B0 FC              BCS   LAB_1898          ; loop if result was +ve
02499    
02500    C9B2  49 FF              EOR   #$FF              ; complement it
02501    C9B4  69 01              ADC   #$01              ; +1 (twos complement)
02502    C9B6  D0 12              BNE   LAB_18B6          ; always print A spaces (result is never $00)
02503    
02504                                  ; do TAB/SPC
02505    LAB_18A2
02506    C9B8  48                 PHA                     ; save token
02507    C9B9  20 A3 D5           JSR   LAB_SGBY          ; scan and get byte parameter
02508    C9BC  C9 29              CMP   #$29              ; is next character )
02509    C9BE  D0 7B              BNE   LAB_1910          ; if not do syntax error then warm start
02510    
02511    C9C0  68                 PLA                     ; get token back
02512    C9C1  C9 AB              CMP   #TK_TAB           ; was it TAB ?
02513    C9C3  D0 06              BNE   LAB_18B7          ; if not go do SPC
02514    
02515                                  ; calculate TAB offset
02516    C9C5  8A                 TXA                     ; copy integer value to A
02517    C9C6  E5 0E              SBC   TPos              ; subtract terminal position
02518    C9C8  90 0A              BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
02519    
02520                                  ; print A spaces
02521    LAB_18B6
02522    C9CA  AA                 TAX                     ; copy result to X
02523    LAB_18B7
02524    C9CB  8A                 TXA                     ; set flags on size for SPC
02525    C9CC  F0 06              BEQ   LAB_18BD          ; branch if result was = $0, already here
02526    
02527                                  ; print X spaces
02528    LAB_18BA
02529    C9CE  20 EF C9           JSR   LAB_18E0          ; print " "
02530    C9D1  CA                 DEX                     ; decrement count
02531    C9D2  D0 FA              BNE   LAB_18BA          ; loop if not all done
02532    
02533                                  ; continue with PRINT processing
02534    LAB_18BD
02535    C9D4  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02536    C9D7  D0 85              BNE   LAB_1831          ; if more to print go do it
02537    
02538    C9D9  60                 RTS
02539    
02540    ; print null terminated string from memory
02541    
02542    LAB_18C3
02543    C9DA  20 58 D2           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
02544    
02545    ; print string from Sutill/Sutilh
02546    
02547    LAB_18C6
02548    C9DD  20 58 D4           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
02549                                  ; space returns with A = length, X=$71=pointer low byte,
02550                                  ; Y=$72=pointer high byte
02551    C9E0  A0 00              LDY   #$00              ; reset index
02552    C9E2  AA                 TAX                     ; copy length to X
02553    C9E3  F0 49              BEQ   LAB_188C          ; exit (RTS) if null string
02554    
02555    LAB_18CD
02556    
02557    C9E5  B1 71              LDA   (ut1_pl),Y        ; get next byte
02558    C9E7  20 F4 C9           JSR   LAB_PRNA          ; go print the character
02559    C9EA  C8                 INY                     ; increment index
02560    C9EB  CA                 DEX                     ; decrement count
02561    C9EC  D0 F7              BNE   LAB_18CD          ; loop if not done yet
02562    
02563    C9EE  60                 RTS
02564    
02565                                  ; Print single format character
02566    ; print " "
02567    
02568    LAB_18E0
02569    C9EF  A9 20              LDA   #$20              ; load " "
02570          .byte $2C               ; change next line to BIT LAB_3FA9
02571    
02572    ; print "?" character
02573    
02574    LAB_18E3
02575    C9F2  A9 3F              LDA   #$3F              ; load "?" character
02576    
02577    ; print character in A
02578    ; now includes the null handler
02579    ; also includes infinite line length code
02580    ; note! some routines expect this one to exit with Zb=0
02581    
02582    LAB_PRNA
02583    C9F4  C9 20              CMP   #' '              ; compare with " "
02584    C9F6  90 19              BCC   LAB_18F9          ; branch if less (non printing)
02585    
02586                                  ; else printable character
02587    C9F8  48                 PHA                     ; save the character
02588    
02589    ; don't check fit if terminal width byte is zero
02590    
02591    C9F9  A5 0F              LDA   TWidth            ; get terminal width
02592    C9FB  D0 0A              BNE   LAB_18F0          ; branch if not zero (not infinite length)
02593    
02594    ; is "infinite line" so check TAB position
02595    
02596    C9FD  A5 0E              LDA   TPos              ; get position
02597    C9FF  E5 64              SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
02598    CA01  D0 0B              BNE   LAB_18F7          ; skip reset if different
02599    
02600    CA03  85 0E              STA   TPos              ; else reset position
02601    CA05  F0 07              BEQ   LAB_18F7          ; go print character
02602    
02603    LAB_18F0
02604    CA07  C5 0E              CMP   TPos              ; compare with terminal character position
02605    CA09  D0 03              BNE   LAB_18F7          ; branch if not at end of line
02606    
02607    CA0B  20 99 C9           JSR   LAB_CRLF          ; else print CR/LF
02608    LAB_18F7
02609    CA0E  E6 0E              INC   TPos              ; increment terminal position
02610    CA10  68                 PLA                     ; get character back
02611    LAB_18F9
02612    CA11  20 02 E2           JSR   V_OUTP            ; output byte via output vector
02613    CA14  C9 0D              CMP   #$0D              ; compare with [CR]
02614    CA16  D0 14              BNE   LAB_188A          ; branch if not [CR]
02615    
02616                                  ; else print nullct nulls after the [CR]
02617    CA18  86 78              STX   TempB             ; save buffer index
02618    CA1A  A6 0D              LDX   Nullct            ; get null count
02619    CA1C  F0 0A              BEQ   LAB_1886          ; branch if no nulls
02620    
02621    CA1E  A9 00              LDA   #$00              ; load [NULL]
02622    LAB_1880
02623    CA20  20 F4 C9           JSR   LAB_PRNA          ; go print the character
02624    CA23  CA                 DEX                     ; decrement count
02625    CA24  D0 FA              BNE   LAB_1880          ; loop if not all done
02626    
02627    CA26  A9 0D              LDA   #$0D              ; restore the character (and set the flags)
02628    LAB_1886
02629    CA28  86 0E              STX   TPos              ; clear terminal position (X always = zero when we get here)
02630    CA2A  A6 78              LDX   TempB             ; restore buffer index
02631    LAB_188A
02632    CA2C  29 FF              AND   #$FF              ; set the flags
02633    LAB_188C
02634    CA2E  60                 RTS
02635    
02636    ; handle bad input data
02637    
02638    LAB_1904
02639    CA2F  A5 62              LDA   Imode             ; get input mode flag, $00=INPUT, $00=READ
02640    CA31  10 0B              BPL   LAB_1913          ; branch if INPUT (go do redo)
02641    
02642    CA33  A5 8D              LDA   Dlinel            ; get current DATA line low byte
02643    CA35  A4 8E              LDY   Dlineh            ; get current DATA line high byte
02644    CA37  85 87              STA   Clinel            ; save current line low byte
02645    CA39  84 88              STY   Clineh            ; save current line high byte
02646    LAB_1910
02647    CA3B  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
02648    
02649                                  ; mode was INPUT
02650    LAB_1913
02651    CA3E  A9 29              LDA   #<LAB_REDO        ; point to redo message (low addr)
02652    CA40  A0 E9              LDY   #>LAB_REDO        ; point to redo message (high addr)
02653    CA42  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
02654    CA45  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
02655    CA47  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
02656    CA49  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
02657    CA4B  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
02658    CA4D  60                 RTS
02659    
02660    ; perform INPUT
02661    
02662    LAB_INPUT
02663    CA4E  C9 22              CMP   #$22              ; compare next byte with open quote
02664    CA50  D0 0B              BNE   LAB_1934          ; branch if no prompt string
02665    
02666    CA52  20 C4 CC           JSR   LAB_1BC1          ; print "..." string
02667    CA55  A9 3B              LDA   #$3B              ; load A with ";"
02668    CA57  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
02669    CA5A  20 DD C9           JSR   LAB_18C6          ; print string from Sutill/Sutilh
02670    
02671                                  ; done with prompt, now get data
02672    LAB_1934
02673    CA5D  20 7E D1           JSR   LAB_CKRN          ; check not Direct, back here if ok
02674    CA60  20 43 C3           JSR   LAB_INLN          ; print "? " and get BASIC input
02675    CA63  A9 00              LDA   #$00              ; set mode = INPUT
02676    CA65  CD 00 0B           CMP   Ibuffs            ; test first byte in buffer
02677    CA68  D0 09              BNE   LAB_1953          ; branch if not null input
02678    
02679    ; *** change p2: keep carry set to throw break message
02680    ;      CLC                     ; was null input so clear carry to exit program
02681    CA6A  4C 2E C6           JMP   LAB_1647          ; go do BREAK exit
02682    
02683    ; perform READ
02684    
02685    LAB_READ
02686    CA6D  A6 8F              LDX   Dptrl             ; get DATA pointer low byte
02687    CA6F  A4 90              LDY   Dptrh             ; get DATA pointer high byte
02688    CA71  A9 80              LDA   #$80              ; set mode = READ
02689    
02690    LAB_1953
02691    CA73  85 62              STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
02692    CA75  86 91              STX   Rdptrl            ; save READ pointer low byte
02693    CA77  84 92              STY   Rdptrh            ; save READ pointer high byte
02694    
02695                                  ; READ or INPUT next variable from list
02696    LAB_195B
02697    CA79  20 BE CE           JSR   LAB_GVAR          ; get (var) address
02698    CA7C  85 97              STA   Lvarpl            ; save address low byte
02699    CA7E  84 98              STY   Lvarph            ; save address high byte
02700    CA80  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
02701    CA82  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
02702    CA84  85 11              STA   Itempl            ; save as temporary integer low byte
02703    CA86  84 12              STY   Itemph            ; save as temporary integer high byte
02704    CA88  A6 91              LDX   Rdptrl            ; get READ pointer low byte
02705    CA8A  A4 92              LDY   Rdptrh            ; get READ pointer high byte
02706    CA8C  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
02707    CA8E  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
02708    CA90  20 C2 00           JSR   LAB_GBYT          ; scan memory
02709    CA93  D0 11              BNE   LAB_1988          ; branch if not null
02710    
02711                                  ; pointer was to null entry
02712    CA95  24 62              BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
02713    CA97  30 65              BMI   LAB_19DD          ; branch if READ
02714    
02715                                  ; mode was INPUT
02716    CA99  20 F2 C9           JSR   LAB_18E3          ; print "?" character (double ? for extended input)
02717    CA9C  20 43 C3           JSR   LAB_INLN          ; print "? " and get BASIC input
02718    CA9F  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
02719    CAA1  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
02720    LAB_1985
02721    CAA3  20 C2 00           JSR   LAB_GBYT          ; scan memory
02722    LAB_1988
02723    CAA6  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
02724    CAA8  10 24              BPL   LAB_19B0          ; branch if numeric
02725    
02726                                  ; else get string
02727    CAAA  85 5B              STA   Srchc             ; save search character
02728    CAAC  C9 22              CMP   #$22              ; was it " ?
02729    CAAE  F0 07              BEQ   LAB_1999          ; branch if so
02730    
02731    CAB0  A9 3A              LDA   #':'              ; else search character is ":"
02732    CAB2  85 5B              STA   Srchc             ; set new search character
02733    CAB4  A9 2C              LDA   #','              ; other search character is ","
02734    CAB6  18                 CLC                     ; clear carry for add
02735    LAB_1999
02736    CAB7  85 5C              STA   Asrch             ; set second search character
02737    CAB9  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
02738    CABB  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
02739    
02740    CABD  69 00              ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
02741    CABF  90 01              BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
02742    
02743    CAC1  C8                 INY                     ; else increment high byte
02744    LAB_19A4
02745    CAC2  20 5E D2           JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
02746    CAC5  20 E2 D5           JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
02747    CAC8  20 D7 C8           JSR   LAB_17D5          ; go do string LET
02748    CACB  4C D4 CA           JMP   LAB_19B6          ; go check string terminator
02749    
02750                                  ; get numeric INPUT
02751    LAB_19B0
02752    CACE  20 B9 DA           JSR   LAB_2887          ; get FAC1 from string
02753    CAD1  20 B6 D9           JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
02754    LAB_19B6
02755    CAD4  20 C2 00           JSR   LAB_GBYT          ; scan memory
02756    CAD7  F0 0A              BEQ   LAB_19C5          ; branch if null (last entry)
02757    
02758    CAD9  C9 2C              CMP   #','              ; else compare with ","
02759    CADB  F0 03              BEQ   LAB_19C2          ; branch if ","
02760    
02761    CADD  4C 2F CA           JMP   LAB_1904          ; else go handle bad input data
02762    
02763                                  ; got good input data
02764    LAB_19C2
02765    CAE0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02766    LAB_19C5
02767    CAE3  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
02768    CAE5  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
02769    CAE7  85 91              STA   Rdptrl            ; save for now
02770    CAE9  84 92              STY   Rdptrh            ; save for now
02771    CAEB  A5 11              LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
02772    CAED  A4 12              LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
02773    CAEF  85 C3              STA   Bpntrl            ; set BASIC execute pointer low byte
02774    CAF1  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
02775    CAF3  20 C2 00           JSR   LAB_GBYT          ; scan memory
02776    CAF6  F0 2C              BEQ   LAB_1A03          ; if null go do extra ignored message
02777    
02778    CAF8  20 04 CD           JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
02779    CAFB  4C 79 CA           JMP   LAB_195B          ; go INPUT next variable from list
02780    
02781                                  ; find next DATA statement or do "Out of DATA" error
02782    LAB_19DD
02783    CAFE  20 A1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
02784    CB01  C8                 INY                     ; increment index
02785    CB02  AA                 TAX                     ; copy character ([:] or [EOL])
02786    CB03  D0 12              BNE   LAB_19F6          ; branch if [:]
02787    
02788    CB05  A2 06              LDX   #$06              ; set for "Out of DATA" error
02789    CB07  C8                 INY                     ; increment index, now points to next line pointer high byte
02790    CB08  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
02791    CB0A  F0 73              BEQ   LAB_1A54          ; branch if end (eventually does error X)
02792    
02793    CB0C  C8                 INY                     ; increment index
02794    CB0D  B1 C3              LDA   (Bpntrl),Y        ; get next line # low byte
02795    CB0F  85 8D              STA   Dlinel            ; save current DATA line low byte
02796    CB11  C8                 INY                     ; increment index
02797    CB12  B1 C3              LDA   (Bpntrl),Y        ; get next line # high byte
02798    CB14  C8                 INY                     ; increment index
02799    CB15  85 8E              STA   Dlineh            ; save current DATA line high byte
02800    LAB_19F6
02801    CB17  B1 C3              LDA   (Bpntrl),Y        ; get byte
02802    CB19  C8                 INY                     ; increment index
02803    CB1A  AA                 TAX                     ; copy to X
02804    CB1B  20 93 C7           JSR   LAB_170F          ; set BASIC execute pointer
02805    CB1E  E0 83              CPX   #TK_DATA          ; compare with "DATA" token
02806    CB20  F0 81              BEQ   LAB_1985          ; was "DATA" so go do next READ
02807    
02808    CB22  D0 DA              BNE   LAB_19DD          ; go find next statement if not "DATA"
02809    
02810    ; end of INPUT/READ routine
02811    
02812    LAB_1A03
02813    CB24  A5 91              LDA   Rdptrl            ; get temp READ pointer low byte
02814    CB26  A4 92              LDY   Rdptrh            ; get temp READ pointer high byte
02815    CB28  A6 62              LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
02816    CB2A  10 03              BPL   LAB_1A0E          ; branch if INPUT
02817    
02818    CB2C  4C 50 C6           JMP   LAB_1624          ; save AY as DATA pointer and return
02819    
02820                                  ; we were getting INPUT
02821    LAB_1A0E
02822    CB2F  A0 00              LDY   #$00              ; clear index
02823    CB31  B1 91              LDA   (Rdptrl),Y        ; get next byte
02824    CB33  D0 01              BNE   LAB_1A1B          ; error if not end of INPUT
02825    
02826    CB35  60                 RTS
02827    
02828                                  ; user typed too much
02829    LAB_1A1B
02830    CB36  A9 18              LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
02831    CB38  A0 E9              LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
02832    CB3A  4C DA C9           JMP   LAB_18C3          ; print null terminated string from memory and return
02833    
02834    ; search the stack for FOR activity
02835    ; exit with z=1 if FOR else exit with z=0
02836    
02837    LAB_11A1
02838    CB3D  BA                 TSX                     ; copy stack pointer
02839    CB3E  E8                 INX                     ; +1 pass return address
02840    CB3F  E8                 INX                     ; +2 pass return address
02841    CB40  E8                 INX                     ; +3 pass calling routine return address
02842    CB41  E8                 INX                     ; +4 pass calling routine return address
02843    LAB_11A6
02844    CB42  BD 01 01           LDA   LAB_STAK+1,X      ; get token byte from stack
02845    CB45  C9 81              CMP   #TK_FOR           ; is it FOR token
02846    CB47  D0 21              BNE   LAB_11CE          ; exit if not FOR token
02847    
02848                                  ; was FOR token
02849    CB49  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
02850    CB4B  D0 0A              BNE   LAB_11BB          ; branch if not null
02851    
02852    CB4D  BD 02 01           LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
02853    CB50  85 97              STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
02854    CB52  BD 03 01           LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
02855    CB55  85 98              STA   Frnxth            ; save var pointer for FOR/NEXT high byte
02856    LAB_11BB
02857    CB57  DD 03 01           CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
02858    CB5A  D0 07              BNE   LAB_11C7          ; branch if no match
02859    
02860    CB5C  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
02861    CB5E  DD 02 01           CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
02862    CB61  F0 07              BEQ   LAB_11CE          ; exit if match found
02863    
02864    LAB_11C7
02865    CB63  8A                 TXA                     ; copy index
02866    CB64  18                 CLC                     ; clear carry for add
02867    CB65  69 10              ADC   #$10              ; add FOR stack use size
02868    CB67  AA                 TAX                     ; copy back to index
02869    CB68  D0 D8              BNE   LAB_11A6          ; loop if not at start of stack
02870    
02871    LAB_11CE
02872    CB6A  60                 RTS
02873    
02874    ; perform NEXT
02875    
02876    LAB_NEXT
02877    CB6B  D0 04              BNE   LAB_1A46          ; branch if NEXT var
02878    
02879    CB6D  A0 00              LDY   #$00              ; else clear Y
02880    CB6F  F0 03              BEQ   LAB_1A49          ; branch always (no variable to search for)
02881    
02882    ; NEXT var
02883    
02884    LAB_1A46
02885    CB71  20 BE CE           JSR   LAB_GVAR          ; get variable address
02886    LAB_1A49
02887    CB74  85 97              STA   Frnxtl            ; store variable pointer low byte
02888    CB76  84 98              STY   Frnxth            ; store variable pointer high byte
02889                                  ; (both cleared if no variable defined)
02890    CB78  20 3D CB           JSR   LAB_11A1          ; search the stack for FOR activity
02891    CB7B  F0 04              BEQ   LAB_1A56          ; branch if found
02892    
02893    CB7D  A2 00              LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
02894    LAB_1A54
02895    CB7F  F0 63              BEQ   LAB_1ABE          ; do error #X, then warm start
02896    
02897    LAB_1A56
02898    CB81  9A                 TXS                     ; set stack pointer, X set by search, dumps return addresses
02899    
02900    CB82  8A                 TXA                     ; copy stack pointer
02901    CB83  38                 SEC                     ; set carry for subtract
02902    CB84  E9 F7              SBC   #$F7              ; point to TO var
02903    CB86  85 73              STA   ut2_pl            ; save pointer to TO var for compare
02904    CB88  69 FB              ADC   #$FB              ; point to STEP var
02905    
02906    CB8A  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
02907    CB8C  20 90 D9           JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
02908    CB8F  BA                 TSX                     ; get stack pointer back
02909    CB90  BD 08 01           LDA   LAB_STAK+8,X      ; get step sign
02910    CB93  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
02911    CB95  A5 97              LDA   Frnxtl            ; get FOR variable pointer low byte
02912    CB97  A4 98              LDY   Frnxth            ; get FOR variable pointer high byte
02913    CB99  20 D1 D6           JSR   LAB_246C          ; add (FOR variable) to FAC1
02914    CB9C  20 B6 D9           JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
02915    CB9F  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
02916    CBA1  20 2C DA           JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
02917    CBA4  BA                 TSX                     ; get stack pointer back
02918    CBA5  DD 08 01           CMP   LAB_STAK+8,X      ; compare step sign
02919    CBA8  F0 17              BEQ   LAB_1A9B          ; branch if = (loop complete)
02920    
02921                                  ; loop back and do it all again
02922    CBAA  BD 0D 01           LDA   LAB_STAK+$0D,X    ; get FOR line low byte
02923    CBAD  85 87              STA   Clinel            ; save current line low byte
02924    CBAF  BD 0E 01           LDA   LAB_STAK+$0E,X    ; get FOR line high byte
02925    CBB2  85 88              STA   Clineh            ; save current line high byte
02926    CBB4  BD 10 01           LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
02927    CBB7  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
02928    CBB9  BD 0F 01           LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
02929    CBBC  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
02930    LAB_1A98
02931    CBBE  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
02932    
02933                                  ; loop complete so carry on
02934    LAB_1A9B
02935    CBC1  8A                 TXA                     ; stack copy to A
02936    CBC2  69 0F              ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
02937    CBC4  AA                 TAX                     ; copy back to index
02938    CBC5  9A                 TXS                     ; copy to stack pointer
02939    CBC6  20 C2 00           JSR   LAB_GBYT          ; scan memory
02940    CBC9  C9 2C              CMP   #','              ; compare with ","
02941    CBCB  D0 F1              BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
02942    
02943                                  ; was "," so another NEXT variable to do
02944    CBCD  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
02945    CBD0  20 71 CB           JSR   LAB_1A46          ; do NEXT (var)
02946    
02947    ; evaluate expression and check is numeric, else do type mismatch
02948    
02949    LAB_EVNM
02950    CBD3  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
02951    
02952    ; check if source is numeric, else do type mismatch
02953    
02954    LAB_CTNM
02955    CBD6  18                 CLC                     ; destination is numeric
02956          .byte $24               ; makes next line BIT $38
02957    
02958    ; check if source is string, else do type mismatch
02959    
02960    LAB_CTST
02961    CBD8  38                 SEC                     ; required type is string
02962    
02963    ; type match check, set C for string, clear C for numeric
02964    
02965    LAB_CKTM
02966    CBD9  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
02967    CBDB  30 03              BMI   LAB_1ABA          ; branch if data type is string
02968    
02969                                  ; else data type was numeric
02970    CBDD  B0 03              BCS   LAB_1ABC          ; if required type is string do type mismatch error
02971    LAB_1AB9
02972    CBDF  60                 RTS
02973    
02974                                  ; data type was string, now check required type
02975    LAB_1ABA
02976    CBE0  B0 FD              BCS   LAB_1AB9          ; exit if required type is string
02977    
02978                                  ; else do type mismatch error
02979    LAB_1ABC
02980    CBE2  A2 18              LDX   #$18              ; error code $18 ("Type mismatch" error)
02981    LAB_1ABE
02982    CBE4  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
02983    
02984    ; evaluate expression
02985    
02986    LAB_EVEX
02987    CBE7  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
02988    CBE9  D0 02              BNE   LAB_1AC7          ; skip next if not zero
02989    
02990    CBEB  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
02991    LAB_1AC7
02992    CBED  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
02993    
02994    LAB_EVEZ
02995    CBEF  A9 00              LDA   #$00              ; set null precedence (flag done)
02996    LAB_1ACC
02997    CBF1  48                 PHA                     ; push precedence byte
02998    CBF2  A9 02              LDA   #$02              ; 2 bytes
02999    CBF4  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
03000    CBF7  20 D3 CC           JSR   LAB_GVAL          ; get value from line
03001    CBFA  A9 00              LDA   #$00              ; clear A
03002    CBFC  85 9B              STA   comp_f            ; clear compare function flag
03003    LAB_1ADB
03004    CBFE  20 C2 00           JSR   LAB_GBYT          ; scan memory
03005    LAB_1ADE
03006    CC01  38                 SEC                     ; set carry for subtract
03007    CC02  E9 C0              SBC   #TK_GT            ; subtract token for > (lowest comparison function)
03008    CC04  90 17              BCC   LAB_1AFA          ; branch if < TK_GT
03009    
03010    CC06  C9 03              CMP   #$03              ; compare with ">" to "<" tokens
03011    CC08  B0 13              BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
03012    
03013                                  ; was token for > = or < (A = 0, 1 or 2)
03014    CC0A  C9 01              CMP   #$01              ; compare with token for =
03015    CC0C  2A                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
03016                                  ; (A = 0, 3 or 5)
03017    CC0D  49 01              EOR   #$01              ; toggle b0
03018                                  ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
03019    CC0F  45 9B              EOR   comp_f            ; EOR with compare function flag bits
03020    CC11  C5 9B              CMP   comp_f            ; compare with compare function flag
03021    CC13  90 67              BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
03022                                  ; was more than one <, = or >)
03023    
03024    CC15  85 9B              STA   comp_f            ; save new compare function flag
03025    CC17  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03026    CC1A  4C 01 CC           JMP   LAB_1ADE          ; go do next character
03027    
03028                                  ; token is < ">" or > "<" tokens
03029    LAB_1AFA
03030    CC1D  A6 9B              LDX   comp_f            ; get compare function flag
03031    CC1F  D0 2C              BNE   LAB_1B2A          ; branch if compare function
03032    
03033    CC21  B0 79              BCS   LAB_1B78          ; go do functions
03034    
03035                                  ; else was <  TK_GT so is operator or lower
03036    CC23  69 0A              ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
03037    CC25  90 75              BCC   LAB_1B78          ; branch if < + operator
03038    
03039                                  ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
03040    CC27  D0 07              BNE   LAB_1B0B          ; branch if not + token
03041    
03042    CC29  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
03043    CC2B  10 03              BPL   LAB_1B0B          ; branch if not string
03044    
03045                                  ; will only be $00 if type is string and token was +
03046    CC2D  4C EE D3           JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
03047                                  ; is in line, and return
03048    
03049    LAB_1B0B
03050    CC30  85 71              STA   ut1_pl            ; save it
03051    CC32  0A                 ASL                     ; *2
03052    CC33  65 71              ADC   ut1_pl            ; *3
03053    CC35  A8                 TAY                     ; copy to index
03054    LAB_1B13
03055    CC36  68                 PLA                     ; pull previous precedence
03056    CC37  D9 00 E4           CMP   LAB_OPPT,Y        ; compare with precedence byte
03057    CC3A  B0 65              BCS   LAB_1B7D          ; branch if A >=
03058    
03059    CC3C  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
03060    LAB_1B1C
03061    CC3F  48                 PHA                     ; save precedence
03062    LAB_1B1D
03063    CC40  20 68 CC           JSR   LAB_1B43          ; get vector, execute function then continue evaluation
03064    CC43  68                 PLA                     ; restore precedence
03065    CC44  A4 99              LDY   prstk             ; get precedence stacked flag
03066    CC46  10 19              BPL   LAB_1B3C          ; branch if stacked values
03067    
03068    CC48  AA                 TAX                     ; copy precedence (set flags)
03069    CC49  F0 76              BEQ   LAB_1B9D          ; exit if done
03070    
03071    CC4B  D0 5D              BNE   LAB_1B86          ; else pop FAC2 and return, branch always
03072    
03073    LAB_1B2A
03074    CC4D  26 5F              ROL   Dtypef            ; shift data type flag into Cb
03075    CC4F  8A                 TXA                     ; copy compare function flag
03076    CC50  85 5F              STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
03077    CC52  2A                 ROL                     ; shift data type into compare function byte b0
03078    CC53  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
03079    CC55  D0 02              BNE   LAB_1B34          ; branch if no underflow
03080    
03081    CC57  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
03082    LAB_1B34
03083    CC59  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
03084      000C             TK_LT_PLUS  = TK_LT-TK_PLUS
03085    CC5B  A0 24              LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
03086    CC5D  85 9B              STA   comp_f            ; save new compare function flag
03087    CC5F  D0 D5              BNE   LAB_1B13          ; branch always
03088    
03089    LAB_1B3C
03090    CC61  D9 00 E4           CMP   LAB_OPPT,Y        ;.compare with stacked function precedence
03091    CC64  B0 44              BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
03092    
03093    CC66  90 D7              BCC   LAB_1B1C          ; branch always
03094    
03095    ;.get vector, execute function then continue evaluation
03096    
03097    LAB_1B43
03098    CC68  B9 02 E4           LDA   LAB_OPPT+2,Y      ; get function vector high byte
03099    CC6B  48                 PHA                     ; onto stack
03100    CC6C  B9 01 E4           LDA   LAB_OPPT+1,Y      ; get function vector low byte
03101    CC6F  48                 PHA                     ; onto stack
03102                                  ; now push sign, round FAC1 and put on stack
03103    ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
03104    ; *** add
03105       .IF [* & $FF] == $FD
03106    ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
03107    CC70  20 7F CC           JSR   LAB_1B5B          ; function will return here, then the next RTS will call
03108                                  ; the function
03109    CC73  A5 9B              LDA   comp_f            ; get compare function flag
03110    CC75  48                 PHA                     ; push compare evaluation byte
03111    CC76  B9 00 E4           LDA   LAB_OPPT,Y        ; get precedence byte
03112    CC79  4C F1 CB           JMP   LAB_1ACC          ; continue evaluating expression
03113    
03114    LAB_1B53
03115    CC7C  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
03116    
03117    ; push sign, round FAC1 and put on stack
03118    
03119    LAB_1B5B
03120    CC7F  68                 PLA                     ; get return addr low byte
03121    CC80  85 71              STA   ut1_pl            ; save it
03122    CC82  E6 71              INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
03123                                  ; note! no check is made on the high byte! if the calling
03124                                  ; routine assembles to a page edge then this all goes
03125                                  ; horribly wrong !!!
03126    CC84  68                 PLA                     ; get return addr high byte
03127    CC85  85 72              STA   ut1_ph            ; save it
03128    CC87  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
03129    CC89  48                 PHA                     ; push sign
03130    
03131    ; round FAC1 and put on stack
03132    
03133    ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
03134    ; *** replace
03135    ;LAB_1B66
03136    ;      JSR   LAB_27BA          ; round FAC1
03137    ; *** with
03138    CC8A  20 EC D9           JSR   LAB_27BA          ; round FAC1
03139    LAB_1B66
03140    ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
03141    CC8D  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03142    CC8F  48                 PHA                     ; push on stack
03143    CC90  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03144    CC92  48                 PHA                     ; push on stack
03145    CC93  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
03146    CC95  48                 PHA                     ; push on stack
03147    CC96  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03148    CC98  48                 PHA                     ; push on stack
03149    CC99  6C 71 00           JMP   (ut1_pl)          ; return, sort of
03150    
03151    ; do functions
03152    
03153    LAB_1B78
03154    CC9C  A0 FF              LDY   #$FF              ; flag function
03155    CC9E  68                 PLA                     ; pull precedence byte
03156    LAB_1B7B
03157    CC9F  F0 20              BEQ   LAB_1B9D          ; exit if done
03158    
03159    LAB_1B7D
03160    CCA1  C9 64              CMP   #$64              ; compare previous precedence with $64
03161    CCA3  F0 03              BEQ   LAB_1B84          ; branch if was $64 (< function)
03162    
03163    CCA5  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
03164    LAB_1B84
03165    CCA8  84 99              STY   prstk             ; save precedence stacked flag
03166    
03167                                  ; pop FAC2 and return
03168    LAB_1B86
03169    CCAA  68                 PLA                     ; pop byte
03170    CCAB  4A                 LSR                     ; shift out comparison evaluation lowest bit
03171    CCAC  85 63              STA   Cflag             ; save comparison evaluation flag
03172    CCAE  68                 PLA                     ; pop exponent
03173    CCAF  85 B3              STA   FAC2_e            ; save FAC2 exponent
03174    CCB1  68                 PLA                     ; pop mantissa1
03175    CCB2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
03176    CCB4  68                 PLA                     ; pop mantissa2
03177    CCB5  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
03178    CCB7  68                 PLA                     ; pop mantissa3
03179    CCB8  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
03180    CCBA  68                 PLA                     ; pop sign
03181    CCBB  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
03182    CCBD  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
03183    CCBF  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
03184    LAB_1B9D
03185    CCC1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03186    CCC3  60                 RTS
03187    
03188    ; print "..." string to string util area
03189    
03190    LAB_1BC1
03191    CCC4  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
03192    CCC6  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
03193    CCC8  69 00              ADC   #$00              ; add carry to low byte
03194    CCCA  90 01              BCC   LAB_1BCA          ; branch if no overflow
03195    
03196    CCCC  C8                 INY                     ; increment high byte
03197    LAB_1BCA
03198    CCCD  20 58 D2           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
03199    CCD0  4C E2 D5           JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
03200    
03201    ; get value from line
03202    
03203    LAB_GVAL
03204    CCD3  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03205    CCD6  B0 03              BCS   LAB_1BAC          ; branch if not numeric character
03206    
03207                                  ; else numeric string found (e.g. 123)
03208    LAB_1BA9
03209    CCD8  4C B9 DA           JMP   LAB_2887          ; get FAC1 from string and return
03210    
03211    ; get value from line .. continued
03212    
03213                                  ; wasn't a number so ..
03214    LAB_1BAC
03215    CCDB  AA                 TAX                     ; set the flags
03216    CCDC  30 2F              BMI   LAB_1BD0          ; if -ve go test token values
03217    
03218                                  ; else it is either a string, number, variable or (<expr>)
03219    CCDE  C9 24              CMP   #'$'              ; compare with "$"
03220    CCE0  F0 F6              BEQ   LAB_1BA9          ; branch if "$", hex number
03221    
03222    CCE2  C9 25              CMP   #'%'              ; else compare with "%"
03223    CCE4  F0 F2              BEQ   LAB_1BA9          ; branch if "%", binary number
03224    
03225    CCE6  C9 2E              CMP   #'.'              ; compare with "."
03226    CCE8  F0 EE              BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
03227    
03228                                  ; it wasn't any sort of number so ..
03229    CCEA  C9 22              CMP   #$22              ; compare with "
03230    CCEC  F0 D6              BEQ   LAB_1BC1          ; branch if open quote
03231    
03232                                  ; wasn't any sort of number so ..
03233    
03234    ; evaluate expression within parentheses
03235    
03236    CCEE  C9 28              CMP   #'('              ; compare with "("
03237    CCF0  D0 5B              BNE   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
03238    
03239    LAB_1BF7
03240    CCF2  20 EF CB           JSR   LAB_EVEZ          ; evaluate expression, no decrement
03241    
03242    ; all the 'scan for' routines return the character after the sought character
03243    
03244    ; scan for ")" , else do syntax error then warm start
03245    
03246    LAB_1BFB
03247    CCF5  A9 29              LDA   #$29              ; load A with ")"
03248    
03249    ; scan for CHR$(A) , else do syntax error then warm start
03250    
03251    LAB_SCCA
03252    CCF7  A0 00              LDY   #$00              ; clear index
03253    CCF9  D1 C3              CMP   (Bpntrl),Y        ; check next byte is = A
03254    CCFB  D0 0B              BNE   LAB_SNER          ; if not do syntax error then warm start
03255    
03256    CCFD  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then return
03257    
03258    ; scan for "(" , else do syntax error then warm start
03259    
03260    LAB_1BFE
03261    CD00  A9 28              LDA   #$28              ; load A with "("
03262    CD02  D0 F3              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
03263                                  ; (branch always)
03264    
03265    ; scan for "," , else do syntax error then warm start
03266    
03267    LAB_1C01
03268    CD04  A9 2C              LDA   #$2C              ; load A with ","
03269    CD06  D0 EF              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
03270                                  ; (branch always)
03271    
03272    ; syntax error then warm start
03273    
03274    LAB_SNER
03275    CD08  A2 02              LDX   #$02              ; error code $02 ("Syntax" error)
03276    CD0A  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
03277    
03278    ; get value from line .. continued
03279    ; do tokens
03280    
03281    LAB_1BD0
03282    CD0D  C9 B7              CMP   #TK_MINUS         ; compare with token for -
03283    CD0F  F0 29              BEQ   LAB_1C11          ; branch if - token (do set-up for functions)
03284    
03285                                  ; wasn't -n so ..
03286    CD11  C9 B6              CMP   #TK_PLUS          ; compare with token for +
03287    CD13  F0 BE              BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
03288    
03289    CD15  C9 B1              CMP   #TK_NOT           ; compare with token for NOT
03290    CD17  D0 13              BNE   LAB_1BE7          ; branch if not token for NOT
03291    
03292                                  ; was NOT token
03293      000B             TK_EQUAL_PLUS     = TK_EQUAL-TK_PLUS
03294    CD19  A0 21              LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
03295    CD1B  D0 1F              BNE   LAB_1C13          ; do set-up for function then execute (branch always)
03296    
03297    ; do = compare
03298    
03299    LAB_EQUAL
03300    CD1D  20 BA CF           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
03301    CD20  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03302    CD22  49 FF              EOR   #$FF              ; invert it
03303    CD24  A8                 TAY                     ; copy it
03304    CD25  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03305    CD27  49 FF              EOR   #$FF              ; invert it
03306    CD29  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03307    
03308    ; get value from line .. continued
03309    
03310                                  ; wasn't +, -, or NOT so ..
03311    LAB_1BE7
03312    CD2C  C9 AE              CMP   #TK_FN            ; compare with token for FN
03313    CD2E  D0 03              BNE   LAB_1BEE          ; branch if not token for FN
03314    
03315    CD30  4C C8 D1           JMP   LAB_201E          ; go evaluate FNx
03316    
03317    ; get value from line .. continued
03318    
03319                                  ; wasn't +, -, NOT or FN so ..
03320    LAB_1BEE
03321    CD33  E9 C3              SBC   #TK_SGN           ; subtract with token for SGN
03322    CD35  B0 27              BCS   LAB_1C27          ; if a function token go do it
03323    
03324    CD37  4C 08 CD           JMP   LAB_SNER          ; else do syntax error
03325    
03326    ; set-up for functions
03327    
03328    LAB_1C11
03329      000A             TK_GT_PLUS  = TK_GT-TK_PLUS
03330    CD3A  A0 1E              LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
03331    LAB_1C13
03332    CD3C  68                 PLA                     ; dump return address low byte
03333    ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
03334    ; *** replace
03335    ;      PLA                     ; dump return address high byte
03336    ;      JMP   LAB_1B1D          ; execute function then continue evaluation
03337    ; *** with
03338    CD3D  AA                 TAX                     ; save to trap concatenate
03339    CD3E  68                 PLA                     ; dump return address high byte
03340    CD3F  E0 F6              CPX   #<[LAB_224Da+2]   ; from concatenate low return address?
03341    CD41  D0 04              BNE   LAB_1C13b         ; No - continue!
03342    CD43  C9 D3              CMP   #>[LAB_224Da+2]   ; from concatenate high return address?
03343    CD45  F0 03              BEQ   LAB_1C13a         ; Yes - error!
03344    LAB_1C13b
03345    CD47  4C 40 CC           JMP   LAB_1B1D          ; execute function then continue evaluation
03346    LAB_1C13a
03347    CD4A  4C E2 CB           JMP   LAB_1ABC          ; throw "type mismatch error" then warm start      
03348    ; *** end   patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
03349    
03350    ; variable name set-up
03351    ; get (var), return value in FAC_1 and $ flag
03352    
03353    LAB_1C18
03354    CD4D  20 BE CE           JSR   LAB_GVAR          ; get (var) address
03355    CD50  85 AE              STA   FAC1_2            ; save address low byte in FAC1 mantissa2
03356    CD52  84 AF              STY   FAC1_3            ; save address high byte in FAC1 mantissa3
03357    CD54  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
03358    CD56  30 03              BMI   LAB_1C25          ; if string then return (does RTS)
03359    
03360    LAB_1C24
03361    CD58  4C 90 D9           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
03362    
03363    LAB_1C25
03364    ; *** begin patch  string pointer high byte trashed when moved to stack
03365    ; *** add
03366    CD5B  46 B9              LSR   FAC1_r            ; clear bit 7 (<$80) = do not round up
03367    ; *** end patch 
03368    CD5D  60                 RTS
03369    
03370    ; get value from line .. continued
03371    ; only functions left so ..
03372    
03373    ; set up function references
03374    
03375    ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
03376    ; to process function calls. now the function vector is computed and pushed on the stack
03377    ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
03378    ; is calculated and the routine called, if not this routine just does RTS. whichever
03379    ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
03380    ; the function code
03381    
03382    ; this also removes some less than elegant code that was used to bypass type checking
03383    ; for functions that returned strings
03384    
03385    LAB_1C27
03386    CD5E  0A                 ASL                     ; *2 (2 bytes per function address)
03387    CD5F  A8                 TAY                     ; copy to index
03388    
03389    CD60  B9 BB E3           LDA   LAB_FTBM,Y        ; get function jump vector high byte
03390    CD63  48                 PHA                     ; push functions jump vector high byte
03391    CD64  B9 BA E3           LDA   LAB_FTBL,Y        ; get function jump vector low byte
03392    CD67  48                 PHA                     ; push functions jump vector low byte
03393    
03394    CD68  B9 75 E3           LDA   LAB_FTPM,Y        ; get function pre process vector high byte
03395    CD6B  F0 05              BEQ   LAB_1C56          ; skip pre process if null vector
03396    
03397    CD6D  48                 PHA                     ; push functions pre process vector high byte
03398    CD6E  B9 74 E3           LDA   LAB_FTPL,Y        ; get function pre process vector low byte
03399    CD71  48                 PHA                     ; push functions pre process vector low byte
03400    
03401    LAB_1C56
03402    CD72  60                 RTS                     ; do function, or pre process, call
03403    
03404    ; process string expression in parenthesis
03405    
03406    LAB_PPFS
03407    CD73  20 F2 CC           JSR   LAB_1BF7          ; process expression in parenthesis
03408    CD76  4C D8 CB           JMP   LAB_CTST          ; check if source is string then do function,
03409                                  ; else do type mismatch
03410    
03411    ; process numeric expression in parenthesis
03412    
03413    LAB_PPFN
03414    CD79  20 F2 CC           JSR   LAB_1BF7          ; process expression in parenthesis
03415    CD7C  4C D6 CB           JMP   LAB_CTNM          ; check if source is numeric then do function,
03416                                  ; else do type mismatch
03417    
03418    ; set numeric data type and increment BASIC execute pointer
03419    
03420    LAB_PPBI
03421    CD7F  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
03422    CD81  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then do function
03423    
03424    ; process string for LEFT$, RIGHT$ or MID$
03425    
03426    LAB_LRMS
03427    CD84  20 EF CB           JSR   LAB_EVEZ          ; evaluate (should be string) expression
03428    CD87  20 04 CD           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
03429    CD8A  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
03430    
03431    CD8D  68                 PLA                     ; get function jump vector low byte
03432    CD8E  AA                 TAX                     ; save functions jump vector low byte
03433    CD8F  68                 PLA                     ; get function jump vector high byte
03434    CD90  A8                 TAY                     ; save functions jump vector high byte
03435    CD91  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
03436    CD93  48                 PHA                     ; push string pointer high byte
03437    CD94  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
03438    CD96  48                 PHA                     ; push string pointer low byte
03439    CD97  98                 TYA                     ; get function jump vector high byte back
03440    CD98  48                 PHA                     ; save functions jump vector high byte
03441    CD99  8A                 TXA                     ; get function jump vector low byte back
03442    CD9A  48                 PHA                     ; save functions jump vector low byte
03443    CD9B  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
03444    CD9E  8A                 TXA                     ; copy byte parameter to A
03445    CD9F  60                 RTS                     ; go do function
03446    
03447    ; process numeric expression(s) for BIN$ or HEX$
03448    
03449    LAB_BHSS
03450    CDA0  20 EF CB           JSR   LAB_EVEZ          ; process expression
03451    CDA3  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
03452    CDA6  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03453    CDA8  C9 98              CMP   #$98              ; compare with exponent = 2^24
03454    CDAA  B0 20              BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
03455    
03456    CDAC  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
03457    CDAF  A2 02              LDX   #$02              ; 3 bytes to do
03458    LAB_CFAC
03459    CDB1  B5 AD              LDA   FAC1_1,X          ; get byte from FAC1
03460    CDB3  95 11              STA   nums_1,X          ; save byte to temp
03461    CDB5  CA                 DEX                     ; decrement index
03462    CDB6  10 F9              BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
03463    
03464    CDB8  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
03465    CDBB  A2 00              LDX   #$00              ; set default to no leading "0"s
03466    CDBD  C9 29              CMP   #')'              ; compare with close bracket
03467    CDBF  F0 0A              BEQ   LAB_1C54          ; if ")" go do rest of function
03468    
03469    CDC1  20 F1 D5           JSR   LAB_SCGB          ; scan for "," and get byte
03470    CDC4  20 C2 00           JSR   LAB_GBYT          ; get last byte back
03471    CDC7  C9 29              CMP   #')'              ; is next character )
03472    CDC9  D0 01              BNE   LAB_BHER          ; if not ")" go do error
03473    
03474    LAB_1C54
03475    CDCB  60                 RTS                     ; else do function
03476    
03477    LAB_BHER
03478    CDCC  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
03479    
03480    ; perform EOR
03481    
03482    ; added operator format is the same as AND or OR, precedence is the same as OR
03483    
03484    ; this bit worked first time but it took a while to sort out the operator table
03485    ; pointers and offsets afterwards!
03486    
03487    LAB_EOR
03488    CDCF  20 F6 CD           JSR   GetFirst          ; get first integer expression (no sign check)
03489    CDD2  45 5B              EOR   XOAw_l            ; EOR with expression 1 low byte
03490    CDD4  A8                 TAY                     ; save in Y
03491    CDD5  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03492    CDD7  45 5C              EOR   XOAw_h            ; EOR with expression 1 high byte
03493    CDD9  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03494    
03495    ; perform OR
03496    
03497    LAB_OR
03498    CDDC  20 F6 CD           JSR   GetFirst          ; get first integer expression (no sign check)
03499    CDDF  05 5B              ORA   XOAw_l            ; OR with expression 1 low byte
03500    CDE1  A8                 TAY                     ; save in Y
03501    CDE2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03502    CDE4  05 5C              ORA   XOAw_h            ; OR with expression 1 high byte
03503    CDE6  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03504    
03505    ; perform AND
03506    
03507    LAB_AND
03508    CDE9  20 F6 CD           JSR   GetFirst          ; get first integer expression (no sign check)
03509    CDEC  25 5B              AND   XOAw_l            ; AND with expression 1 low byte
03510    CDEE  A8                 TAY                     ; save in Y
03511    CDEF  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03512    CDF1  25 5C              AND   XOAw_h            ; AND with expression 1 high byte
03513    CDF3  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03514    
03515    ; get first value for OR, AND or EOR
03516    
03517    GetFirst
03518    CDF6  20 BA CF           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
03519    CDF9  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03520    CDFB  85 5C              STA   XOAw_h            ; save it
03521    CDFD  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03522    CDFF  85 5B              STA   XOAw_l            ; save it
03523    CE01  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
03524    CE04  20 BA CF           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
03525    CE07  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03526    LAB_1C95
03527    CE09  60                 RTS
03528    
03529    ; perform comparisons
03530    
03531    ; do < compare
03532    
03533    LAB_LTHAN
03534    CE0A  20 D9 CB           JSR   LAB_CKTM          ; type match check, set C for string
03535    CE0D  B0 13              BCS   LAB_1CAE          ; branch if string
03536    
03537                                  ; do numeric < compare
03538    CE0F  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
03539    CE11  09 7F              ORA   #$7F              ; set all non sign bits
03540    CE13  25 B4              AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
03541    CE15  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
03542    CE17  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
03543    CE19  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
03544    CE1B  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
03545    CE1E  AA                 TAX                     ; copy result
03546    CE1F  4C 53 CE           JMP   LAB_1CE1          ; go evaluate result
03547    
03548                                  ; do string < compare
03549    LAB_1CAE
03550    CE22  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
03551    CE24  C6 9B              DEC   comp_f            ; clear < bit in compare function flag
03552    CE26  20 58 D4           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
03553                                  ; space returns with A = length, X=pointer low byte,
03554                                  ; Y=pointer high byte
03555    CE29  85 AC              STA   str_ln            ; save length
03556    CE2B  86 AD              STX   str_pl            ; save string pointer low byte
03557    CE2D  84 AE              STY   str_ph            ; save string pointer high byte
03558    CE2F  A5 B5              LDA   FAC2_2            ; get descriptor pointer low byte
03559    CE31  A4 B6              LDY   FAC2_3            ; get descriptor pointer high byte
03560    CE33  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
03561                                  ; returns with A = length, X=pointer low byte,
03562                                  ; Y=pointer high byte
03563    CE36  86 B5              STX   FAC2_2            ; save string pointer low byte
03564    CE38  84 B6              STY   FAC2_3            ; save string pointer high byte
03565    CE3A  AA                 TAX                     ; copy length
03566    CE3B  38                 SEC                     ; set carry for subtract
03567    CE3C  E5 AC              SBC   str_ln            ; subtract string 1 length
03568    CE3E  F0 08              BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
03569    
03570    CE40  A9 01              LDA   #$01              ; set str 1 length > string 2 length
03571    CE42  90 04              BCC   LAB_1CD6          ; branch if so
03572    
03573    CE44  A6 AC              LDX   str_ln            ; get string 1 length
03574    CE46  A9 FF              LDA   #$FF              ; set str 1 length < string 2 length
03575    LAB_1CD6
03576    CE48  85 B0              STA   FAC1_s            ; save length compare
03577    CE4A  A0 FF              LDY   #$FF              ; set index
03578    CE4C  E8                 INX                     ; adjust for loop
03579    LAB_1CDB
03580    CE4D  C8                 INY                     ; increment index
03581    CE4E  CA                 DEX                     ; decrement count
03582    CE4F  D0 07              BNE   LAB_1CE6          ; branch if still bytes to do
03583    
03584    CE51  A6 B0              LDX   FAC1_s            ; get length compare back
03585    LAB_1CE1
03586    CE53  30 0F              BMI   LAB_1CF2          ; branch if str 1 < str 2
03587    
03588    CE55  18                 CLC                     ; flag str 1 <= str 2
03589    CE56  90 0C              BCC   LAB_1CF2          ; go evaluate result
03590    
03591    LAB_1CE6
03592    CE58  B1 B5              LDA   (FAC2_2),Y        ; get string 2 byte
03593    CE5A  D1 AD              CMP   (FAC1_1),Y        ; compare with string 1 byte
03594    CE5C  F0 EF              BEQ   LAB_1CDB          ; loop if bytes =
03595    
03596    CE5E  A2 FF              LDX   #$FF              ; set str 1 < string 2
03597    CE60  B0 02              BCS   LAB_1CF2          ; branch if so
03598    
03599    CE62  A2 01              LDX   #$01              ;  set str 1 > string 2
03600    LAB_1CF2
03601    CE64  E8                 INX                     ; x = 0, 1 or 2
03602    CE65  8A                 TXA                     ; copy to A
03603    CE66  2A                 ROL                     ; *2 (1, 2 or 4)
03604    CE67  25 63              AND   Cflag             ; AND with comparison evaluation flag
03605    CE69  F0 02              BEQ   LAB_1CFB          ; branch if 0 (compare is false)
03606    
03607    CE6B  A9 FF              LDA   #$FF              ; else set result true
03608    LAB_1CFB
03609    CE6D  4C 0D DA           JMP   LAB_27DB          ; save A as integer byte and return
03610    
03611    LAB_1CFE
03612    CE70  20 04 CD           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
03613    
03614    ; perform DIM
03615    
03616    LAB_DIM
03617    CE73  AA                 TAX                     ; copy "DIM" flag to X
03618    CE74  20 C3 CE           JSR   LAB_1D10          ; search for variable
03619    CE77  20 C2 00           JSR   LAB_GBYT          ; scan memory
03620    CE7A  D0 F4              BNE   LAB_1CFE          ; scan for "," and loop if not null
03621    
03622    CE7C  60                 RTS
03623    
03624    ; perform << (left shift)
03625    
03626    LAB_LSHIFT
03627    CE7D  20 B3 CE           JSR   GetPair           ; get integer expression and byte (no sign check)
03628    CE80  A5 AE              LDA   FAC1_2            ; get expression high byte
03629    CE82  A6 78              LDX   TempB             ; get shift count
03630    CE84  F0 22              BEQ   NoShift           ; branch if zero
03631    
03632    CE86  E0 10              CPX   #$10              ; compare bit count with 16d
03633    CE88  B0 23              BCS   TooBig            ; branch if >=
03634    
03635    Ls_loop
03636    CE8A  06 AF              ASL   FAC1_3            ; shift low byte
03637    CE8C  2A                 ROL                     ; shift high byte
03638    CE8D  CA                 DEX                     ; decrement bit count
03639    CE8E  D0 FA              BNE   Ls_loop           ; loop if shift not complete
03640    
03641    CE90  A4 AF              LDY   FAC1_3            ; get expression low byte
03642    CE92  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03643    
03644    ; perform >> (right shift)
03645    
03646    LAB_RSHIFT
03647    CE95  20 B3 CE           JSR   GetPair           ; get integer expression and byte (no sign check)
03648    CE98  A5 AE              LDA   FAC1_2            ; get expression high byte
03649    CE9A  A6 78              LDX   TempB             ; get shift count
03650    CE9C  F0 0A              BEQ   NoShift           ; branch if zero
03651    
03652    CE9E  E0 10              CPX   #$10              ; compare bit count with 16d
03653    CEA0  B0 0B              BCS   TooBig            ; branch if >=
03654    
03655    Rs_loop
03656    CEA2  4A                 LSR                     ; shift high byte
03657    CEA3  66 AF              ROR   FAC1_3            ; shift low byte
03658    CEA5  CA                 DEX                     ; decrement bit count
03659    CEA6  D0 FA              BNE   Rs_loop           ; loop if shift not complete
03660    
03661    NoShift
03662    CEA8  A4 AF              LDY   FAC1_3            ; get expression low byte
03663    CEAA  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03664    
03665    TooBig
03666    CEAD  A9 00              LDA   #$00              ; clear high byte
03667    CEAF  A8                 TAY                     ; copy to low byte
03668    CEB0  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03669    
03670    GetPair
03671    CEB3  20 A9 D5           JSR   LAB_EVBY          ; evaluate byte expression, result in X
03672    CEB6  86 78              STX   TempB             ; save it
03673    CEB8  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
03674    CEBB  4C BA CF           JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
03675    
03676    ; search for variable
03677    
03678    ; return pointer to variable in Cvaral/Cvarah
03679    
03680    LAB_GVAR
03681    CEBE  A2 00              LDX   #$00              ; set DIM flag = $00
03682    CEC0  20 C2 00           JSR   LAB_GBYT          ; scan memory (1st character)
03683    LAB_1D10
03684    CEC3  86 5E              STX   Defdim            ; save DIM flag
03685    LAB_1D12
03686    CEC5  85 93              STA   Varnm1            ; save 1st character
03687    CEC7  29 7F              AND   #$7F              ; clear FN flag bit
03688    CEC9  20 32 CF           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
03689    CECC  B0 03              BCS   LAB_1D1F          ; branch if ok
03690    
03691    CECE  4C 08 CD           JMP   LAB_SNER          ; else syntax error then warm start
03692    
03693                                  ; was variable name so ..
03694    LAB_1D1F
03695    CED1  A2 00              LDX   #$00              ; clear 2nd character temp
03696    CED3  86 5F              STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
03697    CED5  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (2nd character)
03698    CED8  90 05              BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
03699    
03700                                  ; 2nd character wasn't "0" to "9" so ..
03701    CEDA  20 32 CF           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
03702    CEDD  90 0B              BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
03703    
03704    LAB_1D2D
03705    CEDF  AA                 TAX                     ; copy 2nd character
03706    
03707                                  ; ignore further (valid) characters in the variable name
03708    LAB_1D2E
03709    CEE0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (3rd character)
03710    CEE3  90 FB              BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
03711    
03712    CEE5  20 32 CF           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
03713    CEE8  B0 F6              BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
03714    
03715                                  ; check if string variable
03716    LAB_1D38
03717    CEEA  C9 24              CMP   #'$'              ; compare with "$"
03718    CEEC  D0 0B              BNE   LAB_1D47          ; branch if not string
03719    
03720    ; to introduce a new variable type (% suffix for integers say) then this branch
03721    ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
03722    
03723                                  ; type is string
03724    CEEE  A9 FF              LDA   #$FF              ; set data type = string
03725    CEF0  85 5F              STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
03726    CEF2  8A                 TXA                     ; get 2nd character back
03727    CEF3  09 80              ORA   #$80              ; set top bit (indicate string var)
03728    CEF5  AA                 TAX                     ; copy back to 2nd character temp
03729    CEF6  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03730    
03731    ; after we have determined the variable type we need to come back here to determine
03732    ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
03733    
03734    
03735    LAB_1D47                      ; gets here with character after var name in A
03736    CEF9  86 94              STX   Varnm2            ; save 2nd character
03737    CEFB  05 61              ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
03738    CEFD  C9 28              CMP   #'('              ; compare with "("
03739    CEFF  D0 03              BNE   LAB_1D53          ; branch if not "("
03740    
03741    CF01  4C CC CF           JMP   LAB_1E17          ; go find, or make, array
03742    
03743    ; either find or create var
03744    ; var name (1st two characters only!) is in Varnm1,Varnm2
03745    
03746                                  ; variable name wasn't var(... so look for plain var
03747    LAB_1D53
03748    CF04  A9 00              LDA   #$00              ; clear A
03749    CF06  85 61              STA   Sufnxf            ; clear subscript/FNX flag
03750    CF08  A5 7B              LDA   Svarl             ; get start of vars low byte
03751    CF0A  A6 7C              LDX   Svarh             ; get start of vars high byte
03752    CF0C  A0 00              LDY   #$00              ; clear index
03753    LAB_1D5D
03754    CF0E  86 AB              STX   Vrschh            ; save search address high byte
03755    LAB_1D5F
03756    CF10  85 AA              STA   Vrschl            ; save search address low byte
03757    CF12  E4 7E              CPX   Sarryh            ; compare high address with var space end
03758    CF14  D0 04              BNE   LAB_1D69          ; skip next compare if <>
03759    
03760                                  ; high addresses were = so compare low addresses
03761    CF16  C5 7D              CMP   Sarryl            ; compare low address with var space end
03762    CF18  F0 2C              BEQ   LAB_1D8B          ; if not found go make new var
03763    
03764    LAB_1D69
03765    CF1A  A5 93              LDA   Varnm1            ; get 1st character of var to find
03766    CF1C  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 1st character
03767    CF1E  D0 08              BNE   LAB_1D77          ; branch if no match
03768    
03769                                  ; 1st characters match so compare 2nd characters
03770    CF20  A5 94              LDA   Varnm2            ; get 2nd character of var to find
03771    CF22  C8                 INY                     ; index to point to variable name 2nd character
03772    CF23  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 2nd character
03773    CF25  F0 69              BEQ   LAB_1DD7          ; branch if match (found var)
03774    
03775    CF27  88                 DEY                     ; else decrement index (now = $00)
03776    LAB_1D77
03777    CF28  18                 CLC                     ; clear carry for add
03778    CF29  A5 AA              LDA   Vrschl            ; get search address low byte
03779    CF2B  69 06              ADC   #$06              ; +6 (offset to next var name)
03780    CF2D  90 E1              BCC   LAB_1D5F          ; loop if no overflow to high byte
03781    
03782    CF2F  E8                 INX                     ; else increment high byte
03783    CF30  D0 DC              BNE   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
03784    
03785    ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
03786    
03787    LAB_CASC
03788    CF32  C9 61              CMP   #'a'              ; compare with "a"
03789    CF34  B0 0A              BCS   LAB_1D83          ; go check <"z"+1
03790    
03791    ; check byte, return C=0 if<"A" or >"Z"
03792    
03793    LAB_1D82
03794    CF36  C9 41              CMP   #'A'              ; compare with "A"
03795    CF38  90 05              BCC   LAB_1D8A          ; exit if less
03796    
03797                                  ; carry is set
03798    CF3A  E9 5B              SBC   #$5B              ; subtract "Z"+1
03799    CF3C  38                 SEC                     ; set carry
03800    CF3D  E9 A5              SBC   #$A5              ; subtract $A5 (restore byte)
03801                                  ; carry clear if byte>$5A
03802    LAB_1D8A
03803    CF3F  60                 RTS
03804    
03805    LAB_1D83
03806    CF40  E9 7B              SBC   #$7B              ; subtract "z"+1
03807    CF42  38                 SEC                     ; set carry
03808    CF43  E9 85              SBC   #$85              ; subtract $85 (restore byte)
03809                                  ; carry clear if byte>$7A
03810    CF45  60                 RTS
03811    
03812                                  ; reached end of variable mem without match
03813                                  ; .. so create new variable
03814    LAB_1D8B
03815    CF46  68                 PLA                     ; pop return address low byte
03816    CF47  48                 PHA                     ; push return address low byte
03817      CD4F             LAB_1C18p2  = LAB_1C18+2
03818    CF48  C9 4F              CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
03819    CF4A  D0 05              BNE   LAB_1D98          ; if not get (var) go create new var
03820    
03821    ; This will only drop through if the call was from LAB_1C18 and is only called
03822    ; from there if it is searching for a variable from the RHS of a LET a=b statement
03823    ; it prevents the creation of variables not assigned a value.
03824    
03825    ; value returned by this is either numeric zero (exponent byte is $00) or null string
03826    ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
03827    
03828    ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
03829    
03830    ; this is where you would put the undefined variable error call e.g.
03831    
03832    ;                             ; variable doesn't exist so flag error
03833    ;     LDX   #$24              ; error code $24 ("undefined variable" error)
03834    ;     JMP   LAB_XERR          ; do error #X then warm start
03835    
03836    ; the above code has been tested and works a treat! (it replaces the three code lines
03837    ; below)
03838    
03839                                  ; else return dummy null value
03840    CF4C  A9 F8              LDA   #<LAB_1D96        ; low byte point to $00,$00
03841                                  ; (uses part of misc constants table)
03842    CF4E  A0 E2              LDY   #>LAB_1D96        ; high byte point to $00,$00
03843    CF50  60                 RTS
03844    
03845                                  ; create new numeric variable
03846    LAB_1D98
03847    CF51  A5 7D              LDA   Sarryl            ; get var mem end low byte
03848    CF53  A4 7E              LDY   Sarryh            ; get var mem end high byte
03849    CF55  85 AA              STA   Ostrtl            ; save old block start low byte
03850    CF57  84 AB              STY   Ostrth            ; save old block start high byte
03851    CF59  A5 7F              LDA   Earryl            ; get array mem end low byte
03852    CF5B  A4 80              LDY   Earryh            ; get array mem end high byte
03853    CF5D  85 A6              STA   Obendl            ; save old block end low byte
03854    CF5F  84 A7              STY   Obendh            ; save old block end high byte
03855    CF61  18                 CLC                     ; clear carry for add
03856    CF62  69 06              ADC   #$06              ; +6 (space for one var)
03857    CF64  90 01              BCC   LAB_1DAE          ; branch if no overflow to high byte
03858    
03859    CF66  C8                 INY                     ; else increment high byte
03860    LAB_1DAE
03861    CF67  85 A4              STA   Nbendl            ; set new block end low byte
03862    CF69  84 A5              STY   Nbendh            ; set new block end high byte
03863    CF6B  20 C1 C1           JSR   LAB_11CF          ; open up space in memory
03864    CF6E  A5 A4              LDA   Nbendl            ; get new start low byte
03865    CF70  A4 A5              LDY   Nbendh            ; get new start high byte (-$100)
03866    CF72  C8                 INY                     ; correct high byte
03867    CF73  85 7D              STA   Sarryl            ; save new var mem end low byte
03868    CF75  84 7E              STY   Sarryh            ; save new var mem end high byte
03869    CF77  A0 00              LDY   #$00              ; clear index
03870    CF79  A5 93              LDA   Varnm1            ; get var name 1st character
03871    CF7B  91 AA              STA   (Vrschl),Y        ; save var name 1st character
03872    CF7D  C8                 INY                     ; increment index
03873    CF7E  A5 94              LDA   Varnm2            ; get var name 2nd character
03874    CF80  91 AA              STA   (Vrschl),Y        ; save var name 2nd character
03875    CF82  A9 00              LDA   #$00              ; clear A
03876    CF84  C8                 INY                     ; increment index
03877    CF85  91 AA              STA   (Vrschl),Y        ; initialise var byte
03878    CF87  C8                 INY                     ; increment index
03879    CF88  91 AA              STA   (Vrschl),Y        ; initialise var byte
03880    CF8A  C8                 INY                     ; increment index
03881    CF8B  91 AA              STA   (Vrschl),Y        ; initialise var byte
03882    CF8D  C8                 INY                     ; increment index
03883    CF8E  91 AA              STA   (Vrschl),Y        ; initialise var byte
03884    
03885                                  ; found a match for var ((Vrschl) = ptr)
03886    LAB_1DD7
03887    CF90  A5 AA              LDA   Vrschl            ; get var address low byte
03888    CF92  18                 CLC                     ; clear carry for add
03889    CF93  69 02              ADC   #$02              ; +2 (offset past var name bytes)
03890    CF95  A4 AB              LDY   Vrschh            ; get var address high byte
03891    CF97  90 01              BCC   LAB_1DE1          ; branch if no overflow from add
03892    
03893    CF99  C8                 INY                     ; else increment high byte
03894    LAB_1DE1
03895    CF9A  85 95              STA   Cvaral            ; save current var address low byte
03896    CF9C  84 96              STY   Cvarah            ; save current var address high byte
03897    CF9E  60                 RTS
03898    
03899    ; set-up array pointer (Adatal/h) to first element in array
03900    ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
03901    
03902    LAB_1DE6
03903    CF9F  A5 5D              LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
03904    CFA1  0A                 ASL                     ; *2 (also clears the carry !)
03905    CFA2  69 05              ADC   #$05              ; +5 (result is 7, 9 or 11 here)
03906    CFA4  65 AA              ADC   Astrtl            ; add array start pointer low byte
03907    CFA6  A4 AB              LDY   Astrth            ; get array pointer high byte
03908    CFA8  90 01              BCC   LAB_1DF2          ; branch if no overflow
03909    
03910    CFAA  C8                 INY                     ; else increment high byte
03911    LAB_1DF2
03912    CFAB  85 A4              STA   Adatal            ; save array data pointer low byte
03913    CFAD  84 A5              STY   Adatah            ; save array data pointer high byte
03914    CFAF  60                 RTS
03915    
03916    ; evaluate integer expression
03917    
03918    LAB_EVIN
03919    CFB0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03920    CFB3  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
03921                                  ; else do type mismatch
03922    
03923    ; evaluate integer expression (no check)
03924    
03925    LAB_EVPI
03926    CFB6  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
03927    CFB8  30 0D              BMI   LAB_1E12          ; do function call error if -ve
03928    
03929    ; evaluate integer expression (no sign check)
03930    
03931    LAB_EVIR
03932    CFBA  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03933    CFBC  C9 90              CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
03934    CFBE  90 09              BCC   LAB_1E14          ; branch if n<2^16 (is ok)
03935    
03936    CFC0  A9 FF              LDA   #<LAB_1DF7        ; set pointer low byte to -32768
03937    CFC2  A0 E2              LDY   #>LAB_1DF7        ; set pointer high byte to -32768
03938    CFC4  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
03939    LAB_1E12
03940    CFC7  D0 74              BNE   LAB_FCER          ; if <> do function call error then warm start
03941    
03942    LAB_1E14
03943    CFC9  4C 63 DA           JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
03944    
03945    ; find or make array
03946    
03947    LAB_1E17
03948    CFCC  A5 5E              LDA   Defdim            ; get DIM flag
03949    CFCE  48                 PHA                     ; push it
03950    CFCF  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
03951    CFD1  48                 PHA                     ; push it
03952    CFD2  A0 00              LDY   #$00              ; clear dimensions count
03953    
03954    ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
03955    
03956    LAB_1E1F
03957    CFD4  98                 TYA                     ; copy dimensions count
03958    CFD5  48                 PHA                     ; save it
03959    CFD6  A5 94              LDA   Varnm2            ; get array name 2nd byte
03960    CFD8  48                 PHA                     ; save it
03961    CFD9  A5 93              LDA   Varnm1            ; get array name 1st byte
03962    CFDB  48                 PHA                     ; save it
03963    CFDC  20 B0 CF           JSR   LAB_EVIN          ; evaluate integer expression
03964    CFDF  68                 PLA                     ; pull array name 1st byte
03965    CFE0  85 93              STA   Varnm1            ; restore array name 1st byte
03966    CFE2  68                 PLA                     ; pull array name 2nd byte
03967    CFE3  85 94              STA   Varnm2            ; restore array name 2nd byte
03968    CFE5  68                 PLA                     ; pull dimensions count
03969    CFE6  A8                 TAY                     ; restore it
03970    CFE7  BA                 TSX                     ; copy stack pointer
03971    CFE8  BD 02 01           LDA   LAB_STAK+2,X      ; get DIM flag
03972    CFEB  48                 PHA                     ; push it
03973    CFEC  BD 01 01           LDA   LAB_STAK+1,X      ; get data type flag
03974    CFEF  48                 PHA                     ; push it
03975    CFF0  A5 AE              LDA   FAC1_2            ; get this dimension size high byte
03976    CFF2  9D 02 01           STA   LAB_STAK+2,X      ; stack before flag bytes
03977    CFF5  A5 AF              LDA   FAC1_3            ; get this dimension size low byte
03978    CFF7  9D 01 01           STA   LAB_STAK+1,X      ; stack before flag bytes
03979    CFFA  C8                 INY                     ; increment dimensions count
03980    CFFB  20 C2 00           JSR   LAB_GBYT          ; scan memory
03981    CFFE  C9 2C              CMP   #','              ; compare with ","
03982    D000  F0 D2              BEQ   LAB_1E1F          ; if found go do next dimension
03983    
03984    D002  84 5D              STY   Dimcnt            ; store dimensions count
03985    D004  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
03986    D007  68                 PLA                     ; pull data type flag
03987    D008  85 5F              STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
03988    D00A  68                 PLA                     ; pull DIM flag
03989    D00B  85 5E              STA   Defdim            ; restore DIM flag
03990    D00D  A6 7D              LDX   Sarryl            ; get array mem start low byte
03991    D00F  A5 7E              LDA   Sarryh            ; get array mem start high byte
03992    
03993    ; now check to see if we are at the end of array memory (we would be if there were
03994    ; no arrays).
03995    
03996    LAB_1E5C
03997    D011  86 AA              STX   Astrtl            ; save as array start pointer low byte
03998    D013  85 AB              STA   Astrth            ; save as array start pointer high byte
03999    D015  C5 80              CMP   Earryh            ; compare with array mem end high byte
04000    D017  D0 04              BNE   LAB_1E68          ; branch if not reached array mem end
04001    
04002    D019  E4 7F              CPX   Earryl            ; else compare with array mem end low byte
04003    D01B  F0 39              BEQ   LAB_1EA1          ; go build array if not found
04004    
04005                                  ; search for array
04006    LAB_1E68
04007    D01D  A0 00              LDY   #$00              ; clear index
04008    D01F  B1 AA              LDA   (Astrtl),Y        ; get array name first byte
04009    D021  C8                 INY                     ; increment index to second name byte
04010    D022  C5 93              CMP   Varnm1            ; compare with this array name first byte
04011    D024  D0 06              BNE   LAB_1E77          ; branch if no match
04012    
04013    D026  A5 94              LDA   Varnm2            ; else get this array name second byte
04014    D028  D1 AA              CMP   (Astrtl),Y        ; compare with array name second byte
04015    D02A  F0 16              BEQ   LAB_1E8D          ; array found so branch
04016    
04017                                  ; no match
04018    LAB_1E77
04019    D02C  C8                 INY                     ; increment index
04020    D02D  B1 AA              LDA   (Astrtl),Y        ; get array size low byte
04021    D02F  18                 CLC                     ; clear carry for add
04022    D030  65 AA              ADC   Astrtl            ; add array start pointer low byte
04023    D032  AA                 TAX                     ; copy low byte to X
04024    D033  C8                 INY                     ; increment index
04025    D034  B1 AA              LDA   (Astrtl),Y        ; get array size high byte
04026    D036  65 AB              ADC   Astrth            ; add array mem pointer high byte
04027    D038  90 D7              BCC   LAB_1E5C          ; if no overflow go check next array
04028    
04029    ; do array bounds error
04030    
04031    LAB_1E85
04032    D03A  A2 10              LDX   #$10              ; error code $10 ("Array bounds" error)
04033          .byte $2C               ; makes next bit BIT LAB_08A2
04034    
04035    ; do function call error
04036    
04037    LAB_FCER
04038    D03D  A2 08              LDX   #$08              ; error code $08 ("Function call" error)
04039    LAB_1E8A
04040    D03F  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
04041    
04042                                  ; found array, are we trying to dimension it?
04043    LAB_1E8D
04044    D042  A2 12              LDX   #$12              ; set error $12 ("Double dimension" error)
04045    D044  A5 5E              LDA   Defdim            ; get DIM flag
04046    D046  D0 F7              BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
04047                                  ; start
04048    
04049    ; found the array and we're not dimensioning it so we must find an element in it
04050    
04051    D048  20 9F CF           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
04052                                  ; (Astrtl,Astrth points to start of array)
04053    D04B  A5 5D              LDA   Dimcnt            ; get dimensions count
04054    D04D  A0 04              LDY   #$04              ; set index to array's # of dimensions
04055    D04F  D1 AA              CMP   (Astrtl),Y        ; compare with no of dimensions
04056    D051  D0 E7              BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
04057                                  ; dimensions" error here .. if we want a different
04058                                  ; error message
04059    
04060    D053  4C D9 D0           JMP   LAB_1F28          ; found array so go get element
04061                                  ; (could jump to LAB_1F28 as all LAB_1F24 does is take
04062                                  ; Dimcnt and save it at (Astrtl),Y which is already the
04063                                  ; same or we would have taken the BNE)
04064    
04065                                  ; array not found, so build it
04066    LAB_1EA1
04067    D056  20 9F CF           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
04068                                  ; (Astrtl,Astrth points to start of array)
04069    D059  20 0E C2           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
04070                                  ; addr to check is in AY (low/high)
04071    D05C  A0 00              LDY   #$00              ; clear Y (don't need to clear A)
04072    D05E  84 BB              STY   Aspth             ; clear array data size high byte
04073    D060  A5 93              LDA   Varnm1            ; get variable name 1st byte
04074    D062  91 AA              STA   (Astrtl),Y        ; save array name 1st byte
04075    D064  C8                 INY                     ; increment index
04076    D065  A5 94              LDA   Varnm2            ; get variable name 2nd byte
04077    D067  91 AA              STA   (Astrtl),Y        ; save array name 2nd byte
04078    D069  A5 5D              LDA   Dimcnt            ; get dimensions count
04079    D06B  A0 04              LDY   #$04              ; index to dimension count
04080    D06D  84 BA              STY   Asptl             ; set array data size low byte (four bytes per element)
04081    D06F  91 AA              STA   (Astrtl),Y        ; set array's dimensions count
04082    
04083                                  ; now calculate the size of the data space for the array
04084    D071  18                 CLC                     ; clear carry for add (clear on subsequent loops)
04085    LAB_1EC0
04086    D072  A2 0B              LDX   #$0B              ; set default dimension value low byte
04087    D074  A9 00              LDA   #$00              ; set default dimension value high byte
04088    D076  24 5E              BIT   Defdim            ; test default DIM flag
04089    D078  50 07              BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
04090    
04091    D07A  68                 PLA                     ; else pull dimension value low byte
04092    D07B  69 01              ADC   #$01              ; +1 (allow for zeroeth element)
04093    D07D  AA                 TAX                     ; copy low byte to X
04094    D07E  68                 PLA                     ; pull dimension value high byte
04095    D07F  69 00              ADC   #$00              ; add carry from low byte
04096    
04097    LAB_1ED0
04098    D081  C8                 INY                     ; index to dimension value high byte
04099    D082  91 AA              STA   (Astrtl),Y        ; save dimension value high byte
04100    D084  C8                 INY                     ; index to dimension value high byte
04101    D085  8A                 TXA                     ; get dimension value low byte
04102    D086  91 AA              STA   (Astrtl),Y        ; save dimension value low byte
04103    D088  20 28 D1           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
04104    D08B  86 BA              STX   Asptl             ; save array data size low byte
04105    D08D  85 BB              STA   Aspth             ; save array data size high byte
04106    D08F  A4 71              LDY   ut1_pl            ; restore index (saved by subroutine)
04107    D091  C6 5D              DEC   Dimcnt            ; decrement dimensions count
04108    D093  D0 DD              BNE   LAB_1EC0          ; loop while not = 0
04109    
04110    D095  65 A5              ADC   Adatah            ; add size high byte to first element high byte
04111                                  ; (carry is always clear here)
04112    D097  B0 5D              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
04113    
04114    D099  85 A5              STA   Adatah            ; save end of array high byte
04115    D09B  A8                 TAY                     ; copy end high byte to Y
04116    D09C  8A                 TXA                     ; get array size low byte
04117    D09D  65 A4              ADC   Adatal            ; add array start low byte
04118    D09F  90 03              BCC   LAB_1EF3          ; branch if no carry
04119    
04120    D0A1  C8                 INY                     ; else increment end of array high byte
04121    D0A2  F0 52              BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
04122    
04123                                  ; set-up mostly complete, now zero the array
04124    LAB_1EF3
04125    D0A4  20 0E C2           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
04126                                  ; addr to check is in AY (low/high)
04127    D0A7  85 7F              STA   Earryl            ; save array mem end low byte
04128    D0A9  84 80              STY   Earryh            ; save array mem end high byte
04129    D0AB  A9 00              LDA   #$00              ; clear byte for array clear
04130    D0AD  E6 BB              INC   Aspth             ; increment array size high byte (now block count)
04131    D0AF  A4 BA              LDY   Asptl             ; get array size low byte (now index to block)
04132    D0B1  F0 05              BEQ   LAB_1F07          ; branch if low byte = $00
04133    
04134    LAB_1F02
04135    D0B3  88                 DEY                     ; decrement index (do 0 to n-1)
04136    D0B4  91 A4              STA   (Adatal),Y        ; zero byte
04137    D0B6  D0 FB              BNE   LAB_1F02          ; loop until this block done
04138    
04139    LAB_1F07
04140    D0B8  C6 A5              DEC   Adatah            ; decrement array pointer high byte
04141    D0BA  C6 BB              DEC   Aspth             ; decrement block count high byte
04142    D0BC  D0 F5              BNE   LAB_1F02          ; loop until all blocks done
04143    
04144    D0BE  E6 A5              INC   Adatah            ; correct for last loop
04145    D0C0  38                 SEC                     ; set carry for subtract
04146    D0C1  A0 02              LDY   #$02              ; index to array size low byte
04147    D0C3  A5 7F              LDA   Earryl            ; get array mem end low byte
04148    D0C5  E5 AA              SBC   Astrtl            ; subtract array start low byte
04149    D0C7  91 AA              STA   (Astrtl),Y        ; save array size low byte
04150    D0C9  C8                 INY                     ; index to array size high byte
04151    D0CA  A5 80              LDA   Earryh            ; get array mem end high byte
04152    D0CC  E5 AB              SBC   Astrth            ; subtract array start high byte
04153    D0CE  91 AA              STA   (Astrtl),Y        ; save array size high byte
04154    D0D0  A5 5E              LDA   Defdim            ; get default DIM flag
04155    D0D2  D0 53              BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
04156    
04157                                  ; else, find element
04158    D0D4  C8                 INY                     ; index to # of dimensions
04159    
04160    LAB_1F24
04161    D0D5  B1 AA              LDA   (Astrtl),Y        ; get array's dimension count
04162    D0D7  85 5D              STA   Dimcnt            ; save it
04163    
04164    ; we have found, or built, the array. now we need to find the element
04165    
04166    LAB_1F28
04167    D0D9  A9 00              LDA   #$00              ; clear byte
04168    D0DB  85 BA              STA   Asptl             ; clear array data pointer low byte
04169    LAB_1F2C
04170    D0DD  85 BB              STA   Aspth             ; save array data pointer high byte
04171    D0DF  C8                 INY                     ; increment index (point to array bound high byte)
04172    D0E0  68                 PLA                     ; pull array index low byte
04173    D0E1  AA                 TAX                     ; copy to X
04174    D0E2  85 AE              STA   FAC1_2            ; save index low byte to FAC1 mantissa2
04175    D0E4  68                 PLA                     ; pull array index high byte
04176    D0E5  85 AF              STA   FAC1_3            ; save index high byte to FAC1 mantissa3
04177    D0E7  D1 AA              CMP   (Astrtl),Y        ; compare with array bound high byte
04178    D0E9  90 0E              BCC   LAB_1F48          ; branch if within bounds
04179    
04180    D0EB  D0 06              BNE   LAB_1F42          ; if outside bounds do array bounds error
04181    
04182                                  ; else high byte was = so test low bytes
04183    D0ED  C8                 INY                     ; index to array bound low byte
04184    D0EE  8A                 TXA                     ; get array index low byte
04185    D0EF  D1 AA              CMP   (Astrtl),Y        ; compare with array bound low byte
04186    D0F1  90 07              BCC   LAB_1F49          ; branch if within bounds
04187    
04188    LAB_1F42
04189    D0F3  4C 3A D0           JMP   LAB_1E85          ; else do array bounds error
04190    
04191    LAB_1F45
04192    D0F6  4C 3D C2           JMP   LAB_OMER          ; do "Out of memory" error then warm start
04193    
04194    LAB_1F48
04195    D0F9  C8                 INY                     ; index to array bound low byte
04196    LAB_1F49
04197    D0FA  A5 BB              LDA   Aspth             ; get array data pointer high byte
04198    D0FC  05 BA              ORA   Asptl             ; OR with array data pointer low byte
04199    D0FE  F0 0A              BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
04200    
04201    D100  20 28 D1           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
04202    D103  8A                 TXA                     ; get result low byte
04203    D104  65 AE              ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
04204    D106  AA                 TAX                     ; save result low byte
04205    D107  98                 TYA                     ; get result high byte
04206    D108  A4 71              LDY   ut1_pl            ; restore index
04207    LAB_1F5A
04208    D10A  65 AF              ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
04209    D10C  86 BA              STX   Asptl             ; save array data pointer low byte
04210    D10E  C6 5D              DEC   Dimcnt            ; decrement dimensions count
04211    D110  D0 CB              BNE   LAB_1F2C          ; loop if dimensions still to do
04212    
04213    D112  06 BA              ASL   Asptl             ; array data pointer low byte * 2
04214    D114  2A                 ROL                     ; array data pointer high byte * 2
04215    D115  06 BA              ASL   Asptl             ; array data pointer low byte * 4
04216    D117  2A                 ROL                     ; array data pointer high byte * 4
04217    D118  A8                 TAY                     ; copy high byte
04218    D119  A5 BA              LDA   Asptl             ; get low byte
04219    D11B  65 A4              ADC   Adatal            ; add array data start pointer low byte
04220    D11D  85 95              STA   Cvaral            ; save as current var address low byte
04221    D11F  98                 TYA                     ; get high byte back
04222    D120  65 A5              ADC   Adatah            ; add array data start pointer high byte
04223    D122  85 96              STA   Cvarah            ; save as current var address high byte
04224    D124  A8                 TAY                     ; copy high byte to Y
04225    D125  A5 95              LDA   Cvaral            ; get current var address low byte
04226    LAB_1F7B
04227    D127  60                 RTS
04228    
04229    ; does XY = (Astrtl),Y * (Asptl)
04230    
04231    LAB_1F7C
04232    D128  84 71              STY   ut1_pl            ; save index
04233    D12A  B1 AA              LDA   (Astrtl),Y        ; get dimension size low byte
04234    D12C  85 76              STA   dims_l            ; save dimension size low byte
04235    D12E  88                 DEY                     ; decrement index
04236    D12F  B1 AA              LDA   (Astrtl),Y        ; get dimension size high byte
04237    D131  85 77              STA   dims_h            ; save dimension size high byte
04238    
04239    D133  A9 10              LDA   #$10              ; count = $10 (16 bit multiply)
04240    D135  85 A8              STA   numbit            ; save bit count
04241    D137  A2 00              LDX   #$00              ; clear result low byte
04242    D139  A0 00              LDY   #$00              ; clear result high byte
04243    LAB_1F8F
04244    D13B  8A                 TXA                     ; get result low byte
04245    D13C  0A                 ASL                     ; *2
04246    D13D  AA                 TAX                     ; save result low byte
04247    D13E  98                 TYA                     ; get result high byte
04248    D13F  2A                 ROL                     ; *2
04249    D140  A8                 TAY                     ; save result high byte
04250    D141  B0 B3              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
04251    
04252    D143  06 BA              ASL   Asptl             ; shift multiplier low byte
04253    D145  26 BB              ROL   Aspth             ; shift multiplier high byte
04254    D147  90 0B              BCC   LAB_1FA8          ; skip add if no carry
04255    
04256    D149  18                 CLC                     ; else clear carry for add
04257    D14A  8A                 TXA                     ; get result low byte
04258    D14B  65 76              ADC   dims_l            ; add dimension size low byte
04259    D14D  AA                 TAX                     ; save result low byte
04260    D14E  98                 TYA                     ; get result high byte
04261    D14F  65 77              ADC   dims_h            ; add dimension size high byte
04262    D151  A8                 TAY                     ; save result high byte
04263    D152  B0 A2              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
04264    
04265    LAB_1FA8
04266    D154  C6 A8              DEC   numbit            ; decrement bit count
04267    D156  D0 E3              BNE   LAB_1F8F          ; loop until all done
04268    
04269    D158  60                 RTS
04270    
04271    ; perform FRE()
04272    
04273    LAB_FRE
04274    D159  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
04275    D15B  10 03              BPL   LAB_1FB4          ; branch if numeric
04276    
04277    D15D  20 58 D4           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
04278                                  ; space returns with A = length, X=$71=pointer low byte,
04279                                  ; Y=$72=pointer high byte
04280    
04281                                  ; FRE(n) was numeric so do this
04282    LAB_1FB4
04283    D160  20 F5 D2           JSR   LAB_GARB          ; go do garbage collection
04284    D163  38                 SEC                     ; set carry for subtract
04285    D164  A5 81              LDA   Sstorl            ; get bottom of string space low byte
04286    D166  E5 7F              SBC   Earryl            ; subtract array mem end low byte
04287    D168  A8                 TAY                     ; copy result to Y
04288    D169  A5 82              LDA   Sstorh            ; get bottom of string space high byte
04289    D16B  E5 80              SBC   Earryh            ; subtract array mem end high byte
04290    
04291    ; save and convert integer AY to FAC1
04292    
04293    LAB_AYFC
04294    D16D  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
04295    D16F  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
04296    D171  84 AE              STY   FAC1_2            ; save FAC1 mantissa2
04297    D173  A2 90              LDX   #$90              ; set exponent=2^16 (integer)
04298    D175  4C 15 DA           JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
04299    
04300    ; perform POS()
04301    
04302    LAB_POS
04303    D178  A4 0E              LDY   TPos              ; get terminal position
04304    
04305    ; convert Y to byte in FAC1
04306    
04307    LAB_1FD0
04308    D17A  A9 00              LDA   #$00              ; clear high byte
04309    D17C  F0 EF              BEQ   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
04310    
04311    ; check not Direct (used by DEF and INPUT)
04312    
04313    LAB_CKRN
04314    D17E  A6 88              LDX   Clineh            ; get current line high byte
04315    D180  E8                 INX                     ; increment it
04316    D181  D0 A4              BNE   LAB_1F7B          ; return if can continue not direct mode
04317    
04318                                  ; else do illegal direct error
04319    LAB_1FD9
04320    D183  A2 16              LDX   #$16              ; error code $16 ("Illegal direct" error)
04321    LAB_1FDB
04322    D185  4C 3F C2           JMP   LAB_XERR          ; go do error #X, then warm start
04323    
04324    ; perform DEF
04325    
04326    LAB_DEF
04327    D188  20 B9 D1           JSR   LAB_200B          ; check FNx syntax
04328    D18B  85 9C              STA   func_l            ; save function pointer low byte
04329    D18D  84 9D              STY   func_h            ; save function pointer high byte
04330    D18F  20 7E D1           JSR   LAB_CKRN          ; check not Direct (back here if ok)
04331    D192  20 00 CD           JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
04332    D195  A9 80              LDA   #$80              ; set flag for FNx
04333    D197  85 61              STA   Sufnxf            ; save subscript/FNx flag
04334    D199  20 BE CE           JSR   LAB_GVAR          ; get (var) address
04335    D19C  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
04336    D19F  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
04337    D1A2  A9 C1              LDA   #TK_EQUAL         ; get = token
04338    D1A4  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
04339    D1A7  A5 96              LDA   Cvarah            ; get current var address high byte
04340    D1A9  48                 PHA                     ; push it
04341    D1AA  A5 95              LDA   Cvaral            ; get current var address low byte
04342    D1AC  48                 PHA                     ; push it
04343    D1AD  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
04344    D1AF  48                 PHA                     ; push it
04345    D1B0  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
04346    D1B2  48                 PHA                     ; push it
04347    D1B3  20 90 C7           JSR   LAB_DATA          ; go perform DATA
04348    D1B6  4C 28 D2           JMP   LAB_207A          ; put execute pointer and variable pointer into function
04349                                  ; and return
04350    
04351    ; check FNx syntax
04352    
04353    LAB_200B
04354    D1B9  A9 AE              LDA   #TK_FN            ; get FN" token
04355    D1BB  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
04356                                  ; return character after A
04357    D1BE  09 80              ORA   #$80              ; set FN flag bit
04358    D1C0  85 61              STA   Sufnxf            ; save FN flag so array variable test fails
04359    D1C2  20 C5 CE           JSR   LAB_1D12          ; search for FN variable
04360    D1C5  4C D6 CB           JMP   LAB_CTNM          ; check if source is numeric and return, else do type
04361                                  ; mismatch
04362    
04363                                  ; Evaluate FNx
04364    LAB_201E
04365    D1C8  20 B9 D1           JSR   LAB_200B          ; check FNx syntax
04366    D1CB  48                 PHA                     ; push function pointer low byte
04367    D1CC  98                 TYA                     ; copy function pointer high byte
04368    D1CD  48                 PHA                     ; push function pointer high byte
04369    D1CE  20 00 CD           JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
04370    D1D1  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
04371    D1D4  20 F5 CC           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
04372    D1D7  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
04373    D1DA  68                 PLA                     ; pop function pointer high byte
04374    D1DB  85 9D              STA   func_h            ; restore it
04375    D1DD  68                 PLA                     ; pop function pointer low byte
04376    D1DE  85 9C              STA   func_l            ; restore it
04377    D1E0  A2 20              LDX   #$20              ; error code $20 ("Undefined function" error)
04378    D1E2  A0 03              LDY   #$03              ; index to variable pointer high byte
04379    D1E4  B1 9C              LDA   (func_l),Y        ; get variable pointer high byte
04380    D1E6  F0 9D              BEQ   LAB_1FDB          ; if zero go do undefined function error
04381    
04382    D1E8  85 96              STA   Cvarah            ; save variable address high byte
04383    D1EA  88                 DEY                     ; index to variable address low byte
04384    D1EB  B1 9C              LDA   (func_l),Y        ; get variable address low byte
04385    D1ED  85 95              STA   Cvaral            ; save variable address low byte
04386    D1EF  AA                 TAX                     ; copy address low byte
04387    
04388                                  ; now stack the function variable value before use
04389    D1F0  C8                 INY                     ; index to mantissa_3
04390    LAB_2043
04391    D1F1  B1 95              LDA   (Cvaral),Y        ; get byte from variable
04392    D1F3  48                 PHA                     ; stack it
04393    D1F4  88                 DEY                     ; decrement index
04394    D1F5  10 FA              BPL   LAB_2043          ; loop until variable stacked
04395    
04396    D1F7  A4 96              LDY   Cvarah            ; get variable address high byte
04397    D1F9  20 BA D9           JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
04398                                  ; (function variable), return Y=0, always
04399    D1FC  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
04400    D1FE  48                 PHA                     ; push it
04401    D1FF  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
04402    D201  48                 PHA                     ; push it
04403    D202  B1 9C              LDA   (func_l),Y        ; get function execute pointer low byte
04404    D204  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
04405    D206  C8                 INY                     ; index to high byte
04406    D207  B1 9C              LDA   (func_l),Y        ; get function execute pointer high byte
04407    D209  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
04408    D20B  A5 96              LDA   Cvarah            ; get variable address high byte
04409    D20D  48                 PHA                     ; push it
04410    D20E  A5 95              LDA   Cvaral            ; get variable address low byte
04411    D210  48                 PHA                     ; push it
04412    D211  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
04413                                  ; else do type mismatch
04414    D214  68                 PLA                     ; pull variable address low byte
04415    D215  85 9C              STA   func_l            ; save variable address low byte
04416    D217  68                 PLA                     ; pull variable address high byte
04417    D218  85 9D              STA   func_h            ; save variable address high byte
04418    D21A  20 C2 00           JSR   LAB_GBYT          ; scan memory
04419    D21D  F0 03              BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
04420    
04421    D21F  4C 08 CD           JMP   LAB_SNER          ; else syntax error then warm start
04422    
04423    ; restore Bpntrl,Bpntrh and function variable from stack
04424    
04425    LAB_2074
04426    D222  68                 PLA                     ; pull BASIC execute pointer low byte
04427    D223  85 C3              STA   Bpntrl            ; restore BASIC execute pointer low byte
04428    D225  68                 PLA                     ; pull BASIC execute pointer high byte
04429    D226  85 C4              STA   Bpntrh            ; restore BASIC execute pointer high byte
04430    
04431    ; put execute pointer and variable pointer into function
04432    
04433    LAB_207A
04434    D228  A0 00              LDY   #$00              ; clear index
04435    D22A  68                 PLA                     ; pull BASIC execute pointer low byte
04436    D22B  91 9C              STA   (func_l),Y        ; save to function
04437    D22D  C8                 INY                     ; increment index
04438    D22E  68                 PLA                     ; pull BASIC execute pointer high byte
04439    D22F  91 9C              STA   (func_l),Y        ; save to function
04440    D231  C8                 INY                     ; increment index
04441    D232  68                 PLA                     ; pull current var address low byte
04442    D233  91 9C              STA   (func_l),Y        ; save to function
04443    D235  C8                 INY                     ; increment index
04444    D236  68                 PLA                     ; pull current var address high byte
04445    D237  91 9C              STA   (func_l),Y        ; save to function
04446    D239  60                 RTS
04447    
04448    ; perform STR$()
04449    
04450    LAB_STRS
04451    D23A  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
04452    D23D  20 A8 DB           JSR   LAB_296E          ; convert FAC1 to string
04453    D240  A9 F0              LDA   #<Decssp1         ; set result string low pointer
04454    D242  A0 00              LDY   #>Decssp1         ; set result string high pointer
04455    D244  F0 12              BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
04456    
04457    ; Do string vector
04458    ; copy des_pl/h to des_2l/h and make string space A bytes long
04459    
04460    LAB_209C
04461    D246  A6 AE              LDX   des_pl            ; get descriptor pointer low byte
04462    D248  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
04463    D24A  86 9E              STX   des_2l            ; save descriptor pointer low byte
04464    D24C  84 9F              STY   des_2h            ; save descriptor pointer high byte
04465    
04466    ; make string space A bytes long
04467    ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
04468    
04469    LAB_MSSP
04470    D24E  20 C3 D2           JSR   LAB_2115          ; make space in string memory for string A long
04471                                  ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
04472    D251  86 AD              STX   str_pl            ; save string pointer low byte
04473    D253  84 AE              STY   str_ph            ; save string pointer high byte
04474    D255  85 AC              STA   str_ln            ; save length
04475    D257  60                 RTS
04476    
04477    ; Scan, set up string
04478    ; print " terminated string to Sutill/Sutilh
04479    
04480    LAB_20AE
04481    D258  A2 22              LDX   #$22              ; set terminator to "
04482    D25A  86 5B              STX   Srchc             ; set search character (terminator 1)
04483    D25C  86 5C              STX   Asrch             ; set terminator 2
04484    
04485    ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
04486    ; source is AY
04487    
04488    LAB_20B4
04489    D25E  85 B8              STA   ssptr_l           ; store string start low byte
04490    D260  84 B9              STY   ssptr_h           ; store string start high byte
04491    D262  85 AD              STA   str_pl            ; save string pointer low byte
04492    D264  84 AE              STY   str_ph            ; save string pointer high byte
04493    D266  A0 FF              LDY   #$FF              ; set length to -1
04494    LAB_20BE
04495    D268  C8                 INY                     ; increment length
04496    D269  B1 B8              LDA   (ssptr_l),Y       ; get byte from string
04497    D26B  F0 0C              BEQ   LAB_20CF          ; exit loop if null byte [EOS]
04498    
04499    D26D  C5 5B              CMP   Srchc             ; compare with search character (terminator 1)
04500    D26F  F0 04              BEQ   LAB_20CB          ; branch if terminator
04501    
04502    D271  C5 5C              CMP   Asrch             ; compare with terminator 2
04503    D273  D0 F3              BNE   LAB_20BE          ; loop if not terminator 2
04504    
04505    LAB_20CB
04506    D275  C9 22              CMP   #$22              ; compare with "
04507    D277  F0 01              BEQ   LAB_20D0          ; branch if " (carry set if = !)
04508    
04509    LAB_20CF
04510    D279  18                 CLC                     ; clear carry for add (only if [EOL] terminated string)
04511    LAB_20D0
04512    D27A  84 AC              STY   str_ln            ; save length in FAC1 exponent
04513    D27C  98                 TYA                     ; copy length to A
04514    D27D  65 B8              ADC   ssptr_l           ; add string start low byte
04515    D27F  85 BA              STA   Sendl             ; save string end low byte
04516    D281  A6 B9              LDX   ssptr_h           ; get string start high byte
04517    D283  90 01              BCC   LAB_20DC          ; branch if no low byte overflow
04518    
04519    D285  E8                 INX                     ; else increment high byte
04520    LAB_20DC
04521    D286  86 BB              STX   Sendh             ; save string end high byte
04522    D288  A5 B9              LDA   ssptr_h           ; get string start high byte
04523    ; *** begin RAM above code / Ibuff above EhBASIC patch V2 ***
04524    ; *** replace
04525    ;      CMP   #>Ram_base        ; compare with start of program memory
04526    ;      BCS   LAB_RTST          ; branch if not in utility area
04527    ; *** with
04528    D28A  F0 04              BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
04529    D28C  C9 0B              CMP   #>Ibuffs          ; compare with location of input buffer page
04530    D28E  D0 0B              BNE   LAB_RTST          ; branch if not in utility area
04531    LAB_MVST      
04532    ; *** end   RAM above code / Ibuff above EhBASIC patch V2 ***
04533    
04534                                  ; string in utility area, move to string memory
04535    D290  98                 TYA                     ; copy length to A
04536    D291  20 46 D2           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
04537                                  ; long
04538    D294  A6 B8              LDX   ssptr_l           ; get string start low byte
04539    D296  A4 B9              LDY   ssptr_h           ; get string start high byte
04540    D298  20 39 D4           JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
04541    
04542    ; check for space on descriptor stack then ..
04543    ; put string address and length on descriptor stack and update stack pointers
04544    
04545    LAB_RTST
04546    D29B  A6 65              LDX   next_s            ; get string stack pointer
04547    D29D  E0 71              CPX   #des_sk+$09       ; compare with max+1
04548    D29F  D0 05              BNE   LAB_20F8          ; branch if space on string stack
04549    
04550                                  ; else do string too complex error
04551    D2A1  A2 1C              LDX   #$1C              ; error code $1C ("String too complex" error)
04552    LAB_20F5
04553    D2A3  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
04554    
04555    ; put string address and length on descriptor stack and update stack pointers
04556    
04557    LAB_20F8
04558    D2A6  A5 AC              LDA   str_ln            ; get string length
04559    D2A8  95 00              STA   PLUS_0,X          ; put on string stack
04560    D2AA  A5 AD              LDA   str_pl            ; get string pointer low byte
04561    D2AC  95 01              STA   PLUS_1,X          ; put on string stack
04562    D2AE  A5 AE              LDA   str_ph            ; get string pointer high byte
04563    D2B0  95 02              STA   PLUS_2,X          ; put on string stack
04564    D2B2  A0 00              LDY   #$00              ; clear Y
04565    D2B4  86 AE              STX   des_pl            ; save string descriptor pointer low byte
04566    D2B6  84 AF              STY   des_ph            ; save string descriptor pointer high byte (always $00)
04567    D2B8  88                 DEY                     ; Y = $FF
04568    D2B9  84 5F              STY   Dtypef            ; save data type flag, $FF=string
04569    D2BB  86 66              STX   last_sl           ; save old stack pointer (current top item)
04570    D2BD  E8                 INX                     ; update stack pointer
04571    D2BE  E8                 INX                     ; update stack pointer
04572    D2BF  E8                 INX                     ; update stack pointer
04573    D2C0  86 65              STX   next_s            ; save new top item value
04574    D2C2  60                 RTS
04575    
04576    ; Build descriptor
04577    ; make space in string memory for string A long
04578    ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
04579    
04580    LAB_2115
04581    D2C3  46 60              LSR   Gclctd            ; clear garbage collected flag (b7)
04582    
04583                                  ; make space for string A long
04584    LAB_2117
04585    D2C5  48                 PHA                     ; save string length
04586    D2C6  49 FF              EOR   #$FF              ; complement it
04587    D2C8  38                 SEC                     ; set carry for subtract (twos comp add)
04588    D2C9  65 81              ADC   Sstorl            ; add bottom of string space low byte (subtract length)
04589    D2CB  A4 82              LDY   Sstorh            ; get bottom of string space high byte
04590    D2CD  B0 01              BCS   LAB_2122          ; skip decrement if no underflow
04591    
04592    D2CF  88                 DEY                     ; decrement bottom of string space high byte
04593    LAB_2122
04594    D2D0  C4 80              CPY   Earryh            ; compare with array mem end high byte
04595    D2D2  90 11              BCC   LAB_2137          ; do out of memory error if less
04596    
04597    D2D4  D0 04              BNE   LAB_212C          ; if not = skip next test
04598    
04599    D2D6  C5 7F              CMP   Earryl            ; compare with array mem end low byte
04600    D2D8  90 0B              BCC   LAB_2137          ; do out of memory error if less
04601    
04602    LAB_212C
04603    D2DA  85 81              STA   Sstorl            ; save bottom of string space low byte
04604    D2DC  84 82              STY   Sstorh            ; save bottom of string space high byte
04605    D2DE  85 83              STA   Sutill            ; save string utility ptr low byte
04606    D2E0  84 84              STY   Sutilh            ; save string utility ptr high byte
04607    D2E2  AA                 TAX                     ; copy low byte to X
04608    D2E3  68                 PLA                     ; get string length back
04609    D2E4  60                 RTS
04610    
04611    LAB_2137
04612    D2E5  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
04613    D2E7  A5 60              LDA   Gclctd            ; get garbage collected flag
04614    D2E9  30 B8              BMI   LAB_20F5          ; if set then do error code X
04615    
04616    D2EB  20 F5 D2           JSR   LAB_GARB          ; else go do garbage collection
04617    D2EE  A9 80              LDA   #$80              ; flag for garbage collected
04618    D2F0  85 60              STA   Gclctd            ; set garbage collected flag
04619    D2F2  68                 PLA                     ; pull length
04620    D2F3  D0 D0              BNE   LAB_2117          ; go try again (loop always, length should never be = $00)
04621    
04622    ; garbage collection routine
04623    
04624    LAB_GARB
04625    D2F5  A6 85              LDX   Ememl             ; get end of mem low byte
04626    D2F7  A5 86              LDA   Ememh             ; get end of mem high byte
04627    
04628    ; re-run routine from last ending
04629    
04630    LAB_214B
04631    D2F9  86 81              STX   Sstorl            ; set string storage low byte
04632    D2FB  85 82              STA   Sstorh            ; set string storage high byte
04633    D2FD  A0 00              LDY   #$00              ; clear index
04634    D2FF  84 9D              STY   garb_h            ; clear working pointer high byte (flag no strings to move)
04635    ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
04636    ; *** add
04637    D301  84 9C              STY   garb_l            ; clear working pointer low byte (flag no strings to move)
04638    ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
04639    D303  A5 7F              LDA   Earryl            ; get array mem end low byte
04640    D305  A6 80              LDX   Earryh            ; get array mem end high byte
04641    D307  85 AA              STA   Histrl            ; save as highest string low byte
04642    D309  86 AB              STX   Histrh            ; save as highest string high byte
04643    D30B  A9 68              LDA   #des_sk           ; set descriptor stack pointer
04644    D30D  85 71              STA   ut1_pl            ; save descriptor stack pointer low byte
04645    D30F  84 72              STY   ut1_ph            ; save descriptor stack pointer high byte ($00)
04646    LAB_2161
04647    D311  C5 65              CMP   next_s            ; compare with descriptor stack pointer
04648    D313  F0 05              BEQ   LAB_216A          ; branch if =
04649    
04650    D315  20 7B D3           JSR   LAB_21D7          ; go garbage collect descriptor stack
04651    D318  F0 F7              BEQ   LAB_2161          ; loop always
04652    
04653                                  ; done stacked strings, now do string vars
04654    LAB_216A
04655    D31A  06 A0              ASL   g_step            ; set step size = $06
04656    D31C  A5 7B              LDA   Svarl             ; get start of vars low byte
04657    D31E  A6 7C              LDX   Svarh             ; get start of vars high byte
04658    D320  85 71              STA   ut1_pl            ; save as pointer low byte
04659    D322  86 72              STX   ut1_ph            ; save as pointer high byte
04660    LAB_2176
04661    D324  E4 7E              CPX   Sarryh            ; compare start of arrays high byte
04662    D326  D0 04              BNE   LAB_217E          ; branch if no high byte match
04663    
04664    D328  C5 7D              CMP   Sarryl            ; else compare start of arrays low byte
04665    D32A  F0 05              BEQ   LAB_2183          ; branch if = var mem end
04666    
04667    LAB_217E
04668    D32C  20 75 D3           JSR   LAB_21D1          ; go garbage collect strings
04669    D32F  F0 F3              BEQ   LAB_2176          ; loop always
04670    
04671                                  ; done string vars, now do string arrays
04672    LAB_2183
04673    D331  85 A4              STA   Nbendl            ; save start of arrays low byte as working pointer
04674    D333  86 A5              STX   Nbendh            ; save start of arrays high byte as working pointer
04675    D335  A9 04              LDA   #$04              ; set step size
04676    D337  85 A0              STA   g_step            ; save step size
04677    LAB_218B
04678    D339  A5 A4              LDA   Nbendl            ; get pointer low byte
04679    D33B  A6 A5              LDX   Nbendh            ; get pointer high byte
04680    LAB_218F
04681    D33D  E4 80              CPX   Earryh            ; compare with array mem end high byte
04682    D33F  D0 04              BNE   LAB_219A          ; branch if not at end
04683    
04684    D341  C5 7F              CMP   Earryl            ; else compare with array mem end low byte
04685    D343  F0 75              BEQ   LAB_2216          ; tidy up and exit if at end
04686    
04687    LAB_219A
04688    D345  85 71              STA   ut1_pl            ; save pointer low byte
04689    D347  86 72              STX   ut1_ph            ; save pointer high byte
04690    D349  A0 02              LDY   #$02              ; set index
04691    D34B  B1 71              LDA   (ut1_pl),Y        ; get array size low byte
04692    D34D  65 A4              ADC   Nbendl            ; add start of this array low byte
04693    D34F  85 A4              STA   Nbendl            ; save start of next array low byte
04694    D351  C8                 INY                     ; increment index
04695    D352  B1 71              LDA   (ut1_pl),Y        ; get array size high byte
04696    D354  65 A5              ADC   Nbendh            ; add start of this array high byte
04697    D356  85 A5              STA   Nbendh            ; save start of next array high byte
04698    D358  A0 01              LDY   #$01              ; set index
04699    D35A  B1 71              LDA   (ut1_pl),Y        ; get name second byte
04700    D35C  10 DB              BPL   LAB_218B          ; skip if not string array
04701    
04702    ; was string array so ..
04703    
04704    D35E  A0 04              LDY   #$04              ; set index
04705    D360  B1 71              LDA   (ut1_pl),Y        ; get # of dimensions
04706    D362  0A                 ASL                     ; *2
04707    D363  69 05              ADC   #$05              ; +5 (array header size)
04708    D365  20 AD D3           JSR   LAB_2208          ; go set up for first element
04709    LAB_21C4
04710    D368  E4 A5              CPX   Nbendh            ; compare with start of next array high byte
04711    D36A  D0 04              BNE   LAB_21CC          ; branch if <> (go do this array)
04712    
04713    D36C  C5 A4              CMP   Nbendl            ; else compare element pointer low byte with next array
04714                                  ; low byte
04715    D36E  F0 CD              BEQ   LAB_218F          ; if equal then go do next array
04716    
04717    LAB_21CC
04718    D370  20 7B D3           JSR   LAB_21D7          ; go defrag array strings
04719    D373  F0 F3              BEQ   LAB_21C4          ; go do next array string (loop always)
04720    
04721    ; defrag string variables
04722    ; enter with XA = variable pointer
04723    ; return with XA = next variable pointer
04724    
04725    LAB_21D1
04726    D375  C8                 INY                     ; increment index (Y was $00)
04727    D376  B1 71              LDA   (ut1_pl),Y        ; get var name byte 2
04728    D378  10 30              BPL   LAB_2206          ; if not string, step pointer to next var and return
04729    
04730    D37A  C8                 INY                     ; else increment index
04731    LAB_21D7
04732    D37B  B1 71              LDA   (ut1_pl),Y        ; get string length
04733    D37D  F0 2B              BEQ   LAB_2206          ; if null, step pointer to next string and return
04734    
04735    D37F  C8                 INY                     ; else increment index
04736    D380  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte
04737    D382  AA                 TAX                     ; copy to X
04738    D383  C8                 INY                     ; increment index
04739    D384  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte
04740    D386  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
04741    D388  90 06              BCC   LAB_21EC          ; branch if less
04742    
04743    D38A  D0 1E              BNE   LAB_2206          ; if greater, step pointer to next string and return
04744    
04745                                  ; high bytes were = so compare low bytes
04746    D38C  E4 81              CPX   Sstorl            ; compare bottom of string space low byte
04747    D38E  B0 1A              BCS   LAB_2206          ; if >=, step pointer to next string and return
04748    
04749                                  ; string pointer is < string storage pointer (pos in mem)
04750    LAB_21EC
04751    D390  C5 AB              CMP   Histrh            ; compare to highest string high byte
04752    D392  90 17              BCC   LAB_2207          ; if <, step pointer to next string and return
04753    
04754    D394  D0 04              BNE   LAB_21F6          ; if > update pointers, step to next and return
04755    
04756                                  ; high bytes were = so compare low bytes
04757    D396  E4 AA              CPX   Histrl            ; compare to highest string low byte
04758    D398  90 11              BCC   LAB_2207          ; if <, step pointer to next string and return
04759    
04760                                  ; string is in string memory space
04761    LAB_21F6
04762    D39A  86 AA              STX   Histrl            ; save as new highest string low byte
04763    D39C  85 AB              STA   Histrh            ; save as new highest string high byte
04764    D39E  A5 71              LDA   ut1_pl            ; get start of vars(descriptors) low byte
04765    D3A0  A6 72              LDX   ut1_ph            ; get start of vars(descriptors) high byte
04766    D3A2  85 9C              STA   garb_l            ; save as working pointer low byte
04767    D3A4  86 9D              STX   garb_h            ; save as working pointer high byte
04768    D3A6  88                 DEY                     ; decrement index DIFFERS
04769    D3A7  88                 DEY                     ; decrement index (should point to descriptor start)
04770    D3A8  84 A2              STY   g_indx            ; save index pointer
04771    
04772                                  ; step pointer to next string
04773    LAB_2206
04774    D3AA  18                 CLC                     ; clear carry for add
04775    LAB_2207
04776    D3AB  A5 A0              LDA   g_step            ; get step size
04777    LAB_2208
04778    D3AD  65 71              ADC   ut1_pl            ; add pointer low byte
04779    D3AF  85 71              STA   ut1_pl            ; save pointer low byte
04780    D3B1  90 02              BCC   LAB_2211          ; branch if no overflow
04781    
04782    D3B3  E6 72              INC   ut1_ph            ; else increment high byte
04783    LAB_2211
04784    D3B5  A6 72              LDX   ut1_ph            ; get pointer high byte
04785    D3B7  A0 00              LDY   #$00              ; clear Y
04786    D3B9  60                 RTS
04787    
04788    ; search complete, now either exit or set-up and move string
04789    
04790    LAB_2216
04791    D3BA  C6 A0              DEC   g_step            ; decrement step size (now $03 for descriptor stack)
04792    ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
04793    ; *** replace
04794    ;      LDX   garb_h            ; get string to move high byte
04795    ; *** with
04796    D3BC  A5 9D              LDA   garb_h            ; any string to move?
04797    D3BE  05 9C              ORA   garb_l
04798    ; *** end   patch  2.22p5.5  garbage collection may overlap temporary strings
04799    D3C0  F0 F3              BEQ   LAB_2211          ; exit if nothing to move
04800    
04801    D3C2  A4 A2              LDY   g_indx            ; get index byte back (points to descriptor)
04802    D3C4  18                 CLC                     ; clear carry for add
04803    D3C5  B1 9C              LDA   (garb_l),Y        ; get string length
04804    D3C7  65 AA              ADC   Histrl            ; add highest string low byte
04805    D3C9  85 A6              STA   Obendl            ; save old block end low pointer
04806    D3CB  A5 AB              LDA   Histrh            ; get highest string high byte
04807    D3CD  69 00              ADC   #$00              ; add any carry
04808    D3CF  85 A7              STA   Obendh            ; save old block end high byte
04809    D3D1  A5 81              LDA   Sstorl            ; get bottom of string space low byte
04810    D3D3  A6 82              LDX   Sstorh            ; get bottom of string space high byte
04811    D3D5  85 A4              STA   Nbendl            ; save new block end low byte
04812    D3D7  86 A5              STX   Nbendh            ; save new block end high byte
04813    D3D9  20 C8 C1           JSR   LAB_11D6          ; open up space in memory, don't set array end
04814    D3DC  A4 A2              LDY   g_indx            ; get index byte
04815    D3DE  C8                 INY                     ; point to descriptor low byte
04816    D3DF  A5 A4              LDA   Nbendl            ; get string pointer low byte
04817    D3E1  91 9C              STA   (garb_l),Y        ; save new string pointer low byte
04818    D3E3  AA                 TAX                     ; copy string pointer low byte
04819    D3E4  E6 A5              INC   Nbendh            ; correct high byte (move sets high byte -1)
04820    D3E6  A5 A5              LDA   Nbendh            ; get new string pointer high byte
04821    D3E8  C8                 INY                     ; point to descriptor high byte
04822    D3E9  91 9C              STA   (garb_l),Y        ; save new string pointer high byte
04823    D3EB  4C F9 D2           JMP   LAB_214B          ; re-run routine from last ending
04824                                  ; (but don't collect this string)
04825    
04826    ; concatenate
04827    ; add strings, string 1 is in descriptor des_pl, string 2 is in line
04828    
04829    LAB_224D
04830    D3EE  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
04831    D3F0  48                 PHA                     ; put on stack
04832    D3F1  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
04833    D3F3  48                 PHA                     ; put on stack
04834    ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
04835    ; *** add extra label to verify originating function
04836    LAB_224Da
04837    ; *** end patch    2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
04838    D3F4  20 D3 CC           JSR   LAB_GVAL          ; get value from line
04839    D3F7  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
04840    D3FA  68                 PLA                     ; get descriptor pointer low byte back
04841    D3FB  85 B8              STA   ssptr_l           ; set pointer low byte
04842    D3FD  68                 PLA                     ; get descriptor pointer high byte back
04843    D3FE  85 B9              STA   ssptr_h           ; set pointer high byte
04844    D400  A0 00              LDY   #$00              ; clear index
04845    D402  B1 B8              LDA   (ssptr_l),Y       ; get length_1 from descriptor
04846    D404  18                 CLC                     ; clear carry for add
04847    D405  71 AE              ADC   (des_pl),Y        ; add length_2
04848    D407  90 05              BCC   LAB_226D          ; branch if no overflow
04849    
04850    D409  A2 1A              LDX   #$1A              ; else set error code $1A ("String too long" error)
04851    D40B  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
04852    
04853    LAB_226D
04854    D40E  20 46 D2           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
04855                                  ; long
04856    D411  20 2B D4           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
04857    D414  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
04858    D416  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
04859    D418  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
04860                                  ; returns with A = length, ut1_pl = pointer low byte,
04861                                  ; ut1_ph = pointer high byte
04862    D41B  20 3D D4           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
04863    D41E  A5 B8              LDA   ssptr_l           ;.set descriptor pointer low byte
04864    D420  A4 B9              LDY   ssptr_h           ;.set descriptor pointer high byte
04865    D422  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
04866                                  ; returns with A = length, X=ut1_pl=pointer low byte,
04867                                  ; Y=ut1_ph=pointer high byte
04868    D425  20 9B D2           JSR   LAB_RTST          ; check for space on descriptor stack then put string
04869                                  ; address and length on descriptor stack and update stack
04870                                  ; pointers
04871    D428  4C FE CB           JMP   LAB_1ADB          ;.continue evaluation
04872    
04873    ; copy string from descriptor (sdescr) to (Sutill)
04874    
04875    LAB_228A
04876    D42B  A0 00              LDY   #$00              ; clear index
04877    D42D  B1 B8              LDA   (sdescr),Y        ; get string length
04878    D42F  48                 PHA                     ; save on stack
04879    D430  C8                 INY                     ; increment index
04880    D431  B1 B8              LDA   (sdescr),Y        ; get source string pointer low byte
04881    D433  AA                 TAX                     ; copy to X
04882    D434  C8                 INY                     ; increment index
04883    D435  B1 B8              LDA   (sdescr),Y        ; get source string pointer high byte
04884    D437  A8                 TAY                     ; copy to Y
04885    D438  68                 PLA                     ; get length back
04886    
04887    ; store string A bytes long from YX to (Sutill)
04888    
04889    LAB_2298
04890    D439  86 71              STX   ut1_pl            ; save source string pointer low byte
04891    D43B  84 72              STY   ut1_ph            ; save source string pointer high byte
04892    
04893    ; store string A bytes long from (ut1_pl) to (Sutill)
04894    
04895    LAB_229C
04896    D43D  AA                 TAX                     ; copy length to index (don't count with Y)
04897    D43E  F0 14              BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
04898    
04899    D440  A0 00              LDY   #$00              ; zero pointer (copy forward)
04900    LAB_22A0
04901    D442  B1 71              LDA   (ut1_pl),Y        ; get source byte
04902    D444  91 83              STA   (Sutill),Y        ; save destination byte
04903    
04904    D446  C8                 INY                     ; increment index
04905    D447  CA                 DEX                     ; decrement counter
04906    D448  D0 F8              BNE   LAB_22A0          ; loop while <> 0
04907    
04908    D44A  98                 TYA                     ; restore length from Y
04909    LAB_22A9
04910    D44B  18                 CLC                     ; clear carry for add
04911    D44C  65 83              ADC   Sutill            ; add string utility ptr low byte
04912    D44E  85 83              STA   Sutill            ; save string utility ptr low byte
04913    D450  90 02              BCC   LAB_22B2          ; branch if no carry
04914    
04915    D452  E6 84              INC   Sutilh            ; else increment string utility ptr high byte
04916    LAB_22B2
04917    D454  60                 RTS
04918    
04919    ; evaluate string
04920    
04921    LAB_EVST
04922    D455  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
04923    
04924    ; pop string off descriptor stack, or from top of string space
04925    ; returns with A = length, X=pointer low byte, Y=pointer high byte
04926    
04927    LAB_22B6
04928    D458  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
04929    D45A  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
04930    
04931    ; pop (YA) descriptor off stack or from top of string space
04932    ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
04933    
04934    LAB_22BA
04935    D45C  85 71              STA   ut1_pl            ; save descriptor pointer low byte
04936    D45E  84 72              STY   ut1_ph            ; save descriptor pointer high byte
04937    D460  20 8D D4           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
04938    D463  08                 PHP                     ; save status flags
04939    D464  A0 00              LDY   #$00              ; clear index
04940    D466  B1 71              LDA   (ut1_pl),Y        ; get length from string descriptor
04941    D468  48                 PHA                     ; put on stack
04942    D469  C8                 INY                     ; increment index
04943    D46A  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
04944    D46C  AA                 TAX                     ; copy to X
04945    D46D  C8                 INY                     ; increment index
04946    D46E  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
04947    D470  A8                 TAY                     ; copy to Y
04948    D471  68                 PLA                     ; get string length back
04949    D472  28                 PLP                     ; restore status
04950    D473  D0 13              BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
04951    
04952    D475  C4 82              CPY   Sstorh            ; compare bottom of string space high byte
04953    D477  D0 0F              BNE   LAB_22E6          ; branch if <>
04954    
04955    D479  E4 81              CPX   Sstorl            ; else compare bottom of string space low byte
04956    D47B  D0 0B              BNE   LAB_22E6          ; branch if <>
04957    
04958    D47D  48                 PHA                     ; save string length
04959    D47E  18                 CLC                     ; clear carry for add
04960    D47F  65 81              ADC   Sstorl            ; add bottom of string space low byte
04961    D481  85 81              STA   Sstorl            ; save bottom of string space low byte
04962    D483  90 02              BCC   LAB_22E5          ; skip increment if no overflow
04963    
04964    D485  E6 82              INC   Sstorh            ; increment bottom of string space high byte
04965    LAB_22E5
04966    D487  68                 PLA                     ; restore string length
04967    LAB_22E6
04968    D488  86 71              STX   ut1_pl            ; save string pointer low byte
04969    D48A  84 72              STY   ut1_ph            ; save string pointer high byte
04970    D48C  60                 RTS
04971    
04972    ; clean descriptor stack, YA = pointer
04973    ; checks if AY is on the descriptor stack, if so does a stack discard
04974    
04975    LAB_22EB
04976    D48D  C4 67              CPY   last_sh           ; compare pointer high byte
04977    D48F  D0 0C              BNE   LAB_22FB          ; exit if <>
04978    
04979    D491  C5 66              CMP   last_sl           ; compare pointer low byte
04980    D493  D0 08              BNE   LAB_22FB          ; exit if <>
04981    
04982    D495  85 65              STA   next_s            ; save descriptor stack pointer
04983    D497  E9 03              SBC   #$03              ; -3
04984    D499  85 66              STA   last_sl           ; save low byte -3
04985    D49B  A0 00              LDY   #$00              ; clear high byte
04986    LAB_22FB
04987    D49D  60                 RTS
04988    
04989    ; perform CHR$()
04990    
04991    LAB_CHRS
04992    D49E  20 A9 D5           JSR   LAB_EVBY          ; evaluate byte expression, result in X
04993    D4A1  8A                 TXA                     ; copy to A
04994    D4A2  48                 PHA                     ; save character
04995    D4A3  A9 01              LDA   #$01              ; string is single byte
04996    D4A5  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
04997                                  ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
04998    D4A8  68                 PLA                     ; get character back
04999    D4A9  A0 00              LDY   #$00              ; clear index
05000    D4AB  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
05001    D4AD  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put string
05002                                  ; address and length on descriptor stack and update stack
05003                                  ; pointers
05004    
05005    ; perform LEFT$()
05006    
05007    LAB_LEFT
05008    D4B0  48                 PHA                     ; push byte parameter
05009    D4B1  20 11 D5           JSR   LAB_236F          ; pull string data and byte parameter from stack
05010                                  ; return pointer in des_2l/h, byte in A (and X), Y=0
05011    D4B4  D1 9E              CMP   (des_2l),Y        ; compare byte parameter with string length
05012    D4B6  98                 TYA                     ; clear A
05013    D4B7  F0 09              BEQ   LAB_2316          ; go do string copy (branch always)
05014    
05015    ; perform RIGHT$()
05016    
05017    LAB_RIGHT
05018    D4B9  48                 PHA                     ; push byte parameter
05019    D4BA  20 11 D5           JSR   LAB_236F          ; pull string data and byte parameter from stack
05020                                  ; return pointer in des_2l/h, byte in A (and X), Y=0
05021    D4BD  18                 CLC                     ; clear carry for add-1
05022    D4BE  F1 9E              SBC   (des_2l),Y        ; subtract string length
05023    D4C0  49 FF              EOR   #$FF              ; invert it (A=LEN(expression$)-l)
05024    
05025    LAB_2316
05026    D4C2  90 04              BCC   LAB_231C          ; branch if string length > byte parameter
05027    
05028    D4C4  B1 9E              LDA   (des_2l),Y        ; else make parameter = length
05029    D4C6  AA                 TAX                     ; copy to byte parameter copy
05030    D4C7  98                 TYA                     ; clear string start offset
05031    LAB_231C
05032    D4C8  48                 PHA                     ; save string start offset
05033    LAB_231D
05034    D4C9  8A                 TXA                     ; copy byte parameter (or string length if <)
05035    LAB_231E
05036    D4CA  48                 PHA                     ; save string length
05037    D4CB  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
05038                                  ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
05039    D4CE  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
05040    D4D0  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
05041    D4D2  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
05042                                  ; returns with A = length, X=ut1_pl=pointer low byte,
05043                                  ; Y=ut1_ph=pointer high byte
05044    D4D5  68                 PLA                     ; get string length back
05045    D4D6  A8                 TAY                     ; copy length to Y
05046    D4D7  68                 PLA                     ; get string start offset back
05047    D4D8  18                 CLC                     ; clear carry for add
05048    D4D9  65 71              ADC   ut1_pl            ; add start offset to string start pointer low byte
05049    D4DB  85 71              STA   ut1_pl            ; save string start pointer low byte
05050    D4DD  90 02              BCC   LAB_2335          ; branch if no overflow
05051    
05052    D4DF  E6 72              INC   ut1_ph            ; else increment string start pointer high byte
05053    LAB_2335
05054    D4E1  98                 TYA                     ; copy length to A
05055    D4E2  20 3D D4           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
05056    D4E5  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put string
05057                                  ; address and length on descriptor stack and update stack
05058                                  ; pointers
05059    
05060    ; perform MID$()
05061    
05062    LAB_MIDS
05063    D4E8  48                 PHA                     ; push byte parameter
05064    D4E9  A9 FF              LDA   #$FF              ; set default length = 255
05065    D4EB  85 AF              STA   mids_l            ; save default length
05066    D4ED  20 C2 00           JSR   LAB_GBYT          ; scan memory
05067    D4F0  C9 29              CMP   #')'              ; compare with ")"
05068    D4F2  F0 06              BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
05069    
05070    D4F4  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05071    D4F7  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
05072    LAB_2358
05073    D4FA  20 11 D5           JSR   LAB_236F          ; pull string data and byte parameter from stack
05074                                  ; return pointer in des_2l/h, byte in A (and X), Y=0
05075    D4FD  CA                 DEX                     ; decrement start index
05076    D4FE  8A                 TXA                     ; copy to A
05077    D4FF  48                 PHA                     ; save string start offset
05078    D500  18                 CLC                     ; clear carry for sub-1
05079    D501  A2 00              LDX   #$00              ; clear output string length
05080    D503  F1 9E              SBC   (des_2l),Y        ; subtract string length
05081    D505  B0 C2              BCS   LAB_231D          ; if start>string length go do null string
05082    
05083    D507  49 FF              EOR   #$FF              ; complement -length
05084    D509  C5 AF              CMP   mids_l            ; compare byte parameter
05085    D50B  90 BD              BCC   LAB_231E          ; if length>remaining string go do RIGHT$
05086    
05087    D50D  A5 AF              LDA   mids_l            ; get length byte
05088    D50F  B0 B9              BCS   LAB_231E          ; go do string copy (branch always)
05089    
05090    ; pull string data and byte parameter from stack
05091    ; return pointer in des_2l/h, byte in A (and X), Y=0
05092    
05093    LAB_236F
05094    D511  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
05095    D514  68                 PLA                     ; pull return address low byte (return address)
05096    D515  85 A2              STA   Fnxjpl            ; save functions jump vector low byte
05097    D517  68                 PLA                     ; pull return address high byte (return address)
05098    D518  85 A3              STA   Fnxjph            ; save functions jump vector high byte
05099    D51A  68                 PLA                     ; pull byte parameter
05100    D51B  AA                 TAX                     ; copy byte parameter to X
05101    D51C  68                 PLA                     ; pull string pointer low byte
05102    D51D  85 9E              STA   des_2l            ; save it
05103    D51F  68                 PLA                     ; pull string pointer high byte
05104    D520  85 9F              STA   des_2h            ; save it
05105    D522  A0 00              LDY   #$00              ; clear index
05106    D524  8A                 TXA                     ; copy byte parameter
05107    D525  F0 79              BEQ   LAB_23A8          ; if null do function call error then warm start
05108    
05109    D527  E6 A2              INC   Fnxjpl            ; increment function jump vector low byte
05110                                  ; (JSR pushes return addr-1. this is all very nice
05111                                  ; but will go tits up if either call is on a page
05112                                  ; boundary!)
05113    D529  6C A2 00           JMP   (Fnxjpl)          ; in effect, RTS
05114    
05115    ; perform LCASE$()
05116    
05117    LAB_LCASE
05118    D52C  20 55 D4           JSR   LAB_EVST          ; evaluate string
05119    D52F  85 AC              STA   str_ln            ; set string length
05120    D531  A8                 TAY                     ; copy length to Y
05121    D532  F0 38              BEQ   NoString          ; branch if null string
05122    
05123    D534  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=length,
05124                                  ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
05125    D537  86 AD              STX   str_pl            ; save string pointer low byte
05126    D539  84 AE              STY   str_ph            ; save string pointer high byte
05127    D53B  A8                 TAY                     ; get string length back
05128    
05129    LC_loop
05130    D53C  88                 DEY                     ; decrement index
05131    D53D  B1 71              LDA   (ut1_pl),Y        ; get byte from string
05132    D53F  20 36 CF           JSR   LAB_1D82          ; is character "A" to "Z"
05133    D542  90 02              BCC   NoUcase           ; branch if not upper case alpha
05134    
05135    D544  09 20              ORA   #$20              ; convert upper to lower case
05136    NoUcase
05137    D546  91 83              STA   (Sutill),Y        ; save byte back to string
05138    D548  98                 TYA                     ; test index
05139    D549  D0 F1              BNE   LC_loop           ; loop if not all done
05140    
05141    D54B  F0 1F              BEQ   NoString          ; tidy up and exit, branch always
05142    
05143    ; perform UCASE$()
05144    
05145    LAB_UCASE
05146    D54D  20 55 D4           JSR   LAB_EVST          ; evaluate string
05147    D550  85 AC              STA   str_ln            ; set string length
05148    D552  A8                 TAY                     ; copy length to Y
05149    D553  F0 17              BEQ   NoString          ; branch if null string
05150    
05151    D555  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=length,
05152                                  ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
05153    D558  86 AD              STX   str_pl            ; save string pointer low byte
05154    D55A  84 AE              STY   str_ph            ; save string pointer high byte
05155    D55C  A8                 TAY                     ; get string length back
05156    
05157    UC_loop
05158    D55D  88                 DEY                     ; decrement index
05159    D55E  B1 71              LDA   (ut1_pl),Y        ; get byte from string
05160    D560  20 32 CF           JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
05161    D563  90 02              BCC   NoLcase           ; branch if not alpha
05162    
05163    D565  29 DF              AND   #$DF              ; convert lower to upper case
05164    NoLcase
05165    D567  91 83              STA   (Sutill),Y        ; save byte back to string
05166    D569  98                 TYA                     ; test index
05167    D56A  D0 F1              BNE   UC_loop           ; loop if not all done
05168    
05169    NoString
05170    D56C  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put string
05171                                  ; address and length on descriptor stack and update stack
05172                                  ; pointers
05173    
05174    ; perform SADD()
05175    
05176    LAB_SADD
05177    D56F  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
05178    D572  20 BE CE           JSR   LAB_GVAR          ; get var address
05179    
05180    D575  20 F5 CC           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
05181    D578  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
05182    
05183    D57B  A0 02              LDY   #$02              ; index to string pointer high byte
05184    D57D  B1 95              LDA   (Cvaral),Y        ; get string pointer high byte
05185    D57F  AA                 TAX                     ; copy string pointer high byte to X
05186    D580  88                 DEY                     ; index to string pointer low byte
05187    D581  B1 95              LDA   (Cvaral),Y        ; get string pointer low byte
05188    D583  A8                 TAY                     ; copy string pointer low byte to Y
05189    D584  8A                 TXA                     ; copy string pointer high byte to A
05190    D585  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
05191    
05192    ; perform LEN()
05193    
05194    LAB_LENS
05195    D588  20 8E D5           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
05196    D58B  4C 7A D1           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
05197    
05198    ; evaluate string, get length in Y
05199    
05200    LAB_ESGL
05201    D58E  20 55 D4           JSR   LAB_EVST          ; evaluate string
05202    D591  A8                 TAY                     ; copy length to Y
05203    D592  60                 RTS
05204    
05205    ; perform ASC()
05206    
05207    LAB_ASC
05208    D593  20 8E D5           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
05209    D596  F0 08              BEQ   LAB_23A8          ; if null do function call error then warm start
05210    
05211    D598  A0 00              LDY   #$00              ; set index to first character
05212    D59A  B1 71              LDA   (ut1_pl),Y        ; get byte
05213    D59C  A8                 TAY                     ; copy to Y
05214    D59D  4C 7A D1           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
05215    
05216    ; do function call error then warm start
05217    
05218    LAB_23A8
05219    D5A0  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
05220    
05221    ; scan and get byte parameter
05222    
05223    LAB_SGBY
05224    D5A3  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
05225    
05226    ; get byte parameter
05227    
05228    LAB_GTBY
05229    D5A6  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05230                                  ; else do type mismatch
05231    
05232    ; evaluate byte expression, result in X
05233    
05234    LAB_EVBY
05235    D5A9  20 B6 CF           JSR   LAB_EVPI          ; evaluate integer expression (no check)
05236    
05237    D5AC  A4 AE              LDY   FAC1_2            ; get FAC1 mantissa2
05238    D5AE  D0 F0              BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
05239    
05240    D5B0  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
05241    D5B2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
05242    
05243    ; perform VAL()
05244    
05245    LAB_VAL
05246    D5B5  20 8E D5           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
05247    D5B8  D0 03              BNE   LAB_23C5          ; branch if not null string
05248    
05249                                  ; string was null so set result = $00
05250    D5BA  4C 63 D7           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
05251    
05252    LAB_23C5
05253    ; *** begin patch  2.22p5.7  VAL() may cause string variables to be trashed
05254    ; *** replace     
05255    ;      LDX   Bpntrl            ; get BASIC execute pointer low byte
05256    ;      LDY   Bpntrh            ; get BASIC execute pointer high byte
05257    ;      STX   Btmpl             ; save BASIC execute pointer low byte
05258    ;      STY   Btmph             ; save BASIC execute pointer high byte
05259    ;      LDX   ut1_pl            ; get string pointer low byte
05260    ;      STX   Bpntrl            ; save as BASIC execute pointer low byte
05261    ;      CLC                     ; clear carry
05262    ;      ADC   ut1_pl            ; add string length
05263    ;      STA   ut2_pl            ; save string end low byte
05264    ;      LDA   ut1_ph            ; get string pointer high byte
05265    ;      STA   Bpntrh            ; save as BASIC execute pointer high byte
05266    ;      ADC   #$00              ; add carry to high byte
05267    ;      STA   ut2_ph            ; save string end high byte
05268    ;      LDY   #$00              ; set index to $00
05269    ;      LDA   (ut2_pl),Y        ; get string end +1 byte
05270    ;      PHA                     ; push it
05271    ;      TYA                     ; clear A
05272    ;      STA   (ut2_pl),Y        ; terminate string with $00
05273    ;      JSR   LAB_GBYT          ; scan memory
05274    ;      JSR   LAB_2887          ; get FAC1 from string
05275    ;      PLA                     ; restore string end +1 byte
05276    ;      LDY   #$00              ; set index to zero
05277    ;      STA   (ut2_pl),Y        ; put string end byte back
05278    ; *** with
05279    D5BD  48                 PHA                     ; save length
05280    D5BE  C8                 INY                     ; string length +1
05281    D5BF  98                 TYA
05282    D5C0  20 4E D2           JSR   LAB_MSSP          ; allocate temp string +1 bytes long
05283    D5C3  68                 PLA                     ; get length back
05284    D5C4  20 3D D4           JSR   LAB_229C          ; copy string (ut1_pl) -> (Sutill) for A bytes
05285    D5C7  A9 00              LDA   #0                ; add delimiter to end of string
05286    D5C9  A8                 TAY
05287    D5CA  91 83              STA   (Sutill),Y
05288    D5CC  A6 C3              LDX   Bpntrl            ; save BASIC execute pointer low byte
05289    D5CE  A4 C4              LDY   Bpntrh
05290    D5D0  86 BA              STX   Btmpl
05291    D5D2  84 BB              STY   Btmph
05292    D5D4  A6 AD              LDX   str_pl            ; point to temporary string
05293    D5D6  A4 AE              LDY   str_ph
05294    D5D8  86 C3              STX   Bpntrl
05295    D5DA  84 C4              STY   Bpntrh
05296    D5DC  20 C2 00           JSR   LAB_GBYT          ; scan memory
05297    D5DF  20 B9 DA           JSR   LAB_2887          ; get FAC1 from string
05298    ; *** end patch    2.22p5.7  VAL() may cause string variables to be trashed
05299    
05300    ; restore BASIC execute pointer from temp (Btmpl/Btmph)
05301    
05302    LAB_23F3
05303    D5E2  A6 BA              LDX   Btmpl             ; get BASIC execute pointer low byte back
05304    D5E4  A4 BB              LDY   Btmph             ; get BASIC execute pointer high byte back
05305    D5E6  86 C3              STX   Bpntrl            ; save BASIC execute pointer low byte
05306    D5E8  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
05307    D5EA  60                 RTS
05308    
05309    ; get two parameters for POKE or WAIT
05310    
05311    LAB_GADB
05312    D5EB  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05313                                  ; else do type mismatch
05314    D5EE  20 04 D6           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
05315    
05316    ; scan for "," and get byte, else do Syntax error then warm start
05317    
05318    LAB_SCGB
05319    D5F1  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05320    D5F4  A5 12              LDA   Itemph            ; save temporary integer high byte
05321    D5F6  48                 PHA                     ; on stack
05322    D5F7  A5 11              LDA   Itempl            ; save temporary integer low byte
05323    D5F9  48                 PHA                     ; on stack
05324    D5FA  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
05325    D5FD  68                 PLA                     ; pull low byte
05326    D5FE  85 11              STA   Itempl            ; restore temporary integer low byte
05327    D600  68                 PLA                     ; pull high byte
05328    D601  85 12              STA   Itemph            ; restore temporary integer high byte
05329    D603  60                 RTS
05330    
05331    ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
05332    ; -ve and converts it into a right truncated integer in Itempl and Itemph
05333    
05334    ; save unsigned 16 bit integer part of FAC1 in temporary integer
05335    
05336    LAB_F2FX
05337    D604  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05338    D606  C9 98              CMP   #$98              ; compare with exponent = 2^24
05339    D608  B0 96              BCS   LAB_23A8          ; if >= do function call error then warm start
05340    
05341    LAB_F2FU
05342    D60A  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
05343    D60D  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05344    D60F  A4 AF              LDY   FAC1_3            ; get FAC1 mantissa3
05345    D611  84 11              STY   Itempl            ; save temporary integer low byte
05346    D613  85 12              STA   Itemph            ; save temporary integer high byte
05347    D615  60                 RTS
05348    
05349    ; perform PEEK()
05350    
05351    LAB_PEEK
05352    D616  20 04 D6           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
05353    D619  A2 00              LDX   #$00              ; clear index
05354    D61B  A1 11              LDA   (Itempl,X)        ; get byte via temporary integer (addr)
05355    D61D  A8                 TAY                     ; copy byte to Y
05356    D61E  4C 7A D1           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
05357    
05358    ; perform POKE
05359    
05360    LAB_POKE
05361    D621  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
05362    D624  8A                 TXA                     ; copy byte argument to A
05363    D625  A2 00              LDX   #$00              ; clear index
05364    D627  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
05365    D629  60                 RTS
05366    
05367    ; perform DEEK()
05368    
05369    LAB_DEEK
05370    D62A  20 04 D6           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
05371    D62D  A2 00              LDX   #$00              ; clear index
05372    D62F  A1 11              LDA   (Itempl,X)        ; PEEK low byte
05373    D631  A8                 TAY                     ; copy to Y
05374    D632  E6 11              INC   Itempl            ; increment pointer low byte
05375    D634  D0 02              BNE   Deekh             ; skip high increment if no rollover
05376    
05377    D636  E6 12              INC   Itemph            ; increment pointer high byte
05378    Deekh
05379    D638  A1 11              LDA   (Itempl,X)        ; PEEK high byte
05380    D63A  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
05381    
05382    ; perform DOKE
05383    
05384    LAB_DOKE
05385    D63D  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05386                                  ; else do type mismatch
05387    D640  20 04 D6           JSR   LAB_F2FX          ; convert floating-to-fixed
05388    
05389    D643  84 97              STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
05390    D645  85 98              STA   Frnxth            ; save pointer high byte
05391    
05392    D647  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05393    D64A  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05394                                  ; else do type mismatch
05395    D64D  20 04 D6           JSR   LAB_F2FX          ; convert floating-to-fixed
05396    
05397    D650  98                 TYA                     ; copy value low byte (float to fixed returns word in AY)
05398    D651  A2 00              LDX   #$00              ; clear index
05399    D653  81 97              STA   (Frnxtl,X)        ; POKE low byte
05400    D655  E6 97              INC   Frnxtl            ; increment pointer low byte
05401    D657  D0 02              BNE   Dokeh             ; skip high increment if no rollover
05402    
05403    D659  E6 98              INC   Frnxth            ; increment pointer high byte
05404    Dokeh
05405    D65B  A5 12              LDA   Itemph            ; get value high byte
05406    D65D  81 97              STA   (Frnxtl,X)        ; POKE high byte
05407    D65F  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
05408    
05409    ; perform SWAP
05410    
05411    LAB_SWAP
05412    D662  20 BE CE           JSR   LAB_GVAR          ; get var1 address
05413    D665  85 97              STA   Lvarpl            ; save var1 address low byte
05414    D667  84 98              STY   Lvarph            ; save var1 address high byte
05415    D669  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
05416    D66B  48                 PHA                     ; save data type flag
05417    
05418    D66C  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05419    D66F  20 BE CE           JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
05420    D672  68                 PLA                     ; pull var1 data type flag
05421    D673  45 5F              EOR   Dtypef            ; compare with var2 data type
05422    D675  10 10              BPL   SwapErr           ; exit if not both the same type
05423    
05424    D677  A0 03              LDY   #$03              ; four bytes to swap (either value or descriptor+1)
05425    SwapLp
05426    D679  B1 97              LDA   (Lvarpl),Y        ; get byte from var1
05427    D67B  AA                 TAX                     ; save var1 byte
05428    D67C  B1 95              LDA   (Cvaral),Y        ; get byte from var2
05429    D67E  91 97              STA   (Lvarpl),Y        ; save byte to var1
05430    D680  8A                 TXA                     ; restore var1 byte
05431    D681  91 95              STA   (Cvaral),Y        ; save byte to var2
05432    D683  88                 DEY                     ; decrement index
05433    D684  10 F3              BPL   SwapLp            ; loop until done
05434    
05435    D686  60                 RTS
05436    
05437    SwapErr
05438    D687  4C E2 CB           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
05439    
05440    ; perform CALL
05441    
05442    LAB_CALL
05443    D68A  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05444                                  ; else do type mismatch
05445    D68D  20 04 D6           JSR   LAB_F2FX          ; convert floating-to-fixed
05446    D690  A9 D6              LDA   #>CallExit        ; set return address high byte
05447    D692  48                 PHA                     ; put on stack
05448    D693  A9 98              LDA   #<CallExit-1      ; set return address low byte
05449    D695  48                 PHA                     ; put on stack
05450    D696  6C 11 00           JMP   (Itempl)          ; do indirect jump to user routine
05451    
05452    ; if the called routine exits correctly then it will return to here. this will then get
05453    ; the next byte for the interpreter and return
05454    
05455    CallExit
05456    D699  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
05457    
05458    ; perform WAIT
05459    
05460    LAB_WAIT
05461    D69C  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
05462    D69F  86 97              STX   Frnxtl            ; save byte
05463    D6A1  A2 00              LDX   #$00              ; clear mask
05464    D6A3  20 C2 00           JSR   LAB_GBYT          ; scan memory
05465    D6A6  F0 03              BEQ   LAB_2441          ; skip if no third argument
05466    
05467    D6A8  20 F1 D5           JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
05468    LAB_2441
05469    D6AB  86 98              STX   Frnxth            ; save EOR argument
05470    LAB_2445
05471    D6AD  B1 11              LDA   (Itempl),Y        ; get byte via temporary integer (addr)
05472    D6AF  45 98              EOR   Frnxth            ; EOR with second argument (mask)
05473    D6B1  25 97              AND   Frnxtl            ; AND with first argument (byte)
05474    D6B3  F0 F8              BEQ   LAB_2445          ; loop if result is zero
05475    
05476    LAB_244D
05477    D6B5  60                 RTS
05478    
05479    ; perform subtraction, FAC1 from (AY)
05480    
05481    LAB_2455
05482    D6B6  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
05483    
05484    ; perform subtraction, FAC1 from FAC2
05485    
05486    LAB_SUBTRACT
05487    D6B9  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
05488    D6BB  49 FF              EOR   #$FF              ; complement it
05489    D6BD  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05490    D6BF  45 B7              EOR   FAC2_s            ; EOR with FAC2 sign (b7)
05491    D6C1  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
05492    D6C3  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05493    D6C5  4C D4 D6           JMP   LAB_ADD           ; go add FAC2 to FAC1
05494    
05495    ; perform addition
05496    
05497    LAB_2467
05498    D6C8  20 ED D7           JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
05499    D6CB  90 4D              BCC   LAB_24A8          ;.go subtract mantissas
05500    
05501    ; add 0.5 to FAC1
05502    
05503    LAB_244E
05504    D6CD  A9 00              LDA   #<LAB_2A96        ; set 0.5 pointer low byte
05505    D6CF  A0 E3              LDY   #>LAB_2A96        ; set 0.5 pointer high byte
05506    
05507    ; add (AY) to FAC1
05508    
05509    LAB_246C
05510    D6D1  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
05511    
05512    ; add FAC2 to FAC1
05513    
05514    LAB_ADD
05515    D6D4  D0 10              BNE   LAB_2474          ; branch if FAC1 was not zero
05516    
05517    ; copy FAC2 to FAC1
05518    
05519    LAB_279B
05520    D6D6  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
05521    
05522    ; save FAC1 sign and copy ABS(FAC2) to FAC1
05523    
05524    LAB_279D
05525    D6D8  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05526    D6DA  A2 04              LDX   #$04              ; 4 bytes to copy
05527    LAB_27A1
05528    D6DC  B5 B2              LDA   FAC1_o,X          ; get byte from FAC2,X
05529    D6DE  95 AB              STA   FAC1_e-1,X        ; save byte at FAC1,X
05530    D6E0  CA                 DEX                     ; decrement count
05531    D6E1  D0 F9              BNE   LAB_27A1          ; loop if not all done
05532    
05533    D6E3  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
05534    D6E5  60                 RTS
05535    
05536                                  ; FAC1 is non zero
05537    LAB_2474
05538    D6E6  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
05539    D6E8  86 A3              STX   FAC2_r            ; save as FAC2 rounding byte
05540    D6EA  A2 B3              LDX   #FAC2_e           ; set index to FAC2 exponent addr
05541    D6EC  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
05542    LAB_247C
05543    D6EE  A8                 TAY                     ; copy exponent
05544    D6EF  F0 C4              BEQ   LAB_244D          ; exit if zero
05545    
05546    D6F1  38                 SEC                     ; set carry for subtract
05547    D6F2  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
05548    D6F4  F0 24              BEQ   LAB_24A8          ; branch if = (go add mantissa)
05549    
05550    D6F6  90 12              BCC   LAB_2498          ; branch if <
05551    
05552                                  ; FAC2>FAC1
05553    D6F8  84 AC              STY   FAC1_e            ; save FAC1 exponent
05554    D6FA  A4 B7              LDY   FAC2_s            ; get FAC2 sign (b7)
05555    D6FC  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
05556    D6FE  49 FF              EOR   #$FF              ; complement A
05557    D700  69 00              ADC   #$00              ; +1 (twos complement, carry is set)
05558    D702  A0 00              LDY   #$00              ; clear Y
05559    D704  84 A3              STY   FAC2_r            ; clear FAC2 rounding byte
05560    D706  A2 AC              LDX   #FAC1_e           ; set index to FAC1 exponent addr
05561    D708  D0 04              BNE   LAB_249C          ; branch always
05562    
05563    LAB_2498
05564    D70A  A0 00              LDY   #$00              ; clear Y
05565    D70C  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
05566    LAB_249C
05567    D70E  C9 F9              CMP   #$F9              ; compare exponent diff with $F9
05568    D710  30 B6              BMI   LAB_2467          ; branch if range $79-$F8
05569    
05570    D712  A8                 TAY                     ; copy exponent difference to Y
05571    D713  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05572    D715  56 01              LSR   PLUS_1,X          ; shift FAC? mantissa1
05573    D717  20 04 D8           JSR   LAB_2592          ; shift FACX Y times right
05574    
05575                                  ; exponents are equal now do mantissa subtract
05576    LAB_24A8
05577    D71A  24 B8              BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
05578    D71C  10 4C              BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
05579    
05580    D71E  A0 AC              LDY   #FAC1_e           ; set index to FAC1 exponent addr
05581    D720  E0 B3              CPX   #FAC2_e           ; compare X to FAC2 exponent addr
05582    D722  F0 02              BEQ   LAB_24B4          ; branch if =
05583    
05584    D724  A0 B3              LDY   #FAC2_e           ; else set index to FAC2 exponent addr
05585    
05586                                  ; subtract smaller from bigger (take sign of bigger)
05587    LAB_24B4
05588    D726  38                 SEC                     ; set carry for subtract
05589    D727  49 FF              EOR   #$FF              ; ones complement A
05590    D729  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
05591    D72B  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
05592    D72D  B9 03 00           LDA   PLUS_3,Y          ; get FACY mantissa3
05593    D730  F5 03              SBC   PLUS_3,X          ; subtract FACX mantissa3
05594    D732  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
05595    D734  B9 02 00           LDA   PLUS_2,Y          ; get FACY mantissa2
05596    D737  F5 02              SBC   PLUS_2,X          ; subtract FACX mantissa2
05597    D739  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
05598    D73B  B9 01 00           LDA   PLUS_1,Y          ; get FACY mantissa1
05599    D73E  F5 01              SBC   PLUS_1,X          ; subtract FACX mantissa1
05600    D740  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
05601    
05602    ; do ABS and normalise FAC1
05603    
05604    LAB_24D0
05605    D742  B0 03              BCS   LAB_24D5          ; branch if number is +ve
05606    
05607    D744  20 A9 D7           JSR   LAB_2537          ; negate FAC1
05608    
05609    ; normalise FAC1
05610    
05611    LAB_24D5
05612    D747  A0 00              LDY   #$00              ; clear Y
05613    D749  98                 TYA                     ; clear A
05614    D74A  18                 CLC                     ; clear carry for add
05615    LAB_24D9
05616    D74B  A6 AD              LDX   FAC1_1            ; get FAC1 mantissa1
05617    D74D  D0 3E              BNE   LAB_251B          ; if not zero normalise FAC1
05618    
05619    D74F  A6 AE              LDX   FAC1_2            ; get FAC1 mantissa2
05620    D751  86 AD              STX   FAC1_1            ; save FAC1 mantissa1
05621    D753  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
05622    D755  86 AE              STX   FAC1_2            ; save FAC1 mantissa2
05623    D757  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
05624    D759  86 AF              STX   FAC1_3            ; save FAC1 mantissa3
05625    D75B  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
05626    D75D  69 08              ADC   #$08              ; add x to exponent offset
05627    D75F  C9 18              CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
05628    D761  D0 E8              BNE   LAB_24D9          ; loop if not max
05629    
05630    ; clear FAC1 exponent and sign
05631    
05632    LAB_24F1
05633    D763  A9 00              LDA   #$00              ; clear A
05634    LAB_24F3
05635    D765  85 AC              STA   FAC1_e            ; set FAC1 exponent
05636    
05637    ; save FAC1 sign
05638    
05639    LAB_24F5
05640    D767  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05641    D769  60                 RTS
05642    
05643    ; add FAC2 mantissa to FAC1 mantissa
05644    
05645    LAB_24F8
05646    D76A  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
05647    D76C  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
05648    D76E  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
05649    D770  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
05650    D772  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
05651    D774  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05652    D776  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
05653    D778  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
05654    D77A  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
05655    D77C  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
05656    D77E  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
05657    D780  B0 1A              BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
05658    
05659    D782  60                 RTS                     ; else just exit
05660    
05661    LAB_2511
05662    D783  69 01              ADC   #$01              ; add 1 to exponent offset
05663    D785  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
05664    D787  26 AF              ROL   FAC1_3            ; shift FAC1 mantissa3
05665    D789  26 AE              ROL   FAC1_2            ; shift FAC1 mantissa2
05666    D78B  26 AD              ROL   FAC1_1            ; shift FAC1 mantissa1
05667    
05668    ; normalise FAC1
05669    
05670    LAB_251B
05671    D78D  10 F4              BPL   LAB_2511          ; loop if not normalised
05672    
05673    D78F  38                 SEC                     ; set carry for subtract
05674    D790  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
05675    D792  B0 CF              BCS   LAB_24F1          ; branch if underflow (set result = $0)
05676    
05677    D794  49 FF              EOR   #$FF              ; complement exponent
05678    D796  69 01              ADC   #$01              ; +1 (twos complement)
05679    D798  85 AC              STA   FAC1_e            ; save FAC1 exponent
05680    
05681    ; test and normalise FAC1 for C=0/1
05682    
05683    LAB_2528
05684    D79A  90 0C              BCC   LAB_2536          ; exit if no overflow
05685    
05686    ; normalise FAC1 for C=1
05687    
05688    LAB_252A
05689    D79C  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
05690    D79E  F0 36              BEQ   LAB_2564          ; if zero do overflow error and warm start
05691    
05692    D7A0  66 AD              ROR   FAC1_1            ; shift FAC1 mantissa1
05693    D7A2  66 AE              ROR   FAC1_2            ; shift FAC1 mantissa2
05694    D7A4  66 AF              ROR   FAC1_3            ; shift FAC1 mantissa3
05695    D7A6  66 B9              ROR   FAC1_r            ; shift FAC1 rounding byte
05696    LAB_2536
05697    D7A8  60                 RTS
05698    
05699    ; negate FAC1
05700    
05701    LAB_2537
05702    D7A9  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
05703    D7AB  49 FF              EOR   #$FF              ; complement it
05704    D7AD  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05705    
05706    ; twos complement FAC1 mantissa
05707    
05708    LAB_253D
05709    D7AF  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
05710    D7B1  49 FF              EOR   #$FF              ; complement it
05711    D7B3  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
05712    D7B5  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05713    D7B7  49 FF              EOR   #$FF              ; complement it
05714    D7B9  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
05715    D7BB  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
05716    D7BD  49 FF              EOR   #$FF              ; complement it
05717    D7BF  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
05718    D7C1  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05719    D7C3  49 FF              EOR   #$FF              ; complement it
05720    D7C5  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
05721    D7C7  E6 B9              INC   FAC1_r            ; increment FAC1 rounding byte
05722    D7C9  D0 0A              BNE   LAB_2563          ; exit if no overflow
05723    
05724    ; increment FAC1 mantissa
05725    
05726    LAB_2559
05727    D7CB  E6 AF              INC   FAC1_3            ; increment FAC1 mantissa3
05728    D7CD  D0 06              BNE   LAB_2563          ; finished if no rollover
05729    
05730    D7CF  E6 AE              INC   FAC1_2            ; increment FAC1 mantissa2
05731    D7D1  D0 02              BNE   LAB_2563          ; finished if no rollover
05732    
05733    D7D3  E6 AD              INC   FAC1_1            ; increment FAC1 mantissa1
05734    LAB_2563
05735    D7D5  60                 RTS
05736    
05737    ; do overflow error (overflow exit)
05738    
05739    LAB_2564
05740    D7D6  A2 0A              LDX   #$0A              ; error code $0A ("Overflow" error)
05741    D7D8  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
05742    
05743    ; shift FCAtemp << A+8 times
05744    
05745    LAB_2569
05746    D7DB  A2 74              LDX   #FACt_1-1         ; set offset to FACtemp
05747    LAB_256B
05748    D7DD  B4 03              LDY   PLUS_3,X          ; get FACX mantissa3
05749    D7DF  84 B9              STY   FAC1_r            ; save as FAC1 rounding byte
05750    D7E1  B4 02              LDY   PLUS_2,X          ; get FACX mantissa2
05751    D7E3  94 03              STY   PLUS_3,X          ; save FACX mantissa3
05752    D7E5  B4 01              LDY   PLUS_1,X          ; get FACX mantissa1
05753    D7E7  94 02              STY   PLUS_2,X          ; save FACX mantissa2
05754    D7E9  A4 B2              LDY   FAC1_o            ; get FAC1 overflow byte
05755    D7EB  94 01              STY   PLUS_1,X          ; save FACX mantissa1
05756    
05757    ; shift FACX -A times right (> 8 shifts)
05758    
05759    LAB_257B
05760    D7ED  69 08              ADC   #$08              ; add 8 to shift count
05761    D7EF  30 EC              BMI   LAB_256B          ; go do 8 shift if still -ve
05762    
05763    D7F1  F0 EA              BEQ   LAB_256B          ; go do 8 shift if zero
05764    
05765    D7F3  E9 08              SBC   #$08              ; else subtract 8 again
05766    D7F5  A8                 TAY                     ; save count to Y
05767    D7F6  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05768    D7F8  B0 12              BCS   LAB_259A          ;.
05769    
05770    LAB_2588
05771    D7FA  16 01              ASL   PLUS_1,X          ; shift FACX mantissa1
05772    D7FC  90 02              BCC   LAB_258E          ; branch if +ve
05773    
05774    D7FE  F6 01              INC   PLUS_1,X          ; this sets b7 eventually
05775    LAB_258E
05776    D800  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
05777    D802  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
05778    
05779    ; shift FACX Y times right
05780    
05781    LAB_2592
05782    D804  76 02              ROR   PLUS_2,X          ; shift FACX mantissa2
05783    D806  76 03              ROR   PLUS_3,X          ; shift FACX mantissa3
05784    D808  6A                 ROR                     ; shift FACX rounding byte
05785    D809  C8                 INY                     ; increment exponent diff
05786    D80A  D0 EE              BNE   LAB_2588          ; branch if range adjust not complete
05787    
05788    LAB_259A
05789    D80C  18                 CLC                     ; just clear it
05790    D80D  60                 RTS
05791    
05792    ; perform LOG()
05793    
05794    LAB_LOG
05795    D80E  20 FC D9           JSR   LAB_27CA          ; test sign and zero
05796    D811  F0 02              BEQ   LAB_25C4          ; if zero do function call error then warm start
05797    
05798    D813  10 03              BPL   LAB_25C7          ; skip error if +ve
05799    
05800    LAB_25C4
05801    D815  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start (-ve)
05802    
05803    LAB_25C7
05804    D818  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05805    D81A  E9 7F              SBC   #$7F              ; normalise it
05806    D81C  48                 PHA                     ; save it
05807    D81D  A9 80              LDA   #$80              ; set exponent to zero
05808    D81F  85 AC              STA   FAC1_e            ; save FAC1 exponent
05809    D821  A9 80              LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
05810    D823  A0 E2              LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
05811    D825  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
05812    D828  A9 84              LDA   #<LAB_25B1        ; set root2 pointer low byte
05813    D82A  A0 E2              LDY   #>LAB_25B1        ; set root2 pointer high byte
05814    D82C  20 14 D9           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
05815    D82F  A9 F7              LDA   #<LAB_259C        ; set 1 pointer low byte
05816    D831  A0 E2              LDY   #>LAB_259C        ; set 1 pointer high byte
05817    D833  20 B6 D6           JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
05818    D836  A9 73              LDA   #<LAB_25A0        ; set pointer low byte to counter
05819    D838  A0 E2              LDY   #>LAB_25A0        ; set pointer high byte to counter
05820    D83A  20 64 DD           JSR   LAB_2B6E          ; ^2 then series evaluation
05821    D83D  A9 88              LDA   #<LAB_25B5        ; set -0.5 pointer low byte
05822    D83F  A0 E2              LDY   #>LAB_25B5        ; set -0.5 pointer high byte
05823    D841  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
05824    D844  68                 PLA                     ; restore FAC1 exponent
05825    D845  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
05826    D848  A9 8C              LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
05827    D84A  A0 E2              LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
05828    
05829    ; do convert AY, FCA1*(AY)
05830    
05831    LAB_25FB
05832    D84C  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
05833    LAB_MULTIPLY
05834    D84F  F0 4C              BEQ   LAB_264C          ; exit if zero
05835    
05836    D851  20 C4 D8           JSR   LAB_2673          ; test and adjust accumulators
05837    D854  A9 00              LDA   #$00              ; clear A
05838    D856  85 75              STA   FACt_1            ; clear temp mantissa1
05839    D858  85 76              STA   FACt_2            ; clear temp mantissa2
05840    D85A  85 77              STA   FACt_3            ; clear temp mantissa3
05841    D85C  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05842    D85E  20 73 D8           JSR   LAB_2622          ; go do shift/add FAC2
05843    D861  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
05844    D863  20 73 D8           JSR   LAB_2622          ; go do shift/add FAC2
05845    D866  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05846    D868  20 73 D8           JSR   LAB_2622          ; go do shift/add FAC2
05847    D86B  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
05848    D86D  20 79 D8           JSR   LAB_2627          ; go do shift/add FAC2
05849    D870  4C 81 D9           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
05850    
05851    LAB_2622
05852    D873  D0 04              BNE   LAB_2627          ; branch if byte <> zero
05853    ; *** begin patch  2.22p5.6  floating point multiply rounding bug
05854    ; *** replace
05855    ;      JMP   LAB_2569          ; shift FCAtemp << A+8 times
05856    ;
05857    ;                              ; else do shift and add
05858    ;LAB_2627
05859    ;      LSR                     ; shift byte
05860    ;      ORA   #$80              ; set top bit (mark for 8 times)
05861    ; *** with
05862    D875  38                 SEC
05863    D876  4C DB D7           JMP   LAB_2569          ; shift FACtemp << A+8 times
05864    
05865                                  ; else do shift and add
05866    LAB_2627
05867    D879  38                 SEC                     ; set top bit (mark for 8 times)
05868    D87A  6A                 ROR
05869    ; *** end patch    2.22p5.6  floating point multiply rounding bug
05870    LAB_262A
05871    D87B  A8                 TAY                     ; copy result
05872    D87C  90 13              BCC   LAB_2640          ; skip next if bit was zero
05873    
05874    D87E  18                 CLC                     ; clear carry for add
05875    D87F  A5 77              LDA   FACt_3            ; get temp mantissa3
05876    D881  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
05877    D883  85 77              STA   FACt_3            ; save temp mantissa3
05878    D885  A5 76              LDA   FACt_2            ; get temp mantissa2
05879    D887  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
05880    D889  85 76              STA   FACt_2            ; save temp mantissa2
05881    D88B  A5 75              LDA   FACt_1            ; get temp mantissa1
05882    D88D  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
05883    D88F  85 75              STA   FACt_1            ; save temp mantissa1
05884    LAB_2640
05885    D891  66 75              ROR   FACt_1            ; shift temp mantissa1
05886    D893  66 76              ROR   FACt_2            ; shift temp mantissa2
05887    D895  66 77              ROR   FACt_3            ; shift temp mantissa3
05888    D897  66 B9              ROR   FAC1_r            ; shift temp rounding byte
05889    D899  98                 TYA                     ; get byte back
05890    D89A  4A                 LSR                     ; shift byte
05891    D89B  D0 DE              BNE   LAB_262A          ; loop if all bits not done
05892    
05893    LAB_264C
05894    D89D  60                 RTS
05895    
05896    ; unpack memory (AY) into FAC2
05897    
05898    LAB_264D
05899    D89E  85 71              STA   ut1_pl            ; save pointer low byte
05900    D8A0  84 72              STY   ut1_ph            ; save pointer high byte
05901    D8A2  A0 03              LDY   #$03              ; 4 bytes to get (0-3)
05902    D8A4  B1 71              LDA   (ut1_pl),Y        ; get mantissa3
05903    D8A6  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
05904    D8A8  88                 DEY                     ; decrement index
05905    D8A9  B1 71              LDA   (ut1_pl),Y        ; get mantissa2
05906    D8AB  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
05907    D8AD  88                 DEY                     ; decrement index
05908    D8AE  B1 71              LDA   (ut1_pl),Y        ; get mantissa1+sign
05909    D8B0  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
05910    D8B2  45 B0              EOR   FAC1_s            ; EOR with FAC1 sign (b7)
05911    D8B4  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
05912    D8B6  A5 B7              LDA   FAC2_s            ; recover FAC2 sign (b7)
05913    D8B8  09 80              ORA   #$80              ; set 1xxx xxx (set normal bit)
05914    D8BA  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
05915    D8BC  88                 DEY                     ; decrement index
05916    D8BD  B1 71              LDA   (ut1_pl),Y        ; get exponent byte
05917    D8BF  85 B3              STA   FAC2_e            ; save FAC2 exponent
05918    D8C1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05919    D8C3  60                 RTS
05920    
05921    ; test and adjust accumulators
05922    
05923    LAB_2673
05924    D8C4  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
05925    LAB_2675
05926    D8C6  F0 1D              BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
05927    
05928    D8C8  18                 CLC                     ; clear carry for add
05929    D8C9  65 AC              ADC   FAC1_e            ; add FAC1 exponent
05930    D8CB  90 04              BCC   LAB_2680          ; branch if sum of exponents <$0100
05931    
05932    D8CD  30 31              BMI   LAB_269B          ; do overflow error
05933    
05934    D8CF  18                 CLC                     ; clear carry for the add
05935          .byte $2C               ; makes next line BIT $1410
05936    LAB_2680
05937    D8D1  10 12              BPL   LAB_2696          ; if +ve go handle underflow
05938    
05939    D8D3  69 80              ADC   #$80              ; adjust exponent
05940    D8D5  85 AC              STA   FAC1_e            ; save FAC1 exponent
05941    D8D7  D0 03              BNE   LAB_268B          ; branch if not zero
05942    
05943    D8D9  4C 67 D7           JMP   LAB_24F5          ; save FAC1 sign and return
05944    
05945    LAB_268B
05946    D8DC  A5 B8              LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
05947    D8DE  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05948    LAB_268F
05949    D8E0  60                 RTS
05950    
05951    ; handle overflow and underflow
05952    
05953    LAB_2690
05954    D8E1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
05955    D8E3  10 1B              BPL   LAB_269B          ; do overflow error
05956    
05957                                  ; handle underflow
05958    LAB_2696
05959    D8E5  68                 PLA                     ; pop return address low byte
05960    D8E6  68                 PLA                     ; pop return address high byte
05961    D8E7  4C 63 D7           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
05962    
05963    ; multiply by 10
05964    
05965    LAB_269E
05966    D8EA  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
05967    D8ED  AA                 TAX                     ; copy exponent (set the flags)
05968    D8EE  F0 F0              BEQ   LAB_268F          ; exit if zero
05969    
05970    D8F0  18                 CLC                     ; clear carry for add
05971    D8F1  69 02              ADC   #$02              ; add two to exponent (*4)
05972    D8F3  B0 0B              BCS   LAB_269B          ; do overflow error if > $FF
05973    
05974    D8F5  A2 00              LDX   #$00              ; clear byte
05975    D8F7  86 B8              STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
05976    D8F9  20 EE D6           JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
05977    D8FC  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*10)
05978    D8FE  D0 E0              BNE   LAB_268F          ; if non zero just do RTS
05979    
05980    LAB_269B
05981    D900  4C D6 D7           JMP   LAB_2564          ; do overflow error and warm start
05982    
05983    ; divide by 10
05984    
05985    LAB_26B9
05986    D903  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
05987    D906  A9 08              LDA   #<LAB_26B5        ; set pointer to 10d low addr
05988    D908  A0 E3              LDY   #>LAB_26B5        ; set pointer to 10d high addr
05989    D90A  A2 00              LDX   #$00              ; clear sign
05990    
05991    ; divide by (AY) (X=sign)
05992    
05993    LAB_26C2
05994    D90C  86 B8              STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
05995    D90E  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
05996    D911  4C 17 D9           JMP   LAB_DIVIDE        ; do FAC2/FAC1
05997    
05998                                  ; Perform divide-by
05999    ; convert AY and do (AY)/FAC1
06000    
06001    LAB_26CA
06002    D914  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
06003    
06004                                  ; Perform divide-into
06005    LAB_DIVIDE
06006    D917  F0 63              BEQ   LAB_2737          ; if zero go do /0 error
06007    
06008    D919  20 EC D9           JSR   LAB_27BA          ; round FAC1
06009    D91C  A9 00              LDA   #$00              ; clear A
06010    D91E  38                 SEC                     ; set carry for subtract
06011    D91F  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
06012    D921  85 AC              STA   FAC1_e            ; save FAC1 exponent
06013    D923  20 C4 D8           JSR   LAB_2673          ; test and adjust accumulators
06014    D926  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
06015    D928  F0 D6              BEQ   LAB_269B          ; if zero do overflow error
06016    
06017    D92A  A2 FF              LDX   #$FF              ; set index for pre increment
06018    D92C  A9 01              LDA   #$01              ; set bit to flag byte save
06019    LAB_26E4
06020    D92E  A4 B4              LDY   FAC2_1            ; get FAC2 mantissa1
06021    D930  C4 AD              CPY   FAC1_1            ; compare FAC1 mantissa1
06022    D932  D0 0A              BNE   LAB_26F4          ; branch if <>
06023    
06024    D934  A4 B5              LDY   FAC2_2            ; get FAC2 mantissa2
06025    D936  C4 AE              CPY   FAC1_2            ; compare FAC1 mantissa2
06026    D938  D0 04              BNE   LAB_26F4          ; branch if <>
06027    
06028    D93A  A4 B6              LDY   FAC2_3            ; get FAC2 mantissa3
06029    D93C  C4 AF              CPY   FAC1_3            ; compare FAC1 mantissa3
06030    LAB_26F4
06031    D93E  08                 PHP                     ; save FAC2-FAC1 compare status
06032    D93F  2A                 ROL                     ; shift the result byte
06033    D940  90 0E              BCC   LAB_2702          ; if no carry skip the byte save
06034    
06035    D942  A0 01              LDY   #$01              ; set bit to flag byte save
06036    D944  E8                 INX                     ; else increment the index to FACt
06037    D945  E0 02              CPX   #$02              ; compare with the index to FACt_3
06038    D947  30 04              BMI   LAB_2701          ; if not last byte just go save it
06039    
06040    D949  D0 28              BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
06041                                  ; return
06042    
06043    D94B  A0 40              LDY   #$40              ; set bit to flag byte save for the rounding byte
06044    LAB_2701
06045    D94D  95 75              STA   FACt_1,X          ; write result byte to FACt_1 + index
06046    D94F  98                 TYA                     ; copy the next save byte flag
06047    LAB_2702
06048    D950  28                 PLP                     ; restore FAC2-FAC1 compare status
06049    D951  90 14              BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
06050    
06051    D953  A8                 TAY                     ; save FAC2-FAC1 compare status
06052    D954  A5 B6              LDA   FAC2_3            ; get FAC2 mantissa3
06053    D956  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
06054    D958  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
06055    D95A  A5 B5              LDA   FAC2_2            ; get FAC2 mantissa2
06056    D95C  E5 AE              SBC   FAC1_2            ; subtract FAC1 mantissa2
06057    D95E  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
06058    D960  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
06059    D962  E5 AD              SBC   FAC1_1            ; subtract FAC1 mantissa1
06060    D964  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
06061    D966  98                 TYA                     ; restore FAC2-FAC1 compare status
06062    
06063                                  ; FAC2 = FAC2*2
06064    LAB_2704
06065    D967  06 B6              ASL   FAC2_3            ; shift FAC2 mantissa3
06066    D969  26 B5              ROL   FAC2_2            ; shift FAC2 mantissa2
06067    D96B  26 B4              ROL   FAC2_1            ; shift FAC2 mantissa1
06068    D96D  B0 CF              BCS   LAB_26F4          ; loop with no compare
06069    
06070    D96F  30 BD              BMI   LAB_26E4          ; loop with compare
06071    
06072    D971  10 CB              BPL   LAB_26F4          ; loop always with no compare
06073    
06074    ; do A<<6, save as FAC1 rounding byte, normalise and return
06075    
06076    LAB_272B
06077    D973  4A                 LSR                     ; shift b1 - b0 ..
06078    D974  6A                 ROR                     ; ..
06079    D975  6A                 ROR                     ; .. to b7 - b6
06080    D976  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
06081    D978  28                 PLP                     ; dump FAC2-FAC1 compare status
06082    D979  4C 81 D9           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
06083    
06084    ; do "Divide by zero" error
06085    
06086    LAB_2737
06087    D97C  A2 14              LDX   #$14              ; error code $14 ("Divide by zero" error)
06088    D97E  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
06089    
06090    ; copy temp to FAC1 and normalise
06091    
06092    LAB_273C
06093    D981  A5 75              LDA   FACt_1            ; get temp mantissa1
06094    D983  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06095    D985  A5 76              LDA   FACt_2            ; get temp mantissa2
06096    D987  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
06097    D989  A5 77              LDA   FACt_3            ; get temp mantissa3
06098    D98B  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
06099    D98D  4C 47 D7           JMP   LAB_24D5          ; normalise FAC1 and return
06100    
06101    ; unpack memory (AY) into FAC1
06102    
06103    LAB_UFAC
06104    D990  85 71              STA   ut1_pl            ; save pointer low byte
06105    D992  84 72              STY   ut1_ph            ; save pointer high byte
06106    D994  A0 03              LDY   #$03              ; 4 bytes to do
06107    D996  B1 71              LDA   (ut1_pl),Y        ; get last byte
06108    D998  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
06109    D99A  88                 DEY                     ; decrement index
06110    D99B  B1 71              LDA   (ut1_pl),Y        ; get last-1 byte
06111    D99D  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
06112    D99F  88                 DEY                     ; decrement index
06113    D9A0  B1 71              LDA   (ut1_pl),Y        ; get second byte
06114    D9A2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
06115    D9A4  09 80              ORA   #$80              ; set 1xxx xxxx (add normal bit)
06116    D9A6  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06117    D9A8  88                 DEY                     ; decrement index
06118    D9A9  B1 71              LDA   (ut1_pl),Y        ; get first byte (exponent)
06119    D9AB  85 AC              STA   FAC1_e            ; save FAC1 exponent
06120    D9AD  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
06121    D9AF  60                 RTS
06122    
06123    ; pack FAC1 into Adatal
06124    
06125    LAB_276E
06126    D9B0  A2 A4              LDX   #<Adatal          ; set pointer low byte
06127    LAB_2770
06128    D9B2  A0 00              LDY   #>Adatal          ; set pointer high byte
06129    D9B4  F0 04              BEQ   LAB_2778          ; pack FAC1 into (XY) and return
06130    
06131    ; pack FAC1 into (Lvarpl)
06132    
06133    LAB_PFAC
06134    D9B6  A6 97              LDX   Lvarpl            ; get destination pointer low byte
06135    D9B8  A4 98              LDY   Lvarph            ; get destination pointer high byte
06136    
06137    ; pack FAC1 into (XY)
06138    
06139    LAB_2778
06140    D9BA  20 EC D9           JSR   LAB_27BA          ; round FAC1
06141    D9BD  86 71              STX   ut1_pl            ; save pointer low byte
06142    D9BF  84 72              STY   ut1_ph            ; save pointer high byte
06143    D9C1  A0 03              LDY   #$03              ; set index
06144    D9C3  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
06145    D9C5  91 71              STA   (ut1_pl),Y        ; store in destination
06146    D9C7  88                 DEY                     ; decrement index
06147    D9C8  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
06148    D9CA  91 71              STA   (ut1_pl),Y        ; store in destination
06149    D9CC  88                 DEY                     ; decrement index
06150    D9CD  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06151    D9CF  09 7F              ORA   #$7F              ; set bits x111 1111
06152    D9D1  25 AD              AND   FAC1_1            ; AND in FAC1 mantissa1
06153    D9D3  91 71              STA   (ut1_pl),Y        ; store in destination
06154    D9D5  88                 DEY                     ; decrement index
06155    D9D6  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06156    D9D8  91 71              STA   (ut1_pl),Y        ; store in destination
06157    D9DA  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
06158    D9DC  60                 RTS
06159    
06160    ; round and copy FAC1 to FAC2
06161    
06162    LAB_27AB
06163    D9DD  20 EC D9           JSR   LAB_27BA          ; round FAC1
06164    
06165    ; copy FAC1 to FAC2
06166    
06167    LAB_27AE
06168    D9E0  A2 05              LDX   #$05              ; 5 bytes to copy
06169    LAB_27B0
06170    D9E2  B5 AB              LDA   FAC1_e-1,X        ; get byte from FAC1,X
06171    D9E4  95 B2              STA   FAC1_o,X          ; save byte at FAC2,X
06172    D9E6  CA                 DEX                     ; decrement count
06173    D9E7  D0 F9              BNE   LAB_27B0          ; loop if not all done
06174    
06175    D9E9  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
06176    LAB_27B9
06177    D9EB  60                 RTS
06178    
06179    ; round FAC1
06180    
06181    LAB_27BA
06182    D9EC  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06183    D9EE  F0 FB              BEQ   LAB_27B9          ; exit if zero
06184    
06185    D9F0  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
06186    D9F2  90 F7              BCC   LAB_27B9          ; exit if no overflow
06187    
06188    ; round FAC1 (no check)
06189    
06190    LAB_27C2
06191    D9F4  20 CB D7           JSR   LAB_2559          ; increment FAC1 mantissa
06192    D9F7  D0 F2              BNE   LAB_27B9          ; branch if no overflow
06193    
06194    D9F9  4C 9C D7           JMP   LAB_252A          ; normalise FAC1 for C=1 and return
06195    
06196    ; get FAC1 sign
06197    ; return A=FF,C=1/-ve A=01,C=0/+ve
06198    
06199    LAB_27CA
06200    D9FC  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06201    D9FE  F0 09              BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
06202    
06203    ; return A=FF,C=1/-ve A=01,C=0/+ve
06204    ; no = 0 check
06205    
06206    LAB_27CE
06207    DA00  A5 B0              LDA   FAC1_s            ; else get FAC1 sign (b7)
06208    
06209    ; return A=FF,C=1/-ve A=01,C=0/+ve
06210    ; no = 0 check, sign in A
06211    
06212    LAB_27D0
06213    DA02  2A                 ROL                     ; move sign bit to carry
06214    DA03  A9 FF              LDA   #$FF              ; set byte for -ve result
06215    DA05  B0 02              BCS   LAB_27D7          ; return if sign was set (-ve)
06216    
06217    DA07  A9 01              LDA   #$01              ; else set byte for +ve result
06218    LAB_27D7
06219    DA09  60                 RTS
06220    
06221    ; perform SGN()
06222    
06223    LAB_SGN
06224    DA0A  20 FC D9           JSR   LAB_27CA          ; get FAC1 sign
06225                                  ; return A=$FF/-ve A=$01/+ve
06226    ; save A as integer byte
06227    
06228    LAB_27DB
06229    DA0D  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06230    DA0F  A9 00              LDA   #$00              ; clear A
06231    DA11  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
06232    DA13  A2 88              LDX   #$88              ; set exponent
06233    
06234    ; set exp=X, clearFAC1 mantissa3 and normalise
06235    
06236    LAB_27E3
06237    DA15  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
06238    DA17  49 FF              EOR   #$FF              ; complement it
06239    DA19  2A                 ROL                     ; sign bit into carry
06240    
06241    ; set exp=X, clearFAC1 mantissa3 and normalise
06242    
06243    LAB_STFA
06244    DA1A  A9 00              LDA   #$00              ; clear A
06245    DA1C  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
06246    DA1E  86 AC              STX   FAC1_e            ; set FAC1 exponent
06247    DA20  85 B9              STA   FAC1_r            ; clear FAC1 rounding byte
06248    DA22  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
06249    DA24  4C 42 D7           JMP   LAB_24D0          ; do ABS and normalise FAC1
06250    
06251    ; perform ABS()
06252    
06253    LAB_ABS
06254    DA27  46 B0              LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
06255    DA29  60                 RTS
06256    
06257    ; compare FAC1 with (AY)
06258    ; returns A=$00 if FAC1 = (AY)
06259    ; returns A=$01 if FAC1 > (AY)
06260    ; returns A=$FF if FAC1 < (AY)
06261    
06262    LAB_27F8
06263    DA2A  85 73              STA   ut2_pl            ; save pointer low byte
06264    LAB_27FA
06265    DA2C  84 74              STY   ut2_ph            ; save pointer high byte
06266    DA2E  A0 00              LDY   #$00              ; clear index
06267    DA30  B1 73              LDA   (ut2_pl),Y        ; get exponent
06268    DA32  C8                 INY                     ; increment index
06269    DA33  AA                 TAX                     ; copy (AY) exponent to X
06270    DA34  F0 C6              BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
06271                                  ; A=FF,C=1/-ve A=01,C=0/+ve
06272    
06273    DA36  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
06274    DA38  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
06275    DA3A  30 C4              BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
06276                                  ; A=01,C=0/+ve and return
06277    
06278    DA3C  E4 AC              CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
06279    DA3E  D0 1A              BNE   LAB_2828          ; branch if different
06280    
06281    DA40  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
06282    DA42  09 80              ORA   #$80              ; normalise top bit
06283    DA44  C5 AD              CMP   FAC1_1            ; compare with FAC1 mantissa1
06284    DA46  D0 12              BNE   LAB_2828          ; branch if different
06285    
06286    DA48  C8                 INY                     ; increment index
06287    DA49  B1 73              LDA   (ut2_pl),Y        ; get mantissa2
06288    DA4B  C5 AE              CMP   FAC1_2            ; compare with FAC1 mantissa2
06289    DA4D  D0 0B              BNE   LAB_2828          ; branch if different
06290    
06291    DA4F  C8                 INY                     ; increment index
06292    DA50  A9 7F              LDA   #$7F              ; set for 1/2 value rounding byte
06293    DA52  C5 B9              CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
06294    DA54  B1 73              LDA   (ut2_pl),Y        ; get mantissa3
06295    DA56  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
06296    DA58  F0 28              BEQ   LAB_2850          ; exit if mantissa3 equal
06297    
06298    ; gets here if number <> FAC1
06299    
06300    LAB_2828
06301    DA5A  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06302    DA5C  90 02              BCC   LAB_282E          ; branch if FAC1 > (AY)
06303    
06304    DA5E  49 FF              EOR   #$FF              ; else toggle FAC1 sign
06305    LAB_282E
06306    DA60  4C 02 DA           JMP   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
06307    
06308    ; convert FAC1 floating-to-fixed
06309    
06310    LAB_2831
06311    DA63  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06312    DA65  F0 4A              BEQ   LAB_287F          ; if zero go clear FAC1 and return
06313    
06314    DA67  38                 SEC                     ; set carry for subtract
06315    DA68  E9 98              SBC   #$98              ; subtract maximum integer range exponent
06316    DA6A  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
06317    DA6C  10 09              BPL   LAB_2845          ; branch if FAC1 +ve
06318    
06319                                  ; FAC1 was -ve
06320    DA6E  AA                 TAX                     ; copy subtracted exponent
06321    DA6F  A9 FF              LDA   #$FF              ; overflow for -ve number
06322    DA71  85 B2              STA   FAC1_o            ; set FAC1 overflow byte
06323    DA73  20 AF D7           JSR   LAB_253D          ; twos complement FAC1 mantissa
06324    DA76  8A                 TXA                     ; restore subtracted exponent
06325    LAB_2845
06326    DA77  A2 AC              LDX   #FAC1_e           ; set index to FAC1
06327    DA79  C9 F9              CMP   #$F9              ; compare exponent result
06328    DA7B  10 06              BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
06329    
06330    DA7D  20 ED D7           JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
06331    DA80  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
06332    LAB_2850
06333    DA82  60                 RTS
06334    
06335    ; shift FAC1 A times right
06336    
06337    LAB_2851
06338    DA83  A8                 TAY                     ; copy shift count
06339    DA84  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06340    DA86  29 80              AND   #$80              ; mask sign bit only (x000 0000)
06341    DA88  46 AD              LSR   FAC1_1            ; shift FAC1 mantissa1
06342    DA8A  05 AD              ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
06343    DA8C  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06344    DA8E  20 04 D8           JSR   LAB_2592          ; shift FAC1 Y times right
06345    DA91  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
06346    DA93  60                 RTS
06347    
06348    ; perform INT()
06349    
06350    LAB_INT
06351    DA94  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06352    DA96  C9 98              CMP   #$98              ; compare with max int
06353    DA98  B0 1E              BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
06354    
06355    DA9A  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
06356    DA9D  84 B9              STY   FAC1_r            ; save FAC1 rounding byte
06357    DA9F  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06358    DAA1  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
06359    DAA3  49 80              EOR   #$80              ; toggle FAC1 sign
06360    DAA5  2A                 ROL                     ; shift into carry
06361    DAA6  A9 98              LDA   #$98              ; set new exponent
06362    DAA8  85 AC              STA   FAC1_e            ; save FAC1 exponent
06363    DAAA  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
06364    DAAC  85 5B              STA   Temp3             ; save for EXP() function
06365    DAAE  4C 42 D7           JMP   LAB_24D0          ; do ABS and normalise FAC1
06366    
06367    ; clear FAC1 and return
06368    
06369    LAB_287F
06370    DAB1  85 AD              STA   FAC1_1            ; clear FAC1 mantissa1
06371    DAB3  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
06372    DAB5  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
06373    DAB7  A8                 TAY                     ; clear Y
06374    LAB_2886
06375    DAB8  60                 RTS
06376    
06377    ; get FAC1 from string
06378    ; this routine now handles hex and binary values from strings
06379    ; starting with "$" and "%" respectively
06380    
06381    LAB_2887
06382    DAB9  A0 00              LDY   #$00              ; clear Y
06383    DABB  84 5F              STY   Dtypef            ; clear data type flag, $FF=string, $00=numeric
06384    DABD  A2 09              LDX   #$09              ; set index
06385    LAB_288B
06386    DABF  94 A8              STY   numexp,X          ; clear byte
06387    DAC1  CA                 DEX                     ; decrement index
06388    DAC2  10 FB              BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
06389    
06390    DAC4  90 7F              BCC   LAB_28FE          ; branch if 1st character numeric
06391    
06392    ; get FAC1 from string .. first character wasn't numeric
06393    
06394    DAC6  C9 2D              CMP   #'-'              ; else compare with "-"
06395    DAC8  D0 04              BNE   LAB_289A          ; branch if not "-"
06396    
06397    DACA  86 B1              STX   negnum            ; set flag for -ve number (X = $FF)
06398    DACC  F0 04              BEQ   LAB_289C          ; branch always (go scan and check for hex/bin)
06399    
06400    ; get FAC1 from string .. first character wasn't numeric or -
06401    
06402    LAB_289A
06403    DACE  C9 2B              CMP   #'+'              ; else compare with "+"
06404    DAD0  D0 05              BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
06405    
06406    ; was "+" or "-" to start, so get next character
06407    
06408    LAB_289C
06409    DAD2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
06410    DAD5  90 6E              BCC   LAB_28FE          ; branch if numeric character
06411    
06412    ; code here for hex and binary numbers
06413    
06414    LAB_289D
06415    DAD7  C9 24              CMP   #'$'              ; else compare with "$"
06416    DAD9  D0 03              BNE   LAB_NHEX          ; branch if not "$"
06417    
06418    DADB  4C 83 DF           JMP   LAB_CHEX          ; branch if "$"
06419    
06420    LAB_NHEX
06421    DADE  C9 25              CMP   #'%'              ; else compare with "%"
06422    DAE0  D0 08              BNE   LAB_28A3          ; branch if not "%" (continue original code)
06423    
06424    DAE2  4C B1 DF           JMP   LAB_CBIN          ; branch if "%"
06425    
06426    LAB_289E
06427    DAE5  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
06428    LAB_28A1
06429    DAE8  90 5B              BCC   LAB_28FE          ; branch if numeric character
06430    
06431    ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
06432    
06433    LAB_28A3
06434    DAEA  C9 2E              CMP   #'.'              ; else compare with "."
06435    DAEC  F0 2E              BEQ   LAB_28D5          ; branch if "."
06436    
06437    ; get FAC1 from string .. character wasn't numeric, -, + or .
06438    
06439    DAEE  C9 45              CMP   #'E'              ; else compare with "E"
06440    DAF0  D0 30              BNE   LAB_28DB          ; branch if not "E"
06441    
06442                                  ; was "E" so evaluate exponential part
06443    DAF2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
06444    DAF5  90 17              BCC   LAB_28C7          ; branch if numeric character
06445    
06446    DAF7  C9 B7              CMP   #TK_MINUS         ; else compare with token for -
06447    DAF9  F0 0E              BEQ   LAB_28C2          ; branch if token for -
06448    
06449    DAFB  C9 2D              CMP   #'-'              ; else compare with "-"
06450    DAFD  F0 0A              BEQ   LAB_28C2          ; branch if "-"
06451    
06452    DAFF  C9 B6              CMP   #TK_PLUS          ; else compare with token for +
06453    DB01  F0 08              BEQ   LAB_28C4          ; branch if token for +
06454    
06455    DB03  C9 2B              CMP   #'+'              ; else compare with "+"
06456    DB05  F0 04              BEQ   LAB_28C4          ; branch if "+"
06457    
06458    DB07  D0 07              BNE   LAB_28C9          ; branch always
06459    
06460    LAB_28C2
06461    DB09  66 AB              ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
06462    LAB_28C4
06463    DB0B  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
06464    LAB_28C7
06465    DB0E  90 5B              BCC   LAB_2925          ; branch if numeric character
06466    
06467    LAB_28C9
06468    DB10  24 AB              BIT   expneg            ; test exponent -ve flag
06469    DB12  10 0E              BPL   LAB_28DB          ; if +ve go evaluate exponent
06470    
06471                                  ; else do exponent = -exponent 
06472    DB14  A9 00              LDA   #$00              ; clear result
06473    DB16  38                 SEC                     ; set carry for subtract
06474    DB17  E5 A9              SBC   expcnt            ; subtract exponent byte
06475    DB19  4C 24 DB           JMP   LAB_28DD          ; go evaluate exponent
06476    
06477    LAB_28D5
06478    DB1C  66 AA              ROR   numdpf            ; set decimal point flag
06479    DB1E  24 AA              BIT   numdpf            ; test decimal point flag
06480    DB20  50 C3              BVC   LAB_289E          ; branch if only one decimal point so far
06481    
06482                                  ; evaluate exponent
06483    LAB_28DB
06484    DB22  A5 A9              LDA   expcnt            ; get exponent count byte
06485    LAB_28DD
06486    DB24  38                 SEC                     ; set carry for subtract
06487    DB25  E5 A8              SBC   numexp            ; subtract numerator exponent
06488    DB27  85 A9              STA   expcnt            ; save exponent count byte
06489    DB29  F0 12              BEQ   LAB_28F6          ; branch if no adjustment
06490    
06491    DB2B  10 09              BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
06492    
06493                                  ; else go do FAC1/10^(0-expcnt)
06494    LAB_28E6
06495    DB2D  20 03 D9           JSR   LAB_26B9          ; divide by 10
06496    DB30  E6 A9              INC   expcnt            ; increment exponent count byte
06497    DB32  D0 F9              BNE   LAB_28E6          ; loop until all done
06498    
06499    DB34  F0 07              BEQ   LAB_28F6          ; branch always
06500    
06501    LAB_28EF
06502    DB36  20 EA D8           JSR   LAB_269E          ; multiply by 10
06503    DB39  C6 A9              DEC   expcnt            ; decrement exponent count byte
06504    DB3B  D0 F9              BNE   LAB_28EF          ; loop until all done
06505    
06506    LAB_28F6
06507    DB3D  A5 B1              LDA   negnum            ; get -ve flag
06508    DB3F  30 01              BMI   LAB_28FB          ; if -ve do - FAC1 and return
06509    
06510    DB41  60                 RTS
06511    
06512    ; do - FAC1 and return
06513    
06514    LAB_28FB
06515    DB42  4C 07 DD           JMP   LAB_GTHAN         ; do - FAC1 and return
06516    
06517    ; do unsigned FAC1*10+number
06518    
06519    LAB_28FE
06520    DB45  48                 PHA                     ; save character
06521    DB46  24 AA              BIT   numdpf            ; test decimal point flag
06522    DB48  10 02              BPL   LAB_2905          ; skip exponent increment if not set
06523    
06524    DB4A  E6 A8              INC   numexp            ; else increment number exponent
06525    LAB_2905
06526    DB4C  20 EA D8           JSR   LAB_269E          ; multiply FAC1 by 10
06527    DB4F  68                 PLA                     ; restore character
06528    DB50  29 0F              AND   #$0F              ; convert to binary
06529    DB52  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
06530    DB55  4C E5 DA           JMP   LAB_289E          ; go do next character
06531    
06532    ; evaluate new ASCII digit
06533    
06534    LAB_2912
06535    DB58  48                 PHA                     ; save digit
06536    DB59  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
06537    DB5C  68                 PLA                     ; restore digit
06538    DB5D  20 0D DA           JSR   LAB_27DB          ; save A as integer byte
06539    DB60  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
06540    DB62  45 B0              EOR   FAC1_s            ; toggle with FAC1 sign (b7)
06541    DB64  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
06542    DB66  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
06543    DB68  4C D4 D6           JMP   LAB_ADD           ; add FAC2 to FAC1 and return
06544    
06545    ; evaluate next character of exponential part of number
06546    
06547    LAB_2925
06548    DB6B  A5 A9              LDA   expcnt            ; get exponent count byte
06549    DB6D  C9 0A              CMP   #$0A              ; compare with 10 decimal
06550    DB6F  90 09              BCC   LAB_2934          ; branch if less
06551    
06552    DB71  A9 64              LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
06553    DB73  24 AB              BIT   expneg            ; test exponent -ve flag
06554    DB75  30 0E              BMI   LAB_2942          ; branch if -ve
06555    
06556    DB77  4C D6 D7           JMP   LAB_2564          ; else do overflow error
06557    
06558    LAB_2934
06559    DB7A  0A                 ASL                     ; * 2
06560    DB7B  0A                 ASL                     ; * 4
06561    DB7C  65 A9              ADC   expcnt            ; * 5
06562    DB7E  0A                 ASL                     ; * 10
06563    DB7F  A0 00              LDY   #$00              ; set index
06564    DB81  71 C3              ADC   (Bpntrl),Y        ; add character (will be $30 too much!)
06565    DB83  E9 2F              SBC   #'0'-1            ; convert character to binary
06566    LAB_2942
06567    DB85  85 A9              STA   expcnt            ; save exponent count byte
06568    DB87  4C 0B DB           JMP   LAB_28C4          ; go get next character
06569    
06570    ; print " in line [LINE #]"
06571    
06572    LAB_2953
06573    DB8A  A9 04              LDA   #<LAB_LMSG        ; point to " in line " message low byte
06574    DB8C  A0 E9              LDY   #>LAB_LMSG        ; point to " in line " message high byte
06575    DB8E  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
06576    
06577                                  ; print Basic line #
06578    DB91  A5 88              LDA   Clineh            ; get current line high byte
06579    DB93  A6 87              LDX   Clinel            ; get current line low byte
06580    
06581    ; print XA as unsigned integer
06582    
06583    LAB_295E
06584    DB95  85 AD              STA   FAC1_1            ; save low byte as FAC1 mantissa1
06585    DB97  86 AE              STX   FAC1_2            ; save high byte as FAC1 mantissa2
06586    DB99  A2 90              LDX   #$90              ; set exponent to 16d bits
06587    DB9B  38                 SEC                     ; set integer is +ve flag
06588    DB9C  20 1A DA           JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
06589    DB9F  A0 00              LDY   #$00              ; clear index
06590    DBA1  98                 TYA                     ; clear A
06591    DBA2  20 B5 DB           JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
06592    DBA5  4C DA C9           JMP   LAB_18C3          ; print null terminated string from memory and return
06593    
06594    ; convert FAC1 to ASCII string result in (AY)
06595    ; not any more, moved scratchpad to page 0
06596    
06597    LAB_296E
06598    DBA8  A0 01              LDY   #$01              ; set index = 1
06599    DBAA  A9 20              LDA   #$20              ; character = " " (assume +ve)
06600    DBAC  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
06601    DBAE  10 02              BPL   LAB_2978          ; branch if +ve
06602    
06603    DBB0  A9 2D              LDA   #$2D              ; else character = "-"
06604    LAB_2978
06605    DBB2  99 EF 00           STA   Decss,Y           ; save leading character (" " or "-")
06606    LAB_297B
06607    DBB5  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
06608    DBB7  84 BA              STY   Sendl             ; save index
06609    DBB9  C8                 INY                     ; increment index
06610    DBBA  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
06611    DBBC  D0 05              BNE   LAB_2989          ; branch if FAC1<>0
06612    
06613                                  ; exponent was $00 so FAC1 is 0
06614    DBBE  A9 30              LDA   #'0'              ; set character = "0"
06615    DBC0  4C C1 DC           JMP   LAB_2A89          ; save last character, [EOT] and exit
06616    
06617                                  ; FAC1 is some non zero value
06618    LAB_2989
06619    DBC3  A9 00              LDA   #$00              ; clear (number exponent count)
06620    DBC5  E0 81              CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
06621    
06622    DBC7  B0 09              BCS   LAB_299A          ; branch if FAC1=>1
06623    
06624                                  ; FAC1<1
06625    DBC9  A9 98              LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
06626    DBCB  A0 E2              LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
06627    DBCD  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06628    DBD0  A9 FA              LDA   #$FA              ; set number exponent count (-6)
06629    LAB_299A
06630    DBD2  85 A8              STA   numexp            ; save number exponent count
06631    LAB_299C
06632    DBD4  A9 94              LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
06633    DBD6  A0 E2              LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
06634    DBD8  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
06635    DBDB  F0 1E              BEQ   LAB_29C3          ; exit if FAC1 = (AY)
06636    
06637    DBDD  10 12              BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
06638    
06639                                  ; FAC1 < (AY)
06640    LAB_29A7
06641    DBDF  A9 90              LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
06642    DBE1  A0 E2              LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
06643    DBE3  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
06644    DBE6  F0 02              BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
06645    
06646    DBE8  10 0E              BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
06647    
06648                                  ; FAC1 <= (AY)
06649    LAB_29B2
06650    DBEA  20 EA D8           JSR   LAB_269E          ; multiply by 10
06651    DBED  C6 A8              DEC   numexp            ; decrement number exponent count
06652    DBEF  D0 EE              BNE   LAB_29A7          ; go test again (branch always)
06653    
06654    LAB_29B9
06655    DBF1  20 03 D9           JSR   LAB_26B9          ; divide by 10
06656    DBF4  E6 A8              INC   numexp            ; increment number exponent count
06657    DBF6  D0 DC              BNE   LAB_299C          ; go test again (branch always)
06658    
06659    ; now we have just the digits to do
06660    
06661    LAB_29C0
06662    DBF8  20 CD D6           JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
06663    LAB_29C3
06664    DBFB  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
06665    DBFE  A2 01              LDX   #$01              ; set default digits before dp = 1
06666    DC00  A5 A8              LDA   numexp            ; get number exponent count
06667    DC02  18                 CLC                     ; clear carry for add
06668    DC03  69 07              ADC   #$07              ; up to 6 digits before point
06669    DC05  30 09              BMI   LAB_29D8          ; if -ve then 1 digit before dp
06670    
06671    DC07  C9 08              CMP   #$08              ; A>=8 if n>=1E6
06672    DC09  B0 06              BCS   LAB_29D9          ; branch if >= $08
06673    
06674                                  ; carry is clear
06675    DC0B  69 FF              ADC   #$FF              ; take 1 from digit count
06676    DC0D  AA                 TAX                     ; copy to A
06677    DC0E  A9 02              LDA   #$02              ;.set exponent adjust
06678    LAB_29D8
06679    DC10  38                 SEC                     ; set carry for subtract
06680    LAB_29D9
06681    DC11  E9 02              SBC   #$02              ; -2
06682    DC13  85 A9              STA   expcnt            ;.save exponent adjust
06683    DC15  86 A8              STX   numexp            ; save digits before dp count
06684    DC17  8A                 TXA                     ; copy to A
06685    DC18  F0 02              BEQ   LAB_29E4          ; branch if no digits before dp
06686    
06687    DC1A  10 13              BPL   LAB_29F7          ; branch if digits before dp
06688    
06689    LAB_29E4
06690    DC1C  A4 BA              LDY   Sendl             ; get output string index
06691    DC1E  A9 2E              LDA   #$2E              ; character "."
06692    DC20  C8                 INY                     ; increment index
06693    DC21  99 EF 00           STA   Decss,Y           ; save to output string
06694    DC24  8A                 TXA                     ;.
06695    DC25  F0 06              BEQ   LAB_29F5          ;.
06696    
06697    DC27  A9 30              LDA   #'0'              ; character "0"
06698    DC29  C8                 INY                     ; increment index
06699    DC2A  99 EF 00           STA   Decss,Y           ; save to output string
06700    LAB_29F5
06701    DC2D  84 BA              STY   Sendl             ; save output string index
06702    LAB_29F7
06703    DC2F  A0 00              LDY   #$00              ; clear index (point to 100,000)
06704    DC31  A2 80              LDX   #$80              ; 
06705    LAB_29FB
06706    DC33  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
06707    DC35  18                 CLC                     ; clear carry for add
06708    DC36  79 0E E3           ADC   LAB_2A9C,Y        ; add -ve LSB
06709    DC39  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
06710    DC3B  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
06711    DC3D  79 0D E3           ADC   LAB_2A9B,Y        ; add -ve NMSB
06712    DC40  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
06713    DC42  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
06714    DC44  79 0C E3           ADC   LAB_2A9A,Y        ; add -ve MSB
06715    DC47  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06716    DC49  E8                 INX                     ; 
06717    DC4A  B0 04              BCS   LAB_2A18          ; 
06718    
06719    DC4C  10 E5              BPL   LAB_29FB          ; not -ve so try again
06720    
06721    DC4E  30 02              BMI   LAB_2A1A          ; 
06722    
06723    LAB_2A18
06724    DC50  30 E1              BMI   LAB_29FB          ; 
06725    
06726    LAB_2A1A
06727    DC52  8A                 TXA                     ; 
06728    DC53  90 04              BCC   LAB_2A21          ; 
06729    
06730    DC55  49 FF              EOR   #$FF              ; 
06731    DC57  69 0A              ADC   #$0A              ; 
06732    LAB_2A21
06733    DC59  69 2F              ADC   #'0'-1            ; add "0"-1 to result
06734    DC5B  C8                 INY                     ; increment index ..
06735    DC5C  C8                 INY                     ; .. to next less ..
06736    DC5D  C8                 INY                     ; .. power of ten
06737    DC5E  84 95              STY   Cvaral            ; save as current var address low byte
06738    DC60  A4 BA              LDY   Sendl             ; get output string index
06739    DC62  C8                 INY                     ; increment output string index
06740    DC63  AA                 TAX                     ; copy character to X
06741    DC64  29 7F              AND   #$7F              ; mask out top bit
06742    DC66  99 EF 00           STA   Decss,Y           ; save to output string
06743    DC69  C6 A8              DEC   numexp            ; decrement # of characters before the dp
06744    DC6B  D0 06              BNE   LAB_2A3B          ; branch if still characters to do
06745    
06746                                  ; else output the point
06747    DC6D  A9 2E              LDA   #$2E              ; character "."
06748    DC6F  C8                 INY                     ; increment output string index
06749    DC70  99 EF 00           STA   Decss,Y           ; save to output string
06750    LAB_2A3B
06751    DC73  84 BA              STY   Sendl             ; save output string index
06752    DC75  A4 95              LDY   Cvaral            ; get current var address low byte
06753    DC77  8A                 TXA                     ; get character back
06754    DC78  49 FF              EOR   #$FF              ; 
06755    DC7A  29 80              AND   #$80              ; 
06756    DC7C  AA                 TAX                     ; 
06757    DC7D  C0 12              CPY   #$12              ; compare index with max
06758    DC7F  D0 B2              BNE   LAB_29FB          ; loop if not max
06759    
06760                                  ; now remove trailing zeroes
06761    DC81  A4 BA              LDY   Sendl             ; get output string index
06762    LAB_2A4B
06763    DC83  B9 EF 00           LDA   Decss,Y           ; get character from output string
06764    DC86  88                 DEY                     ; decrement output string index
06765    DC87  C9 30              CMP   #'0'              ; compare with "0"
06766    DC89  F0 F8              BEQ   LAB_2A4B          ; loop until non "0" character found
06767    
06768    DC8B  C9 2E              CMP   #'.'              ; compare with "."
06769    DC8D  F0 01              BEQ   LAB_2A58          ; branch if was dp
06770    
06771                                  ; restore last character
06772    DC8F  C8                 INY                     ; increment output string index
06773    LAB_2A58
06774    DC90  A9 2B              LDA   #$2B              ; character "+"
06775    DC92  A6 A9              LDX   expcnt            ; get exponent count
06776    DC94  F0 2E              BEQ   LAB_2A8C          ; if zero go set null terminator and exit
06777    
06778                                  ; exponent isn't zero so write exponent
06779    DC96  10 08              BPL   LAB_2A68          ; branch if exponent count +ve
06780    
06781    DC98  A9 00              LDA   #$00              ; clear A
06782    DC9A  38                 SEC                     ; set carry for subtract
06783    DC9B  E5 A9              SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
06784    DC9D  AA                 TAX                     ; copy exponent count to X
06785    DC9E  A9 2D              LDA   #'-'              ; character "-"
06786    LAB_2A68
06787    DCA0  99 F1 00           STA   Decss+2,Y         ; save to output string
06788    DCA3  A9 45              LDA   #$45              ; character "E"
06789    DCA5  99 F0 00           STA   Decss+1,Y         ; save exponent sign to output string
06790    DCA8  8A                 TXA                     ; get exponent count back
06791    DCA9  A2 2F              LDX   #'0'-1            ; one less than "0" character
06792    DCAB  38                 SEC                     ; set carry for subtract
06793    LAB_2A74
06794    DCAC  E8                 INX                     ; increment 10's character
06795    DCAD  E9 0A              SBC   #$0A              ;.subtract 10 from exponent count
06796    DCAF  B0 FB              BCS   LAB_2A74          ; loop while still >= 0
06797    
06798    DCB1  69 3A              ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
06799    DCB3  99 F3 00           STA   Decss+4,Y         ; save to output string
06800    DCB6  8A                 TXA                     ; copy 10's character
06801    DCB7  99 F2 00           STA   Decss+3,Y         ; save to output string
06802    DCBA  A9 00              LDA   #$00              ; set null terminator
06803    DCBC  99 F4 00           STA   Decss+5,Y         ; save to output string
06804    DCBF  F0 08              BEQ   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
06805    
06806                                  ; save last character, [EOT] and exit
06807    LAB_2A89
06808    DCC1  99 EF 00           STA   Decss,Y           ; save last character to output string
06809    
06810                                  ; set null terminator and exit
06811    LAB_2A8C
06812    DCC4  A9 00              LDA   #$00              ; set null terminator
06813    DCC6  99 F0 00           STA   Decss+1,Y         ; save after last character
06814    
06815                                  ; set string pointer (AY) and exit
06816    LAB_2A91
06817    DCC9  A9 F0              LDA   #<Decssp1         ; set result string low pointer
06818    DCCB  A0 00              LDY   #>Decssp1         ; set result string high pointer
06819    DCCD  60                 RTS
06820    
06821    ; perform power function
06822    
06823    LAB_POWER
06824    DCCE  F0 42              BEQ   LAB_EXP           ; go do  EXP()
06825    
06826    DCD0  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
06827    DCD2  D0 03              BNE   LAB_2ABF          ; branch if FAC2<>0
06828    
06829    DCD4  4C 65 D7           JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
06830    
06831    LAB_2ABF
06832    DCD7  A2 9C              LDX   #<func_l          ; set destination pointer low byte
06833    DCD9  A0 00              LDY   #>func_l          ; set destination pointer high byte
06834    DCDB  20 BA D9           JSR   LAB_2778          ; pack FAC1 into (XY)
06835    DCDE  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
06836    DCE0  10 0F              BPL   LAB_2AD9          ; branch if FAC2>0
06837    
06838                                  ; else FAC2 is -ve and can only be raised to an
06839                                  ; integer power which gives an x +j0 result
06840    DCE2  20 94 DA           JSR   LAB_INT           ; perform INT
06841    DCE5  A9 9C              LDA   #<func_l          ; set source pointer low byte
06842    DCE7  A0 00              LDY   #>func_l          ; set source pointer high byte
06843    DCE9  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
06844    DCEC  D0 03              BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
06845                                  ; this will leave FAC1 -ve and cause a Function Call
06846                                  ; error when LOG() is called
06847    
06848    DCEE  98                 TYA                     ; clear sign b7
06849    DCEF  A4 5B              LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
06850                                  ; for possible later negation, b0
06851    LAB_2AD9
06852    DCF1  20 D8 D6           JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
06853    DCF4  98                 TYA                     ; copy sign back ..
06854    DCF5  48                 PHA                     ; .. and save it
06855    DCF6  20 0E D8           JSR   LAB_LOG           ; do LOG(n)
06856    DCF9  A9 9C              LDA   #<garb_l          ; set pointer low byte
06857    DCFB  A0 00              LDY   #>garb_l          ; set pointer high byte
06858    DCFD  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
06859    DD00  20 12 DD           JSR   LAB_EXP           ; go do EXP(n)
06860    DD03  68                 PLA                     ; pull sign from stack
06861    DD04  4A                 LSR                     ; b0 is to be tested, shift to Cb
06862    DD05  90 0A              BCC   LAB_2AF9          ; if no bit then exit
06863    
06864                                  ; Perform negation
06865    ; do - FAC1
06866    
06867    LAB_GTHAN
06868    DD07  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06869    DD09  F0 06              BEQ   LAB_2AF9          ; exit if FAC1_e = $00
06870    
06871    DD0B  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06872    DD0D  49 FF              EOR   #$FF              ; complement it
06873    DD0F  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
06874    LAB_2AF9
06875    DD11  60                 RTS
06876    
06877    ; perform EXP()   (x^e)
06878    
06879    LAB_EXP
06880    DD12  A9 9C              LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
06881    DD14  A0 E2              LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
06882    DD16  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06883    DD19  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
06884    DD1B  69 50              ADC   #$50              ; +$50/$100
06885    DD1D  90 03              BCC   LAB_2B2B          ; skip rounding if no carry
06886    
06887    DD1F  20 F4 D9           JSR   LAB_27C2          ; round FAC1 (no check)
06888    LAB_2B2B
06889    DD22  85 A3              STA   FAC2_r            ; save FAC2 rounding byte
06890    DD24  20 E0 D9           JSR   LAB_27AE          ; copy FAC1 to FAC2
06891    DD27  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06892    DD29  C9 88              CMP   #$88              ; compare with EXP limit (256d)
06893    DD2B  90 03              BCC   LAB_2B39          ; branch if less
06894    
06895    LAB_2B36
06896    DD2D  20 E1 D8           JSR   LAB_2690          ; handle overflow and underflow
06897    LAB_2B39
06898    DD30  20 94 DA           JSR   LAB_INT           ; perform INT
06899    DD33  A5 5B              LDA   Temp3             ; get mantissa 3 from INT() function
06900    DD35  18                 CLC                     ; clear carry for add
06901    DD36  69 81              ADC   #$81              ; normalise +1
06902    DD38  F0 F3              BEQ   LAB_2B36          ; if $00 go handle overflow
06903    
06904    DD3A  38                 SEC                     ; set carry for subtract
06905    DD3B  E9 01              SBC   #$01              ; now correct for exponent
06906    DD3D  48                 PHA                     ; save FAC2 exponent
06907    
06908                                  ; swap FAC1 and FAC2
06909    DD3E  A2 04              LDX   #$04              ; 4 bytes to do
06910    LAB_2B49
06911    DD40  B5 B3              LDA   FAC2_e,X          ; get FAC2,X
06912    DD42  B4 AC              LDY   FAC1_e,X          ; get FAC1,X
06913    DD44  95 AC              STA   FAC1_e,X          ; save FAC1,X
06914    DD46  94 B3              STY   FAC2_e,X          ; save FAC2,X
06915    DD48  CA                 DEX                     ; decrement count/index
06916    DD49  10 F5              BPL   LAB_2B49          ; loop if not all done
06917    
06918    DD4B  A5 A3              LDA   FAC2_r            ; get FAC2 rounding byte
06919    DD4D  85 B9              STA   FAC1_r            ; save as FAC1 rounding byte
06920    DD4F  20 B9 D6           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
06921    DD52  20 07 DD           JSR   LAB_GTHAN         ; do - FAC1
06922    DD55  A9 A0              LDA   #<LAB_2AFE        ; set counter pointer low byte
06923    DD57  A0 E2              LDY   #>LAB_2AFE        ; set counter pointer high byte
06924    DD59  20 7A DD           JSR   LAB_2B84          ; go do series evaluation
06925    DD5C  A9 00              LDA   #$00              ; clear A
06926    DD5E  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
06927    DD60  68                 PLA                     ;.get saved FAC2 exponent
06928    DD61  4C C6 D8           JMP   LAB_2675          ; test and adjust accumulators and return
06929    
06930    ; ^2 then series evaluation
06931    
06932    LAB_2B6E
06933    DD64  85 BA              STA   Cptrl             ; save count pointer low byte
06934    DD66  84 BB              STY   Cptrh             ; save count pointer high byte
06935    DD68  20 B0 D9           JSR   LAB_276E          ; pack FAC1 into Adatal
06936    DD6B  A9 A4              LDA   #<Adatal          ; set pointer low byte (Y already $00)
06937    DD6D  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06938    DD70  20 7E DD           JSR   LAB_2B88          ; go do series evaluation
06939    DD73  A9 A4              LDA   #<Adatal          ; pointer to original # low byte
06940    DD75  A0 00              LDY   #>Adatal          ; pointer to original # high byte
06941    DD77  4C 4C D8           JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
06942    
06943    ; series evaluation
06944    
06945    LAB_2B84
06946    DD7A  85 BA              STA   Cptrl             ; save count pointer low byte
06947    DD7C  84 BB              STY   Cptrh             ; save count pointer high byte
06948    LAB_2B88
06949    DD7E  A2 A8              LDX   #<numexp          ; set pointer low byte
06950    DD80  20 B2 D9           JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
06951    DD83  B1 BA              LDA   (Cptrl),Y         ; get constants count
06952    DD85  85 B1              STA   numcon            ; save constants count
06953    DD87  A4 BA              LDY   Cptrl             ; get count pointer low byte
06954    DD89  C8                 INY                     ; increment it (now constants pointer)
06955    DD8A  98                 TYA                     ; copy it
06956    DD8B  D0 02              BNE   LAB_2B97          ; skip next if no overflow
06957    
06958    DD8D  E6 BB              INC   Cptrh             ; else increment high byte
06959    LAB_2B97
06960    DD8F  85 BA              STA   Cptrl             ; save low byte
06961    DD91  A4 BB              LDY   Cptrh             ; get high byte
06962    LAB_2B9B
06963    DD93  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06964    DD96  A5 BA              LDA   Cptrl             ; get constants pointer low byte
06965    DD98  A4 BB              LDY   Cptrh             ; get constants pointer high byte
06966    DD9A  18                 CLC                     ; clear carry for add
06967    DD9B  69 04              ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
06968    DD9D  90 01              BCC   LAB_2BA8          ; skip next if no overflow
06969    
06970    DD9F  C8                 INY                     ; increment high byte
06971    LAB_2BA8
06972    DDA0  85 BA              STA   Cptrl             ; save pointer low byte
06973    DDA2  84 BB              STY   Cptrh             ; save pointer high byte
06974    DDA4  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
06975    DDA7  A9 A8              LDA   #<numexp          ; set pointer low byte to partial @ numexp
06976    DDA9  A0 00              LDY   #>numexp          ; set pointer high byte to partial @ numexp
06977    DDAB  C6 B1              DEC   numcon            ; decrement constants count
06978    DDAD  D0 E4              BNE   LAB_2B9B          ; loop until all done
06979    
06980    DDAF  60                 RTS
06981    
06982    ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
06983    ; to get 19th next number in sequence after seed n. This version of the PRNG uses
06984    ; the Galois method and a sample of 65536 bytes produced gives the following values.
06985    
06986    ; Entropy = 7.997442 bits per byte
06987    ; Optimum compression would reduce these 65536 bytes by 0 percent
06988    
06989    ; Chi square distribution for 65536 samples is 232.01, and
06990    ; randomly would exceed this value 75.00 percent of the time
06991    
06992    ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
06993    ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
06994    ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
06995    
06996    LAB_RND
06997    DDB0  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06998    DDB2  F0 07              BEQ   NextPRN           ; do next random # if zero
06999    
07000                                  ; else get seed into random number store
07001    DDB4  A2 D8              LDX   #Rbyte4           ; set PRNG pointer low byte
07002    DDB6  A0 00              LDY   #$00              ; set PRNG pointer high byte
07003    DDB8  20 BA D9           JSR   LAB_2778          ; pack FAC1 into (XY)
07004    NextPRN
07005    DDBB  A2 AF              LDX   #$AF              ; set EOR byte
07006    DDBD  A0 13              LDY   #$13              ; do this nineteen times
07007    LoopPRN
07008    DDBF  06 D9              ASL   Rbyte1            ; shift PRNG most significant byte
07009    DDC1  26 DA              ROL   Rbyte2            ; shift PRNG middle byte
07010    DDC3  26 DB              ROL   Rbyte3            ; shift PRNG least significant byte
07011    DDC5  26 D8              ROL   Rbyte4            ; shift PRNG extra byte
07012    DDC7  90 05              BCC   Ninc1             ; branch if bit 32 clear
07013    
07014    DDC9  8A                 TXA                     ; set EOR byte
07015    DDCA  45 D9              EOR   Rbyte1            ; EOR PRNG extra byte
07016    DDCC  85 D9              STA   Rbyte1            ; save new PRNG extra byte
07017    Ninc1
07018    DDCE  88                 DEY                     ; decrement loop count
07019    DDCF  D0 EE              BNE   LoopPRN           ; loop if not all done
07020    
07021    DDD1  A2 02              LDX   #$02              ; three bytes to copy
07022    CopyPRNG
07023    DDD3  B5 D9              LDA   Rbyte1,X          ; get PRNG byte
07024    DDD5  95 AD              STA   FAC1_1,X          ; save FAC1 byte
07025    DDD7  CA                 DEX
07026    DDD8  10 F9              BPL   CopyPRNG          ; loop if not complete
07027    
07028    DDDA  A9 80              LDA   #$80              ; set the exponent
07029    DDDC  85 AC              STA   FAC1_e            ; save FAC1 exponent
07030    
07031    DDDE  0A                 ASL                     ; clear A
07032    DDDF  85 B0              STA   FAC1_s            ; save FAC1 sign
07033    
07034    DDE1  4C 47 D7           JMP   LAB_24D5          ; normalise FAC1 and return
07035    
07036    ; perform COS()
07037    
07038    LAB_COS
07039    DDE4  A9 BD              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
07040    DDE6  A0 E2              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
07041    DDE8  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
07042    
07043    ; perform SIN()
07044    
07045    LAB_SIN
07046    DDEB  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
07047    DDEE  A9 D2              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
07048    DDF0  A0 E2              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
07049    DDF2  A6 B7              LDX   FAC2_s            ; get FAC2 sign (b7)
07050    DDF4  20 0C D9           JSR   LAB_26C2          ; divide by (AY) (X=sign)
07051    DDF7  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
07052    DDFA  20 94 DA           JSR   LAB_INT           ; perform INT
07053    DDFD  A9 00              LDA   #$00              ; clear byte
07054    DDFF  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
07055    DE01  20 B9 D6           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
07056    DE04  A9 04              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
07057    DE06  A0 E3              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
07058    DE08  20 B6 D6           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
07059    DE0B  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
07060    DE0D  48                 PHA                     ; save FAC1 sign
07061    DE0E  10 0D              BPL   LAB_2C35          ; branch if +ve
07062    
07063                                  ; FAC1 sign was -ve
07064    DE10  20 CD D6           JSR   LAB_244E          ; add 0.5 to FAC1
07065    DE13  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
07066    DE15  30 09              BMI   LAB_2C38          ; branch if -ve
07067    
07068    DE17  A5 63              LDA   Cflag             ; get comparison evaluation flag
07069    DE19  49 FF              EOR   #$FF              ; toggle flag
07070    DE1B  85 63              STA   Cflag             ; save comparison evaluation flag
07071    LAB_2C35
07072    DE1D  20 07 DD           JSR   LAB_GTHAN         ; do - FAC1
07073    LAB_2C38
07074    DE20  A9 04              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
07075    DE22  A0 E3              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
07076    DE24  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
07077    DE27  68                 PLA                     ; restore FAC1 sign
07078    DE28  10 03              BPL   LAB_2C45          ; branch if was +ve
07079    
07080                                  ; else correct FAC1
07081    DE2A  20 07 DD           JSR   LAB_GTHAN         ; do - FAC1
07082    LAB_2C45
07083    DE2D  A9 C1              LDA   #<LAB_2C84        ; set pointer low byte to counter
07084    DE2F  A0 E2              LDY   #>LAB_2C84        ; set pointer high byte to counter
07085    DE31  4C 64 DD           JMP   LAB_2B6E          ; ^2 then series evaluation and return
07086    
07087    ; perform TAN()
07088    
07089    LAB_TAN
07090    DE34  20 B0 D9           JSR   LAB_276E          ; pack FAC1 into Adatal
07091    DE37  A9 00              LDA   #$00              ; clear byte
07092    DE39  85 63              STA   Cflag             ; clear comparison evaluation flag
07093    DE3B  20 EB DD           JSR   LAB_SIN           ; go do SIN(n)
07094    DE3E  A2 9C              LDX   #<func_l          ; set sin(n) pointer low byte
07095    DE40  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
07096    DE42  20 BA D9           JSR   LAB_2778          ; pack FAC1 into (XY)
07097    DE45  A9 A4              LDA   #<Adatal          ; set n pointer low addr
07098    DE47  A0 00              LDY   #>Adatal          ; set n pointer high addr
07099    DE49  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
07100    DE4C  A9 00              LDA   #$00              ; clear byte
07101    DE4E  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
07102    DE50  A5 63              LDA   Cflag             ; get comparison evaluation flag
07103    DE52  20 5C DE           JSR   LAB_2C74          ; save flag and go do series evaluation
07104    
07105    DE55  A9 9C              LDA   #<func_l          ; set sin(n) pointer low byte
07106    DE57  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
07107    DE59  4C 14 D9           JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
07108    
07109    LAB_2C74
07110    DE5C  48                 PHA                     ; save comparison evaluation flag
07111    DE5D  4C 1D DE           JMP   LAB_2C35          ; go do series evaluation
07112    
07113    ; perform USR()
07114    
07115    LAB_USR
07116    DE60  20 0A 00           JSR   Usrjmp            ; call user code
07117    DE63  4C F5 CC           JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
07118    
07119    ; perform ATN()
07120    
07121    LAB_ATN
07122    DE66  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
07123    DE68  48                 PHA                     ; save sign
07124    DE69  10 03              BPL   LAB_2CA1          ; branch if +ve
07125    
07126    DE6B  20 07 DD           JSR   LAB_GTHAN         ; else do - FAC1
07127    LAB_2CA1
07128    DE6E  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07129    DE70  48                 PHA                     ; push exponent
07130    DE71  C9 81              CMP   #$81              ; compare with 1
07131    DE73  90 07              BCC   LAB_2CAF          ; branch if FAC1<1
07132    
07133    DE75  A9 F7              LDA   #<LAB_259C        ; set 1 pointer low byte
07134    DE77  A0 E2              LDY   #>LAB_259C        ; set 1 pointer high byte
07135    DE79  20 14 D9           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
07136    LAB_2CAF
07137    DE7C  A9 D6              LDA   #<LAB_2CC9        ; set pointer low byte to counter
07138    DE7E  A0 E2              LDY   #>LAB_2CC9        ; set pointer high byte to counter
07139    DE80  20 64 DD           JSR   LAB_2B6E          ; ^2 then series evaluation
07140    DE83  68                 PLA                     ; restore old FAC1 exponent
07141    DE84  C9 81              CMP   #$81              ; compare with 1
07142    DE86  90 07              BCC   LAB_2CC2          ; branch if FAC1<1
07143    
07144    DE88  A9 BD              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
07145    DE8A  A0 E2              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
07146    DE8C  20 B6 D6           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
07147    LAB_2CC2
07148    DE8F  68                 PLA                     ; restore FAC1 sign
07149    DE90  10 16              BPL   LAB_2D04          ; exit if was +ve
07150    
07151    DE92  4C 07 DD           JMP   LAB_GTHAN         ; else do - FAC1 and return
07152    
07153    ; perform BITSET
07154    
07155    LAB_BITSET
07156    DE95  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
07157    DE98  E0 08              CPX   #$08              ; only 0 to 7 are allowed
07158    DE9A  B0 20              BCS   FCError           ; branch if > 7
07159    
07160    DE9C  A9 00              LDA   #$00              ; clear A
07161    DE9E  38                 SEC                     ; set the carry
07162    S_Bits
07163    DE9F  2A                 ROL                     ; shift bit
07164    DEA0  CA                 DEX                     ; decrement bit number
07165    DEA1  10 FC              BPL   S_Bits            ; loop if still +ve
07166    
07167    DEA3  E8                 INX                     ; make X = $00
07168    DEA4  01 11              ORA   (Itempl,X)        ; or with byte via temporary integer (addr)
07169    DEA6  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
07170    LAB_2D04
07171    DEA8  60                 RTS
07172    
07173    ; perform BITCLR
07174    
07175    LAB_BITCLR
07176    DEA9  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
07177    DEAC  E0 08              CPX   #$08              ; only 0 to 7 are allowed
07178    DEAE  B0 0C              BCS   FCError           ; branch if > 7
07179    
07180    DEB0  A9 FF              LDA   #$FF              ; set A
07181    S_Bitc
07182    DEB2  2A                 ROL                     ; shift bit
07183    DEB3  CA                 DEX                     ; decrement bit number
07184    DEB4  10 FC              BPL   S_Bitc            ; loop if still +ve
07185    
07186    DEB6  E8                 INX                     ; make X = $00
07187    DEB7  21 11              AND   (Itempl,X)        ; and with byte via temporary integer (addr)
07188    DEB9  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
07189    DEBB  60                 RTS
07190    
07191    FCError
07192    DEBC  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
07193    
07194    ; perform BITTST()
07195    
07196    LAB_BTST
07197    DEBF  20 BC 00           JSR   LAB_IGBY          ; increment BASIC pointer
07198    DEC2  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
07199    DEC5  E0 08              CPX   #$08              ; only 0 to 7 are allowed
07200    DEC7  B0 F3              BCS   FCError           ; branch if > 7
07201    
07202    DEC9  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
07203    DECC  C9 29              CMP   #')'              ; is next character ")"
07204    DECE  F0 03              BEQ   TST_OK            ; if ")" go do rest of function
07205    
07206    DED0  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
07207    
07208    TST_OK
07209    DED3  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
07210    DED6  A9 00              LDA   #$00              ; clear A
07211    DED8  38                 SEC                     ; set the carry
07212    T_Bits
07213    DED9  2A                 ROL                     ; shift bit
07214    DEDA  CA                 DEX                     ; decrement bit number
07215    DEDB  10 FC              BPL   T_Bits            ; loop if still +ve
07216    
07217    DEDD  E8                 INX                     ; make X = $00
07218    DEDE  21 11              AND   (Itempl,X)        ; AND with byte via temporary integer (addr)
07219    DEE0  F0 02              BEQ   LAB_NOTT          ; branch if zero (already correct)
07220    
07221    DEE2  A9 FF              LDA   #$FF              ; set for -1 result
07222    LAB_NOTT
07223    DEE4  4C 0D DA           JMP   LAB_27DB          ; go do SGN tail
07224    
07225    ; perform BIN$()
07226    
07227    LAB_BINS
07228    DEE7  E0 19              CPX   #$19              ; max + 1
07229    DEE9  B0 48              BCS   BinFErr           ; exit if too big ( > or = )
07230    
07231    DEEB  86 78              STX   TempB             ; save # of characters ($00 = leading zero remove)
07232    DEED  A9 18              LDA   #$18              ; need A byte long space
07233    DEEF  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long
07234    DEF2  A0 17              LDY   #$17              ; set index
07235    DEF4  A2 18              LDX   #$18              ; character count
07236    NextB1
07237    DEF6  46 11              LSR   nums_1            ; shift highest byte
07238    DEF8  66 12              ROR   nums_2            ; shift middle byte
07239    DEFA  66 13              ROR   nums_3            ; shift lowest byte bit 0 to carry
07240    DEFC  8A                 TXA                     ; load with "0"/2
07241    DEFD  2A                 ROL                     ; shift in carry
07242    DEFE  91 AD              STA   (str_pl),Y        ; save to temp string + index
07243    DF00  88                 DEY                     ; decrement index
07244    DF01  10 F3              BPL   NextB1            ; loop if not done
07245    
07246    DF03  A5 78              LDA   TempB             ; get # of characters
07247    DF05  F0 0A              BEQ   EndBHS            ; branch if truncate
07248    
07249    DF07  AA                 TAX                     ; copy length to X
07250    DF08  38                 SEC                     ; set carry for add !
07251    DF09  49 FF              EOR   #$FF              ; 1's complement
07252    DF0B  69 18              ADC   #$18              ; add 24d
07253    DF0D  F0 1C              BEQ   GoPr2             ; if zero print whole string
07254    
07255    DF0F  D0 0F              BNE   GoPr1             ; else go make output string
07256          
07257    ; this is the exit code and is also used by HEX$()
07258    ; truncate string to remove leading "0"s
07259    
07260    EndBHS
07261    DF11  A8                 TAY                     ; clear index (A=0, X=length here)
07262    NextB2
07263    DF12  B1 AD              LDA   (str_pl),Y        ; get character from string
07264    DF14  C9 30              CMP   #'0'              ; compare with "0"
07265    DF16  D0 07              BNE   GoPr              ; if not "0" then go print string from here
07266    
07267    DF18  CA                 DEX                     ; decrement character count
07268    DF19  F0 03              BEQ   GoPr3             ; if zero then end of string so go print it
07269    
07270    DF1B  C8                 INY                     ; else increment index
07271    DF1C  10 F4              BPL   NextB2            ; loop always
07272    
07273    ; make fixed length output string - ignore overflows!
07274    
07275    GoPr3
07276    DF1E  E8                 INX                     ; need at least 1 character
07277    GoPr
07278    DF1F  98                 TYA                     ; copy result
07279    GoPr1
07280    DF20  18                 CLC                     ; clear carry for add
07281    DF21  65 AD              ADC   str_pl            ; add low address
07282    DF23  85 AD              STA   str_pl            ; save low address
07283    DF25  A9 00              LDA   #$00              ; do high byte
07284    DF27  65 AE              ADC   str_ph            ; add high address
07285    DF29  85 AE              STA   str_ph            ; save high address
07286    GoPr2
07287    DF2B  86 AC              STX   str_ln            ; X holds string length
07288    DF2D  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
07289    DF30  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put address
07290                                  ; and length on descriptor stack and update stack pointers
07291    
07292    BinFErr
07293    DF33  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
07294    
07295    ; perform HEX$()
07296    
07297    LAB_HEXS
07298    DF36  E0 07              CPX   #$07              ; max + 1
07299    DF38  B0 F9              BCS   BinFErr           ; exit if too big ( > or = )
07300    
07301    DF3A  86 78              STX   TempB             ; save # of characters
07302    
07303    DF3C  A9 06              LDA   #$06              ; need 6 bytes for string
07304    DF3E  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long
07305    DF41  A0 05              LDY   #$05              ; set string index
07306    
07307    ; *** disable decimal mode patch - comment next line ***
07308    ;      SED                     ; need decimal mode for nibble convert
07309    DF43  A5 13              LDA   nums_3            ; get lowest byte
07310    DF45  20 62 DF           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
07311    DF48  A5 12              LDA   nums_2            ; get middle byte
07312    DF4A  20 62 DF           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
07313    DF4D  A5 11              LDA   nums_1            ; get highest byte
07314    DF4F  20 62 DF           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
07315    ; *** disable decimal mode patch - comment next line ***
07316    ;      CLD                     ; back to binary
07317    
07318    DF52  A2 06              LDX   #$06              ; character count
07319    DF54  A5 78              LDA   TempB             ; get # of characters
07320    DF56  F0 B9              BEQ   EndBHS            ; branch if truncate
07321    
07322    DF58  AA                 TAX                     ; copy length to X
07323    DF59  38                 SEC                     ; set carry for add !
07324    DF5A  49 FF              EOR   #$FF              ; 1's complement
07325    DF5C  69 06              ADC   #$06              ; add 6d
07326    DF5E  F0 CB              BEQ   GoPr2             ; if zero print whole string
07327    
07328    DF60  D0 BE              BNE   GoPr1             ; else go make output string (branch always)
07329    
07330    ; convert A to ASCII hex byte and output .. note set decimal mode before calling
07331    
07332    LAB_A2HX
07333    DF62  AA                 TAX                     ; save byte
07334    DF63  29 0F              AND   #$0F              ; mask off top bits
07335    DF65  20 6D DF           JSR   LAB_AL2X          ; convert low nibble to ASCII and output
07336    DF68  8A                 TXA                     ; get byte back
07337    DF69  4A                 LSR                     ; /2  shift high nibble to low nibble
07338    DF6A  4A                 LSR                     ; /4
07339    DF6B  4A                 LSR                     ; /8
07340    DF6C  4A                 LSR                     ; /16
07341    LAB_AL2X
07342    DF6D  C9 0A              CMP   #$0A              ; set carry for +1 if >9
07343    ; *** begin disable decimal mode patch ***
07344    ; *** insert
07345    DF6F  90 02              BCC   LAB_AL20          ; skip adjust if <= 9
07346    DF71  69 06              ADC   #$06              ; adjust for A to F
07347    LAB_AL20
07348    ; *** end   disable decimal mode patch ***
07349    DF73  69 30              ADC   #'0'              ; add ASCII "0"
07350    DF75  91 AD              STA   (str_pl),Y        ; save to temp string
07351    DF77  88                 DEY                     ; decrement counter
07352    DF78  60                 RTS
07353    
07354    LAB_NLTO
07355    DF79  85 AC              STA   FAC1_e            ; save FAC1 exponent
07356    DF7B  A9 00              LDA   #$00              ; clear sign compare
07357    LAB_MLTE
07358    DF7D  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
07359    DF7F  8A                 TXA                     ; restore character
07360    DF80  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
07361    
07362    ; gets here if the first character was "$" for hex
07363    ; get hex number
07364    
07365    LAB_CHEX
07366    DF83  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
07367    DF86  90 0A              BCC   LAB_ISHN          ; branch if numeric character
07368    
07369    DF88  09 20              ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
07370    DF8A  E9 61              SBC   #'a'              ; subtract "a" (carry set here)
07371    DF8C  C9 06              CMP   #$06              ; compare normalised with $06 (max+1)
07372    DF8E  B0 2A              BCS   LAB_EXCH          ; exit if >"f" or <"0"
07373    
07374    DF90  69 0A              ADC   #$0A              ; convert to nibble
07375    LAB_ISHN
07376    DF92  29 0F              AND   #$0F              ; convert to binary
07377    DF94  AA                 TAX                     ; save nibble
07378    DF95  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07379    DF97  F0 E4              BEQ   LAB_MLTE          ; skip multiply if zero
07380    
07381    DF99  69 04              ADC   #$04              ; add four to exponent (*16 - carry clear here)
07382    DF9B  90 DC              BCC   LAB_NLTO          ; if no overflow do evaluate digit
07383    
07384    LAB_MLTO
07385    DF9D  4C D6 D7           JMP   LAB_2564          ; do overflow error and warm start
07386    
07387    LAB_NXCH
07388    DFA0  AA                 TAX                     ; save bit
07389    DFA1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07390    DFA3  F0 06              BEQ   LAB_MLBT          ; skip multiply if zero
07391    
07392    DFA5  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*2)
07393    DFA7  F0 F4              BEQ   LAB_MLTO          ; do overflow error if = $00
07394    
07395    DFA9  A9 00              LDA   #$00              ; clear sign compare
07396    LAB_MLBT
07397    DFAB  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
07398    DFAD  8A                 TXA                     ; restore bit
07399    DFAE  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
07400    
07401    ; gets here if the first character was  "%" for binary
07402    ; get binary number
07403    
07404    LAB_CBIN
07405    DFB1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
07406    DFB4  49 30              EOR   #'0'              ; convert "0" to 0 etc.
07407    DFB6  C9 02              CMP   #$02              ; compare with max+1
07408    DFB8  90 E6              BCC   LAB_NXCH          ; branch exit if < 2
07409    
07410    LAB_EXCH
07411    DFBA  4C 3D DB           JMP   LAB_28F6          ; evaluate -ve flag and return
07412    
07413    ; ctrl-c check routine. includes limited "life" byte save for INGET routine
07414    ; now also the code that checks to see if an interrupt has occurred
07415    
07416    CTRLC
07417    DFBD  AD 00 02           LDA   ccflag            ; get [CTRL-C] check flag
07418    DFC0  D0 18              BNE   LAB_FBA2          ; exit if inhibited
07419    
07420    DFC2  20 FF E1           JSR   V_INPT            ; scan input device
07421    DFC5  90 0B              BCC   LAB_FBA0          ; exit if buffer empty
07422    
07423    DFC7  8D 01 02           STA   ccbyte            ; save received byte
07424    DFCA  A2 20              LDX   #$20              ; "life" timer for bytes
07425    DFCC  8E 02 02           STX   ccnull            ; set countdown
07426    DFCF  4C 1F C6           JMP   LAB_1636          ; return to BASIC
07427    
07428    LAB_FBA0
07429    DFD2  AE 02 02           LDX   ccnull            ; get countdown byte
07430    DFD5  F0 03              BEQ   LAB_FBA2          ; exit if finished
07431    
07432    DFD7  CE 02 02           DEC   ccnull            ; else decrement countdown
07433    LAB_FBA2
07434    DFDA  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
07435    DFDC  20 E5 DF           JSR   LAB_CKIN          ; go check interrupt
07436    DFDF  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
07437    DFE1  20 E5 DF           JSR   LAB_CKIN          ; go check interrupt
07438    LAB_CRTS
07439    DFE4  60                 RTS
07440    
07441    ; check whichever interrupt is indexed by X
07442    
07443    LAB_CKIN
07444    DFE5  B5 00              LDA   PLUS_0,X          ; get interrupt flag byte
07445    DFE7  10 FB              BPL   LAB_CRTS          ; branch if interrupt not enabled
07446    
07447    ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
07448    ; automatically enable the interrupt when we exit
07449    
07450    DFE9  0A                 ASL                     ; move happened bit to setup bit
07451    DFEA  29 40              AND   #$40              ; mask happened bits
07452    DFEC  F0 F6              BEQ   LAB_CRTS          ; if no interrupt then exit
07453    
07454    DFEE  95 00              STA   PLUS_0,X          ; save interrupt flag byte
07455    
07456    DFF0  8A                 TXA                     ; copy index ..
07457    DFF1  A8                 TAY                     ; .. to Y
07458    
07459    DFF2  68                 PLA                     ; dump return address low byte, call from CTRL-C
07460    DFF3  68                 PLA                     ; dump return address high byte
07461    
07462    DFF4  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
07463    DFF6  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
07464    DFF9  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
07465    DFFB  48                 PHA                     ; push on stack
07466    DFFC  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
07467    DFFE  48                 PHA                     ; push on stack
07468    DFFF  A5 88              LDA   Clineh            ; get current line high byte
07469    E001  48                 PHA                     ; push on stack
07470    E002  A5 87              LDA   Clinel            ; get current line low byte
07471    E004  48                 PHA                     ; push on stack
07472    E005  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
07473    E007  48                 PHA                     ; push on stack
07474    
07475    E008  B9 01 00           LDA   PLUS_1,Y          ; get interrupt code pointer low byte
07476    E00B  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
07477    E00D  B9 02 00           LDA   PLUS_2,Y          ; get interrupt code pointer high byte
07478    E010  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
07479    
07480    E012  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
07481                                  ; can't RTS, we used the stack! the RTS from the ctrl-c
07482                                  ; check will be taken when the RETIRQ/RETNMI/RETURN is
07483                                  ; executed at the end of the subroutine
07484    
07485    ; get byte from input device, no waiting
07486    ; returns with carry set if byte in A
07487    
07488    INGET
07489    E015  20 FF E1           JSR   V_INPT            ; call scan input device
07490    E018  B0 09              BCS   LAB_FB95          ; if byte go reset timer
07491    
07492    E01A  AD 02 02           LDA   ccnull            ; get countdown
07493    E01D  F0 09              BEQ   LAB_FB96          ; exit if empty
07494    
07495    E01F  AD 01 02           LDA   ccbyte            ; get last received byte
07496    E022  38                 SEC                     ; flag we got a byte
07497    LAB_FB95
07498    E023  A2 00              LDX   #$00              ; clear X
07499    E025  8E 02 02           STX   ccnull            ; clear timer because we got a byte
07500    LAB_FB96
07501    E028  60                 RTS
07502    
07503    ; these routines only enable the interrupts if the set-up flag is set
07504    ; if not they have no effect
07505    
07506    ; perform IRQ {ON|OFF|CLEAR}
07507    
07508    LAB_IRQ
07509    E029  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
07510          .byte $2C               ; make next line BIT abs.
07511    
07512    ; perform NMI {ON|OFF|CLEAR}
07513    
07514    LAB_NMI
07515    E02C  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
07516    E02E  C9 93              CMP   #TK_ON            ; compare with token for ON
07517    E030  F0 11              BEQ   LAB_INON          ; go turn on interrupt
07518    
07519    E032  C9 B5              CMP   #TK_OFF           ; compare with token for OFF
07520    E034  F0 07              BEQ   LAB_IOFF          ; go turn off interrupt
07521    
07522    E036  49 A2              EOR   #TK_CLEAR         ; compare with token for CLEAR, A = $00 if = TK_CLEAR
07523    E038  F0 0E              BEQ   LAB_INEX          ; go clear interrupt flags and return
07524    
07525    E03A  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
07526    
07527    LAB_IOFF
07528    E03D  A9 7F              LDA   #$7F              ; clear A
07529    E03F  35 00              AND   PLUS_0,X          ; AND with interrupt setup flag
07530    E041  10 05              BPL   LAB_INEX          ; go clear interrupt enabled flag and return
07531    
07532    LAB_INON
07533    E043  B5 00              LDA   PLUS_0,X          ; get interrupt setup flag
07534    E045  0A                 ASL                     ; Shift bit to enabled flag
07535    E046  15 00              ORA   PLUS_0,X          ; OR with flag byte
07536    LAB_INEX
07537    E048  95 00              STA   PLUS_0,X          ; save interrupt flag byte
07538    E04A  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer and return
07539    
07540    ; these routines set up the pointers and flags for the interrupt routines
07541    ; note that the interrupts are also enabled by these commands
07542    
07543    ; perform ON IRQ
07544    
07545    LAB_SIRQ
07546    E04D  58                 CLI                     ; enable interrupts
07547    E04E  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
07548          .byte $2C               ; make next line BIT abs.
07549    
07550    ; perform ON NMI
07551    
07552    LAB_SNMI
07553    E051  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
07554    
07555    E053  86 78              STX   TempB             ; save interrupt pointer
07556    E055  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (past token)
07557    E058  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
07558    E05B  A5 79              LDA   Smeml             ; get start of mem low byte
07559    E05D  A6 7A              LDX   Smemh             ; get start of mem high byte
07560    E05F  20 31 C4           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
07561    E062  B0 03              BCS   LAB_LFND          ; if carry set go set-up interrupt
07562    
07563    E064  4C 76 C7           JMP   LAB_16F7          ; else go do "Undefined statement" error and warm start
07564    
07565    LAB_LFND
07566    E067  A6 78              LDX   TempB             ; get interrupt pointer
07567    E069  A5 AA              LDA   Baslnl            ; get pointer low byte
07568    E06B  E9 01              SBC   #$01              ; -1 (carry already set for subtract)
07569    E06D  95 01              STA   PLUS_1,X          ; save as interrupt pointer low byte
07570    E06F  A5 AB              LDA   Baslnh            ; get pointer high byte
07571    E071  E9 00              SBC   #$00              ; subtract carry
07572    E073  95 02              STA   PLUS_2,X          ; save as interrupt pointer high byte
07573    
07574    E075  A9 C0              LDA   #$C0              ; set interrupt enabled/setup bits
07575    E077  95 00              STA   PLUS_0,X          ; set interrupt flags
07576    LAB_IRTS
07577    E079  60                 RTS
07578    
07579    ; return from IRQ service, restores the enabled flag.
07580    
07581    ; perform RETIRQ
07582    
07583    LAB_RETIRQ
07584    E07A  D0 FD              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
07585    
07586    E07C  A5 DF              LDA   IrqBase           ; get interrupt flags
07587    E07E  0A                 ASL                     ; copy setup to enabled (b7)
07588    E07F  05 DF              ORA   IrqBase           ; OR in setup flag
07589    E081  85 DF              STA   IrqBase           ; save enabled flag
07590    E083  4C 7D C7           JMP   LAB_16E8          ; go do rest of RETURN
07591    
07592    ; return from NMI service, restores the enabled flag.
07593    
07594    ; perform RETNMI
07595    
07596    LAB_RETNMI
07597    E086  D0 F1              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
07598    
07599    E088  A5 DC              LDA   NmiBase           ; get set-up flag
07600    E08A  0A                 ASL                     ; copy setup to enabled (b7)
07601    E08B  05 DC              ORA   NmiBase           ; OR in setup flag
07602    E08D  85 DC              STA   NmiBase           ; save enabled flag
07603    E08F  4C 7D C7           JMP   LAB_16E8          ; go do rest of RETURN
07604    
07605    ; MAX() MIN() pre process
07606    
07607    LAB_MMPP
07608    E092  20 EF CB           JSR   LAB_EVEZ          ; process expression
07609    E095  4C D6 CB           JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
07610    
07611    ; perform MAX()
07612    
07613    LAB_MAX
07614    E098  20 C6 E0           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
07615                                  ; pull FAC2 and compare with FAC1
07616    E09B  10 FB              BPL   LAB_MAX           ; branch if no swap to do
07617    
07618    E09D  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
07619    E09F  09 80              ORA   #$80              ; set top bit (clear sign from compare)
07620    E0A1  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
07621    E0A3  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1
07622    E0A6  F0 F0              BEQ   LAB_MAX           ; go do next (branch always)
07623    
07624    ; perform MIN()
07625    
07626    LAB_MIN
07627    E0A8  20 C6 E0           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
07628                                  ; pull FAC2 and compare with FAC1
07629    E0AB  30 FB              BMI   LAB_MIN           ; branch if no swap to do
07630    
07631    E0AD  F0 F9              BEQ   LAB_MIN           ; branch if no swap to do
07632    
07633    E0AF  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
07634    E0B1  09 80              ORA   #$80              ; set top bit (clear sign from compare)
07635    E0B3  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
07636    E0B5  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1
07637    E0B8  F0 EE              BEQ   LAB_MIN           ; go do next (branch always)
07638    
07639    ; exit routine. don't bother returning to the loop code
07640    ; check for correct exit, else so syntax error
07641    
07642    LAB_MMEC
07643    E0BA  C9 29              CMP   #')'              ; is it end of function?
07644    E0BC  D0 05              BNE   LAB_MMSE          ; if not do MAX MIN syntax error
07645    
07646    E0BE  68                 PLA                     ; dump return address low byte
07647    E0BF  68                 PLA                     ; dump return address high byte
07648    E0C0  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
07649    
07650    LAB_MMSE
07651    E0C3  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
07652    
07653    ; check for next, evaluate and return or exit
07654    ; this is the routine that does most of the work
07655    
07656    LAB_PHFA
07657    E0C6  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
07658    E0C9  C9 2C              CMP   #','              ; is there more ?
07659    E0CB  D0 ED              BNE   LAB_MMEC          ; if not go do end check
07660    
07661                                  ; push FAC1
07662    E0CD  20 EC D9           JSR   LAB_27BA          ; round FAC1
07663    E0D0  A5 B0              LDA   FAC1_s            ; get FAC1 sign
07664    E0D2  09 7F              ORA   #$7F              ; set all non sign bits
07665    E0D4  25 AD              AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
07666    E0D6  48                 PHA                     ; push on stack
07667    E0D7  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
07668    E0D9  48                 PHA                     ; push on stack
07669    E0DA  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
07670    E0DC  48                 PHA                     ; push on stack
07671    E0DD  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07672    E0DF  48                 PHA                     ; push on stack
07673    
07674    E0E0  20 BC 00           JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
07675    E0E3  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
07676                                  ; else do type mismatch
07677    
07678                                  ; pop FAC2 (MAX/MIN expression so far)
07679    E0E6  68                 PLA                     ; pop exponent
07680    E0E7  85 B3              STA   FAC2_e            ; save FAC2 exponent
07681    E0E9  68                 PLA                     ; pop mantissa3
07682    E0EA  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
07683    E0EC  68                 PLA                     ; pop mantissa1
07684    E0ED  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
07685    E0EF  68                 PLA                     ; pop sign/mantissa1
07686    E0F0  85 B4              STA   FAC2_1            ; save FAC2 sign/mantissa1
07687    E0F2  85 B7              STA   FAC2_s            ; save FAC2 sign
07688    
07689                                  ; compare FAC1 with (packed) FAC2
07690    E0F4  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
07691    E0F6  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
07692    E0F8  4C 2A DA           JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
07693                                  ; returns A=$00 if FAC1 = (AY)
07694                                  ; returns A=$01 if FAC1 > (AY)
07695                                  ; returns A=$FF if FAC1 < (AY)
07696    
07697    ; perform WIDTH
07698    
07699    LAB_WDTH
07700    E0FB  C9 2C              CMP   #','              ; is next byte ","
07701    E0FD  F0 1B              BEQ   LAB_TBSZ          ; if so do tab size
07702    
07703    E0FF  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
07704    E102  8A                 TXA                     ; copy width to A
07705    E103  F0 0A              BEQ   LAB_NSTT          ; branch if set for infinite line
07706    
07707    E105  E0 10              CPX   #$10              ; else make min width = 16d
07708    E107  90 45              BCC   TabErr            ; if less do function call error and exit
07709    
07710    ; this next compare ensures that we can't exit WIDTH via an error leaving the
07711    ; tab size greater than the line length.
07712    
07713    E109  E4 64              CPX   TabSiz            ; compare with tab size
07714    E10B  B0 02              BCS   LAB_NSTT          ; branch if >= tab size
07715    
07716    E10D  86 64              STX   TabSiz            ; else make tab size = terminal width
07717    LAB_NSTT
07718    E10F  86 0F              STX   TWidth            ; set the terminal width
07719    E111  20 C2 00           JSR   LAB_GBYT          ; get BASIC byte back
07720    E114  F0 1A              BEQ   WExit             ; exit if no following
07721    
07722    E116  C9 2C              CMP   #','              ; else is it ","
07723    E118  D0 A9              BNE   LAB_MMSE          ; if not do syntax error
07724    
07725    LAB_TBSZ
07726    E11A  20 A3 D5           JSR   LAB_SGBY          ; scan and get byte parameter
07727    E11D  8A                 TXA                     ; copy TAB size
07728    E11E  30 2E              BMI   TabErr            ; if >127 do function call error and exit
07729    
07730    E120  E0 01              CPX   #$01              ; compare with min-1
07731    E122  90 2A              BCC   TabErr            ; if <=1 do function call error and exit
07732    
07733    E124  A5 0F              LDA   TWidth            ; set flags for width
07734    E126  F0 06              BEQ   LAB_SVTB          ; skip check if infinite line
07735    
07736    E128  E4 0F              CPX   TWidth            ; compare TAB with width
07737    E12A  F0 02              BEQ   LAB_SVTB          ; ok if =
07738    
07739    E12C  B0 20              BCS   TabErr            ; branch if too big
07740    
07741    LAB_SVTB
07742    E12E  86 64              STX   TabSiz            ; save TAB size
07743    
07744    ; calculate tab column limit from TAB size. The Iclim is set to the last tab
07745    ; position on a line that still has at least one whole tab width between it
07746    ; and the end of the line.
07747    
07748    WExit
07749    E130  A5 0F              LDA   TWidth            ; get width
07750    E132  F0 06              BEQ   LAB_SULP          ; branch if infinite line
07751    
07752    E134  C5 64              CMP   TabSiz            ; compare with tab size
07753    E136  B0 03              BCS   LAB_WDLP          ; branch if >= tab size
07754    
07755    E138  85 64              STA   TabSiz            ; else make tab size = terminal width
07756    LAB_SULP
07757    E13A  38                 SEC                     ; set carry for subtract
07758    LAB_WDLP
07759    E13B  E5 64              SBC   TabSiz            ; subtract tab size
07760    E13D  B0 FC              BCS   LAB_WDLP          ; loop while no borrow
07761    
07762    E13F  65 64              ADC   TabSiz            ; add tab size back
07763    E141  18                 CLC                     ; clear carry for add
07764    E142  65 64              ADC   TabSiz            ; add tab size back again
07765    E144  85 10              STA   Iclim             ; save for now
07766    E146  A5 0F              LDA   TWidth            ; get width back
07767    E148  38                 SEC                     ; set carry for subtract
07768    E149  E5 10              SBC   Iclim             ; subtract remainder
07769    E14B  85 10              STA   Iclim             ; save tab column limit
07770    LAB_NOSQ
07771    E14D  60                 RTS
07772    
07773    TabErr
07774    E14E  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
07775    
07776    ; perform SQR()
07777    
07778    LAB_SQR
07779    E151  A5 B0              LDA   FAC1_s            ; get FAC1 sign
07780    E153  30 F9              BMI   TabErr            ; if -ve do function call error
07781    
07782    E155  A5 AC              LDA   FAC1_e            ; get exponent
07783    E157  F0 F4              BEQ   LAB_NOSQ          ; if zero just return
07784    
07785                                  ; else do root
07786    E159  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
07787    E15C  A9 00              LDA   #$00              ; clear A
07788    
07789    E15E  85 77              STA   FACt_3            ; clear remainder
07790    E160  85 76              STA   FACt_2            ; ..
07791    E162  85 75              STA   FACt_1            ; ..
07792    E164  85 78              STA   TempB             ; ..
07793    
07794    E166  85 AF              STA   FAC1_3            ; clear root
07795    E168  85 AE              STA   FAC1_2            ; ..
07796    E16A  85 AD              STA   FAC1_1            ; ..
07797    
07798    E16C  A2 18              LDX   #$18              ; 24 pairs of bits to do
07799    E16E  A5 B3              LDA   FAC2_e            ; get exponent
07800    E170  4A                 LSR                     ; check odd/even
07801    E171  B0 0E              BCS   LAB_SQE2          ; if odd only 1 shift first time
07802    
07803    LAB_SQE1
07804    E173  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
07805    E175  26 B5              ROL   FAC2_2            ; ..
07806    E177  26 B4              ROL   FAC2_1            ; ..
07807    E179  26 77              ROL   FACt_3            ; .. into remainder
07808    E17B  26 76              ROL   FACt_2            ; ..
07809    E17D  26 75              ROL   FACt_1            ; ..
07810    E17F  26 78              ROL   TempB             ; .. never overflows
07811    LAB_SQE2
07812    E181  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
07813    E183  26 B5              ROL   FAC2_2            ; ..
07814    E185  26 B4              ROL   FAC2_1            ; ..
07815    E187  26 77              ROL   FACt_3            ; .. into remainder
07816    E189  26 76              ROL   FACt_2            ; ..
07817    E18B  26 75              ROL   FACt_1            ; ..
07818    E18D  26 78              ROL   TempB             ; .. never overflows
07819    
07820    E18F  06 AF              ASL   FAC1_3            ; root = root * 2
07821    E191  26 AE              ROL   FAC1_2            ; ..
07822    E193  26 AD              ROL   FAC1_1            ; .. never overflows
07823    
07824    E195  A5 AF              LDA   FAC1_3            ; get root low byte
07825    E197  2A                 ROL                     ; *2
07826    E198  85 5B              STA   Temp3             ; save partial low byte
07827    E19A  A5 AE              LDA   FAC1_2            ; get root low mid byte
07828    E19C  2A                 ROL                     ; *2
07829    E19D  85 5C              STA   Temp3+1           ; save partial low mid byte
07830    E19F  A5 AD              LDA   FAC1_1            ; get root high mid byte
07831    E1A1  2A                 ROL                     ; *2
07832    E1A2  85 5D              STA   Temp3+2           ; save partial high mid byte
07833    E1A4  A9 00              LDA   #$00              ; get root high byte (always $00)
07834    E1A6  2A                 ROL                     ; *2
07835    E1A7  85 5E              STA   Temp3+3           ; save partial high byte
07836    
07837                                  ; carry clear for subtract +1
07838    E1A9  A5 77              LDA   FACt_3            ; get remainder low byte
07839    E1AB  E5 5B              SBC   Temp3             ; subtract partial low byte
07840    E1AD  85 5B              STA   Temp3             ; save partial low byte
07841    
07842    E1AF  A5 76              LDA   FACt_2            ; get remainder low mid byte
07843    E1B1  E5 5C              SBC   Temp3+1           ; subtract partial low mid byte
07844    E1B3  85 5C              STA   Temp3+1           ; save partial low mid byte
07845    
07846    E1B5  A5 75              LDA   FACt_1            ; get remainder high mid byte
07847    E1B7  E5 5D              SBC   Temp3+2           ; subtract partial high mid byte
07848    E1B9  A8                 TAY                     ; copy partial high mid byte
07849    
07850    E1BA  A5 78              LDA   TempB             ; get remainder high byte
07851    E1BC  E5 5E              SBC   Temp3+3           ; subtract partial high byte
07852    E1BE  90 0E              BCC   LAB_SQNS          ; skip sub if remainder smaller
07853    
07854    E1C0  85 78              STA   TempB             ; save remainder high byte
07855    
07856    E1C2  84 75              STY   FACt_1            ; save remainder high mid byte
07857    
07858    E1C4  A5 5C              LDA   Temp3+1           ; get remainder low mid byte
07859    E1C6  85 76              STA   FACt_2            ; save remainder low mid byte
07860    
07861    E1C8  A5 5B              LDA   Temp3             ; get partial low byte
07862    E1CA  85 77              STA   FACt_3            ; save remainder low byte
07863    
07864    E1CC  E6 AF              INC   FAC1_3            ; increment root low byte (never any rollover)
07865    LAB_SQNS
07866    E1CE  CA                 DEX                     ; decrement bit pair count
07867    E1CF  D0 A2              BNE   LAB_SQE1          ; loop if not all done
07868    
07869    E1D1  38                 SEC                     ; set carry for subtract
07870    E1D2  A5 B3              LDA   FAC2_e            ; get exponent
07871    E1D4  E9 80              SBC   #$80              ; normalise
07872    E1D6  6A                 ROR                     ; /2 and re-bias to $80
07873    E1D7  69 00              ADC   #$00              ; add bit zero back in (allow for half shift)
07874    E1D9  85 AC              STA   FAC1_e            ; save it
07875    E1DB  4C 47 D7           JMP   LAB_24D5          ; normalise FAC1 and return
07876    
07877    ; perform VARPTR()
07878    
07879    LAB_VARPTR
07880    E1DE  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
07881    E1E1  20 BE CE           JSR   LAB_GVAR          ; get var address
07882    E1E4  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
07883    E1E7  A4 95              LDY   Cvaral            ; get var address low byte
07884    E1E9  A5 96              LDA   Cvarah            ; get var address high byte
07885    E1EB  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
07886    
07887    ; perform PI
07888    
07889    LAB_PI
07890    E1EE  A9 D2              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
07891    E1F0  A0 E2              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
07892    E1F2  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
07893    E1F5  C6 AC              DEC   FAC1_e            ; make result = PI
07894    E1F7  60                 RTS
07895    
07896    ; perform TWOPI
07897    
07898    LAB_TWOPI
07899    E1F8  A9 D2              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
07900    E1FA  A0 E2              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
07901    E1FC  4C 90 D9           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
07902    
07903    ; system dependant i/o vectors
07904    ; these are in RAM and are set by the monitor at start-up
07905    
07906    V_INPT
07907    E1FF  6C 05 02           JMP   (VEC_IN)          ; non halting scan input device
07908    V_OUTP
07909    E202  6C 07 02           JMP   (VEC_OUT)         ; send byte to output device
07910    V_LOAD
07911    E205  6C 09 02           JMP   (VEC_LD)          ; load BASIC program
07912    V_SAVE
07913    E208  6C 0B 02           JMP   (VEC_SV)          ; save BASIC program
07914    
07915    ; The rest are tables messages and code for RAM
07916    
07917    ; the rest of the code is tables and BASIC start-up code
07918    
07919    PG2_TABS
07920          .byte $00               ; ctrl-c flag           -     $00 = enabled
07921          .byte $00               ; ctrl-c byte           -     GET needs this
07922          .byte $00               ; ctrl-c byte timeout   -     GET needs this
07923          .word CTRLC             ; ctrl c check vector
07924    ;     .word xxxx              ; non halting key input -     monitor to set this
07925    ;     .word xxxx              ; output vector         -     monitor to set this
07926    ;     .word xxxx              ; load vector           -     monitor to set this
07927    ;     .word xxxx              ; save vector           -     monitor to set this
07928    PG2_TABE
07929    
07930    ; character get subroutine for zero page
07931    
07932    ; For a 1.8432MHz 6502 including the JSR and RTS
07933    ; fastest (>=":") =  29 cycles =  15.7uS
07934    ; slowest (<":")  =  40 cycles =  21.7uS
07935    ; space skip      = +21 cycles = +11.4uS
07936    ; inc across page =  +4 cycles =  +2.2uS
07937    
07938    ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
07939    ; block is copied to it's destination, any non zero page address will do at assembly
07940    ; time, to assemble a three byte instruction.
07941    
07942    ; page 0 initialisation table from $BC
07943    ; increment and scan memory
07944    
07945    LAB_2CEE
07946    E210  E6 C3              INC   Bpntrl            ; increment BASIC execute pointer low byte
07947    E212  D0 02              BNE   LAB_2CF4          ; branch if no carry
07948                                  ; else
07949    E214  E6 C4              INC   Bpntrh            ; increment BASIC execute pointer high byte
07950    
07951    ; page 0 initialisation table from $C2
07952    ; scan memory
07953    
07954    LAB_2CF4
07955    E216  AD FF FF           LDA   $FFFF             ; get byte to scan (addr set by call routine)
07956    E219  C9 AC              CMP   #TK_ELSE          ; compare with the token for ELSE
07957    E21B  F0 0E              BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
07958    
07959    E21D  C9 3A              CMP   #':'              ; compare with ":"
07960    E21F  B0 0A              BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
07961    
07962    E221  C9 20              CMP   #' '              ; compare with " "
07963    E223  F0 EB              BEQ   LAB_2CEE          ; if " " go do next
07964    
07965    E225  38                 SEC                     ; set carry for SBC
07966    E226  E9 30              SBC   #'0'              ; subtract "0"
07967    E228  38                 SEC                     ; set carry for SBC
07968    E229  E9 D0              SBC   #$D0              ; subtract -"0"
07969                                  ; clear carry if byte = "0"-"9"
07970    LAB_2D05
07971    E22B  60                 RTS
07972    
07973    ; page zero initialisation table $00-$12 inclusive
07974    
07975    StrTab
07976          .byte $4C               ; JMP opcode
07977          .word LAB_COLD          ; initial warm start vector (cold start)
07978    
07979          .byte $00               ; these bytes are not used by BASIC
07980          .word $0000             ; 
07981          .word $0000             ; 
07982          .word $0000             ; 
07983    
07984          .byte $4C               ; JMP opcode
07985          .word LAB_FCER          ; initial user function vector ("Function call" error)
07986          .byte $00               ; default NULL count
07987          .byte $00               ; clear terminal position
07988          .byte $00               ; default terminal width byte
07989          .byte $F2               ; default limit for TAB = 14
07990          .word Ram_base          ; start of user RAM
07991    EndTab
07992    
07993    LAB_MSZM
07994          .byte $0D,$0A,"Memory size ",$00
07995    
07996    LAB_SMSG
07997          .byte " Bytes free",$0D,$0A,$0A
07998          .byte "Enhanced BASIC 2.22p5",$0A,$00
07999    
08000    ; numeric constants and series
08001    
08002                                  ; constants and series for LOG(n)
08003    LAB_25A0
08004          .byte $02               ; counter
08005          .byte $80,$19,$56,$62   ; 0.59898
08006          .byte $80,$76,$22,$F3   ; 0.96147
08007    ;##   .byte $80,$76,$22,$F1   ; 0.96147
08008          .byte $82,$38,$AA,$40   ; 2.88539
08009    ;##   .byte $82,$38,$AA,$45   ; 2.88539
08010    
08011    LAB_25AD
08012          .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
08013    LAB_25B1
08014          .byte $81,$35,$04,$F3   ; 1.41421   root 2
08015    LAB_25B5
08016          .byte $80,$80,$00,$00   ; -0.5
08017    LAB_25B9
08018          .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
08019    
08020                                  ; numeric PRINT constants
08021    LAB_2947
08022          .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
08023    LAB_294B
08024          .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
08025    LAB_294F
08026          .byte $94,$74,$24,$00   ; 1000000
08027    
08028                                  ; EXP(n) constants and series
08029    LAB_2AFA
08030          .byte $81,$38,$AA,$3B   ; 1.4427    (1/LOG base 2 e)
08031    LAB_2AFE
08032          .byte $06               ; counter
08033          .byte $74,$63,$90,$8C   ; 2.17023e-4
08034          .byte $77,$23,$0C,$AB   ; 0.00124
08035          .byte $7A,$1E,$94,$00   ; 0.00968
08036          .byte $7C,$63,$42,$80   ; 0.05548
08037          .byte $7E,$75,$FE,$D0   ; 0.24023
08038          .byte $80,$31,$72,$15   ; 0.69315
08039          .byte $81,$00,$00,$00   ; 1.00000
08040    
08041    ;##   .byte $07               ; counter
08042    ;##   .byte $74,$94,$2E,$40   ; -1/7! (-1/5040)
08043    ;##   .byte $77,$2E,$4F,$70   ;  1/6! ( 1/720)
08044    ;##   .byte $7A,$88,$02,$6E   ; -1/5! (-1/120)
08045    ;##   .byte $7C,$2A,$A0,$E6   ;  1/4! ( 1/24)
08046    ;##   .byte $7E,$AA,$AA,$50   ; -1/3! (-1/6)
08047    ;##   .byte $7F,$7F,$FF,$FF   ;  1/2! ( 1/2)
08048    ;##   .byte $81,$80,$00,$00   ; -1/1! (-1/1)
08049    ;##   .byte $81,$00,$00,$00   ;  1/0! ( 1/1)
08050    
08051                                  ; trigonometric constants and series
08052    LAB_2C78
08053          .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
08054    LAB_2C84
08055          .byte $04               ; counter
08056          .byte $86,$1E,$D7,$FB   ; 39.7109
08057    ;##   .byte $86,$1E,$D7,$BA   ; 39.7109
08058          .byte $87,$99,$26,$65   ;-76.575
08059    ;##   .byte $87,$99,$26,$64   ;-76.575
08060          .byte $87,$23,$34,$58   ; 81.6022
08061          .byte $86,$A5,$5D,$E1   ;-41.3417
08062    ;##   .byte $86,$A5,$5D,$E0   ;-41.3417
08063    LAB_2C7C
08064          .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
08065    ;##   .byte $83,$49,$0F,$DA   ; 6.28319 (2*pi) as floating #
08066    
08067    LAB_2CC9
08068          .byte $08               ; counter
08069          .byte $78,$3A,$C5,$37   ; 0.00285
08070          .byte $7B,$83,$A2,$5C   ;-0.0160686
08071          .byte $7C,$2E,$DD,$4D   ; 0.0426915
08072          .byte $7D,$99,$B0,$1E   ;-0.0750429
08073          .byte $7D,$59,$ED,$24   ; 0.106409
08074          .byte $7E,$91,$72,$00   ;-0.142036
08075          .byte $7E,$4C,$B9,$73   ; 0.199926
08076          .byte $7F,$AA,$AA,$53   ;-0.333331
08077    
08078    ;##   .byte $08               ; counter
08079    ;##   .byte $78,$3B,$D7,$4A   ; 1/17
08080    ;##   .byte $7B,$84,$6E,$02   ;-1/15
08081    ;##   .byte $7C,$2F,$C1,$FE   ; 1/13
08082    ;##   .byte $7D,$9A,$31,$74   ;-1/11
08083    ;##   .byte $7D,$5A,$3D,$84   ; 1/9
08084    ;##   .byte $7E,$91,$7F,$C8   ;-1/7
08085    ;##   .byte $7E,$4C,$BB,$E4   ; 1/5
08086    ;##   .byte $7F,$AA,$AA,$6C   ;-1/3
08087    
08088      E2F8             LAB_1D96    = *+1             ; $00,$00 used for undefined variables
08089    LAB_259C
08090          .byte $81,$00,$00,$00   ; 1.000000, used for INC
08091    LAB_2AFD
08092          .byte $81,$80,$00,$00   ; -1.00000, used for DEC. must be on the same page as +1.00
08093    
08094                                  ; misc constants
08095    LAB_1DF7
08096          .byte $90               ;-32768 (uses first three bytes from 0.5)
08097    LAB_2A96
08098          .byte $80,$00,$00,$00   ; 0.5
08099    LAB_2C80
08100          .byte $7F,$00,$00,$00   ; 0.25
08101    LAB_26B5
08102          .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
08103    
08104    ; This table is used in converting numbers to ASCII.
08105    
08106    LAB_2A9A
08107      E30D             LAB_2A9B = LAB_2A9A+1
08108      E30E             LAB_2A9C = LAB_2A9B+1
08109          .byte $FE,$79,$60       ; -100000
08110          .byte $00,$27,$10       ; 10000
08111          .byte $FF,$FC,$18       ; -1000
08112          .byte $00,$00,$64       ; 100
08113          .byte $FF,$FF,$F6       ; -10
08114          .byte $00,$00,$01       ; 1
08115    
08116    LAB_CTBL
08117          .word LAB_END-1         ; END
08118          .word LAB_FOR-1         ; FOR
08119          .word LAB_NEXT-1        ; NEXT
08120          .word LAB_DATA-1        ; DATA
08121          .word LAB_INPUT-1       ; INPUT
08122          .word LAB_DIM-1         ; DIM
08123          .word LAB_READ-1        ; READ
08124          .word LAB_LET-1         ; LET
08125          .word LAB_DEC-1         ; DEC             new command
08126          .word LAB_GOTO-1        ; GOTO
08127          .word LAB_RUN-1         ; RUN
08128          .word LAB_IF-1          ; IF
08129          .word LAB_RESTORE-1     ; RESTORE         modified command
08130          .word LAB_GOSUB-1       ; GOSUB
08131          .word LAB_RETIRQ-1      ; RETIRQ          new command
08132          .word LAB_RETNMI-1      ; RETNMI          new command
08133          .word LAB_RETURN-1      ; RETURN
08134          .word LAB_REM-1         ; REM
08135          .word LAB_STOP-1        ; STOP
08136          .word LAB_ON-1          ; ON              modified command
08137          .word LAB_NULL-1        ; NULL            modified command
08138          .word LAB_INC-1         ; INC             new command
08139          .word LAB_WAIT-1        ; WAIT
08140          .word V_LOAD-1          ; LOAD
08141          .word V_SAVE-1          ; SAVE
08142          .word LAB_DEF-1         ; DEF
08143          .word LAB_POKE-1        ; POKE
08144          .word LAB_DOKE-1        ; DOKE            new command
08145          .word LAB_CALL-1        ; CALL            new command
08146          .word LAB_DO-1          ; DO              new command
08147          .word LAB_LOOP-1        ; LOOP            new command
08148          .word LAB_PRINT-1       ; PRINT
08149          .word LAB_CONT-1        ; CONT
08150          .word LAB_LIST-1        ; LIST
08151          .word LAB_CLEAR-1       ; CLEAR
08152          .word LAB_NEW-1         ; NEW
08153          .word LAB_WDTH-1        ; WIDTH           new command
08154          .word LAB_GET-1         ; GET             new command
08155          .word LAB_SWAP-1        ; SWAP            new command
08156          .word LAB_BITSET-1      ; BITSET          new command
08157          .word LAB_BITCLR-1      ; BITCLR          new command
08158          .word LAB_IRQ-1         ; IRQ             new command
08159          .word LAB_NMI-1         ; NMI             new command
08160    
08161    ; function pre process routine table
08162    
08163    LAB_FTPL
08164      E375             LAB_FTPM    = LAB_FTPL+$01
08165          .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
08166          .word LAB_PPFN-1        ; INT(n)          "
08167          .word LAB_PPFN-1        ; ABS(n)          "
08168          .word LAB_EVEZ-1        ; USR(x)    process any expression
08169          .word LAB_1BF7-1        ; FRE(x)          "
08170          .word LAB_1BF7-1        ; POS(x)          "
08171          .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
08172          .word LAB_PPFN-1        ; RND(n)          "
08173          .word LAB_PPFN-1        ; LOG(n)          "
08174          .word LAB_PPFN-1        ; EXP(n)          "
08175          .word LAB_PPFN-1        ; COS(n)          "
08176          .word LAB_PPFN-1        ; SIN(n)          "
08177          .word LAB_PPFN-1        ; TAN(n)          "
08178          .word LAB_PPFN-1        ; ATN(n)          "
08179          .word LAB_PPFN-1        ; PEEK(n)         "
08180          .word LAB_PPFN-1        ; DEEK(n)         "
08181          .word $0000             ; SADD()    none
08182          .word LAB_PPFS-1        ; LEN($)    process string expression in ()
08183          .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
08184          .word LAB_PPFS-1        ; VAL($)    process string expression in ()
08185          .word LAB_PPFS-1        ; ASC($)          "
08186          .word LAB_PPFS-1        ; UCASE$($)       "
08187          .word LAB_PPFS-1        ; LCASE$($)       "
08188          .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
08189          .word LAB_BHSS-1        ; HEX$(n)         "
08190          .word LAB_BHSS-1        ; BIN$(n)         "
08191          .word $0000             ; BITTST()  none
08192          .word LAB_MMPP-1        ; MAX()     process numeric expression
08193          .word LAB_MMPP-1        ; MIN()           "
08194          .word LAB_PPBI-1        ; PI        advance pointer
08195          .word LAB_PPBI-1        ; TWOPI           "
08196          .word $0000             ; VARPTR()  none
08197          .word LAB_LRMS-1        ; LEFT$()   process string expression
08198          .word LAB_LRMS-1        ; RIGHT$()        "
08199          .word LAB_LRMS-1        ; MID$()          "
08200    
08201    ; action addresses for functions
08202    
08203    LAB_FTBL
08204      E3BB             LAB_FTBM    = LAB_FTBL+$01
08205          .word LAB_SGN-1         ; SGN()
08206          .word LAB_INT-1         ; INT()
08207          .word LAB_ABS-1         ; ABS()
08208          .word LAB_USR-1         ; USR()
08209          .word LAB_FRE-1         ; FRE()
08210          .word LAB_POS-1         ; POS()
08211          .word LAB_SQR-1         ; SQR()
08212          .word LAB_RND-1         ; RND()           modified function
08213          .word LAB_LOG-1         ; LOG()
08214          .word LAB_EXP-1         ; EXP()
08215          .word LAB_COS-1         ; COS()
08216          .word LAB_SIN-1         ; SIN()
08217          .word LAB_TAN-1         ; TAN()
08218          .word LAB_ATN-1         ; ATN()
08219          .word LAB_PEEK-1        ; PEEK()
08220          .word LAB_DEEK-1        ; DEEK()          new function
08221          .word LAB_SADD-1        ; SADD()          new function
08222          .word LAB_LENS-1        ; LEN()
08223          .word LAB_STRS-1        ; STR$()
08224          .word LAB_VAL-1         ; VAL()
08225          .word LAB_ASC-1         ; ASC()
08226          .word LAB_UCASE-1       ; UCASE$()        new function
08227          .word LAB_LCASE-1       ; LCASE$()        new function
08228          .word LAB_CHRS-1        ; CHR$()
08229          .word LAB_HEXS-1        ; HEX$()          new function
08230          .word LAB_BINS-1        ; BIN$()          new function
08231          .word LAB_BTST-1        ; BITTST()        new function
08232          .word LAB_MAX-1         ; MAX()           new function
08233          .word LAB_MIN-1         ; MIN()           new function
08234          .word LAB_PI-1          ; PI              new function
08235          .word LAB_TWOPI-1       ; TWOPI           new function
08236          .word LAB_VARPTR-1      ; VARPTR()        new function
08237          .word LAB_LEFT-1        ; LEFT$()
08238          .word LAB_RIGHT-1       ; RIGHT$()
08239          .word LAB_MIDS-1        ; MID$()
08240    
08241    ; hierarchy and action addresses for operator
08242    
08243    LAB_OPPT
08244          .byte $79               ; +
08245          .word LAB_ADD-1
08246          .byte $79               ; -
08247          .word LAB_SUBTRACT-1
08248          .byte $7B               ; *
08249          .word LAB_MULTIPLY-1
08250          .byte $7B               ; /
08251          .word LAB_DIVIDE-1
08252          .byte $7F               ; ^
08253          .word LAB_POWER-1
08254          .byte $50               ; AND
08255          .word LAB_AND-1
08256          .byte $46               ; EOR             new operator
08257          .word LAB_EOR-1
08258          .byte $46               ; OR
08259          .word LAB_OR-1
08260          .byte $56               ; >>              new operator
08261          .word LAB_RSHIFT-1
08262          .byte $56               ; <<              new operator
08263          .word LAB_LSHIFT-1
08264          .byte $7D               ; >
08265          .word LAB_GTHAN-1
08266          .byte $5A               ; =
08267          .word LAB_EQUAL-1
08268          .byte $64               ; <
08269          .word LAB_LTHAN-1
08270    
08271    ; keywords start with ..
08272    ; this is the first character table and must be in alphabetic order
08273    
08274    TAB_1STC
08275          .byte "*"
08276          .byte "+"
08277          .byte "-"
08278          .byte "/"
08279          .byte "<"
08280          .byte "="
08281          .byte ">"
08282          .byte "?"
08283          .byte "A"
08284          .byte "B"
08285          .byte "C"
08286          .byte "D"
08287          .byte "E"
08288          .byte "F"
08289          .byte "G"
08290          .byte "H"
08291          .byte "I"
08292          .byte "L"
08293          .byte "M"
08294          .byte "N"
08295          .byte "O"
08296          .byte "P"
08297          .byte "R"
08298          .byte "S"
08299          .byte "T"
08300          .byte "U"
08301          .byte "V"
08302          .byte "W"
08303          .byte "^"
08304          .byte $00               ; table terminator
08305    
08306    ; pointers to keyword tables
08307    
08308    TAB_CHRT
08309          .word TAB_STAR          ; table for "*"
08310          .word TAB_PLUS          ; table for "+"
08311          .word TAB_MNUS          ; table for "-"
08312          .word TAB_SLAS          ; table for "/"
08313          .word TAB_LESS          ; table for "<"
08314          .word TAB_EQUL          ; table for "="
08315          .word TAB_MORE          ; table for ">"
08316          .word TAB_QEST          ; table for "?"
08317          .word TAB_ASCA          ; table for "A"
08318          .word TAB_ASCB          ; table for "B"
08319          .word TAB_ASCC          ; table for "C"
08320          .word TAB_ASCD          ; table for "D"
08321          .word TAB_ASCE          ; table for "E"
08322          .word TAB_ASCF          ; table for "F"
08323          .word TAB_ASCG          ; table for "G"
08324          .word TAB_ASCH          ; table for "H"
08325          .word TAB_ASCI          ; table for "I"
08326          .word TAB_ASCL          ; table for "L"
08327          .word TAB_ASCM          ; table for "M"
08328          .word TAB_ASCN          ; table for "N"
08329          .word TAB_ASCO          ; table for "O"
08330          .word TAB_ASCP          ; table for "P"
08331          .word TAB_ASCR          ; table for "R"
08332          .word TAB_ASCS          ; table for "S"
08333          .word TAB_ASCT          ; table for "T"
08334          .word TAB_ASCU          ; table for "U"
08335          .word TAB_ASCV          ; table for "V"
08336          .word TAB_ASCW          ; table for "W"
08337          .word TAB_POWR          ; table for "^"
08338    
08339    ; tables for each start character, note if a longer keyword with the same start
08340    ; letters as a shorter one exists then it must come first, else the list is in
08341    ; alphabetical order as follows ..
08342    
08343    ; [keyword,token
08344    ; [keyword,token]]
08345    ; end marker (#$00)
08346    
08347    TAB_STAR
08348          .byte TK_MUL,$00        ; *
08349    TAB_PLUS
08350          .byte TK_PLUS,$00       ; +
08351    TAB_MNUS
08352          .byte TK_MINUS,$00      ; -
08353    TAB_SLAS
08354          .byte TK_DIV,$00        ; /
08355    TAB_LESS
08356    LBB_LSHIFT
08357          .byte "<",TK_LSHIFT     ; <<  note - "<<" must come before "<"
08358          .byte TK_LT             ; <
08359          .byte $00
08360    TAB_EQUL
08361          .byte TK_EQUAL,$00      ; =
08362    TAB_MORE
08363    LBB_RSHIFT
08364          .byte ">",TK_RSHIFT     ; >>  note - ">>" must come before ">"
08365          .byte TK_GT             ; >
08366          .byte $00
08367    TAB_QEST
08368          .byte TK_PRINT,$00      ; ?
08369    TAB_ASCA
08370    LBB_ABS
08371          .byte "BS(",TK_ABS      ; ABS(
08372    LBB_AND
08373          .byte "ND",TK_AND       ; AND
08374    LBB_ASC
08375          .byte "SC(",TK_ASC      ; ASC(
08376    LBB_ATN
08377          .byte "TN(",TK_ATN      ; ATN(
08378          .byte $00
08379    TAB_ASCB
08380    LBB_BINS
08381          .byte "IN$(",TK_BINS    ; BIN$(
08382    LBB_BITCLR
08383          .byte "ITCLR",TK_BITCLR ; BITCLR
08384    LBB_BITSET
08385          .byte "ITSET",TK_BITSET ; BITSET
08386    LBB_BITTST
08387          .byte "ITTST(",TK_BITTST
08388                                  ; BITTST(
08389          .byte $00
08390    TAB_ASCC
08391    LBB_CALL
08392          .byte "ALL",TK_CALL     ; CALL
08393    LBB_CHRS
08394          .byte "HR$(",TK_CHRS    ; CHR$(
08395    LBB_CLEAR
08396          .byte "LEAR",TK_CLEAR   ; CLEAR
08397    LBB_CONT
08398          .byte "ONT",TK_CONT     ; CONT
08399    LBB_COS
08400          .byte "OS(",TK_COS      ; COS(
08401          .byte $00
08402    TAB_ASCD
08403    LBB_DATA
08404          .byte "ATA",TK_DATA     ; DATA
08405    LBB_DEC
08406          .byte "EC",TK_DEC       ; DEC
08407    LBB_DEEK
08408          .byte "EEK(",TK_DEEK    ; DEEK(
08409    LBB_DEF
08410          .byte "EF",TK_DEF       ; DEF
08411    LBB_DIM
08412          .byte "IM",TK_DIM       ; DIM
08413    LBB_DOKE
08414          .byte "OKE",TK_DOKE     ; DOKE note - "DOKE" must come before "DO"
08415    LBB_DO
08416          .byte "O",TK_DO         ; DO
08417          .byte $00
08418    TAB_ASCE
08419    LBB_ELSE
08420          .byte "LSE",TK_ELSE     ; ELSE
08421    LBB_END
08422          .byte "ND",TK_END       ; END
08423    LBB_EOR
08424          .byte "OR",TK_EOR       ; EOR
08425    LBB_EXP
08426          .byte "XP(",TK_EXP      ; EXP(
08427          .byte $00
08428    TAB_ASCF
08429    LBB_FN
08430          .byte "N",TK_FN         ; FN
08431    LBB_FOR
08432          .byte "OR",TK_FOR       ; FOR
08433    LBB_FRE
08434          .byte "RE(",TK_FRE      ; FRE(
08435          .byte $00
08436    TAB_ASCG
08437    LBB_GET
08438          .byte "ET",TK_GET       ; GET
08439    LBB_GOSUB
08440          .byte "OSUB",TK_GOSUB   ; GOSUB
08441    LBB_GOTO
08442          .byte "OTO",TK_GOTO     ; GOTO
08443          .byte $00
08444    TAB_ASCH
08445    LBB_HEXS
08446          .byte "EX$(",TK_HEXS    ; HEX$(
08447          .byte $00
08448    TAB_ASCI
08449    LBB_IF
08450          .byte "F",TK_IF         ; IF
08451    LBB_INC
08452          .byte "NC",TK_INC       ; INC
08453    LBB_INPUT
08454          .byte "NPUT",TK_INPUT   ; INPUT
08455    LBB_INT
08456          .byte "NT(",TK_INT      ; INT(
08457    LBB_IRQ
08458          .byte "RQ",TK_IRQ       ; IRQ
08459          .byte $00
08460    TAB_ASCL
08461    LBB_LCASES
08462          .byte "CASE$(",TK_LCASES
08463                                  ; LCASE$(
08464    LBB_LEFTS
08465          .byte "EFT$(",TK_LEFTS  ; LEFT$(
08466    LBB_LEN
08467          .byte "EN(",TK_LEN      ; LEN(
08468    LBB_LET
08469          .byte "ET",TK_LET       ; LET
08470    LBB_LIST
08471          .byte "IST",TK_LIST     ; LIST
08472    LBB_LOAD
08473          .byte "OAD",TK_LOAD     ; LOAD
08474    LBB_LOG
08475          .byte "OG(",TK_LOG      ; LOG(
08476    LBB_LOOP
08477          .byte "OOP",TK_LOOP     ; LOOP
08478          .byte $00
08479    TAB_ASCM
08480    LBB_MAX
08481          .byte "AX(",TK_MAX      ; MAX(
08482    LBB_MIDS
08483          .byte "ID$(",TK_MIDS    ; MID$(
08484    LBB_MIN
08485          .byte "IN(",TK_MIN      ; MIN(
08486          .byte $00
08487    TAB_ASCN
08488    LBB_NEW
08489          .byte "EW",TK_NEW       ; NEW
08490    LBB_NEXT
08491          .byte "EXT",TK_NEXT     ; NEXT
08492    LBB_NMI
08493          .byte "MI",TK_NMI       ; NMI
08494    LBB_NOT
08495          .byte "OT",TK_NOT       ; NOT
08496    LBB_NULL
08497          .byte "ULL",TK_NULL     ; NULL
08498          .byte $00
08499    TAB_ASCO
08500    LBB_OFF
08501          .byte "FF",TK_OFF       ; OFF
08502    LBB_ON
08503          .byte "N",TK_ON         ; ON
08504    LBB_OR
08505          .byte "R",TK_OR         ; OR
08506          .byte $00
08507    TAB_ASCP
08508    LBB_PEEK
08509          .byte "EEK(",TK_PEEK    ; PEEK(
08510    LBB_PI
08511          .byte "I",TK_PI         ; PI
08512    LBB_POKE
08513          .byte "OKE",TK_POKE     ; POKE
08514    LBB_POS
08515          .byte "OS(",TK_POS      ; POS(
08516    LBB_PRINT
08517          .byte "RINT",TK_PRINT   ; PRINT
08518          .byte $00
08519    TAB_ASCR
08520    LBB_READ
08521          .byte "EAD",TK_READ     ; READ
08522    LBB_REM
08523          .byte "EM",TK_REM       ; REM
08524    LBB_RESTORE
08525          .byte "ESTORE",TK_RESTORE
08526                                  ; RESTORE
08527    LBB_RETIRQ
08528          .byte "ETIRQ",TK_RETIRQ ; RETIRQ
08529    LBB_RETNMI
08530          .byte "ETNMI",TK_RETNMI ; RETNMI
08531    LBB_RETURN
08532          .byte "ETURN",TK_RETURN ; RETURN
08533    LBB_RIGHTS
08534          .byte "IGHT$(",TK_RIGHTS
08535                                  ; RIGHT$(
08536    LBB_RND
08537          .byte "ND(",TK_RND      ; RND(
08538    LBB_RUN
08539          .byte "UN",TK_RUN       ; RUN
08540          .byte $00
08541    TAB_ASCS
08542    LBB_SADD
08543          .byte "ADD(",TK_SADD    ; SADD(
08544    LBB_SAVE
08545          .byte "AVE",TK_SAVE     ; SAVE
08546    LBB_SGN
08547          .byte "GN(",TK_SGN      ; SGN(
08548    LBB_SIN
08549          .byte "IN(",TK_SIN      ; SIN(
08550    LBB_SPC
08551          .byte "PC(",TK_SPC      ; SPC(
08552    LBB_SQR
08553          .byte "QR(",TK_SQR      ; SQR(
08554    LBB_STEP
08555          .byte "TEP",TK_STEP     ; STEP
08556    LBB_STOP
08557          .byte "TOP",TK_STOP     ; STOP
08558    LBB_STRS
08559          .byte "TR$(",TK_STRS    ; STR$(
08560    LBB_SWAP
08561          .byte "WAP",TK_SWAP     ; SWAP
08562          .byte $00
08563    TAB_ASCT
08564    LBB_TAB
08565          .byte "AB(",TK_TAB      ; TAB(
08566    LBB_TAN
08567          .byte "AN(",TK_TAN      ; TAN(
08568    LBB_THEN
08569          .byte "HEN",TK_THEN     ; THEN
08570    LBB_TO
08571          .byte "O",TK_TO         ; TO
08572    LBB_TWOPI
08573          .byte "WOPI",TK_TWOPI   ; TWOPI
08574          .byte $00
08575    TAB_ASCU
08576    LBB_UCASES
08577          .byte "CASE$(",TK_UCASES
08578                                  ; UCASE$(
08579    LBB_UNTIL
08580          .byte "NTIL",TK_UNTIL   ; UNTIL
08581    LBB_USR
08582          .byte "SR(",TK_USR      ; USR(
08583          .byte $00
08584    TAB_ASCV
08585    LBB_VAL
08586          .byte "AL(",TK_VAL      ; VAL(
08587    LBB_VPTR
08588          .byte "ARPTR(",TK_VPTR  ; VARPTR(
08589          .byte $00
08590    TAB_ASCW
08591    LBB_WAIT
08592          .byte "AIT",TK_WAIT     ; WAIT
08593    LBB_WHILE
08594          .byte "HILE",TK_WHILE   ; WHILE
08595    LBB_WIDTH
08596          .byte "IDTH",TK_WIDTH   ; WIDTH
08597          .byte $00
08598    TAB_POWR
08599          .byte TK_POWER,$00      ; ^
08600    
08601    ; new decode table for LIST
08602    ; Table is ..
08603    ; byte - keyword length, keyword first character
08604    ; word - pointer to rest of keyword from dictionary
08605    
08606    ; note if length is 1 then the pointer is ignored
08607    
08608    LAB_KEYT
08609          .byte 3,'E'
08610          .word LBB_END           ; END
08611          .byte 3,'F'
08612          .word LBB_FOR           ; FOR
08613          .byte 4,'N'
08614          .word LBB_NEXT          ; NEXT
08615          .byte 4,'D'
08616          .word LBB_DATA          ; DATA
08617          .byte 5,'I'
08618          .word LBB_INPUT         ; INPUT
08619          .byte 3,'D'
08620          .word LBB_DIM           ; DIM
08621          .byte 4,'R'
08622          .word LBB_READ          ; READ
08623          .byte 3,'L'
08624          .word LBB_LET           ; LET
08625          .byte 3,'D'
08626          .word LBB_DEC           ; DEC
08627          .byte 4,'G'
08628          .word LBB_GOTO          ; GOTO
08629          .byte 3,'R'
08630          .word LBB_RUN           ; RUN
08631          .byte 2,'I'
08632          .word LBB_IF            ; IF
08633          .byte 7,'R'
08634          .word LBB_RESTORE       ; RESTORE
08635          .byte 5,'G'
08636          .word LBB_GOSUB         ; GOSUB
08637          .byte 6,'R'
08638          .word LBB_RETIRQ        ; RETIRQ
08639          .byte 6,'R'
08640          .word LBB_RETNMI        ; RETNMI
08641          .byte 6,'R'
08642          .word LBB_RETURN        ; RETURN
08643          .byte 3,'R'
08644          .word LBB_REM           ; REM
08645          .byte 4,'S'
08646          .word LBB_STOP          ; STOP
08647          .byte 2,'O'
08648          .word LBB_ON            ; ON
08649          .byte 4,'N'
08650          .word LBB_NULL          ; NULL
08651          .byte 3,'I'
08652          .word LBB_INC           ; INC
08653          .byte 4,'W'
08654          .word LBB_WAIT          ; WAIT
08655          .byte 4,'L'
08656          .word LBB_LOAD          ; LOAD
08657          .byte 4,'S'
08658          .word LBB_SAVE          ; SAVE
08659          .byte 3,'D'
08660          .word LBB_DEF           ; DEF
08661          .byte 4,'P'
08662          .word LBB_POKE          ; POKE
08663          .byte 4,'D'
08664          .word LBB_DOKE          ; DOKE
08665          .byte 4,'C'
08666          .word LBB_CALL          ; CALL
08667          .byte 2,'D'
08668          .word LBB_DO            ; DO
08669          .byte 4,'L'
08670          .word LBB_LOOP          ; LOOP
08671          .byte 5,'P'
08672          .word LBB_PRINT         ; PRINT
08673          .byte 4,'C'
08674          .word LBB_CONT          ; CONT
08675          .byte 4,'L'
08676          .word LBB_LIST          ; LIST
08677          .byte 5,'C'
08678          .word LBB_CLEAR         ; CLEAR
08679          .byte 3,'N'
08680          .word LBB_NEW           ; NEW
08681          .byte 5,'W'
08682          .word LBB_WIDTH         ; WIDTH
08683          .byte 3,'G'
08684          .word LBB_GET           ; GET
08685          .byte 4,'S'
08686          .word LBB_SWAP          ; SWAP
08687          .byte 6,'B'
08688          .word LBB_BITSET        ; BITSET
08689          .byte 6,'B'
08690          .word LBB_BITCLR        ; BITCLR
08691          .byte 3,'I'
08692          .word LBB_IRQ           ; IRQ
08693          .byte 3,'N'
08694          .word LBB_NMI           ; NMI
08695    
08696    ; secondary commands (can't start a statement)
08697    
08698          .byte 4,'T'
08699          .word LBB_TAB           ; TAB
08700          .byte 4,'E'
08701          .word LBB_ELSE          ; ELSE
08702          .byte 2,'T'
08703          .word LBB_TO            ; TO
08704          .byte 2,'F'
08705          .word LBB_FN            ; FN
08706          .byte 4,'S'
08707          .word LBB_SPC           ; SPC
08708          .byte 4,'T'
08709          .word LBB_THEN          ; THEN
08710          .byte 3,'N'
08711          .word LBB_NOT           ; NOT
08712          .byte 4,'S'
08713          .word LBB_STEP          ; STEP
08714          .byte 5,'U'
08715          .word LBB_UNTIL         ; UNTIL
08716          .byte 5,'W'
08717          .word LBB_WHILE         ; WHILE
08718          .byte 3,'O'
08719          .word LBB_OFF           ; OFF
08720    
08721    ; opperators
08722    
08723          .byte 1,'+'
08724          .word $0000             ; +
08725          .byte 1,'-'
08726          .word $0000             ; -
08727          .byte 1,'*'
08728          .word $0000             ; *
08729          .byte 1,'/'
08730          .word $0000             ; /
08731          .byte 1,'^'
08732          .word $0000             ; ^
08733          .byte 3,'A'
08734          .word LBB_AND           ; AND
08735          .byte 3,'E'
08736          .word LBB_EOR           ; EOR
08737          .byte 2,'O'
08738          .word LBB_OR            ; OR
08739          .byte 2,'>'
08740          .word LBB_RSHIFT        ; >>
08741          .byte 2,'<'
08742          .word LBB_LSHIFT        ; <<
08743          .byte 1,'>'
08744          .word $0000             ; >
08745          .byte 1,'='
08746          .word $0000             ; =
08747          .byte 1,'<'
08748          .word $0000             ; <
08749    
08750    ; functions
08751    
08752          .byte 4,'S'             ;
08753          .word LBB_SGN           ; SGN
08754          .byte 4,'I'             ;
08755          .word LBB_INT           ; INT
08756          .byte 4,'A'             ;
08757          .word LBB_ABS           ; ABS
08758          .byte 4,'U'             ;
08759          .word LBB_USR           ; USR
08760          .byte 4,'F'             ;
08761          .word LBB_FRE           ; FRE
08762          .byte 4,'P'             ;
08763          .word LBB_POS           ; POS
08764          .byte 4,'S'             ;
08765          .word LBB_SQR           ; SQR
08766          .byte 4,'R'             ;
08767          .word LBB_RND           ; RND
08768          .byte 4,'L'             ;
08769          .word LBB_LOG           ; LOG
08770          .byte 4,'E'             ;
08771          .word LBB_EXP           ; EXP
08772          .byte 4,'C'             ;
08773          .word LBB_COS           ; COS
08774          .byte 4,'S'             ;
08775          .word LBB_SIN           ; SIN
08776          .byte 4,'T'             ;
08777          .word LBB_TAN           ; TAN
08778          .byte 4,'A'             ;
08779          .word LBB_ATN           ; ATN
08780          .byte 5,'P'             ;
08781          .word LBB_PEEK          ; PEEK
08782          .byte 5,'D'             ;
08783          .word LBB_DEEK          ; DEEK
08784          .byte 5,'S'             ;
08785          .word LBB_SADD          ; SADD
08786          .byte 4,'L'             ;
08787          .word LBB_LEN           ; LEN
08788          .byte 5,'S'             ;
08789          .word LBB_STRS          ; STR$
08790          .byte 4,'V'             ;
08791          .word LBB_VAL           ; VAL
08792          .byte 4,'A'             ;
08793          .word LBB_ASC           ; ASC
08794          .byte 7,'U'             ;
08795          .word LBB_UCASES        ; UCASE$
08796          .byte 7,'L'             ;
08797          .word LBB_LCASES        ; LCASE$
08798          .byte 5,'C'             ;
08799          .word LBB_CHRS          ; CHR$
08800          .byte 5,'H'             ;
08801          .word LBB_HEXS          ; HEX$
08802          .byte 5,'B'             ;
08803          .word LBB_BINS          ; BIN$
08804          .byte 7,'B'             ;
08805          .word LBB_BITTST        ; BITTST
08806          .byte 4,'M'             ;
08807          .word LBB_MAX           ; MAX
08808          .byte 4,'M'             ;
08809          .word LBB_MIN           ; MIN
08810          .byte 2,'P'             ;
08811          .word LBB_PI            ; PI
08812          .byte 5,'T'             ;
08813          .word LBB_TWOPI         ; TWOPI
08814          .byte 7,'V'             ;
08815          .word LBB_VPTR          ; VARPTR
08816          .byte 6,'L'             ;
08817          .word LBB_LEFTS         ; LEFT$
08818          .byte 7,'R'             ;
08819          .word LBB_RIGHTS        ; RIGHT$
08820          .byte 5,'M'             ;
08821          .word LBB_MIDS          ; MID$
08822    
08823    ; BASIC messages, mostly error messages
08824    
08825    LAB_BAER
08826          .word ERR_NF            ;$00 NEXT without FOR
08827          .word ERR_SN            ;$02 syntax
08828          .word ERR_RG            ;$04 RETURN without GOSUB
08829          .word ERR_OD            ;$06 out of data
08830          .word ERR_FC            ;$08 function call
08831          .word ERR_OV            ;$0A overflow
08832          .word ERR_OM            ;$0C out of memory
08833          .word ERR_US            ;$0E undefined statement
08834          .word ERR_BS            ;$10 array bounds
08835          .word ERR_DD            ;$12 double dimension array
08836          .word ERR_D0            ;$14 divide by 0
08837          .word ERR_ID            ;$16 illegal direct
08838          .word ERR_TM            ;$18 type mismatch
08839          .word ERR_LS            ;$1A long string
08840          .word ERR_ST            ;$1C string too complex
08841          .word ERR_CN            ;$1E continue error
08842          .word ERR_UF            ;$20 undefined function
08843          .word ERR_LD            ;$22 LOOP without DO
08844    
08845    ; I may implement these two errors to force definition of variables and
08846    ; dimensioning of arrays before use.
08847    
08848    ;     .word ERR_UV            ;$24 undefined variable
08849    
08850    ; the above error has been tested and works (see code and comments below LAB_1D8B)
08851    
08852    ;     .word ERR_UA            ;$26 undimensioned array
08853    
08854    ERR_NF      .byte "NEXT without FOR",$00
08855    ERR_SN      .byte "Syntax",$00
08856    ERR_RG      .byte "RETURN without GOSUB",$00
08857    ERR_OD      .byte "Out of DATA",$00
08858    ERR_FC      .byte "Function call",$00
08859    ERR_OV      .byte "Overflow",$00
08860    ERR_OM      .byte "Out of memory",$00
08861    ERR_US      .byte "Undefined statement",$00
08862    ERR_BS      .byte "Array bounds",$00
08863    ERR_DD      .byte "Double dimension",$00
08864    ERR_D0      .byte "Divide by zero",$00
08865    ERR_ID      .byte "Illegal direct",$00
08866    ERR_TM      .byte "Type mismatch",$00
08867    ERR_LS      .byte "String too long",$00
08868    ERR_ST      .byte "String too complex",$00
08869    ERR_CN      .byte "Can't continue",$00
08870    ERR_UF      .byte "Undefined function",$00
08871    ERR_LD      .byte "LOOP without DO",$00
08872    
08873    ;ERR_UV     .byte "Undefined variable",$00
08874    
08875    ; the above error has been tested and works (see code and comments below LAB_1D8B)
08876    
08877    ;ERR_UA     .byte "Undimensioned array",$00
08878    
08879    LAB_BMSG    .byte $0D,$0A,"Break",$00
08880    LAB_EMSG    .byte " Error",$00
08881    LAB_LMSG    .byte " in line ",$00
08882    LAB_RMSG    .byte $0D,$0A,"Ready",$0D,$0A,$00
08883    
08884    LAB_IMSG    .byte " Extra ignored",$0D,$0A,$00
08885    LAB_REDO    .byte " Redo from start",$0D,$0A,$00
08886    
08887    AA_end_basic
08888    AA_end_basic
08889    ; put the IRQ and MNI code in RAM so that it can be changed
08890    
08891    ; IRQ_vec	= VEC_SV+2              ; Previous IRQ code vector
08892      F900             IRQ_vec		= IRQH_ProcessIRQs	; IRQ code vector
08893      F90A             NMI_vec		= IRQ_vec+$0A           ; NMI code vector
08894    
08895    
08896    ; OS System variables live here
08897    
08898      05E0             MON_sysvars   = $5E0			; base address of the 16 bytes of memory reserved
08899      05E0             os_outsel     = MON_sysvars		; output selection variable
08900      05E1             os_infilt     = os_outsel+1		; Filter switches for character input filtering.
08901    
08902      00E7             TOE_MemptrLo  = $E7			; General purpose memory pointer low byte
08903      00E8             TOE_MemptrHi  = $E8			; General purpose memory pointer high byte
08904    
08905    
08906    ; OS Bit Definitions
08907    
08908      0001             ACIA1_out_sw	= @00000001
08909      0002             ANSI_out_sw	= @00000010
08910      0004             TPB_out_sw	= @00000100
08911      0008             ACIA2_out_sw	= @00001000
08912    
08913    
08914    ; now the code. This sets up the vectors, interrupt code,
08915    ; and waits for the user to select [C]old or [W]arm start.
08916    ;
08917    ; Also, during the running phase, the extra OS features are hosted here.
08918    
08919      .ROM_AREA $C100,$FFFF
08920      
08921    F000                 *= $F000                            ; Give ourselves room for the OS.
08922      .INCLUDE "ACIA.asm"
08923    ; Duncan's 6551 ACIA Library
08924    ;
08925    
08926    ; This is the configuration section for the ACIA.
08927    ;
08928    ; Make changes to setup here.
08929    ;
08930      001E             ACIA_CTRL_IDLE = ACIA_WL8 | ACIA_RCS_BRG | ACIA_9600 | ACIA_TIC_10
08931      001E             ACIA_CTRL_LISTEN = ACIA_WL8 | ACIA_RCS_BRG | ACIA_9600 | ACIA_TIC_00
08932      008B             ACIA_CMD_SETUP  = ACIA_PMC_DIS | ACIA_PME_DIS | ACIA_REM_OFF | ACIA_TIC_10 | ACIA_INT_DIS | ACIA_DTR_RDY
08933    
08934    
08935    ; ACIA1 Registers
08936    
08937      C010             ACIA1_base     = $C010                 ; Change as needed later.
08938      C010             ACIA1_tx       = ACIA1_base
08939      C010             ACIA1_rx       = ACIA1_base
08940      C011             ACIA1_sts      = ACIA1_base + 1
08941      C012             ACIA1_cmd      = ACIA1_base + 2
08942      C013             ACIA1_ctrl     = ACIA1_base + 3
08943    
08944    
08945    ; ACIA2 Registers
08946    
08947      C014             ACIA2_base     = $C014                 ; Change as needed later.
08948      C014             ACIA2_tx       = ACIA2_base
08949      C014             ACIA2_rx       = ACIA2_base
08950      C015             ACIA2_sts      = ACIA2_base + 1
08951      C016             ACIA2_cmd      = ACIA2_base + 2
08952      C017             ACIA2_ctrl     = ACIA2_base + 3
08953    
08954    
08955    
08956    ; ACIA Speeds
08957    
08958      0000             ACIA_16x      = 0
08959      0001             ACIA_50       = @0001
08960      0002             ACIA_75       = @0010
08961      0003             ACIA_109p92   = @0011
08962      0004             ACIA_134p51   = @0100
08963      0005             ACIA_150      = @0101
08964      0006             ACIA_300      = @0110
08965      0007             ACIA_600      = @0111
08966      0008             ACIA_1200     = @1000
08967      0009             ACIA_1800     = @1001
08968      000A             ACIA_2400     = @1010
08969      000B             ACIA_3600     = @1011
08970      000C             ACIA_4800     = @1100
08971      000D             ACIA_7200     = @1101
08972      000E             ACIA_9600     = @1110
08973      000F             ACIA_19200    = @1111
08974    
08975    
08976    ; ACIA Word lengths
08977    
08978      0000             ACIA_WL8            = @00000000
08979      0020             ACIA_WL7            = @00100000
08980      0040             ACIA_WL6            = @01000000
08981      0060             ACIA_WL5            = @01100000
08982    
08983    
08984    ; ACIA Command bits
08985    
08986      0000             ACIA_PMC_ODD        = @00000000        ; Parity Mode Control bits
08987      0040             ACIA_PMC_EVN        = @01000000
08988      0080             ACIA_PMC_DIS        = @10000000
08989    
08990      0000             ACIA_PME_DIS        = @00000000        ; Parity Mode Enable bit
08991      0020             ACIA_PME_ENA        = @00100000
08992    
08993      0000             ACIA_REM_OFF        = @00000000        ; Receiver Echo Mode bit
08994      0010             ACIA_REM_ON         = @00010000
08995    
08996      0000             ACIA_TIC_00         = @00000000        ; RTSB High, Transmit Int disabled
08997      0004             ACIA_TIC_01         = @00000100        ; RTSB Low, Transmit Int enabled
08998      0008             ACIA_TIC_10         = @00001000        ; RTSB Low, Transmit Int disabled
08999      000C             ACIA_TIC_11         = @00001100        ; RTSB Low, Transmit Int disabled & Transmit break on TxD
09000      0002             ACIA_INT_DIS        = @00000010
09001      0000             ACIA_INT_ENA        = @00000000
09002      0000             ACIA_DTR_NRDY       = @00000000
09003      0001             ACIA_DTR_RDY        = @00000001
09004    
09005    
09006    ; ACIA Clock Source
09007    
09008      0000             ACIA_RCS_EXT	= @00000000
09009      0010             ACIA_RCS_BRG	= @00010000
09010    
09011    
09012    ; Status Flags
09013    
09014      0001             ACIA_PER	= @00000001
09015      0002             ACIA_FER	= @00000010
09016      0004             ACIA_OVR	= @00000100
09017      0008             ACIA_RBF	= @00001000
09018      0010             ACIA_TXE	= @00010000
09019      0020             ACIA_DCD	= @00100000
09020      0040             ACIA_DSR	= @01000000
09021      0080             ACIA_INT	= @10000000
09022    
09023    
09024    ; Filter Switch
09025    
09026      0001             LF_filt_sw1	= @00000001
09027      0002             LF_filt_sw2	= @00000010
09028    
09029    
09030    
09031    ; Tower of Eightness Specific serial routines.
09032    	
09033    INI_ACIA1                         ; As required for a 6551 ACIA
09034    F000  A9 8B          LDA #ACIA_CMD_SETUP
09035    F002  8D 12 C0       STA ACIA1_cmd                    ; Set the command reg for specified baud rate
09036    F005  A9 1E          LDA #ACIA_CTRL_LISTEN
09037    F007  8D 13 C0       STA ACIA1_ctrl                   ; Set the control reg for correct operation
09038    F00A  20 3A F0       JSR ACIA1in                      ; Swallow the first byte (experimental fix)
09039    F00D  60             RTS
09040      
09041      
09042    INI_ACIA2                         ; As required for a 6551 ACIA
09043    F00E  A9 8B          LDA #ACIA_CMD_SETUP
09044    F010  8D 16 C0       STA ACIA2_cmd                    ; Set the command reg for specified baud rate
09045    F013  A9 1E          LDA #ACIA_CTRL_LISTEN
09046    F015  8D 17 C0       STA ACIA2_ctrl                   ; Set the control reg for correct operation
09047    F018  20 4F F0       JSR ACIA2in                      ; Swallow the first byte (experimental fix)
09048    F01B  60             RTS
09049    
09050    
09051    ; byte out to 6551 ACIA1
09052    
09053    ACIA1out
09054    F01C  08             PHP                             ; Save registers as we aren't allowed to change them
09055    F01D  48             PHA
09056    	
09057    F01E  8D 10 C0       STA ACIA1_tx                     ; write to ACIA TX buffer
09058    F021  A9 10          LDA #ACIA_TXE
09059    
09060    ACIA1_wr_wait
09061    F023  2C 11 C0       BIT ACIA1_sts
09062    F026  F0 FB          BEQ ACIA1_wr_wait                ; Wait until written.
09063    	
09064    F028  68             PLA                             ; Restore registers. We're all good.
09065    F029  28             PLP
09066    	
09067    F02A  60             RTS                             ; Done... Hopefully.
09068      
09069      
09070      
09071    ; byte out to 6551 ACIA2
09072    
09073    ACIA2out
09074    F02B  08             PHP                             ; Save registers as we aren't allowed to change them
09075    F02C  48             PHA
09076    	
09077    F02D  8D 14 C0       STA ACIA2_tx                     ; write to ACIA TX buffer
09078    F030  A9 10          LDA #ACIA_TXE
09079    
09080    ACIA2_wr_wait
09081    F032  2C 15 C0       BIT ACIA2_sts
09082    F035  F0 FB          BEQ ACIA2_wr_wait                ; Wait until written.
09083    	
09084    F037  68             PLA                             ; Restore registers. We're all good.
09085    F038  28             PLP
09086    	
09087    F039  60             RTS                             ; Done... Hopefully.
09088    
09089    
09090    ; byte in from 6551 ACIA 1
09091    
09092    ACIA1in
09093    F03A  A9 08          LDA #ACIA_RBF
09094    F03C  2C 11 C0       BIT ACIA1_sts				; do we have a byte?
09095    F03F  F0 2A          BEQ LAB_nobyw				; branch if no byte waiting
09096    
09097    F041  AD 10 C0       LDA ACIA1_rx				; Get byte sent.
09098    F044  38             SEC					; flag byte received
09099      
09100    F045  48             PHA
09101    F046  A9 01          LDA #LF_filt_sw1
09102    F048  2C E1 05       BIT os_infilt
09103    F04B  F0 17          BEQ filter_inp
09104    F04D  68             PLA
09105    F04E  60             RTS
09106    
09107    
09108    ; byte in from 6551 ACIA 2
09109      
09110    ACIA2in
09111    F04F  A9 08          LDA #ACIA_RBF
09112    F051  2C 15 C0       BIT ACIA2_sts				; do we have a byte?
09113    F054  F0 15          BEQ LAB_nobyw				; branch if no byte waiting
09114    
09115    F056  AD 14 C0       LDA ACIA2_rx				; Get byte sent.
09116    F059  38             SEC					; flag byte received
09117      
09118    F05A  48             PHA
09119    F05B  A9 02          LDA #LF_filt_sw2
09120    F05D  2C E1 05       BIT os_infilt
09121    F060  F0 02          BEQ filter_inp
09122    F062  68             PLA
09123    F063  60             RTS
09124    
09125    ; Byte filter feature.  Applicable to both ACIAs.
09126    
09127    
09128    filter_inp  
09129    F064  68             PLA
09130    F065  C9 0A          CMP #$A
09131    F067  F0 02          BEQ LAB_nobyw
09132    F069  38             SEC
09133    F06A  60             RTS
09134      
09135    LAB_nobyw
09136    F06B  A9 00          LDA #0
09137    F06D  18             CLC
09138    F06E  60             RTS                             ; flag no byte received
09139      RTS                             ; flag no byte received
09140      .INCLUDE "ANSICARD.asm"
09141    ; Duncan's ANSI Video card library
09142    ;
09143    ; This card is based on a 6522 VIA chip.
09144    
09145    
09146    ; Register addresses
09147    
09148      C000             ANSI_base	= $C000
09149      C000             ANSI_reg_b	= ANSI_base
09150      C001             ANSI_reg_a	= ANSI_base+1
09151      C002             ANSI_ddr_b	= ANSI_base+2
09152      C003             ANSI_ddr_a	= ANSI_base+3
09153    
09154    ; Control Bits
09155    
09156      0040             ANSI_AVAIL	= @01000000
09157      0080             ANSI_ACK	= @10000000
09158    
09159    
09160    ; Memory allocations
09161    
09162      05F0             ANSI_area	= $5F0
09163      05F0             ANSI_LastACK	= ANSI_area
09164      05F1             ANSI_LastAVL	= ANSI_area+1
09165    
09166    
09167    ; Initialisation Routine
09168    
09169    ANSI_INIT
09170    F06F  A9 0C          LDA #12
09171    F071  8D 00 C0       STA ANSI_reg_b
09172    F074  A9 40          LDA #ANSI_AVAIL
09173    F076  8D 03 C0       STA ANSI_ddr_a
09174    F079  A9 FF          LDA #$FF
09175    F07B  8D 02 C0       STA ANSI_ddr_b
09176    F07E  AD 01 C0       LDA ANSI_reg_a
09177    F081  25 80          AND ANSI_ACK
09178    F083  8D F0 05       STA ANSI_LastACK
09179    F086  0A             ASL
09180    F087  8D F1 05       STA ANSI_LastAVL
09181    F08A  0D F0 05       ORA ANSI_LastACK
09182    F08D  8D 01 C0       STA ANSI_reg_a
09183    F090  60             RTS
09184      
09185    
09186    ; ANSI Write.
09187    ; *================================*
09188    ; *                                *
09189    ; *  ENTRY: A=char                 *
09190    ; *  EXIT: As found                *
09191    ; *                                *
09192    ; **********************************
09193    
09194    ANSI_write
09195    
09196    F091  08             PHP			; Save Register States
09197    F092  48             PHA
09198      
09199    F093  20 A7 F0       JSR ANSI_wait		; Wait until AVAIL and ACK agree
09200      
09201    F096  8D 00 C0       STA ANSI_reg_b	; Write the char to output
09202    F099  AD F1 05       LDA ANSI_LastAVL	; Flip and re-write avail bit to tell
09203    F09C  49 40          EOR #ANSI_AVAIL	; the ANSI processor of new data
09204    F09E  8D 01 C0       STA ANSI_reg_a
09205    F0A1  8D F1 05       STA ANSI_LastAVL
09206      
09207    F0A4  68             PLA
09208    F0A5  28             PLP
09209    F0A6  60             RTS
09210      
09211    ANSI_wait
09212    F0A7  48             PHA
09213      
09214    ANSI_w_loop
09215    F0A8  AD 01 C0       LDA ANSI_reg_a	; Check ACK against AVAIL
09216    F0AB  29 80          AND #ANSI_ACK
09217    F0AD  4A             LSR
09218    F0AE  CD F1 05       CMP ANSI_LastAVL
09219    F0B1  D0 F5          BNE ANSI_w_loop	; Until they match
09220      
09221    F0B3  68             PLA
09222    F0B4  60             RTS
09223      .INCLUDE "TPBCARD.asm"
09224    ; Duncan's TPB Card driver
09225    ;
09226    ; This card is based on a 6522 VIA chip.
09227    
09228    
09229    ; Register addresses
09230    
09231      C020             TPB_base        = $C020
09232      C020             TPB_reg_b       = TPB_base
09233      C021             TPB_reg_a       = TPB_base+1
09234      C022             TPB_ddr_b       = TPB_base+2
09235      C023             TPB_ddr_a       = TPB_base+3
09236      C02C             TPB_pcr         = TPB_base+$C
09237      C02D             TPB_ifr         = TPB_base+$D
09238    
09239    
09240    ; LPT Control Bits
09241    
09242      0002             TPB_LPT_stb_b   = @00000010
09243      0001             TPB_LPT_ack_b   = @00000001
09244      0002             TPB_ACK_CA1_b   = @00000010
09245      0001             TPB_CA1_pe_b    = @00000001
09246    
09247    
09248    ; TPB Bus Control Bits
09249    
09250      0010             TPB_BUS_clkout  = @00010000       ; Clock line output (Port B, out)
09251      0040             TPB_BUS_clkin   = @01000000       ; Clock line readback (Port B, in)
09252      0020             TPB_BUS_datout  = @00100000       ; Data line output (Port B, out)
09253      0080             TPB_BUS_datin   = @10000000       ; Data line readback (Port B, in)
09254      0008             TPB_BUS_select  = @00001000       ; TPB bus select (Port B, out) signals bus selection.
09255      0004             TPB_BUS_atnin   = @00000100       ; ATN signal readback (Port B, in) indicates a peripheral needs attention or select signal
09256      0001             TPB_BUS_atnout  = @00000001       ; ATN signal output.  When used, tells a device that the data is a select signal.
09257    
09258    
09259    ; TPB Configuration parameters
09260    
09261      00FF             TPB_BUS_lim_c   = 255             ; Number of samples before giving up on device
09262      000F             TPB_BUS_dev_max = 15              ; Highest device address permitted, host being 0.
09263    
09264    ; *****************************************************************************
09265    ; *                           TABLE 1: BLOCK TYPES                            *
09266    ; *                           --------------------                            *
09267    ; * 1.  Command Block (Always the same size 4 bytes at current).              *
09268    ; * 2.  Response Block (Same size as the command block).                      *
09269    ; * 3.  Data Block.  Upto 65535 bytes. It is not reccomended to go that big,  *
09270    ; *     you would touch registers that way!                                   *
09271    ; * 4.  Broadcast Block (4 bytes long).                                       *
09272    ; *                                                                           *
09273    ; *****************************************************************************
09274    
09275      0001             TPB_BLK_cmd        = 1
09276      0002             TPB_BLK_rsp        = 2
09277      0003             TPB_BLK_dat        = 3
09278      0004             TPB_BLK_brd        = 4
09279    
09280    
09281    ; *****************************************************************************
09282    ; *                                                                           *
09283    ; *                          TABLE 2: DEVICE TYPES                            *
09284    ; *                          ---------------------                            *
09285    ; * 1.  DEVType_BlkStorage.  Block storage device.                            *
09286    ; * 2.  DEVType_IOStream.    Input/Output Stream device.                      *
09287    ; * 15. DEVType_User.        User defined device.  Must use own code.         *
09288    ; *                                                                           *
09289    ; *                                                                           *
09290    ; *                                                                           *
09291    ; *                                                                           *
09292    ; *****************************************************************************
09293    
09294      0001             DEVType_blkstorage = 1
09295      0002             DEVType_IOstream   = 2
09296      000F             DEVType_User       = 15
09297    
09298    
09299    ; Memory allocations
09300    
09301      05F2             TPB_worksp         = $5F2                 ; Start of TPB card memory allocation
09302      05F2             TPB_curr_dev       = TPB_worksp           ; Currently selected TPB devce ID
09303      05F3             TPB_dev_type       = TPB_worksp+1         ; Device class of selected device
09304      05F4             TPB_last_rd        = TPB_worksp+2         ; last byte read from TPB device
09305      05F5             TPB_BUS_status     = TPB_worksp+3         ; Status word from TPB engine (subject to change)
09306      05F6             TPB_BUS_tries      = TPB_worksp+4         ; Bus device counter.  This ensures fewer hangs.
09307      05F7             TPB_BUS_lim        = TPB_worksp+5         ; Bus countdown timer limit. (Reload value).
09308      05F8             TPB_BUS_blk_lenlo  = TPB_worksp+6         ; Length of block in or out
09309      05F9             TPB_BUS_blk_lenhi  = TPB_worksp+7         ; Length of block in or out
09310      05F8             TPB_BUS_blk_len    = TPB_BUS_blk_lenlo    ; Convenience pointer to TPB_BUS_blk_lenlo
09311      05FA             TPB_BUS_blk_stlo   = TPB_worksp+8         ; Start address low byte of block
09312      05FB             TPB_BUS_blk_sthi   = TPB_worksp+9         ; Start address high byte of block
09313      05FA             TPB_BUS_blk_st     = TPB_BUS_blk_stlo     ; Convenience pointer to TPB_BUS_BLK_stlo
09314      05FC             TPB_BUS_blk_type   = TPB_worksp+$A        ; Type of block transfer. See table 1
09315      00E2             TPB_Temp1          = $E2                  ; Temporary memory location 1
09316      00E3             TPB_Temp2          = $E3                  ; Temporary memory location 2
09317      00E4             TPB_Temp3          = $E4                  ; Temporary memory location 3
09318    
09319    ; 3 spaces remain between the system variables and the buffer block.
09320    ; This means we end up with $5FD to $5FF unused.
09321    
09322    ; Last TPB workspace allocation @ $5FC before buffers.
09323    
09324    
09325    ; TPB Command Codes
09326    
09327      0000             PRESENCE           = 0                  ; Check for device presence by ID   <DONE>
09328      0001             ATN_CHK            = 1                  ; Check if device is asserting ATN   <DONE>
09329      0002             REQ_DEV_TYPE       = 2                  ; Request device type-code.
09330      0003             CTRL_BLK_WR        = 3                  ; Write to control block
09331      0004             CTRL_BLK_RD        = 4                  ; Read from control block
09332      0005             BUFF_BLK_WR        = 5                  ; Write to device buffer
09333      0006             BUFF_BLK_RD        = 6                  ; Read from device buffer
09334      0007             BUFF_PROCESS       = 7                  ; Process buffer contents
09335      0008             STREAM_OUT         = 8                  ; Stream out (each char requires an ACK or NACK after)
09336      0009             STREAM_IN          = 9                  ; Stream in (for each char in, you must send an ACK or NACK)
09337    
09338    
09339    ; ACK and NACK codes
09340    
09341      00F1             TPB_ACK            = $F1                ; Acknowledge code (Continuance signal)
09342      00F5             TPB_NACK           = $F5                ; Not Acknoledge code. (Terminator)
09343    
09344    
09345      0600             TPB_BUS_RAMBASE    = $600
09346      0600             TPB_Dev_table      = TPB_BUS_RAMBASE                     ; Start of the TPB bus device table.
09347      0610             TPB_BUS_IO_buff    = TPB_Dev_table + TPB_BUS_dev_max + 1 ; Page of buffer for TPB transfers
09348      0700             TPB_BUFFER         = $700                                ; Block transfers go here. Max 1 page.
09349    
09350    
09351    ; Control Block Structure and Location.
09352    
09353      0610             TPB_ctrl_blk       = TPB_BUS_IO_buff
09354      0610             DEV_ID             = TPB_ctrl_blk
09355      0611             DEV_BLK_TYPE       = TPB_ctrl_blk + 1
09356      0612             DEV_CMD_RSP        = TPB_ctrl_blk + 2
09357      0613             CHECKSUM           = TPB_ctrl_blk + 3
09358    
09359    ; Initialisation Routine
09360    
09361      0002             TPB_PbInitial   = TPB_LPT_stb_b
09362      003B             TPB_PbOutputs   = TPB_LPT_stb_b | TPB_BUS_clkout | TPB_BUS_datout | TPB_BUS_atnout | TPB_BUS_select
09363    
09364    
09365    TPB_INIT
09366    ;  This first part initialises the on-card 6522 VIA pins for both features.
09367    
09368    F0B5  A9 00          LDA #0                          ; Set our registers to defaults
09369    F0B7  8D 21 C0       STA TPB_reg_a
09370    F0BA  A9 02          LDA #TPB_PbInitial
09371    F0BC  8D 20 C0       STA TPB_reg_b
09372      
09373    F0BF  A9 FF          LDA #$FF
09374    F0C1  8D 23 C0       STA TPB_ddr_a                   ; Setup port a as outputs to our LPT
09375    F0C4  A9 3B          LDA #TPB_PbOutputs
09376    F0C6  8D 22 C0       STA TPB_ddr_b                   ; Setup port B for both LPT and TPB initial state.
09377    F0C9  A9 01          LDA #TPB_CA1_pe_b               ; Configure for positive edge interrupt trigger.
09378    F0CB  8D 2C C0       STA TPB_pcr                     ; on CA1
09379      
09380      ;  This second part initialises the Tower Peripheral Bus engine.
09381      
09382    F0CE  A9 00          LDA #0
09383    F0D0  8D F5 05       STA TPB_BUS_status              ; Set the bus to listening.
09384    
09385    F0D3  A9 FF          LDA #TPB_BUS_lim_c
09386    F0D5  8D F7 05       STA TPB_BUS_lim                 ; Set the bus response tries limit (variable for latency)
09387    F0D8  60             RTS
09388    
09389    
09390    ; TPB Write to remote device control block
09391    ; *******************************************************
09392    ; *                                                     *
09393    ; *  ENTRY:                                             *
09394    ; *  EXIT:                                              *
09395    ; *         Affects, A,X,Y,P.                           *
09396    ; *         C = 0: Fail                                 *
09397    ; *         C = 1: Success.                             *
09398    ; *                                                     *
09399    ; *******************************************************
09400    
09401    TPB_Ctrl_Blk_Wr
09402    F0D9  AD F2 05       LDA TPB_curr_dev                ; Setup Command Block
09403    F0DC  8D 10 06       STA DEV_ID
09404    F0DF  A9 01          LDA #TPB_BLK_cmd
09405    F0E1  8D 11 06       STA DEV_BLK_TYPE
09406    F0E4  A9 03          LDA #CTRL_BLK_WR
09407    F0E6  8D 12 06       STA DEV_CMD_RSP
09408    F0E9  20 2F F2       JSR TPB_calc_ctrl_csum
09409    
09410    F0EC  20 9E F1       JSR TPB_Tx_CMD                  ; Issue write to remote control block command.
09411        
09412    F0EF  20 B6 F1       JSR TPB_WaitATN                 ; Wait for Attention signal
09413    F0F2  90 19          BCC CBW_Fail                    ; If no device then quit with carry clear.
09414      
09415    F0F4  A9 00          LDA #<TPB_BUFFER                ; Setup for device control block transmit.
09416    F0F6  8D FA 05       STA TPB_BUS_blk_stlo
09417    F0F9  A9 07          LDA #>TPB_BUFFER
09418    F0FB  8D FB 05       STA TPB_BUS_blk_sthi
09419    F0FE  A9 10          LDA #16                         ; Control blocks are 16 bytes in length
09420    F100  8D F8 05       STA TPB_BUS_blk_lenlo           ; at present.  I may change this...
09421    F103  A9 00          LDA #0
09422    F105  8D F9 05       STA TPB_BUS_blk_lenhi
09423      
09424    F108  20 DA F2       JSR TPB_tx_block                ; Transmit the control block.
09425      
09426    F10B  38             SEC                             ; Exit signalling success.
09427    F10C  60             RTS
09428      
09429    CBW_Fail  
09430    F10D  18             CLC                             ; Exit signalling fail.
09431    F10E  60             RTS
09432      
09433      
09434      ; TPB Read from remote device control block
09435    ; *******************************************************
09436    ; *                                                     *
09437    ; *  ENTRY:                                             *
09438    ; *  EXIT:                                              *
09439    ; *         Affects, A,X,Y,P.                           *
09440    ; *         C = 0: Fail                                 *
09441    ; *         C = 1: Success.                             *
09442    ; *                                                     *
09443    ; *******************************************************
09444    
09445    TPB_Ctrl_Blk_Rd
09446    F10F  AD F2 05       LDA TPB_curr_dev                ; Setup Command Block
09447    F112  8D 10 06       STA DEV_ID
09448    F115  A9 01          LDA #TPB_BLK_cmd
09449    F117  8D 11 06       STA DEV_BLK_TYPE
09450    F11A  A9 04          LDA #CTRL_BLK_RD
09451    F11C  8D 12 06       STA DEV_CMD_RSP
09452    F11F  20 2F F2       JSR TPB_calc_ctrl_csum
09453    
09454    F122  20 9E F1       JSR TPB_Tx_CMD                  ; Issue write to remote control block command.
09455     
09456    F125  20 B6 F1       JSR TPB_WaitATN                 ; Wait for Attention signal
09457    F128  90 1A          BCC CBR_Fail                    ; If no device then quit with carry clear.
09458      
09459    F12A  A9 00          LDA #<TPB_BUFFER                ; Setup for device control block receive.
09460    F12C  8D FA 05       STA TPB_BUS_blk_stlo
09461    F12F  A9 07          LDA #>TPB_BUFFER
09462    F131  8D FB 05       STA TPB_BUS_blk_sthi
09463    F134  A9 10          LDA #16                         ; Control blocks are 16 bytes in length
09464    F136  8D F8 05       STA TPB_BUS_blk_lenlo           ; at present.  I may change this...
09465    F139  A9 00          LDA #0
09466    F13B  8D F9 05       STA TPB_BUS_blk_lenhi
09467      
09468    F13E  20 1E F3       JSR TPB_rx_block                ; Receive the control block.
09469    F141  90 01          BCC CBR_Fail
09470        
09471    F143  60             RTS                             ; Exit successfully.
09472      
09473    CBR_Fail  
09474    F144  18             CLC                             ; Exit signalling fail.
09475    F145  60             RTS
09476      
09477      
09478      
09479    
09480    ; TPB Request device type code
09481    ; *******************************************************
09482    ; *                                                     *
09483    ; *  ENTRY: A=Device ID                                 *
09484    ; *  EXIT:  A=Device Type                               *
09485    ; *         Affects, A,X,Y,P.                           *
09486    ; *         C = 0: Fail                                 *
09487    ; *         C = 1: Success.                             *
09488    ; *                                                     *
09489    ; *******************************************************
09490      
09491    TPB_Req_Dev_Type
09492    F146  8D 10 06       STA DEV_ID                      ; Setup Command Block
09493    F149  A9 01          LDA #TPB_BLK_cmd
09494    F14B  8D 11 06       STA DEV_BLK_TYPE
09495    F14E  A9 02          LDA #REQ_DEV_TYPE
09496    F150  8D 12 06       STA DEV_CMD_RSP
09497    F153  20 2F F2       JSR TPB_calc_ctrl_csum
09498      
09499    F156  20 9E F1       JSR TPB_Tx_CMD                  ; Issue Req_Dev_Type command
09500        
09501    F159  20 B6 F1       JSR TPB_WaitATN                 ; Wait for Attention signal
09502    F15C  90 34          BCC DevType_Fail                ; If no device then quit with carry clear.
09503    
09504    F15E  A9 10          LDA #<TPB_ctrl_blk              ; Setup for device reply to the control block
09505    F160  8D FA 05       STA TPB_BUS_blk_stlo
09506    F163  A9 06          LDA #>TPB_ctrl_blk
09507    F165  8D FB 05       STA TPB_BUS_blk_sthi
09508    F168  A9 04          LDA #4
09509    F16A  8D F8 05       STA TPB_BUS_blk_lenlo
09510    F16D  A9 00          LDA #0
09511    F16F  8D F9 05       STA TPB_BUS_blk_lenhi
09512      
09513    F172  20 1E F3       JSR TPB_rx_block                ; Get our reply block.
09514    F175  90 1B          BCC DevType_Fail                ; Error if TPB_rx_block fails.
09515      
09516    F177  18             CLC                            ; Calculate Checksum
09517    F178  AD 10 06       LDA DEV_ID
09518    F17B  6D 11 06       ADC DEV_BLK_TYPE
09519    F17E  6D 12 06       ADC DEV_CMD_RSP
09520      
09521    F181  CD 13 06       CMP CHECKSUM                   ; Compare with received checksum
09522    F184  D0 0C          BNE DevType_Fail               ; Signal appropriately with the carry bit.
09523      
09524    F186  AD 11 06       LDA DEV_BLK_TYPE               ; Check for the appropriate response.
09525    F189  C9 02          CMP #TPB_BLK_rsp
09526    F18B  D0 05          BNE DevType_Fail               ; ...and fail if incorrect.
09527      
09528    F18D  AD 12 06       LDA DEV_CMD_RSP                ; Reply with device type.
09529      
09530    F190  38             SEC
09531    F191  60             RTS
09532    
09533    DevType_Fail
09534    F192  18             CLC                            ; General failiure exit point.
09535    F193  60             RTS
09536      
09537      
09538    ; TPB Check ATN state.
09539    ; *******************************************************
09540    ; *                                                     *
09541    ; *  ENTRY:                                             *
09542    ; *  EXIT: A, P, carry is set when asserted, otherwise  *
09543    ; *           cleared.                                  *
09544    ; *                                                     *
09545    ; *******************************************************
09546    
09547    
09548    TPB_Check_ATN
09549    F194  AD 20 C0       LDA TPB_reg_b                   ; Check if ATN is asserted
09550    F197  29 04          AND #TPB_BUS_atnin
09551    F199  38             SEC
09552    F19A  F0 01          BEQ ATN_asserted                ; Skip clearing C if ATN is asserted.
09553    F19C  18             CLC                             ; Carry is cleared as ATN isn't asserted.
09554    ATN_asserted
09555    F19D  60             RTS 
09556                       
09557    
09558    ; TPB Transmit Command
09559    ; ****************************************************
09560    ; *                                                  *
09561    ; *  ENTRY:                                          *
09562    ; *  EXIT:  A, X, Y, P affected                      *
09563    ; *                                                  *
09564    ; ****************************************************
09565    
09566    
09567    TPB_Tx_CMD
09568    F19E  A9 10          LDA #<DEV_ID                   ; Setup pointers and transmit control block.
09569    F1A0  8D FA 05       STA TPB_BUS_blk_stlo
09570    F1A3  A9 06          LDA #>DEV_ID
09571    F1A5  8D FB 05       STA TPB_BUS_blk_sthi
09572    F1A8  A9 04          LDA #4
09573    F1AA  8D F8 05       STA TPB_BUS_blk_lenlo
09574    F1AD  A9 00          LDA #0
09575    F1AF  8D F9 05       STA TPB_BUS_blk_lenhi
09576      
09577    F1B2  20 DA F2       JSR TPB_tx_block
09578      
09579    F1B5  60             RTS
09580    
09581    
09582    ; TPB Attention Signal handler with wait.
09583    ; ****************************************************
09584    ; *                                                  *
09585    ; *  ENTRY:                                          *
09586    ; *  EXIT:  A,X,P                                    *
09587    ; *         C=0 ATN line not asserted or timeout.    *
09588    ; *         C=1 ATN line asserted                    *
09589    ; *                                                  *
09590    ; ****************************************************
09591    
09592    TPB_WaitATN
09593    F1B6  A2 FF          LDX #TPB_BUS_lim_c                ; Set number of tries
09594      
09595    TPB_WaitATN_try
09596    F1B8  20 A5 F3       JSR TPB_delay                     ; Wait and check
09597    F1BB  20 94 F1       JSR TPB_Check_ATN
09598    F1BE  B0 04          BCS FinWaitATN
09599    F1C0  CA             DEX                               ; Reduce counter and try again
09600    F1C1  D0 F5          BNE TPB_WaitATN_try
09601    F1C3  18             CLC  
09602    FinWaitATN
09603    F1C4  60             RTS
09604    
09605    
09606    ; TPB DEVICE_PRESENCE handler (Currently broken)
09607    ; ****************************************************
09608    ; *                                                  *
09609    ; *  ENTRY: A=ID                                     *
09610    ; *  EXIT:  TPB_BUS_IO_buff = reply block            *
09611    ; *         C=0 (No device or block fail),           *
09612    ; *         C=1 Success.                             *
09613    ; *                                                  *
09614    ; ****************************************************
09615    
09616    
09617    ; Setup Command Block 
09618    
09619    TPB_Dev_Presence
09620      ; Command Setup
09621    F1C5  8D 10 06       STA DEV_ID                     ; Store device ID
09622    F1C8  A9 01          LDA #TPB_BLK_cmd
09623    F1CA  8D 11 06       STA DEV_BLK_TYPE
09624    F1CD  A9 00          LDA #PRESENCE                  ; Command: PRESENCE check.
09625    F1CF  8D 12 06       STA DEV_CMD_RSP  
09626    F1D2  20 2F F2       JSR TPB_calc_ctrl_csum         ; Calculate checksum
09627      ; Command Issue
09628    F1D5  20 9E F1       JSR TPB_Tx_CMD                 ; Transmit Command
09629      ; Process Outcome
09630    F1D8  20 B6 F1       JSR TPB_WaitATN                ; Wait for Attention signal
09631    F1DB  90 2A          BCC PRESENCE_NoRESP            ; If no device then skip RESP fetch
09632    
09633    F1DD  A9 10          LDA #<DEV_ID                   ; Setup pointers for RESP block.
09634    F1DF  8D FA 05       STA TPB_BUS_blk_stlo
09635    F1E2  A9 06          LDA #>DEV_ID
09636    F1E4  8D FB 05       STA TPB_BUS_blk_sthi
09637    F1E7  A9 04          LDA #4
09638    F1E9  8D F8 05       STA TPB_BUS_blk_lenlo
09639    F1EC  A9 00          LDA #0
09640    F1EE  8D F9 05       STA TPB_BUS_blk_lenhi
09641      
09642    F1F1  20 1E F3       JSR TPB_rx_block               ; Get RESPonse block
09643      
09644    F1F4  90 11          BCC PRESENCE_NoRESP            ; If failed or no response fall through.
09645      
09646    F1F6  18             CLC                            ; Calculate Checksum
09647    F1F7  AD 10 06       LDA DEV_ID
09648    F1FA  6D 11 06       ADC DEV_BLK_TYPE
09649    F1FD  6D 12 06       ADC DEV_CMD_RSP
09650      
09651    F200  CD 13 06       CMP CHECKSUM                   ; Compare with received checksum
09652    F203  D0 02          BNE PRESENCE_NoRESP            ; Signal appropriately with the carry bit.
09653    F205  38             SEC
09654    F206  60             RTS                            ; Return with positive response
09655      
09656    PRESENCE_NoRESP
09657    F207  18             CLC
09658    F208  60             RTS                            ; ...Else return negative.
09659    
09660    
09661    ; TPB Attention handler (Needs work, do not use)
09662    ; ****************************************************
09663    ; *                                                  *
09664    ; *  ENTRY:                                          *
09665    ; *  EXIT:                                           *
09666    ; *                                                  *
09667    ; *                                                  *
09668    ; *                                                  *
09669    ; ****************************************************
09670    
09671    TPB_ATN_handler
09672      
09673    F209  A0 00          LDY #0
09674    ATN_next                          ; Work our way through the device table
09675    F20B  B9 00 06       LDA TPB_Dev_table,Y           
09676      
09677    F20E  F0 1E          BEQ TPB_EOT                     ; Check for end of table marker (0).
09678                                      ; Initialise our control block for attention check
09679    F210  8D 10 06       STA DEV_ID                      ; Store device ID.
09680    F213  98             TYA
09681    F214  48             PHA                             ; Stack our table pointer for later.
09682    F215  A9 01          LDA #TPB_BLK_cmd
09683    F217  8D 11 06       STA DEV_BLK_TYPE
09684    F21A  A9 01          LDA #ATN_CHK
09685    F21C  8D 12 06       STA DEV_CMD_RSP
09686      
09687    F21F  20 2F F2       JSR TPB_calc_ctrl_csum
09688      
09689    F222  20 9E F1       JSR TPB_Tx_CMD                  ; Transmit Command
09690      
09691    F225  20 DA F2       JSR TPB_tx_block
09692      
09693      ;JSR TPB_ctrl_rd
09694      
09695    F228  68             PLA                             ; Get our id table pointer back.
09696    F229  A8             TAY
09697    F22A  C8             INY                             ; Advance to next table entry  
09698    F22B  4C 0B F2       JMP ATN_next
09699    TPB_EOT
09700    F22E  60             RTS
09701      
09702    TPB_calc_ctrl_csum
09703    F22F  18             CLC
09704    F230  A9 00          LDA #0                          ; Calculate and store checksum for block.
09705    F232  6D 10 06       ADC DEV_ID
09706    F235  6D 11 06       ADC DEV_BLK_TYPE
09707    F238  6D 12 06       ADC DEV_CMD_RSP
09708    F23B  8D 13 06       STA CHECKSUM
09709    F23E  60             RTS
09710     
09711     
09712    ; TPB transmit byte
09713    ; *================================*
09714    ; *                                *
09715    ; *  ENTRY: A=byte                 *
09716    ; *  EXIT: Affects X, P            *
09717    ; *                                *
09718    ; *================================*
09719    
09720    TPB_tx_byte
09721    F23F  A2 0A          LDX #10                   ; 1 start bit, 8 data bits and 1 stop bit.
09722    F241  38             SEC                       ; We want a start bit.
09723    F242  48             PHA
09724    TPB_bit_out  
09725    F243  90 0F          BCC TPB_out_zero          ; Determine whether a 1 or 0 to be sent.
09726      
09727    ; output 1 on TPB data
09728    F245  AD 20 C0       LDA TPB_reg_b
09729    F248  09 20          ORA #TPB_BUS_datout
09730    F24A  8D 20 C0       STA TPB_reg_b
09731    F24D  EA             NOP                       ; This NOP compensates for the branch timing.
09732    F24E  20 62 F2       JSR TPB_pulseclk
09733      
09734    F251  4C 79 F2       JMP TPB_shiftbit
09735       
09736    ; output 0 on TPB data  
09737    TPB_out_zero
09738    F254  AD 20 C0       LDA TPB_reg_b
09739    F257  29 DF          AND #~TPB_BUS_datout
09740    F259  8D 20 C0       STA TPB_reg_b
09741    F25C  20 62 F2       JSR TPB_pulseclk 
09742      
09743    F25F  4C 79 F2       JMP TPB_shiftbit
09744    
09745    
09746    ; Clock line Pulse function
09747    ; **********************************
09748    ; *                                *
09749    ; *   ENTRY: None                  *
09750    ; *   EXIT: A,P Affected           *
09751    ; *   USES: TPB_delay              *
09752    ; *                                *
09753    ; **********************************
09754    
09755    TPB_pulseclk  
09756    F262  AD 20 C0       LDA TPB_reg_b
09757    F265  09 10          ORA #TPB_BUS_clkout       ; Set the clock line output
09758    F267  8D 20 C0       STA TPB_reg_b
09759      
09760    F26A  20 A5 F3       JSR TPB_delay
09761    
09762    F26D  AD 20 C0       LDA TPB_reg_b
09763    F270  29 EF          AND #~TPB_BUS_clkout      ; Clear the clock line output
09764    F272  8D 20 C0       STA TPB_reg_b
09765      
09766    F275  20 A5 F3       JSR TPB_delay
09767    F278  60             RTS
09768    
09769          
09770    TPB_shiftbit  
09771    F279  CA             DEX
09772    F27A  F0 06          BEQ TPB_wr_done
09773    F27C  68             PLA
09774    F27D  0A             ASL
09775    F27E  48             PHA
09776    F27F  4C 43 F2       JMP TPB_bit_out
09777      
09778    TPB_wr_done
09779    F282  68             PLA
09780    F283  60             RTS
09781    
09782    
09783    ; TPB recieve byte
09784    ; *======================================*
09785    ; *                                      *
09786    ; *  ENTRY:                              *
09787    ; *  EXIT: Affects A,X,Y,P               *
09788    ; *        A = byte                      *
09789    ; *        C = 1 Sucess, 0 Fail          *
09790    ; *                                      *
09791    ; *======================================*
09792    
09793    TPB_rx_byte                       ; Read one byte
09794    F284  A9 00          LDA #0                          ; This is our starting value
09795    F286  85 E4          STA TPB_Temp3                   ; Keep it safe in Temp3
09796      
09797    F288  AD 20 C0       LDA TPB_reg_b                   ; Signal start bit required.
09798    F28B  09 10          ORA #TPB_BUS_clkout             ; Set the clock line output
09799    F28D  8D 20 C0       STA TPB_reg_b
09800      
09801    F290  18             CLC
09802    F291  A0 FF          LDY #TPB_BUS_lim_c              ; Load our limit (preventing bus hangs)
09803    TPB_chk_databit
09804    F293  20 A5 F3       JSR TPB_delay                   ; Small delay.  This may change later.
09805    F296  AD 20 C0       LDA TPB_reg_b
09806    F299  29 80          AND #TPB_BUS_datin
09807    F29B  F0 12          BEQ TPB_sbit_asserted
09808      
09809    F29D  88             DEY                             ; Check for timeout & branch if still waiting.
09810    F29E  D0 F3          BNE TPB_chk_databit
09811      
09812    TPB_rx_fail
09813    F2A0  AD 20 C0       LDA TPB_reg_b                   ; Clear clock line output
09814    F2A3  29 EF          AND #~TPB_BUS_clkout
09815    F2A5  8D 20 C0       STA TPB_reg_b
09816    F2A8  20 A5 F3       JSR TPB_delay                   ; ...and include a small delay
09817    
09818    F2AB  A9 00          LDA #0                          ; We timed out so let's signal that
09819    F2AD  18             CLC
09820    F2AE  60             RTS
09821      
09822    TPB_sbit_asserted
09823    F2AF  AD 20 C0       LDA TPB_reg_b                   ; Clear clock line output
09824    F2B2  29 EF          AND #~TPB_BUS_clkout
09825    F2B4  8D 20 C0       STA TPB_reg_b
09826    F2B7  20 A5 F3       JSR TPB_delay                   ; ...and include a small delay
09827      
09828    
09829    F2BA  A2 08          LDX #8                          ; Receive and store 8 bits.
09830    TPB_rcv_nextbit  
09831    F2BC  20 CD F2       JSR TPB_Takebit
09832    F2BF  26 E4          ROL TPB_Temp3                   ; Push our sampled bit into our output.
09833    
09834    F2C1  CA             DEX
09835    F2C2  D0 F8          BNE TPB_rcv_nextbit
09836      
09837    F2C4  20 CD F2       JSR TPB_Takebit                 ; Receive the stop bit.  
09838    F2C7  B0 D7          BCS TPB_rx_fail
09839      
09840    F2C9  A5 E4          LDA TPB_Temp3                   ; Retrieve our finished byte
09841    F2CB  38             SEC                             ; and signal that we were successful
09842    F2CC  60             RTS
09843      
09844    TPB_Takebit  
09845    F2CD  20 62 F2       JSR TPB_pulseclk                ; Sample the bus and set or clear carry as required.
09846    F2D0  AD 20 C0       LDA TPB_reg_b
09847    F2D3  29 80          AND #TPB_BUS_datin
09848    F2D5  18             CLC
09849    F2D6  D0 01          BNE TPB_skip_setbit
09850    F2D8  38             SEC
09851    TPB_skip_setbit
09852    F2D9  60             RTS
09853      
09854    
09855    ; TPB transmit block
09856    ; *==================================================*
09857    ; *                                                  *
09858    ; *  ENTRY: TPB_BUS_blk_lenlo = length of block (LO) *
09859    ; *         TPB_BUS_blk_lenhi = length of block (HI) *
09860    ; *                                                  *
09861    ; *         TPB_BUS_blk_st  = start of block         *
09862    ; *                                                  *
09863    ; *  EXIT:  TPB_BUS_blk_len = unchanged              *
09864    ; *         TPB_BUS_blk_st  = st+len                 *
09865    ; *         A,X,Y,P affected.                        *
09866    ; *                                                  *
09867    ; *                                                  *
09868    ; *==================================================*
09869    
09870    TPB_tx_block
09871    F2DA  AD FA 05       LDA TPB_BUS_blk_stlo             ; Copy block address to temp1/2
09872    F2DD  85 E2          STA TPB_Temp1
09873    F2DF  AD FB 05       LDA TPB_BUS_blk_sthi
09874    F2E2  85 E3          STA TPB_Temp2
09875      
09876    TPB_BUS_tx_next                    ; Transmitter inside loop
09877    F2E4  AD F8 05       LDA TPB_BUS_blk_lenlo            ; Finish when TPB_blk_len(lo and hi) = 0
09878    F2E7  0D F9 05       ORA TPB_BUS_blk_lenhi
09879    F2EA  F0 31          BEQ TPB_tx_block_done
09880      
09881    F2EC  A0 00          LDY #0                           ; Get and transmit byte.
09882    F2EE  B1 E2          LDA (TPB_Temp1),Y
09883    F2F0  20 3F F2       JSR TPB_tx_byte
09884    
09885    F2F3  AD F8 05       LDA TPB_BUS_blk_lenlo            ; Decrement our length counter
09886    F2F6  38             SEC
09887    F2F7  E9 01          SBC #1
09888    F2F9  8D F8 05       STA TPB_BUS_blk_lenlo
09889    F2FC  AD F9 05       LDA TPB_BUS_blk_lenhi
09890    F2FF  E9 00          SBC #0
09891    F301  8D F9 05       STA TPB_BUS_blk_lenhi
09892      
09893    F304  18             CLC                              ; Increment TPB_BUS_blk_len copy in TPB_Temp1/2
09894    F305  A5 E2          LDA TPB_Temp1
09895    F307  69 01          ADC #1
09896    F309  85 E2          STA TPB_Temp1
09897    F30B  A5 E3          LDA TPB_Temp2
09898    F30D  69 00          ADC #0
09899    F30F  85 E3          STA TPB_Temp2
09900      
09901    F311  20 A5 F3       JSR TPB_delay                    ; Add a little delay between bytes.
09902    F314  20 A5 F3       JSR TPB_delay                    ; thereby allowing the receiver to do something useful.
09903    F317  20 A5 F3       JSR TPB_delay
09904      
09905    F31A  4C E4 F2       JMP TPB_BUS_tx_next
09906      
09907    TPB_tx_block_done
09908    F31D  60             RTS
09909     
09910    
09911    ; TPB receive block
09912    ; *==================================================*
09913    ; *                                                  *
09914    ; *  ENTRY: TPB_BUS_blk_lenlo = length of block (LO) *
09915    ; *         TPB_BUS_blk_lenhi = length of block (HI) *
09916    ; *                                                  *
09917    ; *         TPB_BUS_blk_st  = start of block         *
09918    ; *                                                  *
09919    ; *  EXIT:  TPB_BUS_blk_len = unchanged              *
09920    ; *         TPB_BUS_blk_st  = st+len                 *
09921    ; *         Temp1, Temp2 Corrupted                   *
09922    ; *         A,X,Y,P all affected.                    *
09923    ; *         C=0 Fail, C=1 Success                    *
09924    ; *                                                  *
09925    ; *==================================================*
09926     
09927    TPB_rx_block
09928    F31E  AD FA 05       LDA TPB_BUS_blk_stlo             ; Copy block address to temp1/2
09929    F321  85 E2          STA TPB_Temp1
09930    F323  AD FB 05       LDA TPB_BUS_blk_sthi
09931    F326  85 E3          STA TPB_Temp2
09932      
09933    TPB_BUS_rx_next
09934    F328  AD F8 05       LDA TPB_BUS_blk_lenlo            ; While block length > 0.
09935    F32B  0D F9 05       ORA TPB_BUS_blk_lenhi
09936    F32E  F0 2B          BEQ TPB_rx_block_done
09937      
09938    F330  20 84 F2       JSR TPB_rx_byte                  ; Get byte.
09939      
09940    F333  B0 01          BCS TPB_rx_continue              ; Continue unless TPB_rx_byte signals failiure.
09941    F335  60             RTS
09942      
09943    TPB_rx_continue
09944    F336  A0 00          LDY #0                           
09945    F338  91 E2          STA (TPB_Temp1),Y                ; Store our successfully received byte.
09946      
09947    F33A  AD F8 05       LDA TPB_BUS_blk_lenlo            ; Decrement our length counter
09948    F33D  38             SEC
09949    F33E  E9 01          SBC #1
09950    F340  8D F8 05       STA TPB_BUS_blk_lenlo
09951    F343  AD F9 05       LDA TPB_BUS_blk_lenhi
09952    F346  E9 00          SBC #0
09953    F348  8D F9 05       STA TPB_BUS_blk_lenhi
09954      
09955    F34B  18             CLC                              ; Increment TPB_BUS_blk_len copy in TPB_Temp1/2
09956    F34C  A5 E2          LDA TPB_Temp1
09957    F34E  69 01          ADC #1
09958    F350  85 E2          STA TPB_Temp1
09959    F352  A5 E3          LDA TPB_Temp2
09960    F354  69 00          ADC #0
09961    F356  85 E3          STA TPB_Temp2
09962      
09963    F358  4C 28 F3       JMP TPB_BUS_rx_next
09964      
09965    TPB_rx_block_done
09966    F35B  38             SEC
09967    F35C  60             RTS
09968      
09969      
09970    ; TPB Device Select
09971    ; *==================================================*
09972    ; *                                                  *
09973    ; *   ENTRY:   A = Device to select                  *
09974    ; *   EXIT:    None                                  *
09975    ; *   AFFECTS: A,X,Y,P                               *
09976    ; *                                                  *
09977    ; *                                                  *
09978    ; *==================================================*
09979    
09980    TPB_dev_select
09981    F35D  A8             TAY                       ; Save our device ID
09982      
09983      
09984    F35E  A9 08          LDA #TPB_BUS_select       ; Assert SELECT signal
09985    F360  8D 20 C0       STA TPB_reg_b
09986    
09987    F363  A2 00          LDX #$0                   ; Give device time to act
09988    ATN_Resp_Dwell
09989    F365  CA             DEX
09990    F366  EA             NOP
09991    F367  EA             NOP
09992    F368  D0 FB          BNE ATN_Resp_Dwell
09993      
09994    F36A  98             TYA                       ; Get our ID from Y
09995    F36B  20 3F F2       JSR TPB_tx_byte           ; Transmit our device ID
09996      
09997    F36E  A9 F7          LDA #~TPB_BUS_select      ; Deassert SELECT
09998    F370  8D 20 C0       STA TPB_reg_b
09999      
10000    F373  8C F2 05       STY TPB_curr_dev          ; Update current dev variable
10001      
10002    F376  60             RTS
10003      
10004    
10005    
10006        
10007    FINDME:
10008    
10009    ; TPB LPT Write.
10010    ; *================================*
10011    ; *                                *
10012    ; *  ENTRY: A=char                 *
10013    ; *  EXIT: As found                *
10014    ; *                                *
10015    ; **********************************
10016    
10017    TPB_LPT_write
10018    
10019    F377  08             PHP                             ; Save Register States
10020    F378  48             PHA
10021      
10022    F379  20 9B F3       JSR STB_ack_wait                ; Wait until Ack=1
10023      
10024    F37C  20 A5 F3       JSR TPB_delay
10025      
10026    F37F  8D 21 C0       STA TPB_reg_a                   ; Write the char to output
10027      
10028    F382  20 A5 F3       JSR TPB_delay
10029      
10030    F385  AD 20 C0       LDA TPB_reg_b                   ; Set the strobe bit low (Active)
10031    F388  29 FD          AND #~TPB_LPT_stb_b             ; and only the strobe bit.
10032    F38A  8D 20 C0       STA TPB_reg_b
10033      
10034    F38D  20 A5 F3       JSR TPB_delay
10035      
10036    F390  AD 20 C0       LDA TPB_reg_b                   ; Now we return the strobe bit to it's
10037    F393  09 02          ORA #TPB_LPT_stb_b              ; 'idle' state.
10038    F395  8D 20 C0       STA TPB_reg_b
10039      
10040    F398  68             PLA
10041    F399  28             PLP
10042    F39A  60             RTS  
10043      
10044    STB_ack_wait
10045    F39B  48             PHA
10046      
10047    TPB_w_loop
10048    F39C  AD 2D C0       LDA TPB_ifr                     ; Check IFR for interrupt flag on CB1 set
10049    F39F  29 02          AND #TPB_ACK_CA1_b
10050    F3A1  F0 F9          BEQ TPB_w_loop                  ; Until they match
10051      
10052    F3A3  68             PLA
10053    F3A4  60             RTS
10054     
10055     
10056    ; Delay routine for TPB, there are better ways but this will do for now.
10057      
10058    TPB_delay
10059    F3A5  48             PHA
10060      
10061    F3A6  A9 06          LDA #6
10062    F3A8  38             SEC
10063      
10064    TPB_delay_loop
10065    F3A9  E9 01          SBC #1
10066    F3AB  D0 FC          BNE TPB_delay_loop
10067      
10068    F3AD  68             PLA
10069    F3AE  60             RTS
10070    
10071    ; *****************************************************************
10072    ;
10073    ;                       END OF TPBCARD.asm
10074    ;
10075    ; *****************************************************************
10076    ; *****************************************************************
10077      .INCLUDE "TAPE_IO.asm"
10078    ; Tape Interface Functions for ToE Tape and Joystick interface.
10079    
10080    ; Compatible with versions 1 and 1.1 of the interface as of 30/12/2020
10081    
10082    
10083    ; Tape interface bitfield definitions
10084    
10085      0080             TAPE_out		= @10000000			; This is the bit to toggle for tape writing.
10086      0040             TAPE_in			= @01000000			; This is the bit to sample for tape reading.
10087      003F             JOYSTICK_bits		= @00111111			; These bits are used by the joystick interface.
10088      0001             JOYSTICK_sel		= @00000001			; 0 selects Joystick 0, 1 selects joystick 2. Easy.
10089    
10090      0001             TAPE_Stat_overrun	= @00000001			; Stop bit was a one!
10091      0002             TAPE_Stat_par_err	= @00000010			; Parity error.  It remains to be seen if this gets implemented.
10092      0004             TAPE_Stat_RXFull	= @00000100			; Byte received
10093      0008             TAPE_Stat_Escape	= @00001000			; Indication that the escape key has been pressed
10094    
10095      0001             TAPE_BlockIn_Complete	= @00000001
10096      0002             TAPE_BlockIn_Escape	= @00000010
10097      0004             TAPE_BlockIn_Error	= @00000100
10098    
10099    
10100    ; Tape interface port addresses
10101    
10102      C040             TAPE_IOBASE		= $C040				; Base address for our tape port.  This is normally set to whatever the GPIO card is.
10103      C040             TAPE_IOP		= TAPE_IOBASE			; We are currently using PORT B on the user port card for IO.
10104      C042             TAPE_DDRB		= TAPE_IOBASE + 2
10105    
10106    
10107    ; Tape system storage zeropage addresses
10108      00E4             TAPE_temp		= $E4				; Let's use one of the zero page addresses
10109      00E5             TAPE_BlockLo		= $E5
10110      00E6             TAPE_BlockHi		= $E6
10111    
10112    ; Tape timing values.
10113    
10114    ; Please note that all this is subject to changes as and when needed because I'm in uncharted territory
10115    ; and don't quite know what I'm doing yet.
10116    
10117    
10118      0008             C_TAPE_Phasetime	= 8				; How long to wait between phases.  Bigger is slower
10119      0014             C_TAPE_Sample_Offset	= 20				; How far is the middle of the bit. Note: timing errors will cause this to stretch
10120      0036             C_TAPE_Bitlength	= 54				; How many passes for a full bit
10121      0008             C_TAPE_bitcycles	= 8				; Number of cycles to a bit
10122      000A             C_TAPE_BitsPerFrame	= 10				; Total number of bits per frame including start and stop bits.
10123      00AA             C_TAPE_LeaderByte	= $AA				; Leader byte
10124      0055             C_TAPE_EndOfLeaderByte  = $55				; End of leader signal byte
10125      AFC8             C_TAPE_Interblock_pause = 45000				; How long between blocks to wait before starting the next one.
10126    
10127      0064             TAPE_Leader_Bytes	= 100				; Set leader length in bits.
10128    
10129    ; File type constants
10130    
10131      0000             C_TAPE_FType_BASIC	= 0				; BASIC program
10132      0001             C_TAPE_FType_BINARY	= 1				; Binary Data
10133      0002             C_TAPE_FType_TEXT	= 2				; Pure text.  NOTE: Good for merging snippets of code.
10134    
10135    
10136    ; System variables for tape routines.
10137    
10138    
10139    ; +================================+
10140    ; !                                !
10141    ; ! TAPE SPACE FROM $900 TO $AFF   !
10142    ; !                                !
10143    ; !                                !
10144    ; !                                !
10145    ; +================================+
10146    
10147      0900             TAPE_RAM_Start			= $900				; Base address of the tape filing system main memory
10148    
10149      0900             V_TAPE_BlockSize		= TAPE_RAM_Start		; 2 Byte address for block size
10150      0902             TAPE_temp2			= TAPE_RAM_Start + 2		; Second temporary store for tape functions.
10151      0903             TAPE_temp3			= TAPE_RAM_Start + 3		; Third temporary store for tape functions.
10152      0904             TAPE_temp4			= TAPE_RAM_Start + 4		; Fourth temporary store for tape functions.
10153      0905             TAPE_LineUptime			= TAPE_RAM_Start + 5		; How many passes of the superloop the line has been up.
10154      0906             TAPE_Demod_Status		= TAPE_RAM_Start + 6		; Demodulated bit status.
10155      0907             TAPE_Demod_Last			= TAPE_RAM_Start + 7		; Our previous demod status.  Used for edge detection etc.
10156      0908             TAPE_StartDet			= TAPE_RAM_Start + 8		; Start bit detected is 1, 0 otherwise
10157      0909             TAPE_RX_Status			= TAPE_RAM_Start + 9		; Receive engine status bitfield.
10158      090A             TAPE_BitsToDecode		= TAPE_RAM_Start + 10		; Bit countdown counter when decoding
10159      090B             TAPE_ByteReceived		= TAPE_RAM_Start + 11		; Last byte received
10160      090C             TAPE_Sample_Position		= TAPE_RAM_Start + 12		; Countdown timer for bit engine sample synchronization
10161      090D             TAPE_BlockIn_Status		= TAPE_RAM_Start + 13		; Status register for the F_TAPE_BlockIn function.
10162    
10163      090E             TAPE_Header_Buffer		= TAPE_BlockIn_Status + 1	; This is where the tape header data starts
10164      090E             TAPE_FileType			= TAPE_Header_Buffer		; This is the file type ID goes. 0 is for BASIC, otherwise ignored by LOAD.
10165      090F             TAPE_FileSizeLo			= TAPE_FileType + 1		; Low byte of the file size
10166      0910             TAPE_FileSizeHi			= TAPE_FileSizeLo + 1		; High byte of the file size
10167      0911             TAPE_LoadAddrLo			= TAPE_FileSizeHi + 1		; Low byte of the file load address
10168      0912             TAPE_LoadAddrHi			= TAPE_LoadAddrLo + 1		; High byte of the file load address
10169      0913             TAPE_FileName			= TAPE_LoadAddrHi + 1		; Null terminated filename field 17 bytes long.
10170      0924             TAPE_ChecksumLo			= TAPE_FileName + 17		; Checksum Low byte
10171      0925             TAPE_ChecksumHi			= TAPE_ChecksumLo + 1		; Checksum High byte
10172      092D             TAPE_Header_End			= TAPE_Header_Buffer + 31	; End of header space.
10173    
10174      092E             TAPE_CS_AccLo			= TAPE_Header_End + 1		; Tape checksum Accumulator low byte
10175      092F             TAPE_CS_AccHi			= TAPE_CS_AccLo + 1		; Tape checksum Accumulator high byte
10176    
10177      0930             V_TAPE_Phasetime		= TAPE_CS_AccHi + 1		; Tape phasetime variable
10178      0931             V_TAPE_Sample_Offset		= V_TAPE_Phasetime + 1		; Sample offset variable
10179      0932             V_TAPE_Bitlength		= V_TAPE_Sample_Offset + 1	; How long a bit is in passes variable
10180      0933             V_TAPE_bitcycles		= V_TAPE_Bitlength + 1		; Number of cycles to a bit variable
10181    
10182    
10183    
10184    ; Next is $934.
10185    
10186    ; +-------------------------------------------------------------------------------------------+
10187    ; +                                                                                           +
10188    ; +                              TAPE FILING SYSTEM MESSAGE STRINGS.                          +
10189    ; +                                                                                           +
10190    ; +-------------------------------------------------------------------------------------------+
10191    
10192    
10193    TMSG_init_msg						; Filing System initialisation string.
10194     
10195      .BYTE $0C,1,$18,$03,$0D,$0A
10196      .BYTE "TowerTAPE Filing System",$0D,$0A
10197      .BYTE "V1.1",$0D,$0A,$0D,$0A,$00
10198      
10199    
10200    TMSG_Ready
10201    
10202      .BYTE $D,$A
10203      .BYTE "Ready.",$D,$A,0
10204      
10205      
10206    TMSG_Saving
10207    
10208      .BYTE $D,$A
10209      .BYTE "Saving...",$D,$A,0
10210      
10211      
10212    TMSG_Searching
10213    
10214      .BYTE $D,$A
10215      .BYTE "Searching...",$D,$A,0
10216    
10217    
10218    TMSG_Loading
10219    
10220      .BYTE $D,$A
10221      .BYTE "Loading.",$D,$A,0
10222      
10223    TMSG_Verifying
10224    
10225      .BYTE $D,$A
10226      .BYTE "Verifying.",$D,$A,0
10227    
10228    TMSG_TapeError
10229    
10230      .BYTE $D,$A
10231      .BYTE "Tape loading error.",$D,$A,0
10232      
10233    TMSG_HeaderError  
10234    
10235      .BYTE $D,$A
10236      .BYTE "Header error. Retrying.",$D,$A,0
10237    
10238    
10239    
10240    ; +-------------------------------------------------------------------------------------------------+
10241    ; +                                                                                                 +
10242    ; +                        Functions for tape loading and saving start here.                        +
10243    ; +                        =================================================                        +
10244    ; +                                                                                                 +
10245    ; +                                                                                                 +
10246    ; +-------------------------------------------------------------------------------------------------+
10247    
10248    
10249    ;*****************************************************************************************
10250    ;**                                                                                     **
10251    ;**                                                                                     **
10252    ;**                HOUSEKEEPING AND INITIALISATION FUNCTIONS GO HERE.                   **
10253    ;**                                                                                     **
10254    ;**                                                                                     **
10255    ;*****************************************************************************************
10256    
10257    F_TAPE_Init
10258    F451  A9 81          LDA #TAPE_out | JOYSTICK_sel				; Setup tape and joystick 6522 DDR Bits.
10259    F453  8D 42 C0       STA TAPE_DDRB
10260    
10261    F456  A0 00          LDY #0						; Setup our index to the start of the string
10262      
10263    L_TAPE_init_msg  
10264    F458  B9 AF F3       LDA TMSG_init_msg,Y					; Get the character
10265    F45B  F0 07          BEQ TAPE_msg_done					; Break out of the loop when we're done.
10266      
10267    F45D  20 02 E2       JSR V_OUTP						; output character
10268      
10269    F460  C8             INY							; Do the next character
10270    F461  4C 58 F4       JMP L_TAPE_init_msg
10271    
10272    TAPE_msg_done  
10273    F464  60             RTS
10274        
10275    
10276      
10277    
10278    
10279    ;*****************************************************************************************
10280    ;**                                                                                     **
10281    ;**                                                                                     **
10282    ;**          Helper and high level functions for tape loading and saving.               **
10283    ;**                                                                                     **
10284    ;**                                                                                     **
10285    ;*****************************************************************************************
10286    
10287    F_TAPE_Getname						; Purpose, to get a filename for the tape header.
10288    
10289    F465  60             RTS							; TODO:- Write this function.
10290    
10291    F_TAPE_SAVE_BASIC
10292      
10293    F466  A9 E2          LDA #<TMSG_Saving					; Tell the user that we are saving.
10294    F468  85 E7          STA TOE_MemptrLo
10295    F46A  A9 F3          LDA #>TMSG_Saving
10296    F46C  85 E8          STA TOE_MemptrHi
10297    F46E  20 D2 FF       JSR TOE_PrintStr_vec
10298    
10299    F471  20 FF F5       JSR F_TAPE_GetBASIC_Size				; Start by measuring our program
10300      
10301    F474  AD 00 09       LDA V_TAPE_BlockSize					; Save our program size to the header
10302    F477  8D 0F 09       STA TAPE_FileSizeLo
10303    F47A  AD 01 09       LDA V_TAPE_BlockSize + 1
10304    F47D  8D 10 09       STA TAPE_FileSizeHi
10305      
10306    F480  A9 00          LDA #<Ram_base					; Get our starting pointer for calculating our checksum loaded.
10307    F482  85 E5          STA TAPE_BlockLo
10308    F484  A9 0C          LDA #>Ram_base
10309    F486  85 E6          STA TAPE_BlockHi
10310      
10311    F488  20 C4 F5       JSR F_TAPE_CalcChecksum				; Get our checksum value
10312    
10313    F48B  AD 2E 09       LDA TAPE_CS_AccLo					; Store our calculated Checksum
10314    F48E  8D 24 09       STA TAPE_ChecksumLo
10315    F491  AD 2F 09       LDA TAPE_CS_AccHi
10316    F494  8D 25 09       STA TAPE_ChecksumHi
10317      
10318    F497  A9 00          LDA #<Ram_base					; Include the start of basic to the load address in the header
10319    F499  8D 11 09       STA TAPE_LoadAddrLo
10320    F49C  A9 0C          LDA #>Ram_base
10321    F49E  8D 12 09       STA TAPE_LoadAddrHi
10322      
10323    F4A1  A9 00          LDA #C_TAPE_FType_BASIC				; Setup the file type in the header to BASIC
10324    F4A3  8D 0E 09       STA TAPE_FileType
10325      
10326    F4A6  A9 0E          LDA #<TAPE_Header_Buffer				; Setup our block pointer to the start of the header
10327    F4A8  85 E5          STA TAPE_BlockLo
10328    F4AA  A9 09          LDA #>TAPE_Header_Buffer
10329    F4AC  85 E6          STA TAPE_BlockHi
10330      
10331    F4AE  A9 00          LDA #0						; Load our blocksize with the size of our header buffer
10332    F4B0  8D 01 09       STA V_TAPE_BlockSize + 1
10333    F4B3  A9 1F          LDA #TAPE_Header_End - TAPE_Header_Buffer
10334    F4B5  8D 00 09       STA V_TAPE_BlockSize
10335      
10336    F4B8  20 65 F4       JSR F_TAPE_Getname
10337      
10338    F4BB  20 99 F6       JSR F_TAPE_BlockOut					; Write our block to tape
10339      
10340    F4BE  A2 C8          LDX #<C_TAPE_Interblock_pause				; Wait a little before writing the actual program data block.
10341    F4C0  A0 AF          LDY #>C_TAPE_Interblock_pause
10342    F4C2  20 B1 F5       JSR F_TAPE_Pause
10343      
10344    F4C5  AD 11 09       LDA TAPE_LoadAddrLo					; Transfer our start address to our Block pointer
10345    F4C8  85 E5          STA TAPE_BlockLo
10346    F4CA  AD 12 09       LDA TAPE_LoadAddrHi
10347    F4CD  85 E6          STA TAPE_BlockHi
10348      
10349    F4CF  AD 0F 09       LDA TAPE_FileSizeLo					; Setup our blocksize counter
10350    F4D2  8D 00 09       STA V_TAPE_BlockSize
10351    F4D5  AD 10 09       LDA TAPE_FileSizeHi
10352    F4D8  8D 01 09       STA V_TAPE_BlockSize + 1
10353      
10354    F4DB  20 99 F6       JSR F_TAPE_BlockOut					; Write our file
10355        
10356    F4DE  60             RTS							; We're done for now.
10357      
10358    
10359    ; Tape LOADing routine.
10360    ; ---------------------
10361    
10362    TAPE_BlockIn_LoadErr
10363    F4DF  A9 1D          LDA #<TMSG_TapeError					; Tell the user that we are have encountered an error.
10364    F4E1  85 E7          STA TOE_MemptrLo
10365    F4E3  A9 F4          LDA #>TMSG_TapeError
10366    F4E5  85 E8          STA TOE_MemptrHi
10367    F4E7  20 D2 FF       JSR TOE_PrintStr_vec
10368    F4EA  60             RTS
10369    TAPE_BlockIn_EscHandler
10370    F4EB  A9 F5          LDA #<LAB_BMSG					; Tell the user that we are have pressed Escape.
10371    F4ED  85 E7          STA TOE_MemptrLo
10372    F4EF  A9 E8          LDA #>LAB_BMSG
10373    F4F1  85 E8          STA TOE_MemptrHi
10374    F4F3  20 D2 FF       JSR TOE_PrintStr_vec
10375    F4F6  60             RTS
10376      
10377      
10378    ;To load BASIC call here.
10379      
10380    F_TAPE_LOAD_BASIC
10381    
10382    F4F7  A9 0E          LDA #<TAPE_Header_Buffer				; Point to start of header buffer
10383    F4F9  85 E5          STA TAPE_BlockLo
10384    F4FB  A9 09          LDA #>TAPE_Header_Buffer
10385    F4FD  85 E6          STA TAPE_BlockHi
10386      
10387    F4FF  A9 1F          LDA #TAPE_Header_End - TAPE_Header_Buffer		; Specify how big our header is.
10388    F501  8D 00 09       STA V_TAPE_BlockSize
10389    F504  A9 00          LDA #0
10390    F506  8D 01 09       STA V_TAPE_BlockSize + 1
10391      
10392    F509  A9 F0          LDA #<TMSG_Searching					; Tell the user that we are searching.
10393    F50B  85 E7          STA TOE_MemptrLo
10394    F50D  A9 F3          LDA #>TMSG_Searching
10395    F50F  85 E8          STA TOE_MemptrHi
10396    F511  20 D2 FF       JSR TOE_PrintStr_vec
10397    
10398    F514  20 78 F7       JSR F_TAPE_BlockIn					; Load the header block.
10399    
10400    F517  AD 0D 09       LDA TAPE_BlockIn_Status				; Branch on non load conditions
10401    F51A  C9 02          CMP #TAPE_BlockIn_Escape
10402    F51C  F0 CD          BEQ TAPE_BlockIn_EscHandler				; If escaping jump to the escape handler
10403    F51E  C9 04          CMP #TAPE_BlockIn_Error
10404    F520  D0 0E          BNE TAPE_BASIC_Load_Verify_Stage
10405    
10406    F522  A9 35          LDA #<TMSG_HeaderError				; Tell the user of the header error and retry
10407    F524  85 E7          STA TOE_MemptrLo
10408    F526  A9 F4          LDA #>TMSG_HeaderError
10409    F528  85 E8          STA TOE_MemptrHi
10410    F52A  20 D2 FF       JSR TOE_PrintStr_vec
10411    F52D  4C F7 F4       JMP F_TAPE_LOAD_BASIC
10412      
10413    
10414    TAPE_BASIC_Load_Verify_Stage   
10415    F530  AD 0F 09       LDA TAPE_FileSizeLo					; Tell the system how big the file to load is.
10416    F533  8D 00 09       STA V_TAPE_BlockSize
10417    F536  AD 10 09       LDA TAPE_FileSizeHi
10418    F539  8D 01 09       STA V_TAPE_BlockSize + 1
10419      
10420    F53C  A9 00          LDA #<Ram_base					; Tell the system where to load the BASIC program. This should point to Ram_base
10421    F53E  85 E5          STA TAPE_BlockLo
10422    F540  A9 0C          LDA #>Ram_base
10423    F542  85 E6          STA TAPE_BlockHi
10424      
10425    F544  A9 01          LDA #<TMSG_Loading					; Tell the user that we are loading.
10426    F546  85 E7          STA TOE_MemptrLo
10427    F548  A9 F4          LDA #>TMSG_Loading
10428    F54A  85 E8          STA TOE_MemptrHi
10429    F54C  20 D2 FF       JSR TOE_PrintStr_vec
10430      
10431    F54F  20 78 F7       JSR F_TAPE_BlockIn					; Load the BASIC program.
10432      
10433    F552  AD 0D 09       LDA TAPE_BlockIn_Status				; Branch on non load conditions
10434    F555  C9 02          CMP #TAPE_BlockIn_Escape
10435    F557  F0 92          BEQ TAPE_BlockIn_EscHandler				; If escaping jump to the escape handler
10436      
10437    F559  C9 01          CMP #TAPE_BlockIn_Complete
10438    F55B  F0 0E          BEQ TAPE_BASIC_LoadingDone
10439    
10440    F55D  A9 35          LDA #<TMSG_HeaderError				; Tell the user of the header error and retry
10441    F55F  85 E7          STA TOE_MemptrLo
10442    F561  A9 F4          LDA #>TMSG_HeaderError
10443    F563  85 E8          STA TOE_MemptrHi
10444    F565  20 D2 FF       JSR TOE_PrintStr_vec
10445    F568  4C DF F4       JMP TAPE_BlockIn_LoadErr
10446      
10447    TAPE_BASIC_LoadingDone  
10448    F56B  A9 00          LDA #<Ram_base					; Setup our pointer to the start of BASIC Program memory
10449    F56D  85 E5          STA TAPE_BlockLo
10450    F56F  A9 0C          LDA #>Ram_base
10451    F571  85 E6          STA TAPE_BlockHi
10452      
10453    F573  20 C4 F5       JSR F_TAPE_CalcChecksum				; Get our checksum value into TAPE_CS_Acc_Lo and Hi
10454      
10455    F576  AD 24 09       LDA TAPE_ChecksumLo					; First we check the low byte.
10456    F579  CD 2E 09       CMP TAPE_CS_AccLo
10457    F57C  D0 26          BNE TAPE_CS_Fail
10458      
10459    F57E  AD 25 09       LDA TAPE_ChecksumHi					; And then if necessary, we check the high byte.
10460    F581  CD 2F 09       CMP TAPE_CS_AccHi
10461    F584  D0 1E          BNE TAPE_CS_Fail
10462    
10463    F586  A9 D7          LDA #<TMSG_Ready					; Inform the user they are back in immediate mode.
10464    F588  85 E7          STA TOE_MemptrLo
10465    F58A  A9 F3          LDA #>TMSG_Ready
10466    F58C  85 E8          STA TOE_MemptrHi
10467    F58E  20 D2 FF       JSR TOE_PrintStr_vec
10468    
10469    TAPE_BASICload_exit
10470    
10471    F591  A5 E5          LDA TAPE_BlockLo					; Return the system to a useable state
10472    F593  85 7B          STA Svarl
10473    F595  85 7D          STA Sarryl
10474    F597  85 7F          STA Earryl
10475    F599  A5 E6          LDA TAPE_BlockHi
10476    F59B  85 7C          STA Svarh
10477    F59D  85 7E          STA Sarryh
10478    F59F  85 80          STA Earryh
10479    F5A1  4C 17 C3       JMP LAB_1319						; Tidy up system.
10480      
10481    TAPE_CS_Fail
10482    F5A4  A9 1D          LDA #<TMSG_TapeError					; Inform the user of their loading error.
10483    F5A6  85 E7          STA TOE_MemptrLo
10484    F5A8  A9 F4          LDA #>TMSG_TapeError
10485    F5AA  85 E8          STA TOE_MemptrHi
10486    F5AC  20 D2 FF       JSR TOE_PrintStr_vec
10487    F5AF  80 E0          BRA TAPE_BASICload_exit
10488      
10489      
10490    F_TAPE_Pause
10491    
10492    F5B1  EA             NOP
10493    F5B2  EA             NOP
10494    F5B3  EA             NOP
10495    F5B4  EA             NOP
10496    F5B5  EA             NOP
10497    F5B6  EA             NOP
10498    F5B7  EA             NOP
10499    F5B8  EA             NOP
10500      
10501    F5B9  CA             DEX
10502    F5BA  E0 FF          CPX #$FF
10503    F5BC  D0 F3          BNE F_TAPE_Pause
10504      
10505    F5BE  88             DEY
10506    F5BF  C0 00          CPY #0
10507    F5C1  D0 EE          BNE F_TAPE_Pause
10508      
10509    F5C3  60             RTS
10510    
10511    
10512    F_TAPE_CalcChecksum
10513    
10514    F5C4  AE 00 09       LDX V_TAPE_BlockSize					; Set up our block counter
10515    F5C7  AC 01 09       LDY V_TAPE_BlockSize + 1
10516        
10517    F5CA  A9 00          LDA #0						; Clear the checksum accumulator
10518    F5CC  8D 2E 09       STA TAPE_CS_AccLo
10519    F5CF  8D 2F 09       STA TAPE_CS_AccHi
10520    
10521    L_TAPE_CS_NEXT  
10522    F5D2  AD 2E 09       LDA TAPE_CS_AccLo					; Add our byte to the checksum
10523    F5D5  18             CLC
10524    F5D6  72 E5          ADC (TAPE_BlockLo)
10525    F5D8  8D 2E 09       STA TAPE_CS_AccLo
10526    F5DB  AD 2F 09       LDA TAPE_CS_AccHi
10527    F5DE  69 00          ADC #0
10528    F5E0  8D 2F 09       STA TAPE_CS_AccHi
10529      
10530    F5E3  A5 E5          LDA TAPE_BlockLo					; Advance our pointer.
10531    F5E5  18             CLC
10532    F5E6  69 01          ADC #1
10533    F5E8  85 E5          STA TAPE_BlockLo
10534    F5EA  A5 E6          LDA TAPE_BlockHi
10535    F5EC  69 00          ADC #0
10536    F5EE  85 E6          STA TAPE_BlockHi
10537      
10538    F5F0  CA             DEX							; Repeat until 0
10539    F5F1  E0 FF          CPX #$FF
10540    F5F3  D0 01          BNE CS_No_Y_update  
10541    F5F5  88             DEY
10542    CS_No_Y_update
10543    F5F6  C0 00          CPY #0
10544    F5F8  D0 D8          BNE L_TAPE_CS_NEXT
10545    F5FA  E0 00          CPX #0
10546    F5FC  D0 D4          BNE L_TAPE_CS_NEXT
10547      
10548    F5FE  60             RTS
10549    
10550    
10551    F_TAPE_GetBASIC_Size
10552    
10553    F5FF  38             SEC
10554    F600  A5 7B          LDA Svarl
10555    F602  E9 00          SBC #<Ram_base
10556    F604  8D 00 09       STA V_TAPE_BlockSize
10557    F607  A5 7C          LDA Svarh
10558    F609  E9 0C          SBC #>Ram_base
10559    F60B  8D 01 09       STA V_TAPE_BlockSize + 1
10560      
10561    F60E  60             RTS
10562    
10563    
10564    ;*****************************************************************************************
10565    ;**                                                                                     **
10566    ;**                Timing and Synchronization functions go here.                        **
10567    ;**                ---------------------------------------------                        **
10568    ;**                                                                                     **
10569    ;*****************************************************************************************
10570    
10571    
10572    ; Wait for 50uS.  Note that JSR's cost 6 cycles
10573    
10574    F_TAPE_Phasetime_pause
10575    ; Each pass takes 10 cycles unless across a page boundary then it's 11 for an error of 10%!!
10576    
10577    ; Also, we need to make up the loss of 12 Cycles in calling it and in theory also the variable loading
10578    ; at the time of the call.
10579    
10580    ; First we disregard 20 cycles, then we burn them at 10 cycles a pass.
10581    
10582    F60F  A2 08          LDX #C_TAPE_Phasetime					; 2 Cycles
10583    F611  CA             DEX							; 2 Cycles saving 10
10584    F612  CA             DEX							; 2 Cycles saving 10
10585    F613  EA             NOP							; 2 Cycles
10586    F614  EA             NOP							; 2 Cycles
10587    F615  EA             NOP							; 2 Cycles
10588    F616  EA             NOP							; 2 Cycles
10589      
10590    TAPE_Phasetime_loop
10591    F617  CA             DEX							; 2 Cycles
10592    F618  EA             NOP							; 2 Cycles
10593    F619  EA             NOP							; 2 Cycles
10594    F61A  EA             NOP							; 2 Cycles
10595    F61B  D0 FA          BNE TAPE_Phasetime_loop				; 2 Cycles unless across pages.
10596      
10597    F61D  60             RTS							; 6 Cycles
10598      
10599      
10600      
10601      
10602    ;*****************************************************************************************
10603    ;**                                                                                     **
10604    ;**             Output Generating Functions.  Spoiler, It's all bitbashed!              **
10605    ;**             ----------------------------------------------------------              **
10606    ;**                                                                                     **
10607    ;*****************************************************************************************
10608      
10609        
10610    ;===============================================================================================
10611    ; TAPE Bit pulse generator  Takes the Z bit into consideration.
10612    
10613    
10614    F_TAPE_BitGen
10615    
10616    F61E  A0 08          LDY #C_TAPE_bitcycles					; Setup bitcycles loop
10617      
10618    TAPE_bitcycles_loop
10619    F620  48             PHA
10620    F621  C9 00          CMP #0
10621    F623  F0 05          BEQ TAPE_No_Pulse
10622      
10623    
10624    F625  A9 80          LDA #TAPE_out						; Set high phase
10625    F627  8D 40 C0       STA TAPE_IOP
10626    TAPE_No_Pulse
10627    F62A  20 0F F6       JSR F_TAPE_Phasetime_pause				; Wait hightone time which is eight times phase time.
10628    F62D  20 0F F6       JSR F_TAPE_Phasetime_pause				; This is so that the same loop can be used to capture the data for serial input
10629    F630  20 0F F6       JSR F_TAPE_Phasetime_pause
10630    F633  20 0F F6       JSR F_TAPE_Phasetime_pause
10631    F636  20 0F F6       JSR F_TAPE_Phasetime_pause
10632    F639  20 0F F6       JSR F_TAPE_Phasetime_pause
10633    F63C  20 0F F6       JSR F_TAPE_Phasetime_pause
10634    F63F  20 0F F6       JSR F_TAPE_Phasetime_pause
10635      
10636    
10637      
10638    
10639    F642  A9 00          LDA #0
10640    F644  8D 40 C0       STA TAPE_IOP						; Set low phase
10641    F647  20 0F F6       JSR F_TAPE_Phasetime_pause				; Wait hightone time
10642    F64A  20 0F F6       JSR F_TAPE_Phasetime_pause
10643    F64D  20 0F F6       JSR F_TAPE_Phasetime_pause
10644    F650  20 0F F6       JSR F_TAPE_Phasetime_pause
10645    F653  20 0F F6       JSR F_TAPE_Phasetime_pause
10646    F656  20 0F F6       JSR F_TAPE_Phasetime_pause
10647    F659  20 0F F6       JSR F_TAPE_Phasetime_pause
10648    F65C  20 0F F6       JSR F_TAPE_Phasetime_pause
10649      
10650    F65F  68             PLA
10651    F660  88             DEY
10652    F661  D0 BD          BNE TAPE_bitcycles_loop
10653    
10654    F663  60             RTS
10655      
10656      
10657    ;===============================================================================================  
10658    ; Tape byte output routine LSb first.  Accumulator holds the current byte.
10659    
10660    F_TAPE_ByteOut
10661    F664  08             PHP								; Save and disable IRQ status.
10662    F665  78             SEI
10663      
10664    F666  48             PHA								; Generate start bit.
10665    F667  A9 01          LDA #1
10666    F669  20 1E F6       JSR F_TAPE_BitGen
10667    F66C  68             PLA
10668    
10669    F66D  A2 08          LDX #8							; Set our bit counter for 8 bits.
10670      
10671    TAPE_Nextbit
10672    F66F  48             PHA								; Save the byte for later use.
10673    F670  DA             PHX								; Save our counter
10674      
10675    F671  29 01          AND #1							; Keep just the bit of interest.
10676    F673  20 1E F6       JSR F_TAPE_BitGen						; Output our bit.
10677    
10678    F676  FA             PLX								; Recover our counter
10679    F677  68             PLA								; Recover our working byte out
10680      
10681    F678  4A             LSR								; Move on to the next bit
10682    F679  CA             DEX								; Decrement our counter
10683      
10684    F67A  D0 F3          BNE TAPE_Nextbit						; Keep going until completed.
10685      
10686    F67C  48             PHA								; Generate stop bit
10687    F67D  A9 00          LDA #0
10688    F67F  20 1E F6       JSR F_TAPE_BitGen
10689    F682  A9 00          LDA #0							; Generate first guard bit
10690    F684  20 1E F6       JSR F_TAPE_BitGen
10691    F687  A9 00          LDA #0							; Generate second guard bit
10692    F689  20 1E F6       JSR F_TAPE_BitGen
10693    F68C  A9 00          LDA #0							; Generate third guard bit!
10694    F68E  20 1E F6       JSR F_TAPE_BitGen
10695    F691  A9 00          LDA #0							; Generate fourth guard bit!
10696    F693  20 1E F6       JSR F_TAPE_BitGen
10697    ;  LDA #0							; Generate fifth guard bit!
10698    ;  JSR F_TAPE_BitGen
10699    ;  LDA #0							; Generate sixth guard bit!
10700    ;  JSR F_TAPE_BitGen
10701    ;  LDA #0							; Generate seventh guard bit!
10702    ;  JSR F_TAPE_BitGen
10703    ;  LDA #0							; Generate EIGHTH guard bit!
10704    ;  JSR F_TAPE_BitGen
10705    F696  68             PLA
10706      
10707    F697  28             PLP								; Restore IRQ status
10708      
10709    F698  60             RTS
10710    
10711    
10712    ;===============================================================================================  
10713    ; Block output routine
10714    ;
10715    ; This requires the starting address and number of bytes output to operate.
10716    ; X contains the low byte of the count, Y contains the high byte and a two byte zero page variable
10717    ; holds the starting address, which is incremented as used.
10718    
10719    F_TAPE_BlockOut
10720    
10721    F699  20 CA F6       JSR F_TAPE_Leader						; Generate block leader
10722    
10723    F69C  AE 00 09       LDX V_TAPE_BlockSize						; Get the low byte of BlockStart
10724    F69F  AC 01 09       LDY V_TAPE_BlockSize+1					; Get the high byte of BlockStart
10725      
10726    L_TAPE_BlockOut
10727      
10728    F6A2  B2 E5          LDA (TAPE_BlockLo)						; Get the byte to output to tape
10729      
10730    F6A4  DA             PHX
10731    F6A5  5A             PHY
10732    F6A6  20 64 F6       JSR F_TAPE_ByteOut						; Transmit the byte.
10733    F6A9  7A             PLY
10734    F6AA  FA             PLX
10735      
10736    F6AB  A5 E5          LDA TAPE_BlockLo						; Increment our byte pointer
10737    F6AD  18             CLC
10738    F6AE  69 01          ADC #1
10739    F6B0  85 E5          STA TAPE_BlockLo
10740    F6B2  A5 E6          LDA TAPE_BlockHi
10741    F6B4  69 00          ADC #0
10742    F6B6  85 E6          STA TAPE_BlockHi
10743      
10744    TAPE_DecCounter
10745    F6B8  C0 00          CPY #0
10746    F6BA  D0 04          BNE TAPE_BlockOut_DecCounter
10747    F6BC  E0 00          CPX #0
10748    F6BE  F0 09          BEQ TAPE_BlockOut_Finish
10749    
10750    TAPE_BlockOut_DecCounter
10751    F6C0  CA             DEX
10752    F6C1  E0 FF          CPX #$FF
10753    F6C3  D0 DD          BNE L_TAPE_BlockOut
10754    F6C5  88             DEY
10755    F6C6  4C A2 F6       JMP L_TAPE_BlockOut
10756    
10757    TAPE_BlockOut_Finish  
10758    F6C9  60             RTS
10759      
10760    
10761    ;===============================================================================================  
10762    ; Tape leader_tone  
10763    
10764    F_TAPE_Leader
10765    F6CA  A2 64          LDX #TAPE_Leader_Bytes				; Put the leader cycles low byte into X
10766    
10767    TAPE_leader_lp
10768    F6CC  DA             PHX							; Save our cycle counter for later
10769      
10770    F6CD  A9 AA          LDA #C_TAPE_LeaderByte
10771    F6CF  20 64 F6       JSR F_TAPE_ByteOut					; Send leader byte
10772    
10773    
10774    F6D2  FA             PLX							; Retrieve our counter
10775    
10776    F6D3  CA             DEX							; Decrement our counter
10777    F6D4  D0 F6          BNE TAPE_leader_lp					; and loopback as necessary
10778    F6D6  A9 55          LDA #C_TAPE_EndOfLeaderByte
10779    F6D8  20 64 F6       JSR F_TAPE_ByteOut					; Send Terminating byte
10780    
10781    F6DB  60             RTS
10782    
10783    
10784    ;*****************************************************************************************
10785    ;**                                                                                     **
10786    ;**              Input Generating Functions.  Spoiler, It's all bitbashed!              **
10787    ;**              ---------------------------------------------------------              **
10788    ;**                                                                                     **
10789    ;*****************************************************************************************
10790    
10791    
10792    ;===============================================================================================  
10793    ; Tape line status sampler, temporarily flipped  
10794    
10795    
10796    F_TAPE_Sample_Tapeline
10797    F6DC  AD 40 C0       LDA TAPE_IOP						; Get sample
10798    F6DF  29 40          AND #TAPE_in
10799      
10800    F6E1  F0 02          BEQ TAPE_line_low					; Set or clear carry as needed.
10801    F6E3  38             SEC
10802    F6E4  60             RTS
10803      
10804    TAPE_line_low
10805    F6E5  18             CLC
10806    F6E6  60             RTS
10807    
10808    
10809    ;===============================================================================================
10810    ; Pulse Decoding engine.  This is where deserialisation happens.
10811    
10812    TAPE_PulseDecoder
10813    F6E7  AD 08 09       LDA TAPE_StartDet					; If the start bit has been detected
10814    F6EA  D0 1A          BNE TAPE_SamplePos_Check				; Seek rising edge and end otherwise
10815      
10816    F6EC  AD 06 09       LDA TAPE_Demod_Status					; Detect rising edge
10817    F6EF  F0 14          BEQ TAPE_NotRising
10818    F6F1  AD 07 09       LDA TAPE_Demod_Last
10819    F6F4  D0 0F          BNE TAPE_NotRising
10820    
10821    F6F6  A9 01          LDA #1						; Store rising edge signal
10822    F6F8  8D 08 09       STA TAPE_StartDet
10823    F6FB  A9 14          LDA #C_TAPE_Sample_Offset				; Start the counter for mid-bit
10824    F6FD  8D 0C 09       STA TAPE_Sample_Position
10825    F700  A9 0A          LDA #C_TAPE_BitsPerFrame
10826    F702  8D 0A 09       STA TAPE_BitsToDecode
10827    
10828    TAPE_NotRising
10829    F705  60             RTS
10830    
10831    TAPE_SamplePos_Check
10832    F706  A9 00          LDA #0						; Are we at the bit sample position
10833    F708  CD 0C 09       CMP TAPE_Sample_Position
10834    F70B  F0 04          BEQ TAPE_AtStartBit
10835      
10836    F70D  CE 0C 09       DEC TAPE_Sample_Position				; Decrement sample position end.
10837    F710  60             RTS
10838      
10839    TAPE_AtStartBit						; At start bit?
10840    F711  AD 0A 09       LDA TAPE_BitsToDecode
10841    F714  C9 0A          CMP #C_TAPE_BitsPerFrame
10842    F716  D0 17          BNE TAPE_AtStopBit
10843      
10844    F718  AD 06 09       LDA TAPE_Demod_Status					; Branch on start bit state.
10845    F71B  D0 09          BNE TAPE_AdjustCountersStart
10846      
10847    F71D  A9 00          LDA #0						; Path of invalid start bit.
10848    F71F  8D 08 09       STA TAPE_StartDet					; Clear start condition
10849    F722  8D 09 09       STA TAPE_RX_Status					; and status register.
10850    F725  60             RTS
10851      
10852    TAPE_AdjustCountersStart
10853    F726  A9 36          LDA #C_TAPE_Bitlength					; Start the counter for the next bit to sample
10854    F728  8D 0C 09       STA TAPE_Sample_Position
10855    F72B  CE 0A 09       DEC TAPE_BitsToDecode
10856    F72E  60             RTS
10857      
10858    TAPE_AtStopBit						; Stop bit?
10859    F72F  AD 0A 09       LDA TAPE_BitsToDecode
10860    F732  C9 01          CMP #1
10861    F734  D0 1B          BNE TAPE_AtDataBit
10862    
10863    F736  AD 06 09       LDA TAPE_Demod_Status
10864    F739  D0 0B          BNE TAPE_Overrun
10865      
10866    F73B  A9 00          LDA #0						; Clear Start detect bit
10867    F73D  8D 08 09       STA TAPE_StartDet
10868    F740  A9 04          LDA #TAPE_Stat_RXFull					; Indicate byte received
10869    F742  8D 09 09       STA TAPE_RX_Status
10870    F745  60             RTS
10871      
10872    TAPE_Overrun
10873    F746  A9 00          LDA #0						; Clear Start detect bit
10874    F748  8D 08 09       STA TAPE_StartDet
10875    F74B  A9 01          LDA #TAPE_Stat_overrun				; Indicate byte received
10876    F74D  8D 09 09       STA TAPE_RX_Status
10877    F750  60             RTS
10878    
10879    TAPE_AtDataBit
10880    F751  AD 06 09       LDA TAPE_Demod_Status					; Shift our bit into the byte received LSb when not a stop bit
10881    F754  6A             ROR
10882    F755  6E 0B 09       ROR TAPE_ByteReceived
10883      
10884    
10885    F758  CE 0A 09       DEC TAPE_BitsToDecode					; Adjust counters accordingly
10886    F75B  A9 36          LDA #C_TAPE_Bitlength
10887    F75D  8D 0C 09       STA TAPE_Sample_Position
10888     
10889    F760  60             RTS
10890      
10891      
10892    
10893    
10894    ;*****************************************************************************************
10895    ;**                                                                                     **
10896    ;**           Tape Input Functions.  These are all hand calibrated so take care.        **
10897    ;**           ------------------------------------------------------------------        **
10898    ;**                                                                                     **
10899    ;*****************************************************************************************
10900    
10901    
10902    
10903    
10904    
10905    F_TAPE_FindStart
10906    F761  20 D8 F7       JSR F_TAPE_GetByte
10907    F764  AD 09 09       LDA TAPE_RX_Status
10908      
10909    F767  C9 08          CMP #TAPE_Stat_Escape						; Break on Escape condition
10910    F769  D0 01          BNE TAPE_LeaderNoBreak
10911      
10912    F76B  60             RTS
10913      
10914    TAPE_LeaderNoBreak
10915    F76C  C9 01          CMP #TAPE_Stat_overrun
10916    F76E  F0 F1          BEQ F_TAPE_FindStart
10917      
10918    F770  AD 0B 09       LDA TAPE_ByteReceived
10919    F773  C9 55          CMP #C_TAPE_EndOfLeaderByte					; Keep trying until end of leader byte is received
10920    F775  D0 EA          BNE F_TAPE_FindStart
10921      
10922    F777  60             RTS
10923    
10924    
10925    
10926    
10927    ;===============================================================================================  
10928    ; Block read routine
10929    ;
10930    ; This requires the starting address and number of bytes output to operate.
10931    ; X contains the low byte of the count, Y contains the high byte and a two byte zero page variable
10932    ; holds the starting address, which is incremented as used.
10933    
10934    F_TAPE_BlockIn
10935    
10936    F778  20 61 F7       JSR F_TAPE_FindStart						; Follow the leader signal
10937      
10938    F77B  AD 09 09       LDA TAPE_RX_Status
10939    F77E  C9 08          CMP #TAPE_Stat_Escape
10940    F780  F0 1D          BEQ TAPE_BlockIn_Sig_Escape
10941      
10942    F782  AE 00 09       LDX V_TAPE_BlockSize						; Get the low byte of BlockStart
10943    F785  AC 01 09       LDY V_TAPE_BlockSize+1					; Get the high byte of BlockStart
10944      
10945    F788  A9 00          LDA #0							; Initialise BlockIn's status register
10946    F78A  8D 0D 09       STA TAPE_BlockIn_Status
10947      
10948    L_TAPE_BlockIn
10949    
10950    F78D  DA             PHX								; Get a byte from the tape interface
10951    F78E  5A             PHY
10952    F78F  20 D8 F7       JSR F_TAPE_GetByte
10953    F792  7A             PLY
10954    F793  FA             PLX
10955      
10956    F794  AD 09 09       LDA TAPE_RX_Status						; failing gracefully upon bad events.
10957    F797  C9 04          CMP #TAPE_Stat_RXFull
10958    F799  F0 10          BEQ TAPE_BlockIn_Store
10959      
10960    F79B  C9 08          CMP #TAPE_Stat_Escape
10961    F79D  D0 06          BNE TAPE_BlockIn_CheckError
10962      
10963    TAPE_BlockIn_Sig_Escape  
10964    F79F  A9 02          LDA #TAPE_BlockIn_Escape
10965    F7A1  8D 0D 09       STA TAPE_BlockIn_Status
10966    F7A4  60             RTS								; Escape
10967      
10968    TAPE_BlockIn_CheckError  
10969    F7A5  A9 04          LDA #TAPE_BlockIn_Error
10970    F7A7  8D 0D 09       STA TAPE_BlockIn_Status
10971    F7AA  60             RTS								; Failed  
10972      
10973    TAPE_BlockIn_Store
10974    F7AB  AD 0B 09       LDA TAPE_ByteReceived						; Store our received byte to our current pointer address.
10975    F7AE  92 E5          STA (TAPE_BlockLo)
10976    
10977    F7B0  A5 E5          LDA TAPE_BlockLo						; Increment our byte pointer
10978    F7B2  18             CLC
10979    F7B3  69 01          ADC #1
10980    F7B5  85 E5          STA TAPE_BlockLo
10981    F7B7  A5 E6          LDA TAPE_BlockHi
10982    F7B9  69 00          ADC #0
10983    F7BB  85 E6          STA TAPE_BlockHi
10984    
10985    F7BD  C0 00          CPY #0
10986    F7BF  D0 04          BNE TAPE_BlockIn_DecCounter
10987    F7C1  E0 00          CPX #0
10988    F7C3  F0 09          BEQ TAPE_BlockIn_Finish
10989    
10990    TAPE_BlockIn_DecCounter
10991    F7C5  CA             DEX
10992    F7C6  E0 FF          CPX #$FF
10993    F7C8  D0 C3          BNE L_TAPE_BlockIn
10994    F7CA  88             DEY
10995    F7CB  4C 8D F7       JMP L_TAPE_BlockIn
10996      
10997    TAPE_BlockIn_Finish
10998    F7CE  A9 01          LDA #TAPE_BlockIn_Complete					; Indicate tast completion
10999    F7D0  8D 0D 09       STA TAPE_BlockIn_Status
11000    F7D3  60             RTS
11001      
11002    
11003      
11004    TAPE_BytePumpIn							; Save the byte counter high byte
11005      
11006    
11007      
11008    F7D4  4C 8D F7       JMP L_TAPE_BlockIn
11009      
11010    F7D7  60             RTS
11011    
11012    
11013    
11014    
11015    
11016    
11017    
11018    
11019    
11020    
11021    
11022    
11023    
11024    
11025    ;===============================================================================================
11026    ; Byte Reader.
11027    
11028    F_TAPE_GetByte
11029    
11030    ; First some initial housekeeping
11031    
11032    F7D8  08             PHP							; Save and disable IRQ status
11033    F7D9  78             SEI
11034    
11035    F7DA  A9 00          LDA #0
11036    F7DC  8D 06 09       STA TAPE_Demod_Status					; Start our bit demod with zero.
11037    F7DF  8D 07 09       STA TAPE_Demod_Last					; Set our initial demod status too.
11038    F7E2  8D 05 09       STA TAPE_LineUptime					; Set our initial uptime counter to zero.
11039    F7E5  8D 09 09       STA TAPE_RX_Status					; Clear our Status register
11040      
11041    TAPE_pulselatch
11042      
11043    F7E8  AD 09 09       LDA TAPE_RX_Status
11044    F7EB  D0 0A          BNE TAPE_ByteCaptured					; Check status for received byte.
11045      
11046    F7ED  20 3A F0       JSR ACIA1in						; Just in case the user needs to get out of this loop
11047    F7F0  90 07          BCC TAPE_ContLoop					; Caught in a landsliiiide, no escape TO re-al-ih-teeeee!
11048    F7F2  A9 08          LDA #TAPE_Stat_Escape
11049    F7F4  8D 09 09       STA TAPE_RX_Status
11050      
11051    
11052    TAPE_ByteCaptured
11053    F7F7  28             PLP							; Restore IRQ status
11054      
11055    F7F8  60             RTS							; Done
11056    
11057    
11058    ; Services that use the pulse decoded go here.
11059    
11060    TAPE_ContLoop
11061      ; JSR TAPE_TestOutput					; Set our status
11062    F7F9  20 E7 F6       JSR TAPE_PulseDecoder					; We gotta do something with these pulses right...?
11063    
11064    F7FC  AD 06 09       LDA TAPE_Demod_Status					; Update some variables
11065    F7FF  8D 07 09       STA TAPE_Demod_Last
11066    
11067    ; =-=-=-=-=-=-=-=-----------------=-=-=-=-=-=-=-=---------=-=-=-=-=-=-=-=-
11068    ;
11069    ; The actual pulse demodulation code starts here
11070    ;
11071    ; =-=-=-=-=-=-=-=-----------------=-=-=-=-=-=-=-=---------=-=-=-=-=-=-=-=-
11072      
11073    F802  20 0F F6       JSR F_TAPE_Phasetime_pause				; and delay for our respective looptime
11074      
11075    F805  20 DC F6       JSR F_TAPE_Sample_Tapeline				; Update status
11076    F808  90 0A          BCC TAPE_DontSet
11077      
11078    F80A  A9 01          LDA #1
11079    F80C  8D 06 09       STA TAPE_Demod_Status					; Set our line status to up
11080    F80F  A9 0A          LDA #10						; THIS WAS WORKING AT 7
11081    F811  8D 05 09       STA TAPE_LineUptime					; Reset our latch counter
11082      
11083    TAPE_DontSet
11084    F814  AD 05 09       LDA TAPE_LineUptime
11085    F817  F0 06          BEQ TAPE_AtMinimum
11086      
11087    F819  CE 05 09       DEC TAPE_LineUptime
11088    F81C  4C E8 F7       JMP TAPE_pulselatch
11089        
11090    TAPE_AtMinimum
11091    F81F  A9 00          LDA #0						; Clear our line status
11092    F821  8D 06 09       STA TAPE_Demod_Status
11093    F824  4C E8 F7       JMP TAPE_pulselatch
11094    
11095    
11096    
11097    
11098    
11099    
11100    
11101    ;#################################
11102    
11103    ; Test code here.
11104    
11105    ;#################################
11106    
11107    
11108    TAPE_TestOutput
11109    ;  LDA TAPE_StartDet
11110    ;  STA $C041
11111    ;  RTS
11112    
11113    
11114    
11115    F827  AD 0C 09       LDA TAPE_Sample_Position
11116    F82A  D0 06          BNE TAPE_Marker
11117    F82C  A9 01          LDA #1
11118    F82E  8D 41 C0       STA $C041
11119    F831  60             RTS
11120    TAPE_Marker
11121    F832  A9 00          LDA #0
11122      
11123    ;  LDA TAPE_Demod_Status
11124    
11125    F834  8D 41 C0       STA $C041
11126    
11127    F837  60             RTS
11128      
11129      
11130      .INCLUDE "AY_DRIVER.asm"
11131    ; AY-3-891x Register Driver
11132    ;
11133    ; By Duncan Gunn.
11134    
11135    
11136    ; AY_6522 Registers
11137    
11138      C0E0             AY_6522_Base	 	=	$C0E0
11139      C0E0             AY_6522_ORB		=	AY_6522_Base
11140      C0E1             AY_6522_ORA		=	AY_6522_Base + $01
11141      C0E2             AY_6522_DDRB		=	AY_6522_Base + $02
11142      C0E3             AY_6522_DDRA		=	AY_6522_Base + $03
11143      C0E4             AY_6522_T1C_L		=	AY_6522_Base + $04
11144      C0E5             AY_6522_T1C_H		=	AY_6522_Base + $05
11145      C0E6             AY_6522_L1L_L		=	AY_6522_Base + $06
11146      C0E7             AY_6522_L1L_H		=	AY_6522_Base + $07
11147      C0E8             AY_6522_T2C_L		=	AY_6522_Base + $08
11148      C0E9             AY_6522_T2C_H		=	AY_6522_Base + $09
11149      C0EA             AY_6522_SR		=	AY_6522_Base + $0A
11150      C0EB             AY_6522_ACR		=	AY_6522_Base + $0B
11151      C0EC             AY_6522_PCR		=	AY_6522_Base + $0C
11152      C0ED             AY_6522_IFR		=	AY_6522_Base + $0D
11153      C0EE             AY_6522_IER		=	AY_6522_Base + $0E
11154      C0EF             AY_6522_ORA_IRA		=	AY_6522_Base + $0F
11155    
11156    
11157    ; AY_6522 HW Mappings.
11158    
11159      C0E0             AY_DATAPORT		=	AY_6522_ORB
11160      C0E2             AY_DDR_DATA		=	AY_6522_DDRB
11161    
11162      C0E1             AY_CTRLPORT		=	AY_6522_ORA
11163      C0E3             AY_DDR_CTRL		=	AY_6522_DDRA
11164    
11165      0001             AY_CTRL_bit_BC1		= 	@00000001
11166      0002             AY_CTRL_bit_BDIR	=	@00000010
11167    
11168      0003             AY_CTRL_dir		=	AY_CTRL_bit_BC1 | AY_CTRL_bit_BDIR	; Set relevant port bits as outputs
11169      00FF             AY_DATA_out		=	$FF
11170      0000             AY_DATA_in		=	$0
11171    
11172    
11173    
11174    ; AY Registers
11175    
11176      0000             AY_CH_A_TP_FINE		= $0
11177      0001             AY_CH_A_TP_COARSE	= $1	; Bottom four bits only
11178      0002             AY_CH_B_TP_FINE		= $2
11179      0003             AY_CH_B_TP_COARSE	= $3	; Bottom four bits only
11180      0004             AY_CH_C_TP_FINE		= $4
11181      0005             AY_CH_C_TP_COARSE	= $5
11182      0006             AY_NOISE_PERIOD		= $6	; Bottom five bits only
11183      0007             AY_NOT_ENABLE		= $7	; Bitfield: See table 1 below
11184      0008             AY_CH_A_AMP		= $8	; M (Bit 5) when set uses the Envelope gen, otherwise B3-B0 sets the volume
11185      0009             AY_CH_B_AMP		= $9	; See channel A
11186      000A             AY_CH_C_AMP		= $A	; See channel A
11187      000B             AY_ENV_P_FINE		= $B	
11188      000C             AY_ENV_P_COARSE		= $C
11189      000D             AY_ENV_SH_CYC		= $D	; See table 2 below
11190      000E             AY_PORTA_REG		= $E	; Not implemented for the AY-3-8912
11191      000F             AY_PORTB_REG		= $F	; Not implemented for the AY-3-8912
11192    
11193    
11194    ; Table 1.  AY_NOT_ENABLE bitfield.
11195    ;
11196    ; +---------+-----------+-----------+
11197    ; | IN/nOUT |   nNOISE  |   nTONE   |
11198    ; +----+----+---+---+---+---+---+---+
11199    ; |IOB |IOA | C | B | A | C | B | A |
11200    ; +----+----+---+---+---+---+---+---+
11201    
11202      0020             AY_bit_nNOISE_C		= @00100000
11203      0010             AY_bit_nNOISE_B		= @00010000
11204      0008             AY_bit_nNOISE_A		= @00001000
11205      0004             AY_bit_nTONE_C		= @00000100
11206      0002             AY_bit_nTONE_B		= @00000010
11207      0001             AY_bit_nTONE_A		= @00000001
11208    
11209    
11210    ; Table 2.  Envelope shape/cycle bitfield.
11211    ;
11212    ; +--------+--------+--------+--------+--------+--------+--------+--------+
11213    ; |   B7   |   B6   |   B5   |   B4   |   B3   |   B2   |   B1   |   B0   |
11214    ; +--------+--------+--------+--------+--------+--------+--------+--------+
11215    ; |          B7-B4 Not used.          | Cont   | Attack | Alt    | Hold   |
11216    ; +--------+--------+--------+--------+--------+--------+--------+--------+
11217    ;
11218    ; CONTinue causes the pattern to cycle when set.
11219    ; Setting Attack makes the envelope counter count up, but when cleared causes a count down instead.
11220    ; Setting ALTernate causes the counter to reverse direction at the end of each cycle.
11221    ; Setting HOLD limits the envelope generator to one cycle
11222    
11223      0008             AY_bit_CONT		= @00001000
11224      0004             AY_bit_ATTACK		= @00000100
11225      0002             AY_bit_ALT		= @00000010
11226      0001             AY_bit_HOLD		= @00000001
11227    
11228    
11229    ; AY control modes
11230    
11231      0000             AY_INACK		= 0
11232      0001             AY_READ			= AY_CTRL_bit_BC1
11233      0002             AY_WRITE		= AY_CTRL_bit_BDIR
11234      0003             AY_LAT_ADDR		= AY_CTRL_bit_BC1 | AY_CTRL_bit_BDIR
11235    
11236    
11237    ; AY Soundcard memory allocations.
11238    
11239      0A00             AY_Memstart		= $A00
11240      0A00             AY_Reg			= AY_Memstart
11241      0A01             AY_Data			= AY_Reg + 1
11242    
11243    
11244    ; AY_Initialisation routine.
11245    
11246    AY_Init
11247    F838  A9 00          LDA #0
11248    F83A  8D E1 C0       STA AY_CTRLPORT	; Let's make our control port inactive first.
11249    F83D  A9 03          LDA #AY_CTRL_dir
11250    F83F  8D E3 C0       STA AY_DDR_CTRL
11251      
11252    
11253    F842  A2 0F          LDX #$F		; Clear all the registers
11254    AY_Init_Loop
11255    
11256    F844  A9 00          LDA #0
11257    F846  20 88 F8       JSR AY_wr_to_reg
11258    F849  CA             DEX
11259    F84A  D0 F8          BNE AY_Init_Loop
11260    F84C  60             RTS
11261      
11262    
11263    ; AY register read-write primitives
11264    ;
11265    
11266    ; Writes the register address to the AY
11267    ;
11268    ; Takes A as the register parameter. Corrupts A
11269    AY_wr_reg
11270    F84D  8D E0 C0       STA AY_DATAPORT	; Place our register value on the AY bus
11271      
11272    F850  A9 FF          LDA #AY_DATA_out
11273    F852  8D E2 C0       STA AY_DDR_DATA	; And ensure the bus is an output.
11274      
11275    F855  A9 03          LDA #AY_LAT_ADDR	; Latch our data to the AY
11276    F857  8D E1 C0       STA AY_CTRLPORT
11277      ;NOP
11278      ;NOP
11279    F85A  A9 00          LDA #AY_INACK		; And ensure out bus goes inactive again.
11280    F85C  8D E1 C0       STA AY_CTRLPORT
11281    F85F  60             RTS
11282    
11283    ; Writes data to the currently selected register
11284    ;
11285    ; Takes A as the register parameter. Corrupts A
11286    AY_wr_data
11287    F860  8D E0 C0       STA AY_DATAPORT	; Place our data on the AY bus
11288    
11289    F863  A9 FF          LDA #AY_DATA_out
11290    F865  8D E2 C0       STA AY_DDR_DATA
11291        
11292    F868  A9 02          LDA #AY_WRITE
11293    F86A  8D E1 C0       STA AY_CTRLPORT
11294      ;NOP
11295      ;NOP
11296    F86D  A9 00          LDA #AY_INACK		; And ensure the bus is an output.
11297    F86F  8D E1 C0       STA AY_CTRLPORT
11298    F872  60             RTS
11299    
11300    ; Read register		; Corrupts Y, returns the result in A.
11301    AY_rd_data
11302    F873  A9 00          LDA #AY_DATA_in	; Make our bus an input so that the AY can drive it.
11303    F875  8D E2 C0       STA AY_DDR_DATA
11304      
11305    F878  A9 01          LDA #AY_READ		; Set our AY to output it's register contents
11306    F87A  8D E1 C0       STA AY_CTRLPORT
11307      
11308    F87D  AD E0 C0       LDA AY_DATAPORT	; Grab those contents and put them in Y
11309    F880  A8             TAY
11310      
11311    F881  A9 00          LDA #AY_INACK		; Put our AY but back inactive.
11312    F883  8D E1 C0       STA AY_CTRLPORT
11313      
11314    F886  98             TYA			; Put our result back into A
11315      
11316    F887  60             RTS			; Were finished.
11317      
11318      
11319    ; The 'All in one' function.
11320    ;
11321    AY_wr_to_reg
11322    F888  48             PHA
11323    F889  8A             TXA
11324      
11325    F88A  20 4D F8       JSR AY_wr_reg
11326    F88D  68             PLA
11327    F88E  20 60 F8       JSR AY_wr_data
11328    F891  60             RTS
11329      
11330    
11331    ; For the users of BASIC, here's the easier read/write functions. 
11332    
11333    AY_Userwrite
11334    F892  AD 01 0A       LDA AY_Data
11335    F895  AE 00 0A       LDX AY_Reg
11336    F898  20 88 F8       JSR AY_wr_to_reg
11337    F89B  60             RTS
11338      
11339    AY_Userread
11340    F89C  AD 00 0A       LDA AY_Reg		; Select our register of interest.
11341    F89F  20 4D F8       JSR AY_wr_reg
11342      
11343    F8A2  20 73 F8       JSR AY_rd_data	; Get the contents of the register of interest.
11344    F8A5  8D 01 0A       STA AY_Data
11345    F8A8  60             RTS
11346      .INCLUDE "IRQ_Handler.asm"
11347    ; IRQ Manager.
11348    ;
11349    ; Interrupt request handling and masking on per device basis.
11350    
11351    
11352    ; System constants.  Presently only one exists.
11353    
11354      0000             IRQH_Version_C		= 0				; Version 0 (Pre-release)
11355    
11356    
11357    ; IRQ Memory table
11358    ;
11359      0A20             IRQH_Table_Base		= $A20 				; Beginning of IRQ Handler Memory.
11360      0A20             IRQH_CallList		= IRQH_Table_Base		; All sixteen bytes for eight addresses.
11361      0A30             IRQH_CallReg		= IRQH_CallList + 16		; Two bytes containing an address being transferred.
11362      0A32             IRQH_ClaimsList		= IRQH_CallReg + 2		; Byte with list of calls that returned and IRQ Claim
11363      0A33             IRQH_MaskByte		= IRQH_ClaimsList + 1		; Byte containing IRQ Table entry mask bits. IRQ entry LSb is IRQ entry 0.
11364      0A34             IRQH_WorkingMask	= IRQH_MaskByte + 1		; Walking bit for masking and setting purposes.
11365      0A35             IRQH_CurrentEntry	= IRQH_WorkingMask + 1		; Pointer for IRQ Table entries.
11366    
11367    ; Table current size is 21 bytes.
11368    
11369    
11370    ; IRQ Handler Initialisation Call
11371    
11372    IRQH_Handler_Init_F
11373    F8A9  78             SEI						; Disable IRQ's so we don't break anything already happening.
11374      
11375    F8AA  A9 D0          LDA #<IRQH_Null_F				; Put the null IRQ Function address into IRQ_CallReg
11376    F8AC  8D 30 0A       STA IRQH_CallReg
11377    F8AF  A9 F8          LDA #>IRQH_Null_F
11378    F8B1  8D 31 0A       STA IRQH_CallReg + 1
11379      
11380    F8B4  A9 07          LDA #7					; Point at the last table entry
11381    F8B6  A8             TAY
11382    
11383    IRQH_FillTable_L
11384    F8B7  20 DC F8       JSR IRQH_SetIRQ_F				; Iterate copy to whole table
11385      
11386    F8BA  98             TYA
11387    F8BB  38             SEC
11388    F8BC  E9 01          SBC #1
11389    F8BE  A8             TAY
11390      
11391    F8BF  B0 F6          BCS IRQH_FillTable_L
11392      
11393    F8C1  A9 00          LDA #0					; Clear rest of the IRQ Handler's structure.
11394    F8C3  8D 32 0A       STA IRQH_ClaimsList
11395    F8C6  8D 33 0A       STA IRQH_MaskByte
11396    F8C9  8D 34 0A       STA IRQH_WorkingMask
11397    F8CC  8D 35 0A       STA IRQH_CurrentEntry
11398      
11399    F8CF  60             RTS						; Return to caller.
11400      
11401      
11402    ; IRQ Null function
11403    
11404    IRQH_Null_F
11405    F8D0  AD 34 0A       LDA IRQH_WorkingMask				; Get our Working position
11406      
11407    F8D3  49 FF          EOR #$FF					; Unset our Claim bit.
11408    F8D5  2D 32 0A       AND IRQH_ClaimsList
11409    F8D8  8D 32 0A       STA IRQH_ClaimsList
11410      
11411    F8DB  60             RTS
11412      
11413    
11414    ; Function to atomically add an IRQ to the IRQ Table.
11415    
11416    IRQH_SetIRQ_F
11417    
11418    F8DC  08             PHP						; Assure atomic
11419    F8DD  78             SEI
11420      
11421    F8DE  0A             ASL						; Multiply our pointer by two as the table uses words not bytes.
11422      
11423    F8DF  AA             TAX						; Transfer our table reference to index X
11424      
11425    F8E0  AD 30 0A       LDA IRQH_CallReg				; Get our call low-byte
11426    F8E3  9D 20 0A       STA IRQH_CallList,X				; Store our low byte
11427      
11428    F8E6  AD 31 0A       LDA IRQH_CallReg + 1				; Get our call high-byte
11429    F8E9  E8             INX
11430    F8EA  9D 20 0A       STA IRQH_CallList,X				; Store our high byte.
11431      
11432    F8ED  28             PLP						; End atomic operation
11433    F8EE  60             RTS
11434      
11435      
11436    ; Function to atomically clear an IRQ from the table
11437    
11438    IRQH_ClrIRQ_F
11439    F8EF  08             PHP						; Assure atomic
11440    F8F0  78             SEI
11441    
11442    F8F1  0A             ASL						; Multiply our pointer by two
11443    F8F2  AA             TAX						; and place it in X
11444    
11445    F8F3  A9 D0          LDA #<IRQH_Null_F				; Transfer our Null function address to the table
11446    F8F5  9D 20 0A       STA IRQH_CallList,X
11447    F8F8  A9 F8          LDA #>IRQH_Null_F
11448    F8FA  E8             INX
11449    F8FB  9D 20 0A       STA IRQH_CallList,X
11450      
11451    F8FE  28             PLP						; End atomic operation
11452    F8FF  60             RTS
11453      
11454      
11455    ; IRQ Handler function.
11456    
11457    IRQH_ProcessIRQs
11458    F900  48             PHA						; Save processor registers
11459    F901  DA             PHX
11460    F902  5A             PHY
11461      
11462    F903  D8             CLD						; We have no idea what mode the processor was in when this was called so let's clear it.
11463      
11464    F904  AD 33 0A       LDA IRQH_MaskByte				; Get IRQ mask
11465    F907  F0 29          BEQ IRQH_FinishIRQs_B				; and quit early if all disabled.
11466      
11467    F909  A9 01          LDA #1					; Put 1 into our working mask
11468    F90B  8D 34 0A       STA IRQH_WorkingMask				
11469    
11470    F90E  A2 00          LDX #0					; Start with X at table entry 0
11471      
11472    IRQH_CheckCall_B  
11473    F910  AD 33 0A       LDA IRQH_MaskByte				; Check if we need to call that table entry or not
11474    F913  2D 34 0A       AND IRQH_WorkingMask
11475    F916  F0 0A          BEQ IRQH_SkipCall_B
11476      
11477    
11478    F918  A9 F9          LDA #>IRQH_Return_B				; Place our return address-1 on the stack for the ensuing RTS (which adds 1)
11479    F91A  48             PHA
11480    F91B  A9 21          LDA #<IRQH_Return_B
11481    F91D  48             PHA
11482      
11483    F91E  7C 20 0A       JMP (IRQH_CallList,X)				; Make the call, including the table offset
11484      
11485    IRQH_Return_B					; Since the 65C02 won't JSR to our chosen address, this is the return address
11486    F921  EA             NOP						; non executed packer.  It's cheaper than the arithmetic approach.
11487    
11488    IRQH_SkipCall_B
11489    F922  EE 35 0A       INC IRQH_CurrentEntry				; Advance to the next table entry
11490    F925  E8             INX
11491    F926  E8             INX
11492      
11493    F927  8A             TXA						; Have we processed them all?
11494    F928  C9 10          CMP #16					; If so, we shall go to the finish-line.
11495    F92A  F0 06          BEQ IRQH_FinishIRQs_B
11496      
11497    F92C  18             CLC						; Move our working mask to the next IRQ
11498    F92D  2E 34 0A       ROL IRQH_WorkingMask
11499      
11500    F930  80 DE          BRA IRQH_CheckCall_B				; Check the next call.
11501      
11502    IRQH_FinishIRQs_B
11503    F932  7A             PLY						; Retrieve processor registers
11504    F933  FA             PLX
11505    F934  68             PLA
11506      
11507    F935  40             RTI
11508      
11509      
11510    ; Function to return table base address and version number.
11511    ; Used for keeping programs compatible over generational changes.
11512    
11513    IRQH_SystemReport_F
11514    
11515    F936  A9 00          LDA #IRQH_Version_C
11516    F938  A2 20          LDX #<IRQH_Table_Base
11517    F93A  A0 0A          LDY #>IRQH_Table_Base
11518    F93C  60             RTS
11519      .INCLUDE "TEST_IRQ.asm"
11520    ; Test IRQ.  The job of this IRQ handler besides prooving the system works is to
11521    ; Add a free-running system counter.  This is to be driven from the timer on the GPIO card.
11522    
11523    
11524    ; Variables
11525    
11526      0A50             CTR_V			= $A50		; This is our counter variable base address.
11527      0A52             CTR_LOAD_VAL_V		= $A52		; This is the interval between counts in PHI2 ticks
11528    
11529    
11530    ; Constants
11531    
11532      9C3F             TIM_DELAY_C		= 39999		; This is the value we are going to use to set the timer. 10ms @4MHz
11533    
11534    
11535    ; Hardware constants
11536    
11537    
11538      C044             TIM_T1L			= TAPE_IOBASE + 4
11539      C045             TIM_T1H			= TAPE_IOBASE + 5
11540    
11541      C04B             TIM_ACR			= TAPE_IOBASE + $B
11542      C04D             TIM_IFR			= TAPE_IOBASE + $D
11543      C04E             TIM_IER			= TAPE_IOBASE + $E
11544    
11545    INIT_TEST_IRQ
11546    
11547    F93D  A9 00          LDA #0				; Initialise our counter to 0
11548    F93F  8D 50 0A       STA CTR_V
11549    F942  8D 51 0A       STA CTR_V + 1
11550      
11551      
11552    F945  A9 3F          LDA #<TIM_DELAY_C			; Load timer value to our variable
11553    F947  8D 52 0A       STA CTR_LOAD_VAL_V
11554    F94A  A9 9D          LDA #>TIM_DELAY_C + 1
11555    F94C  8D 53 0A       STA CTR_LOAD_VAL_V + 1
11556      
11557    F94F  A9 41          LDA #@01000001				; Load Auxilliary Control Register with continuous interrupts on T1 with latching
11558    F951  8D 4B C0       STA TIM_ACR
11559      
11560    F954  A9 C0          LDA #@11000000
11561    F956  8D 4E C0       STA TIM_IER
11562      
11563    F959  20 72 F9       JSR TIM_Update_T1_F
11564    
11565    F95C  60             RTS
11566      
11567    
11568    TEST_IRQ
11569    
11570    F95D  18             CLC
11571    F95E  AD 50 0A       LDA CTR_V
11572    F961  69 01          ADC #1
11573    F963  8D 50 0A       STA CTR_V
11574    F966  AD 51 0A       LDA CTR_V + 1
11575    F969  69 00          ADC #0
11576    F96B  8D 51 0A       STA CTR_V + 1
11577      
11578    F96E  AD 44 C0       LDA TIM_T1L
11579    
11580    F971  60             RTS
11581      
11582      
11583    TIM_Update_T1_F
11584    
11585    F972  08             PHP					; Save IRQ state and disable interrupts
11586    F973  78             SEI
11587      
11588    F974  AD 52 0A       LDA CTR_LOAD_VAL_V			; Load timer
11589    F977  8D 44 C0       STA TIM_T1L
11590    F97A  AD 53 0A       LDA CTR_LOAD_VAL_V + 1
11591    F97D  8D 45 C0       STA TIM_T1H				; Count commences from here (if running)
11592      
11593    F980  28             PLP					; Restore IRQ status
11594      
11595    F981  60             RTS
11596      RTS
11597    
11598    
11599    ; reset vector points here
11600    
11601    RES_vec
11602    F982  78             SEI					; Ensure IRQ's are turned off.
11603    F983  D8             CLD					; clear decimal mode
11604    F984  A2 FF          LDX #$FF				; empty stack
11605    F986  9A             TXS					; set the stack
11606    
11607    F987  20 DB FF       JSR IRQH_Handler_Init_vec		; Initialise the IRQ Handler
11608    
11609    ; test code
11610    F98A  A9 5D          LDA #<TEST_IRQ			; Put the test IRQ address into the table at IRQ Location 0
11611    F98C  8D 30 0A       STA IRQH_CallReg
11612    F98F  A9 F9          LDA #>TEST_IRQ
11613    F991  8D 31 0A       STA IRQH_CallReg + 1
11614    F994  A9 00          LDA #0
11615    F996  20 DE FF       JSR IRQH_SetIRQ_vec
11616      
11617    F999  A9 01          LDA #1				; Enable IRQ 0
11618    F99B  0D 33 0A       ORA IRQH_MaskByte
11619    F99E  8D 33 0A       STA IRQH_MaskByte
11620      
11621    F9A1  20 3D F9       JSR INIT_TEST_IRQ
11622       
11623    F9A4  58             CLI					; Enable IRQs globally.
11624    
11625    ; end of test code
11626    
11627    F9A5  20 A5 F3       JSR TPB_delay
11628      
11629    F9A8  A9 02          LDA #ANSI_out_sw                    ; Set our default output options for ANSI output mode.
11630    ;  LDA #ACIA_out_sw                   ; Set our default output options for ACIA output mode.
11631    F9AA  8D E0 05       STA os_outsel                       ; to the ANSI card only.
11632    F9AD  A9 01          LDA #LF_filt_sw1
11633    F9AF  8D E1 05       STA os_infilt                       ; Switch on $A filtering on the ACIA.
11634      
11635    F9B2  20 00 F0       JSR INI_ACIA1                       ; Init ACIA1. We currently need this for the keyboard.
11636    F9B5  20 0E F0       JSR INI_ACIA2                       ; Init ACIA2. Just in case.
11637    F9B8  20 90 FF       JSR ANSI_init_vec                   ; Initialise the ANSI text video card.
11638    F9BB  20 96 FF       JSR TPB_init_vec                    ; Init Tower Peripheral Bus
11639    F9BE  20 38 F8       JSR AY_Init                         ; Initialise the AY sound system.
11640      
11641    ; set up vectors and interrupt code, copy them to page 2
11642    
11643    F9C1  A0 5F          LDY #END_CODE-LAB_vec               ; set index/count
11644    LAB_stlp
11645    F9C3  B9 F0 F9       LDA LAB_vec-1,Y                     ; get byte from interrupt code
11646    F9C6  99 04 02       STA VEC_IN-1,Y                      ; save to RAM
11647    F9C9  88             DEY                                 ; decrement index/count
11648    F9CA  D0 F7          BNE LAB_stlp                        ; loop if more to do
11649    
11650      
11651    ; Initialise filing system
11652    
11653    F9CC  20 C9 FF       JSR TAPE_init_vec                   ; Initialise TowerTAPE filing system.
11654        
11655    ; now do the signon message
11656    
11657    F9CF  A0 00          LDY #0
11658    LAB_signon
11659    
11660    F9D1  B9 50 FA       LDA LAB_mess,Y                      ; get byte from sign on message
11661    F9D4  F0 06          BEQ LAB_nokey                       ; exit loop if done
11662    
11663    F9D6  20 02 E2       JSR V_OUTP                          ; output character
11664    F9D9  C8             INY                                 ; increment index
11665    F9DA  D0 F5          BNE LAB_signon                      ; loop, branch always
11666    
11667    LAB_nokey
11668    F9DC  20 FF E1       JSR V_INPT                          ; call scan input device
11669    F9DF  90 FB          BCC LAB_nokey                       ; loop if no key
11670    
11671    F9E1  29 DF          AND #$DF                            ; mask xx0x xxxx, ensure upper case
11672    F9E3  C9 57          CMP #'W'                            ; compare with [W]arm start
11673    F9E5  F0 07          BEQ LAB_dowarm                      ; branch if [W]arm start
11674    
11675    F9E7  C9 43          CMP #'C'                            ; compare with [C]old start.
11676    F9E9  D0 E6          BNE LAB_signon                      ; loop if not [C]old start
11677    
11678    F9EB  4C 00 C1       JMP LAB_COLD                        ; do EhBASIC cold start
11679    
11680    LAB_dowarm
11681    F9EE  4C 00 00       JMP LAB_WARM                        ; do EhBASIC warm start
11682    
11683    
11684    ; EhBASIC vector tables
11685    
11686    LAB_vec
11687      .word ACIA1in                       ; byte in from ACIA1
11688      .word WR_char                       ; byte out to ACIA1
11689      .word TAPE_LOAD_BASIC_vec           ; null load vector for EhBASIC
11690      .word TAPE_SAVE_BASIC_vec           ; save vector for EhBASIC
11691    
11692    ; EhBASIC IRQ support
11693    
11694    IRQ_CODE
11695    F9F9  48             PHA                                 ; save A
11696    F9FA  A5 DF          LDA IrqBase                         ; get the IRQ flag byte
11697    F9FC  4A             LSR                                 ; shift the set b7 to b6, and on down ...
11698    F9FD  05 DF          ORA IrqBase                         ; OR the original back in
11699    F9FF  85 DF          STA IrqBase                         ; save the new IRQ flag byte
11700    FA01  68             PLA                                 ; restore A
11701    FA02  40             RTI
11702    
11703    
11704    ; EhBASIC NMI support
11705    
11706    NMI_CODE
11707    FA03  48             PHA                                 ; save A
11708    FA04  A5 DC          LDA NmiBase                         ; get the NMI flag byte
11709    FA06  4A             LSR                                 ; shift the set b7 to b6, and on down ...
11710    FA07  05 DC          ORA NmiBase                         ; OR the original back in
11711    FA09  85 DC          STA NmiBase                         ; save the new NMI flag byte
11712    FA0B  68             PLA                                 ; restore A
11713    FA0C  40             RTI
11714    
11715    
11716    ; OS output stream management support.
11717    
11718    WR_char
11719    FA0D  08             PHP                                 ; Save our registers in case we need 'em
11720    FA0E  48             PHA
11721       
11722    FA0F  A9 01          LDA #ACIA1_out_sw
11723    FA11  2C E0 05       BIT os_outsel
11724    FA14  F0 05          BEQ no_ACIA1
11725    FA16  68             PLA
11726    FA17  20 1C F0       JSR ACIA1out                         ; Print to ACIA1
11727    
11728    FA1A  48             PHA
11729    no_ACIA1  
11730    FA1B  A9 08          LDA #ACIA2_out_sw
11731    FA1D  2C E0 05       BIT os_outsel
11732    FA20  F0 05          BEQ no_ACIA2
11733    FA22  68             PLA
11734    FA23  20 2B F0       JSR ACIA2out                         ; Print to ACIA1
11735      
11736    FA26  48             PHA
11737    no_ACIA2
11738    FA27  A9 02          LDA #ANSI_out_sw
11739    FA29  2C E0 05       BIT os_outsel
11740    FA2C  F0 05          BEQ no_ANSI
11741    FA2E  68             PLA
11742    FA2F  20 93 FF       JSR ANSI_write_vec                  ; Print to ANSI video card
11743        
11744    FA32  48             PHA
11745    no_ANSI
11746    FA33  A9 04          LDA #TPB_out_sw
11747    FA35  2C E0 05       BIT os_outsel
11748    FA38  F0 06          BEQ no_TPB_LPT
11749    FA3A  68             PLA
11750    FA3B  20 99 FF       JSR TPB_LPT_write_vec               ; Print to TPB LPT card
11751      
11752    FA3E  28             PLP
11753    FA3F  60             RTS
11754      
11755    no_TPB_LPT
11756    FA40  68             PLA
11757    FA41  28             PLP
11758    FA42  60             RTS
11759      
11760      
11761    ; Tower string printing routine.
11762    TOE_PrintStr
11763    FA43  A0 00          LDY #0					; Initialise loop index.
11764    TOE_PrintStr_L
11765    FA45  B1 E7          LDA (TOE_MemptrLo),Y				; Print character.
11766    FA47  F0 06          BEQ TOE_DonePrinting
11767    FA49  20 02 E2       JSR V_OUTP
11768    FA4C  C8             INY
11769    FA4D  80 F6          BRA TOE_PrintStr_L
11770    
11771    TOE_DonePrinting
11772    FA4F  60             RTS
11773      
11774    END_CODE
11775    
11776    LAB_mess
11777                                          ; sign on string
11778    
11779      .byte "Tower of Eightness OS 21.8.2021.1",$0D,$0A,$0D,$0A
11780      .byte $0D,$0A,"6502 EhBASIC [C]old/[W]arm ?",$00
11781    
11782    
11783    ; ToE OS Vectors
11784    
11785    FF90                 *= $FF90
11786      
11787    ; ANSI Card vectors
11788    
11789    ANSI_init_vec
11790    FF90  4C 6F F0       JMP ANSI_INIT            ; FF90
11791    ANSI_write_vec
11792    FF93  4C 91 F0       JMP ANSI_write           ; FF93
11793      
11794    
11795    ; Tower Peripheral Bus vectors
11796    
11797    TPB_init_vec
11798    FF96  4C B5 F0       JMP TPB_INIT             ; FF96
11799    TPB_LPT_write_vec
11800    FF99  4C 77 F3       JMP TPB_LPT_write        ; FF99
11801    TPB_tx_byte_vec
11802    FF9C  4C 3F F2       JMP TPB_tx_byte          ; FF9C
11803    TPB_tx_block_vec
11804    FF9F  4C DA F2       JMP TPB_tx_block         ; FF9F
11805    TPB_ATN_handler_vec
11806    FFA2  4C 09 F2       JMP TPB_ATN_handler      ; FFA2
11807    TPB_rx_byte_vec  
11808    FFA5  4C 84 F2       JMP TPB_rx_byte          ; FFA5
11809    TPB_rx_block_vec
11810    FFA8  4C 1E F3       JMP TPB_rx_block         ; FFA8
11811    TPB_Dev_Presence_vec
11812    FFAB  4C C5 F1       JMP TPB_Dev_Presence     ; FFAB
11813    TPB_Req_Dev_Type_vec
11814    FFAE  4C 46 F1       JMP TPB_Req_Dev_Type     ; FFAE
11815    TPB_dev_select_vec
11816    FFB1  4C 5D F3       JMP TPB_dev_select       ; FFB1
11817    TPB_Ctrl_Blk_Wr_vec
11818    FFB4  4C D9 F0       JMP TPB_Ctrl_Blk_Wr      ; FFB4
11819    TPB_Ctrl_Blk_Rd_vec
11820    FFB7  4C 0F F1       JMP TPB_Ctrl_Blk_Rd      ; FFB7
11821    
11822    
11823    ; TAPE subsystem vectors
11824    
11825    TAPE_Leader_vec
11826    FFBA  4C CA F6       JMP F_TAPE_Leader        ; FFBA
11827    TAPE_BlockOut_vec
11828    FFBD  4C 99 F6       JMP F_TAPE_BlockOut      ; FFBD
11829    TAPE_ByteOut_vec
11830    FFC0  4C 64 F6       JMP F_TAPE_ByteOut       ; FFC0
11831    TAPE_BlockIn_vec
11832    FFC3  4C 78 F7       JMP F_TAPE_BlockIn       ; FFC3
11833    TAPE_ByteIn_vec
11834    FFC6  4C D8 F7       JMP F_TAPE_GetByte       ; FFC6
11835    TAPE_init_vec
11836    FFC9  4C 51 F4       JMP F_TAPE_Init          ; FFC9
11837    TAPE_SAVE_BASIC_vec  
11838    FFCC  4C 66 F4       JMP F_TAPE_SAVE_BASIC    ; FFCC
11839    TAPE_LOAD_BASIC_vec  
11840    FFCF  4C F7 F4       JMP F_TAPE_LOAD_BASIC    ; FFCF
11841    
11842    
11843    ; Stream output vector.  
11844    
11845    TOE_PrintStr_vec
11846    FFD2  4C 43 FA       JMP TOE_PrintStr         ; FFD2
11847    
11848    
11849    ; AY Soundcard vectors.
11850      
11851    AY_Userwrite_vec           ; FFD5
11852    FFD5  4C 92 F8       JMP AY_Userwrite
11853    AY_Userread_vec            ; FFD8
11854    FFD8  4C 9C F8       JMP AY_Userread
11855    
11856    
11857    ; IRQ Handler Subsystem vectors
11858      
11859    IRQH_Handler_Init_vec	   ; FFDB
11860    FFDB  4C A9 F8       JMP IRQH_Handler_Init_F
11861    IRQH_SetIRQ_vec		   ; FFDE
11862    FFDE  4C DC F8       JMP IRQH_SetIRQ_F
11863    IRQH_ClrIRQ_vec		   ; FFE1
11864    FFE1  4C EF F8       JMP IRQH_ClrIRQ_F
11865    IRQH_SystemReport_vec	   ; FFE4
11866    FFE4  4C 36 F9       JMP IRQH_SystemReport_F
11867    
11868    
11869    ; processor hardware vectors.  These are fixed in hardware and cannot be moved.
11870    
11871    FFFA                 *= $FFFA
11872    
11873      .word NMI_vec                ; NMI vector
11874      .word RES_vec                ; RESET vector
11875      .word IRQ_vec                ; IRQ vector
11876    
11877    
11878    
