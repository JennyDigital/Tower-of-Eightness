00001    ; Tower of Eightness OS
00002    
00003    
00004      .include "basic_ToE.asm"
00005    
00006    ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22p5
00007    
00008    ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
00009    
00010    ; 2.00      new revision numbers start here
00011    ; 2.01      fixed LCASE$() and UCASE$()
00012    ; 2.02      new get value routine done
00013    ; 2.03      changed RND() to galoise method
00014    ; 2.04      fixed SPC()
00015    ; 2.05      new get value routine fixed
00016    ; 2.06      changed USR() code
00017    ; 2.07      fixed STR$()
00018    ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
00019    ; 2.09      fixed RND()
00020    ; 2.10      integrated missed changes from an earlier version
00021    ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
00022    ; 2.21      fixed IF .. THEN RETURN to not cause error
00023    ; 2.22      fixed RND() breaking the get byte routine
00024    ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
00025    ;              (bugsnquirks.txt notes 2, 4 and 5)
00026    ;              tabs converted to spaces, tabwidth=6
00027    ; 2.22p2    fixed can't continue error on 1st statement after direct mode
00028    ;              changed INPUT to throw "break in line ##" on empty line input
00029    ; 2.22p3    fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
00030    ;              fix provided by github user mgcaret
00031    ; 2.22p4    fixed string compare of equal strings in direct mode returns FALSE
00032    ;              fixed FALSE stored to a variable after a string compare 
00033    ;                 is > 0 and < 1E-16
00034    ;              added additional stack floor protection for background interrupts
00035    ;              fixed conditional LOOP & NEXT cannot find their data strucure on stack
00036    ; 2.22p5    fixes issues reported by users Ruud and dclxvi on the 6502.org forum
00037    ;      5.0     http://forum.6502.org/viewtopic.php?f=5&t=5500
00038    ;              sanity check for RAM top allows values below RAM base
00039    ;      5.1-7   http://forum.6502.org/viewtopic.php?f=5&t=5606
00040    ;              1-7 coresponds to the bug# in the thread
00041    ;      5.1     TO expression with a subtract may evaluate with the sign bit flipped
00042    ;      5.3     call to LAB_1B5B may return to an address -$100 (page not incremented)
00043    ;      5.4     string concatenate followed by MINUS or NOT() crashes EhBASIC
00044    ;      5.5     garbage collection may cause an overlap with temporary strings
00045    ;      5.6     floating point multiply rounding bug
00046    ;      5.7     VAL() may cause string variables to be trashed
00047    
00048    ; zero page use ..
00049    
00050    ; the following locations are bulk initialized from StrTab at LAB_GMEM
00051      0000             LAB_WARM          = $00       ; BASIC warm start entry point
00052      0001             Wrmjpl            = LAB_WARM+1; BASIC warm start vector jump low byte
00053      0002             Wrmjph            = LAB_WARM+2; BASIC warm start vector jump high byte
00054    
00055      000A             Usrjmp            = $0A       ; USR function JMP address
00056      000B             Usrjpl            = Usrjmp+1  ; USR function JMP vector low byte
00057      000C             Usrjph            = Usrjmp+2  ; USR function JMP vector high byte
00058      000D             Nullct            = $0D       ; nulls output after each line
00059      000E             TPos              = $0E       ; BASIC terminal position byte
00060      000F             TWidth            = $0F       ; BASIC terminal width byte
00061      0010             Iclim             = $10       ; input column limit
00062      0011             Itempl            = $11       ; temporary integer low byte
00063      0012             Itemph            = Itempl+1  ; temporary integer high byte
00064    ; end bulk initialize from StrTab at LAB_GMEM
00065    
00066      0011             nums_1            = Itempl    ; number to bin/hex string convert MSB
00067      0012             nums_2            = nums_1+1  ; number to bin/hex string convert
00068      0013             nums_3            = nums_1+2  ; number to bin/hex string convert LSB
00069    
00070      005B             Srchc             = $5B       ; search character
00071      005B             Temp3             = Srchc     ; temp byte used in number routines
00072      005C             Scnquo            = $5C       ; scan-between-quotes flag
00073      005C             Asrch             = Scnquo    ; alt search character
00074    
00075      005B             XOAw_l            = Srchc     ; eXclusive OR, OR and AND word low byte
00076      005C             XOAw_h            = Scnquo    ; eXclusive OR, OR and AND word high byte
00077    
00078      005D             Ibptr             = $5D       ; input buffer pointer
00079      005D             Dimcnt            = Ibptr     ; # of dimensions
00080      005D             Tindx             = Ibptr     ; token index
00081    
00082      005E             Defdim            = $5E       ; default DIM flag
00083      005F             Dtypef            = $5F       ; data type flag, $FF=string, $00=numeric
00084      0060             Oquote            = $60       ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
00085      0060             Gclctd            = $60       ; garbage collected flag
00086      0061             Sufnxf            = $61       ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
00087      0062             Imode             = $62       ; input mode flag, $00=INPUT, $80=READ
00088    
00089      0063             Cflag             = $63       ; comparison evaluation flag
00090    
00091      0064             TabSiz            = $64       ; TAB step size (was input flag)
00092    
00093      0065             next_s            = $65       ; next descriptor stack address
00094    
00095                                  ; these two bytes form a word pointer to the item
00096                                  ; currently on top of the descriptor stack
00097      0066             last_sl           = $66       ; last descriptor stack address low byte
00098      0067             last_sh           = $67       ; last descriptor stack address high byte (always $00)
00099    
00100      0068             des_sk            = $68       ; descriptor stack start address (temp strings)
00101    
00102    ;                 = $70       ; End of descriptor stack
00103    
00104      0071             ut1_pl            = $71       ; utility pointer 1 low byte
00105      0072             ut1_ph            = ut1_pl+1  ; utility pointer 1 high byte
00106      0073             ut2_pl            = $73       ; utility pointer 2 low byte
00107      0074             ut2_ph            = ut2_pl+1  ; utility pointer 2 high byte
00108    
00109      0071             Temp_2            = ut1_pl    ; temp byte for block move    
00110    
00111      0075             FACt_1            = $75       ; FAC temp mantissa1
00112      0076             FACt_2            = FACt_1+1  ; FAC temp mantissa2
00113      0077             FACt_3            = FACt_2+1  ; FAC temp mantissa3
00114    
00115      0076             dims_l            = FACt_2    ; array dimension size low byte
00116      0077             dims_h            = FACt_3    ; array dimension size high byte
00117    
00118      0078             TempB             = $78       ; temp page 0 byte
00119    
00120      0079             Smeml             = $79       ; start of mem low byte       (Start-of-Basic)
00121      007A             Smemh             = Smeml+1   ; start of mem high byte      (Start-of-Basic)
00122      007B             Svarl             = $7B       ; start of vars low byte      (Start-of-Variables)
00123      007C             Svarh             = Svarl+1   ; start of vars high byte     (Start-of-Variables)
00124      007D             Sarryl            = $7D       ; var mem end low byte        (Start-of-Arrays)
00125      007E             Sarryh            = Sarryl+1  ; var mem end high byte       (Start-of-Arrays)
00126      007F             Earryl            = $7F       ; array mem end low byte      (End-of-Arrays)
00127      0080             Earryh            = Earryl+1  ; array mem end high byte     (End-of-Arrays)
00128      0081             Sstorl            = $81       ; string storage low byte     (String storage (moving down))
00129      0082             Sstorh            = Sstorl+1  ; string storage high byte    (String storage (moving down))
00130      0083             Sutill            = $83       ; string utility ptr low byte
00131      0084             Sutilh            = Sutill+1  ; string utility ptr high byte
00132      0085             Ememl             = $85       ; end of mem low byte         (Limit-of-memory)
00133      0086             Ememh             = Ememl+1   ; end of mem high byte        (Limit-of-memory)
00134      0087             Clinel            = $87       ; current line low byte       (Basic line number)
00135      0088             Clineh            = Clinel+1  ; current line high byte      (Basic line number)
00136      0089             Blinel            = $89       ; break line low byte         (Previous Basic line number)
00137      008A             Blineh            = Blinel+1  ; break line high byte        (Previous Basic line number)
00138    
00139      008B             Cpntrl            = $8B       ; continue pointer low byte
00140      008C             Cpntrh            = Cpntrl+1  ; continue pointer high byte
00141    
00142      008D             Dlinel            = $8D       ; current DATA line low byte
00143      008E             Dlineh            = Dlinel+1  ; current DATA line high byte
00144    
00145      008F             Dptrl             = $8F       ; DATA pointer low byte
00146      0090             Dptrh             = Dptrl+1   ; DATA pointer high byte
00147    
00148      0091             Rdptrl            = $91       ; read pointer low byte
00149      0092             Rdptrh            = Rdptrl+1  ; read pointer high byte
00150    
00151      0093             Varnm1            = $93       ; current var name 1st byte
00152      0094             Varnm2            = Varnm1+1  ; current var name 2nd byte
00153    
00154      0095             Cvaral            = $95       ; current var address low byte
00155      0096             Cvarah            = Cvaral+1  ; current var address high byte
00156    
00157      0097             Frnxtl            = $97       ; var pointer for FOR/NEXT low byte
00158      0098             Frnxth            = Frnxtl+1  ; var pointer for FOR/NEXT high byte
00159    
00160      0097             Tidx1             = Frnxtl    ; temp line index
00161    
00162      0097             Lvarpl            = Frnxtl    ; let var pointer low byte
00163      0098             Lvarph            = Frnxth    ; let var pointer high byte
00164    
00165      0099             prstk             = $99       ; precedence stacked flag
00166    
00167      009B             comp_f            = $9B       ; compare function flag, bits 0,1 and 2 used
00168                                  ; bit 2 set if >
00169                                  ; bit 1 set if =
00170                                  ; bit 0 set if <
00171    
00172      009C             func_l            = $9C       ; function pointer low byte
00173      009D             func_h            = func_l+1  ; function pointer high byte
00174    
00175      009C             garb_l            = func_l    ; garbage collection working pointer low byte
00176      009D             garb_h            = func_h    ; garbage collection working pointer high byte
00177    
00178      009E             des_2l            = $9E       ; string descriptor_2 pointer low byte
00179      009F             des_2h            = des_2l+1  ; string descriptor_2 pointer high byte
00180    
00181      00A0             g_step            = $A0       ; garbage collect step size
00182    
00183      00A1             Fnxjmp            = $A1       ; jump vector for functions
00184      00A2             Fnxjpl            = Fnxjmp+1  ; functions jump vector low byte
00185      00A3             Fnxjph            = Fnxjmp+2  ; functions jump vector high byte
00186    
00187      00A2             g_indx            = Fnxjpl    ; garbage collect temp index
00188    
00189      00A3             FAC2_r            = $A3       ; FAC2 rounding byte
00190    
00191      00A4             Adatal            = $A4       ; array data pointer low byte
00192      00A5             Adatah            = Adatal+1  ; array data pointer high  byte
00193    
00194      00A4             Nbendl            = Adatal    ; new block end pointer low byte
00195      00A5             Nbendh            = Adatah    ; new block end pointer high  byte
00196    
00197      00A6             Obendl            = $A6       ; old block end pointer low byte
00198      00A7             Obendh            = Obendl+1  ; old block end pointer high  byte
00199    
00200      00A8             numexp            = $A8       ; string to float number exponent count
00201      00A9             expcnt            = $A9       ; string to float exponent count
00202    
00203      00A8             numbit            = numexp    ; bit count for array element calculations
00204    
00205      00AA             numdpf            = $AA       ; string to float decimal point flag
00206      00AB             expneg            = $AB       ; string to float eval exponent -ve flag
00207    
00208      00AA             Astrtl            = numdpf    ; array start pointer low byte
00209      00AB             Astrth            = expneg    ; array start pointer high  byte
00210    
00211      00AA             Histrl            = numdpf    ; highest string low byte
00212      00AB             Histrh            = expneg    ; highest string high  byte
00213    
00214      00AA             Baslnl            = numdpf    ; BASIC search line pointer low byte
00215      00AB             Baslnh            = expneg    ; BASIC search line pointer high  byte
00216    
00217      00AA             Fvar_l            = numdpf    ; find/found variable pointer low byte
00218      00AB             Fvar_h            = expneg    ; find/found variable pointer high  byte
00219    
00220      00AA             Ostrtl            = numdpf    ; old block start pointer low byte
00221      00AB             Ostrth            = expneg    ; old block start pointer high  byte
00222    
00223      00AA             Vrschl            = numdpf    ; variable search pointer low byte
00224      00AB             Vrschh            = expneg    ; variable search pointer high  byte
00225    
00226      00AC             FAC1_e            = $AC       ; FAC1 exponent
00227      00AD             FAC1_1            = FAC1_e+1  ; FAC1 mantissa1
00228      00AE             FAC1_2            = FAC1_e+2  ; FAC1 mantissa2
00229      00AF             FAC1_3            = FAC1_e+3  ; FAC1 mantissa3
00230      00B0             FAC1_s            = FAC1_e+4  ; FAC1 sign (b7)
00231    
00232      00AC             str_ln            = FAC1_e    ; string length
00233      00AD             str_pl            = FAC1_1    ; string pointer low byte
00234      00AE             str_ph            = FAC1_2    ; string pointer high byte
00235    
00236      00AE             des_pl            = FAC1_2    ; string descriptor pointer low byte
00237      00AF             des_ph            = FAC1_3    ; string descriptor pointer high byte
00238    
00239      00AF             mids_l            = FAC1_3    ; MID$ string temp length byte
00240    
00241      00B1             negnum            = $B1       ; string to float eval -ve flag
00242      00B1             numcon            = $B1       ; series evaluation constant count
00243    
00244      00B2             FAC1_o            = $B2       ; FAC1 overflow byte
00245    
00246      00B3             FAC2_e            = $B3       ; FAC2 exponent
00247      00B4             FAC2_1            = FAC2_e+1  ; FAC2 mantissa1
00248      00B5             FAC2_2            = FAC2_e+2  ; FAC2 mantissa2
00249      00B6             FAC2_3            = FAC2_e+3  ; FAC2 mantissa3
00250      00B7             FAC2_s            = FAC2_e+4  ; FAC2 sign (b7)
00251    
00252      00B8             FAC_sc            = $B8       ; FAC sign comparison, Acc#1 vs #2
00253      00B9             FAC1_r            = $B9       ; FAC1 rounding byte
00254    
00255      00B8             ssptr_l           = FAC_sc    ; string start pointer low byte
00256      00B9             ssptr_h           = FAC1_r    ; string start pointer high byte
00257    
00258      00B8             sdescr            = FAC_sc    ; string descriptor pointer
00259    
00260      00BA             csidx             = $BA       ; line crunch save index
00261      00BA             Asptl             = csidx     ; array size/pointer low byte
00262      00BB             Aspth             = $BB       ; array size/pointer high byte
00263    
00264      00BA             Btmpl             = Asptl     ; BASIC pointer temp low byte
00265      00BB             Btmph             = Aspth     ; BASIC pointer temp low byte
00266    
00267      00BA             Cptrl             = Asptl     ; BASIC pointer temp low byte
00268      00BB             Cptrh             = Aspth     ; BASIC pointer temp low byte
00269    
00270      00BA             Sendl             = Asptl     ; BASIC pointer temp low byte
00271      00BB             Sendh             = Aspth     ; BASIC pointer temp low byte
00272    
00273    ; the following locations are bulk initialized from LAB_2CEE at LAB_2D4E
00274      00BC             LAB_IGBY          = $BC       ; get next BASIC byte subroutine
00275    
00276      00C2             LAB_GBYT          = $C2       ; get current BASIC byte subroutine
00277      00C3             Bpntrl            = $C3       ; BASIC execute (get byte) pointer low byte
00278      00C4             Bpntrh            = Bpntrl+1  ; BASIC execute (get byte) pointer high byte
00279    
00280    ;                 = $D7       ; end of get BASIC char subroutine
00281    ; end bulk initialize from LAB_2CEE at LAB_2D4E
00282    
00283      00D8             Rbyte4            = $D8       ; extra PRNG byte
00284      00D9             Rbyte1            = Rbyte4+1  ; most significant PRNG byte
00285      00DA             Rbyte2            = Rbyte4+2  ; middle PRNG byte
00286      00DB             Rbyte3            = Rbyte4+3  ; least significant PRNG byte
00287    
00288      00DC             NmiBase           = $DC       ; NMI handler enabled/setup/triggered flags
00289                                  ; bit function
00290                                  ; === ========
00291                                  ; 7   interrupt enabled
00292                                  ; 6   interrupt setup
00293                                  ; 5   interrupt happened
00294    ;                 = $DD       ; NMI handler addr low byte
00295    ;                 = $DE       ; NMI handler addr high byte
00296      00DF             IrqBase           = $DF       ; IRQ handler enabled/setup/triggered flags
00297    ;                 = $E0       ; IRQ handler addr low byte
00298    ;                 = $E1       ; IRQ handler addr high byte
00299    
00300    ; *** removed unused comments for $DE-$E1
00301    
00302    ;                 = $E2       ; TPB card temporary location
00303    ;                 = $E3       ; TPB card temporary location
00304    ;                 = $E4       ; TAPE tempoaray location.
00305    ;                 = $E5       ; TAPE BlockLo
00306    ;                 = $E6       ; TAPE blockHi
00307    ;                 = $E7       ; TOE_MemptrLo low byte general purpose pointer
00308    ;                 = $E8       ; TOE_MemptrHi high byte general purpose pointer.
00309    ;                 = $E9       ; unused
00310    ;                 = $EA       ; unused
00311    ;                 = $EB       ; unused
00312    ;                 = $EC       ; unused
00313    ;                 = $ED       ; unused
00314    ;                 = $EE       ; unused
00315    
00316      00EF             Decss             = $EF       ; number to decimal string start
00317      00F0             Decssp1           = Decss+1   ; number to decimal string start
00318    
00319    ;                 = $FF       ; decimal string end
00320    
00321    ; token values needed for BASIC
00322    
00323    ; primary command tokens (can start a statement)
00324    
00325      0080             TK_END            = $80             ; END token
00326      0081             TK_FOR            = TK_END+1        ; FOR token
00327      0082             TK_NEXT           = TK_FOR+1        ; NEXT token
00328      0083             TK_DATA           = TK_NEXT+1       ; DATA token
00329      0084             TK_INPUT          = TK_DATA+1       ; INPUT token
00330      0085             TK_DIM            = TK_INPUT+1      ; DIM token
00331      0086             TK_READ           = TK_DIM+1        ; READ token
00332      0087             TK_LET            = TK_READ+1       ; LET token
00333      0088             TK_DEC            = TK_LET+1        ; DEC token
00334      0089             TK_GOTO           = TK_DEC+1        ; GOTO token
00335      008A             TK_RUN            = TK_GOTO+1       ; RUN token
00336      008B             TK_IF             = TK_RUN+1        ; IF token
00337      008C             TK_RESTORE        = TK_IF+1         ; RESTORE token
00338      008D             TK_GOSUB          = TK_RESTORE+1    ; GOSUB token
00339      008E             TK_RETIRQ         = TK_GOSUB+1      ; RETIRQ token
00340      008F             TK_RETNMI         = TK_RETIRQ+1     ; RETNMI token
00341      0090             TK_RETURN         = TK_RETNMI+1     ; RETURN token
00342      0091             TK_REM            = TK_RETURN+1     ; REM token
00343      0092             TK_STOP           = TK_REM+1        ; STOP token
00344      0093             TK_ON             = TK_STOP+1       ; ON token
00345      0094             TK_NULL           = TK_ON+1         ; NULL token
00346      0095             TK_INC            = TK_NULL+1       ; INC token
00347      0096             TK_WAIT           = TK_INC+1        ; WAIT token
00348      0097             TK_LOAD           = TK_WAIT+1       ; LOAD token
00349      0098             TK_SAVE           = TK_LOAD+1       ; SAVE token
00350      0099             TK_DEF            = TK_SAVE+1       ; DEF token
00351      009A             TK_POKE           = TK_DEF+1        ; POKE token
00352      009B             TK_DOKE           = TK_POKE+1       ; DOKE token
00353      009C             TK_CALL           = TK_DOKE+1       ; CALL token
00354      009D             TK_DO             = TK_CALL+1       ; DO token
00355      009E             TK_LOOP           = TK_DO+1         ; LOOP token
00356      009F             TK_PRINT          = TK_LOOP+1       ; PRINT token
00357      00A0             TK_CONT           = TK_PRINT+1      ; CONT token
00358      00A1             TK_LIST           = TK_CONT+1       ; LIST token
00359      00A2             TK_CLEAR          = TK_LIST+1       ; CLEAR token
00360      00A3             TK_NEW            = TK_CLEAR+1      ; NEW token
00361      00A4             TK_WIDTH          = TK_NEW+1        ; WIDTH token
00362      00A5             TK_GET            = TK_WIDTH+1      ; GET token
00363      00A6             TK_SWAP           = TK_GET+1        ; SWAP token
00364      00A7             TK_BITSET         = TK_SWAP+1       ; BITSET token
00365      00A8             TK_BITCLR         = TK_BITSET+1     ; BITCLR token
00366      00A9             TK_IRQ            = TK_BITCLR+1     ; IRQ token
00367      00AA             TK_NMI            = TK_IRQ+1        ; NMI token
00368      00AB             TK_VERIFY         = TK_NMI+1        ; VERIFY token
00369    
00370    
00371    ; secondary command tokens, can't start a statement
00372    
00373      00AC             TK_TAB            = TK_VERIFY+1     ; TAB token
00374      00AD             TK_ELSE           = TK_TAB+1        ; ELSE token
00375      00AE             TK_TO             = TK_ELSE+1       ; TO token
00376      00AF             TK_FN             = TK_TO+1         ; FN token
00377      00B0             TK_SPC            = TK_FN+1         ; SPC token
00378      00B1             TK_THEN           = TK_SPC+1        ; THEN token
00379      00B2             TK_NOT            = TK_THEN+1       ; NOT token
00380      00B3             TK_STEP           = TK_NOT+1        ; STEP token
00381      00B4             TK_UNTIL          = TK_STEP+1       ; UNTIL token
00382      00B5             TK_WHILE          = TK_UNTIL+1      ; WHILE token
00383      00B6             TK_OFF            = TK_WHILE+1      ; OFF token
00384    
00385    ; opperator tokens
00386    
00387      00B7             TK_PLUS           = TK_OFF+1        ; + token
00388      00B8             TK_MINUS          = TK_PLUS+1       ; - token
00389      00B9             TK_MUL            = TK_MINUS+1      ; * token
00390      00BA             TK_DIV            = TK_MUL+1        ; / token
00391      00BB             TK_POWER          = TK_DIV+1        ; ^ token
00392      00BC             TK_AND            = TK_POWER+1      ; AND token
00393      00BD             TK_EOR            = TK_AND+1        ; EOR token
00394      00BE             TK_OR             = TK_EOR+1        ; OR token
00395      00BF             TK_RSHIFT         = TK_OR+1         ; RSHIFT token
00396      00C0             TK_LSHIFT         = TK_RSHIFT+1     ; LSHIFT token
00397      00C1             TK_GT             = TK_LSHIFT+1     ; > token
00398      00C2             TK_EQUAL          = TK_GT+1         ; = token
00399      00C3             TK_LT             = TK_EQUAL+1      ; < token
00400    
00401    ; functions tokens
00402    
00403      00C4             TK_SGN            = TK_LT+1         ; SGN token
00404      00C5             TK_INT            = TK_SGN+1        ; INT token
00405      00C6             TK_ABS            = TK_INT+1        ; ABS token
00406      00C7             TK_USR            = TK_ABS+1        ; USR token
00407      00C8             TK_FRE            = TK_USR+1        ; FRE token
00408      00C9             TK_POS            = TK_FRE+1        ; POS token
00409      00CA             TK_SQR            = TK_POS+1        ; SQR token
00410      00CB             TK_RND            = TK_SQR+1        ; RND token
00411      00CC             TK_LOG            = TK_RND+1        ; LOG token
00412      00CD             TK_EXP            = TK_LOG+1        ; EXP token
00413      00CE             TK_COS            = TK_EXP+1        ; COS token
00414      00CF             TK_SIN            = TK_COS+1        ; SIN token
00415      00D0             TK_TAN            = TK_SIN+1        ; TAN token
00416      00D1             TK_ATN            = TK_TAN+1        ; ATN token
00417      00D2             TK_PEEK           = TK_ATN+1        ; PEEK token
00418      00D3             TK_DEEK           = TK_PEEK+1       ; DEEK token
00419      00D4             TK_SADD           = TK_DEEK+1       ; SADD token
00420      00D5             TK_LEN            = TK_SADD+1       ; LEN token
00421      00D6             TK_STRS           = TK_LEN+1        ; STR$ token
00422      00D7             TK_VAL            = TK_STRS+1       ; VAL token
00423      00D8             TK_ASC            = TK_VAL+1        ; ASC token
00424      00D9             TK_UCASES         = TK_ASC+1        ; UCASE$ token
00425      00DA             TK_LCASES         = TK_UCASES+1     ; LCASE$ token
00426      00DB             TK_CHRS           = TK_LCASES+1     ; CHR$ token
00427      00DC             TK_HEXS           = TK_CHRS+1       ; HEX$ token
00428      00DD             TK_BINS           = TK_HEXS+1       ; BIN$ token
00429      00DE             TK_BITTST         = TK_BINS+1       ; BITTST token
00430      00DF             TK_MAX            = TK_BITTST+1     ; MAX token
00431      00E0             TK_MIN            = TK_MAX+1        ; MIN token
00432      00E1             TK_PI             = TK_MIN+1        ; PI token
00433      00E2             TK_TWOPI          = TK_PI+1         ; TWOPI token
00434      00E3             TK_VPTR           = TK_TWOPI+1      ; VARPTR token
00435      00E4             TK_LEFTS          = TK_VPTR+1       ; LEFT$ token
00436      00E5             TK_RIGHTS         = TK_LEFTS+1      ; RIGHT$ token
00437      00E6             TK_MIDS           = TK_RIGHTS+1     ; MID$ token
00438    
00439    ; offsets from a base of X or Y
00440    
00441      0000             PLUS_0            = $00       ; X or Y plus 0
00442      0001             PLUS_1            = $01       ; X or Y plus 1
00443      0002             PLUS_2            = $02       ; X or Y plus 2
00444      0003             PLUS_3            = $03       ; X or Y plus 3
00445    
00446      0100             LAB_STAK          = $0100     ; stack bottom, no offset
00447    
00448      01FE             LAB_SKFE          = LAB_STAK+$FE
00449                                  ; flushed stack address
00450      01FF             LAB_SKFF          = LAB_STAK+$FF
00451                                  ; flushed stack address
00452    
00453    ; the following locations are bulk initialized from PG2_TABS at LAB_COLD
00454      0200             ccflag            = $0200     ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
00455      0201             ccbyte            = ccflag+1  ; BASIC CTRL-C byte
00456      0202             ccnull            = ccbyte+1  ; BASIC CTRL-C byte timeout
00457    
00458      0203             VEC_CC            = ccnull+1  ; ctrl c check vector
00459    ; end bulk initialize from PG2_TABS at LAB_COLD
00460    
00461    ; the following locations are bulk initialized by min_mon.asm from LAB_vec at LAB_stlp
00462      0205             VEC_IN            = VEC_CC+2  ; input vector
00463      0207             VEC_OUT           = VEC_IN+2  ; output vector
00464      0209             VEC_LD            = VEC_OUT+2 ; load vector
00465      020B             VEC_SV            = VEC_LD+2  ; save vector
00466      020D             VEC_VERIFY        = VEC_SV+2  ; verify vector
00467    ; end bulk initialize by min_mon.asm from LAB_vec at LAB_stlp
00468    
00469    ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
00470    ; the input buffer must not cross a page boundary and must not overlap with
00471    ; program RAM pages!
00472    
00473    ; FINDME
00474    ; $900-$AFF Allocated to the cassette file system.  This is probably generous.
00475    
00476    ;Ibuffs            = IRQ_vec+$14
00477      0B00             Ibuffs            = $B00       ; TODO: Create a method of allocation controlled from an
00478                                   ; external file
00479                                   ; start of input buffer after IRQ/NMI code
00480      0B7F             Ibuffe            = Ibuffs+$7F ; end of input buffer
00481    
00482      0C00             Ram_base          = $0C00      ; start of user RAM (set as needed, should be page aligned)
00483      C000             Ram_top           = $C000      ; end of user RAM+1 (set as needed, should be page aligned)
00484    
00485      0010             Stack_floor       = 16         ; bytes left free on stack for background interrupts
00486    
00487    ; This start can be changed to suit your system
00488    
00489    C100                     *=    $C100
00490    
00491    ; BASIC cold start entry point
00492    
00493    ; new page 2 initialisation, copy block to ccflag on
00494    
00495    LAB_COLD
00496    C100  A0 04              LDY   #PG2_TABE-PG2_TABS-1
00497                                  ; byte count-1
00498    LAB_2D13
00499    C102  B9 0E E2           LDA   PG2_TABS,Y        ; get byte
00500    C105  99 00 02           STA   ccflag,Y          ; store in page 2
00501    C108  88                 DEY                     ; decrement count
00502    C109  10 F7              BPL   LAB_2D13          ; loop if not done
00503    
00504    C10B  A2 FF              LDX   #$FF              ; set byte
00505    C10D  86 88              STX   Clineh            ; set current line high byte (set immediate mode)
00506    C10F  9A                 TXS                     ; reset stack pointer
00507    
00508    C110  A9 4C              LDA   #$4C              ; code for JMP
00509    C112  85 A1              STA   Fnxjmp            ; save for jump vector for functions
00510    
00511    ; copy block from LAB_2CEE to $00BC - $00D7
00512    
00513    C114  A2 1C              LDX   #StrTab-LAB_2CEE  ; set byte count
00514    LAB_2D4E
00515    C116  BD 12 E2           LDA   LAB_2CEE-1,X      ; get byte from table
00516    C119  95 BB              STA   LAB_IGBY-1,X      ; save byte in page zero
00517    C11B  CA                 DEX                     ; decrement count
00518    C11C  D0 F8              BNE   LAB_2D4E          ; loop if not all done
00519    
00520    ; copy block from StrTab to $0000 - $0012
00521    
00522    LAB_GMEM
00523    C11E  A2 12              LDX   #EndTab-StrTab-1  ; set byte count-1
00524    TabLoop
00525    C120  BD 2F E2           LDA   StrTab,X          ; get byte from table
00526    C123  95 00              STA   PLUS_0,X          ; save byte in page zero
00527    C125  CA                 DEX                     ; decrement count
00528    C126  10 F8              BPL   TabLoop           ; loop if not all done
00529    
00530    ; set-up start values
00531    
00532    C128  A9 00              LDA   #$00              ; clear A
00533    C12A  85 DC              STA   NmiBase           ; clear NMI handler enabled flag
00534    C12C  85 DF              STA   IrqBase           ; clear IRQ handler enabled flag
00535    C12E  85 B2              STA   FAC1_o            ; clear FAC1 overflow byte
00536    C130  85 67              STA   last_sh           ; clear descriptor stack top item pointer high byte
00537    
00538    C132  A9 0E              LDA   #$0E              ; set default tab size
00539    C134  85 64              STA   TabSiz            ; save it
00540    C136  A9 03              LDA   #$03              ; set garbage collect step size for descriptor stack
00541    C138  85 A0              STA   g_step            ; save it
00542    C13A  A2 68              LDX   #des_sk           ; descriptor stack start
00543    C13C  86 65              STX   next_s            ; set descriptor stack pointer
00544    C13E  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
00545    C141  A9 42              LDA   #<LAB_MSZM        ; point to memory size message (low addr)
00546    C143  A0 E2              LDY   #>LAB_MSZM        ; point to memory size message (high addr)
00547    C145  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00548    C148  20 43 C3           JSR   LAB_INLN          ; print "? " and get BASIC input
00549    C14B  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00550    C14D  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00551    C14F  20 C2 00           JSR   LAB_GBYT          ; get last byte back
00552    
00553    C152  D0 1F              BNE   LAB_2DAA          ; branch if not null (user typed something)
00554    
00555    C154  A0 00              LDY   #$00              ; else clear Y
00556                                  ; character was null so get memory size the hard way
00557                                  ; we get here with Y=0 and Itempl/h = Ram_base
00558    LAB_2D93
00559    C156  E6 11              INC   Itempl            ; increment temporary integer low byte
00560    C158  D0 08              BNE   LAB_2D99          ; branch if no overflow
00561    
00562    C15A  E6 12              INC   Itemph            ; increment temporary integer high byte
00563    C15C  A5 12              LDA   Itemph            ; get high byte
00564    C15E  C9 C0              CMP   #>Ram_top         ; compare with top of RAM+1
00565    C160  F0 1D              BEQ   LAB_2DB6          ; branch if match (end of user RAM)
00566    
00567    LAB_2D99
00568    C162  A9 55              LDA   #$55              ; set test byte
00569    C164  91 11              STA   (Itempl),Y        ; save via temporary integer
00570    C166  D1 11              CMP   (Itempl),Y        ; compare via temporary integer
00571    C168  D0 15              BNE   LAB_2DB6          ; branch if fail
00572    
00573    C16A  0A                 ASL                     ; shift test byte left (now $AA)
00574    C16B  91 11              STA   (Itempl),Y        ; save via temporary integer
00575    C16D  D1 11              CMP   (Itempl),Y        ; compare via temporary integer
00576    C16F  F0 E5              BEQ   LAB_2D93          ; if ok go do next byte
00577    
00578    C171  D0 0C              BNE   LAB_2DB6          ; branch if fail
00579    
00580    LAB_2DAA
00581    C173  20 B9 DA           JSR   LAB_2887          ; get FAC1 from string
00582    C176  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00583    C178  C9 98              CMP   #$98              ; compare with exponent = 2^24
00584    C17A  B0 A2              BCS   LAB_GMEM          ; if too large go try again
00585    
00586    C17C  20 0A D6           JSR   LAB_F2FU          ; save integer part of FAC1 in temporary integer
00587                                  ; (no range check)
00588    
00589    LAB_2DB6
00590    C17F  A5 11              LDA   Itempl            ; get temporary integer low byte
00591    C181  A4 12              LDY   Itemph            ; get temporary integer high byte
00592    ; *** begin patch  2.22p5.0 RAM top sanity check ***
00593    ; *** replace
00594    ;      CPY   #<Ram_base+1      ; compare with start of RAM+$100 high byte
00595    ; +++ with
00596    C183  C0 0D              CPY   #>Ram_base+1      ; compare with start of RAM+$100 high byte
00597    ; *** end patch    2.22p5.0 ***
00598    C185  90 97              BCC   LAB_GMEM          ; if too small go try again
00599    
00600    
00601    ; uncomment these lines if you want to check on the high limit of memory. Note if
00602    ; Ram_top is set too low then this will fail. default is ignore it and assume the
00603    ; users know what they're doing!
00604    
00605    ;     CPY   #>Ram_top         ; compare with top of RAM high byte
00606    ;     BCC   MEM_OK            ; branch if < RAM top
00607    
00608    ;     BNE   LAB_GMEM          ; if too large go try again
00609                                  ; else was = so compare low bytes
00610    ;     CMP   #<Ram_top         ; compare with top of RAM low byte
00611    ;     BEQ   MEM_OK            ; branch if = RAM top
00612    
00613    ;     BCS   LAB_GMEM          ; if too large go try again
00614    
00615    ;MEM_OK
00616    C187  85 85              STA   Ememl             ; set end of mem low byte
00617    C189  84 86              STY   Ememh             ; set end of mem high byte
00618    C18B  85 81              STA   Sstorl            ; set bottom of string space low byte
00619    C18D  84 82              STY   Sstorh            ; set bottom of string space high byte
00620    
00621    C18F  A0 00              LDY   #<Ram_base        ; set start addr low byte
00622    C191  A2 0C              LDX   #>Ram_base        ; set start addr high byte
00623    C193  84 79              STY   Smeml             ; save start of mem low byte
00624    C195  86 7A              STX   Smemh             ; save start of mem high byte
00625    
00626    ; this line is only needed if Ram_base is not $xx00
00627          .IF   Ram_base&$FF>0
00628    
00629    C197  98                 TYA                     ; clear A
00630    C198  91 79              STA   (Smeml),Y         ; clear first byte
00631    C19A  E6 79              INC   Smeml             ; increment start of mem low byte
00632    
00633    ; these two lines are only needed if Ram_base is $xxFF
00634          .IF   Ram_base&$FF==$FF
00635    
00636    C19C  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
00637    C19F  20 59 C4           JSR   LAB_1463          ; do "NEW" and "CLEAR"
00638    C1A2  A5 85              LDA   Ememl             ; get end of mem low byte
00639    C1A4  38                 SEC                     ; set carry for subtract
00640    C1A5  E5 79              SBC   Smeml             ; subtract start of mem low byte
00641    C1A7  AA                 TAX                     ; copy to X
00642    C1A8  A5 86              LDA   Ememh             ; get end of mem high byte
00643    C1AA  E5 7A              SBC   Smemh             ; subtract start of mem high byte
00644    C1AC  20 95 DB           JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
00645    C1AF  A9 51              LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
00646    C1B1  A0 E2              LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
00647    C1B3  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00648    C1B6  A9 5D              LDA   #<LAB_1274        ; warm start vector low byte
00649    C1B8  A0 C2              LDY   #>LAB_1274        ; warm start vector high byte
00650    C1BA  85 01              STA   Wrmjpl            ; save warm start vector low byte
00651    C1BC  84 02              STY   Wrmjph            ; save warm start vector high byte
00652    C1BE  6C 01 00           JMP   (Wrmjpl)          ; go do warm start
00653    
00654    ; open up space in memory
00655    ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00656    
00657    ; Nbendl,Nbendh - new block end address (A/Y)
00658    ; Obendl,Obendh - old block end address
00659    ; Ostrtl,Ostrth - old block start address
00660    
00661    ; returns with ..
00662    
00663    ; Nbendl,Nbendh - new block start address (high byte - $100)
00664    ; Obendl,Obendh - old block start address (high byte - $100)
00665    ; Ostrtl,Ostrth - old block start address (unchanged)
00666    
00667    LAB_11CF
00668    C1C1  20 0E C2           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
00669                                  ; addr to check is in AY (low/high)
00670    C1C4  85 7F              STA   Earryl            ; save new array mem end low byte
00671    C1C6  84 80              STY   Earryh            ; save new array mem end high byte
00672    
00673    ; open up space in memory
00674    ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00675    ; don't set array end
00676    
00677    LAB_11D6
00678    C1C8  38                 SEC                     ; set carry for subtract
00679    C1C9  A5 A6              LDA   Obendl            ; get block end low byte
00680    C1CB  E5 AA              SBC   Ostrtl            ; subtract block start low byte
00681    C1CD  A8                 TAY                     ; copy MOD(block length/$100) byte to Y
00682    C1CE  A5 A7              LDA   Obendh            ; get block end high byte
00683    C1D0  E5 AB              SBC   Ostrth            ; subtract block start high byte
00684    C1D2  AA                 TAX                     ; copy block length high byte to X
00685    C1D3  E8                 INX                     ; +1 to allow for count=0 exit
00686    C1D4  98                 TYA                     ; copy block length low byte to A
00687    C1D5  F0 24              BEQ   LAB_120A          ; branch if length low byte=0
00688    
00689                                  ; block is (X-1)*256+Y bytes, do the Y bytes first
00690    
00691    C1D7  38                 SEC                     ; set carry for add + 1, two's complement
00692    C1D8  49 FF              EOR   #$FF              ; invert low byte for subtract
00693    C1DA  65 A6              ADC   Obendl            ; add block end low byte
00694    
00695    C1DC  85 A6              STA   Obendl            ; save corrected old block end low byte
00696    C1DE  B0 03              BCS   LAB_11F3          ; branch if no underflow
00697    
00698    C1E0  C6 A7              DEC   Obendh            ; else decrement block end high byte
00699    C1E2  38                 SEC                     ; set carry for add + 1, two's complement
00700    LAB_11F3
00701    C1E3  98                 TYA                     ; get MOD(block length/$100) byte
00702    C1E4  49 FF              EOR   #$FF              ; invert low byte for subtract
00703    C1E6  65 A4              ADC   Nbendl            ; add destination end low byte
00704    C1E8  85 A4              STA   Nbendl            ; save modified new block end low byte
00705    C1EA  B0 08              BCS   LAB_1203          ; branch if no underflow
00706    
00707    C1EC  C6 A5              DEC   Nbendh            ; else decrement block end high byte
00708    C1EE  90 04              BCC   LAB_1203          ; branch always
00709    
00710    LAB_11FF
00711    C1F0  B1 A6              LDA   (Obendl),Y        ; get byte from source
00712    C1F2  91 A4              STA   (Nbendl),Y        ; copy byte to destination
00713    LAB_1203
00714    C1F4  88                 DEY                     ; decrement index
00715    C1F5  D0 F9              BNE   LAB_11FF          ; loop until Y=0
00716    
00717                                  ; now do Y=0 indexed byte
00718    C1F7  B1 A6              LDA   (Obendl),Y        ; get byte from source
00719    C1F9  91 A4              STA   (Nbendl),Y        ; save byte to destination
00720    LAB_120A
00721    C1FB  C6 A7              DEC   Obendh            ; decrement source pointer high byte
00722    C1FD  C6 A5              DEC   Nbendh            ; decrement destination pointer high byte
00723    C1FF  CA                 DEX                     ; decrement block count
00724    C200  D0 F2              BNE   LAB_1203          ; loop until count = $0
00725    
00726    C202  60                 RTS
00727    
00728    ; check room on stack for A bytes
00729    ; stack too deep? do OM error
00730    
00731    LAB_1212
00732    ; *** patch - additional stack floor protection for background interrupts
00733    ; *** add
00734          .IF   Stack_floor
00735    C203  18                 CLC                     ; prep ADC
00736    C204  69 10              ADC   #Stack_floor      ; stack pointer lower limit before interrupts
00737          .ENDIF
00738    ; *** end patch
00739    C206  85 78              STA   TempB             ; save result in temp byte
00740    C208  BA                 TSX                     ; copy stack
00741    C209  E4 78              CPX   TempB             ; compare new "limit" with stack
00742    C20B  90 30              BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
00743    
00744    C20D  60                 RTS
00745    
00746    ; check available memory, "Out of memory" error if no room
00747    ; addr to check is in AY (low/high)
00748    
00749    LAB_121F
00750    C20E  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
00751    C210  90 2A              BCC   LAB_124B          ; if less then exit (is ok)
00752    
00753    C212  D0 04              BNE   LAB_1229          ; skip next test if greater (tested <)
00754    
00755                                  ; high byte was =, now do low byte
00756    C214  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
00757    C216  90 24              BCC   LAB_124B          ; if less then exit (is ok)
00758    
00759                                  ; addr is > string storage ptr (oops!)
00760    LAB_1229
00761    C218  48                 PHA                     ; push addr low byte
00762    C219  A2 08              LDX   #$08              ; set index to save Adatal to expneg inclusive
00763    C21B  98                 TYA                     ; copy addr high byte (to push on stack)
00764    
00765                                  ; save misc numeric work area
00766    LAB_122D
00767    C21C  48                 PHA                     ; push byte
00768    C21D  B5 A3              LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
00769    C21F  CA                 DEX                     ; decrement index
00770    C220  10 FA              BPL   LAB_122D          ; loop until all done
00771    
00772    C222  20 F5 D2           JSR   LAB_GARB          ; garbage collection routine
00773    
00774                                  ; restore misc numeric work area
00775    C225  A2 00              LDX   #$00              ; clear the index to restore bytes
00776    LAB_1238
00777    C227  68                 PLA                     ; pop byte
00778    C228  95 A4              STA   Adatal,X          ; save byte to Adatal to expneg
00779    C22A  E8                 INX                     ; increment index
00780    C22B  E0 08              CPX   #$08              ; compare with end + 1
00781    C22D  30 F8              BMI   LAB_1238          ; loop if more to do
00782    
00783    C22F  68                 PLA                     ; pop addr high byte
00784    C230  A8                 TAY                     ; copy back to Y
00785    C231  68                 PLA                     ; pop addr low byte
00786    C232  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
00787    C234  90 06              BCC   LAB_124B          ; if less then exit (is ok)
00788    
00789    C236  D0 05              BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
00790    
00791                                  ; high byte was =, now do low byte
00792    C238  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
00793    C23A  B0 01              BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
00794    
00795                                  ; ok exit, carry clear
00796    LAB_124B
00797    C23C  60                 RTS
00798    
00799    ; do "Out of memory" error then warm start
00800    
00801    LAB_OMER
00802    C23D  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
00803    
00804    ; do error #X, then warm start
00805    
00806    LAB_XERR
00807    C23F  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
00808    
00809    C242  BD CF E7           LDA   LAB_BAER,X        ; get error message pointer low byte
00810    C245  BC D0 E7           LDY   LAB_BAER+1,X      ; get error message pointer high byte
00811    C248  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00812    
00813    C24B  20 92 C4           JSR   LAB_1491          ; flush stack and clear continue flag
00814    C24E  A9 20              LDA   #<LAB_EMSG        ; point to " Error" low addr
00815    C250  A0 E9              LDY   #>LAB_EMSG        ; point to " Error" high addr
00816    LAB_1269
00817    C252  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
00818    C255  A4 88              LDY   Clineh            ; get current line high byte
00819    C257  C8                 INY                     ; increment it
00820    C258  F0 03              BEQ   LAB_1274          ; go do warm start (was immediate mode)
00821    
00822                                  ; else print line number
00823    C25A  20 8A DB           JSR   LAB_2953          ; print " in line [LINE #]"
00824    
00825    ; BASIC warm start entry point
00826    ; wait for Basic command
00827    
00828    LAB_1274
00829                                  ; clear ON IRQ/NMI bytes
00830    C25D  A9 00              LDA   #$00              ; clear A
00831    C25F  85 DF              STA   IrqBase           ; clear enabled byte
00832    C261  85 DC              STA   NmiBase           ; clear enabled byte
00833    C263  A9 31              LDA   #<LAB_RMSG        ; point to "Ready" message low byte
00834    C265  A0 E9              LDY   #>LAB_RMSG        ; point to "Ready" message high byte
00835    
00836    C267  20 DA C9           JSR   LAB_18C3          ; go do print string
00837    
00838    ; wait for Basic command (no "Ready")
00839    
00840    LAB_127D
00841    C26A  20 50 C3           JSR   LAB_1357          ; call for BASIC input
00842    LAB_1280
00843    C26D  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00844    C26F  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00845    C271  20 C2 00           JSR   LAB_GBYT          ; scan memory
00846    C274  F0 F4              BEQ   LAB_127D          ; loop while null
00847    
00848    ; got to interpret input line now ..
00849    
00850    C276  A2 FF              LDX   #$FF              ; current line to null value
00851    C278  86 88              STX   Clineh            ; set current line high byte
00852    C27A  90 06              BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
00853    
00854                                  ; no line number .. immediate mode
00855    C27C  20 81 C3           JSR   LAB_13A6          ; crunch keywords into Basic tokens
00856    C27F  4C FB C5           JMP   LAB_15F6          ; go scan and interpret code
00857    
00858    ; handle new BASIC line
00859    
00860    LAB_1295
00861    C282  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00862    C285  20 81 C3           JSR   LAB_13A6          ; crunch keywords into Basic tokens
00863    C288  84 5D              STY   Ibptr             ; save index pointer to end of crunched line
00864    C28A  20 2D C4           JSR   LAB_SSLN          ; search BASIC for temp integer line number
00865    C28D  90 44              BCC   LAB_12E6          ; branch if not found
00866    
00867                                  ; aroooogah! line # already exists! delete it
00868    C28F  A0 01              LDY   #$01              ; set index to next line pointer high byte
00869    C291  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
00870    C293  85 72              STA   ut1_ph            ; save it
00871    C295  A5 7B              LDA   Svarl             ; get start of vars low byte
00872    C297  85 71              STA   ut1_pl            ; save it
00873    C299  A5 AB              LDA   Baslnh            ; get found line pointer high byte
00874    C29B  85 74              STA   ut2_ph            ; save it
00875    C29D  A5 AA              LDA   Baslnl            ; get found line pointer low byte
00876    C29F  88                 DEY                     ; decrement index
00877    C2A0  F1 AA              SBC   (Baslnl),Y        ; subtract next line pointer low byte
00878    C2A2  18                 CLC                     ; clear carry for add
00879    C2A3  65 7B              ADC   Svarl             ; add start of vars low byte
00880    C2A5  85 7B              STA   Svarl             ; save new start of vars low byte
00881    C2A7  85 73              STA   ut2_pl            ; save destination pointer low byte
00882    C2A9  A5 7C              LDA   Svarh             ; get start of vars high byte
00883    C2AB  69 FF              ADC   #$FF              ; -1 + carry
00884    C2AD  85 7C              STA   Svarh             ; save start of vars high byte
00885    C2AF  E5 AB              SBC   Baslnh            ; subtract found line pointer high byte
00886    C2B1  AA                 TAX                     ; copy to block count
00887    C2B2  38                 SEC                     ; set carry for subtract
00888    C2B3  A5 AA              LDA   Baslnl            ; get found line pointer low byte
00889    C2B5  E5 7B              SBC   Svarl             ; subtract start of vars low byte
00890    C2B7  A8                 TAY                     ; copy to bytes in first block count
00891    C2B8  B0 03              BCS   LAB_12D0          ; branch if overflow
00892    
00893    C2BA  E8                 INX                     ; increment block count (correct for =0 loop exit)
00894    C2BB  C6 74              DEC   ut2_ph            ; decrement destination high byte
00895    LAB_12D0
00896    C2BD  18                 CLC                     ; clear carry for add
00897    C2BE  65 71              ADC   ut1_pl            ; add source pointer low byte
00898    C2C0  90 03              BCC   LAB_12D8          ; branch if no overflow
00899    
00900    C2C2  C6 72              DEC   ut1_ph            ; else decrement source pointer high byte
00901    C2C4  18                 CLC                     ; clear carry
00902    
00903                                  ; close up memory to delete old line
00904    LAB_12D8
00905    C2C5  B1 71              LDA   (ut1_pl),Y        ; get byte from source
00906    C2C7  91 73              STA   (ut2_pl),Y        ; copy to destination
00907    C2C9  C8                 INY                     ; increment index
00908    C2CA  D0 F9              BNE   LAB_12D8          ; while <> 0 do this block
00909    
00910    C2CC  E6 72              INC   ut1_ph            ; increment source pointer high byte
00911    C2CE  E6 74              INC   ut2_ph            ; increment destination pointer high byte
00912    C2D0  CA                 DEX                     ; decrement block count
00913    C2D1  D0 F2              BNE   LAB_12D8          ; loop until all done
00914    
00915                                  ; got new line in buffer and no existing same #
00916    LAB_12E6
00917    C2D3  AD 00 0B           LDA   Ibuffs            ; get byte from start of input buffer
00918    C2D6  F0 3F              BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
00919    
00920                                  ; got new line and it isn't empty line
00921    C2D8  A5 85              LDA   Ememl             ; get end of mem low byte
00922    C2DA  A4 86              LDY   Ememh             ; get end of mem high byte
00923    C2DC  85 81              STA   Sstorl            ; set bottom of string space low byte
00924    C2DE  84 82              STY   Sstorh            ; set bottom of string space high byte
00925    C2E0  A5 7B              LDA   Svarl             ; get start of vars low byte  (end of BASIC)
00926    C2E2  85 A6              STA   Obendl            ; save old block end low byte
00927    C2E4  A4 7C              LDY   Svarh             ; get start of vars high byte (end of BASIC)
00928    C2E6  84 A7              STY   Obendh            ; save old block end high byte
00929    C2E8  65 5D              ADC   Ibptr             ; add input buffer pointer    (also buffer length)
00930    C2EA  90 01              BCC   LAB_1301          ; branch if no overflow from add
00931    
00932    C2EC  C8                 INY                     ; else increment high byte
00933    LAB_1301
00934    C2ED  85 A4              STA   Nbendl            ; save new block end low byte (move to, low byte)
00935    C2EF  84 A5              STY   Nbendh            ; save new block end high byte
00936    C2F1  20 C1 C1           JSR   LAB_11CF          ; open up space in memory
00937                                  ; old start pointer Ostrtl,Ostrth set by the find line call
00938    C2F4  A5 7F              LDA   Earryl            ; get array mem end low byte
00939    C2F6  A4 80              LDY   Earryh            ; get array mem end high byte
00940    C2F8  85 7B              STA   Svarl             ; save start of vars low byte
00941    C2FA  84 7C              STY   Svarh             ; save start of vars high byte
00942    C2FC  A4 5D              LDY   Ibptr             ; get input buffer pointer    (also buffer length)
00943    C2FE  88                 DEY                     ; adjust for loop type
00944    LAB_1311
00945    C2FF  B9 FC 0A           LDA   Ibuffs-4,Y        ; get byte from crunched line
00946    C302  91 AA              STA   (Baslnl),Y        ; save it to program memory
00947    C304  88                 DEY                     ; decrement count
00948    C305  C0 03              CPY   #$03              ; compare with first byte-1
00949    C307  D0 F6              BNE   LAB_1311          ; continue while count <> 3
00950    
00951    C309  A5 12              LDA   Itemph            ; get line # high byte
00952    C30B  91 AA              STA   (Baslnl),Y        ; save it to program memory
00953    C30D  88                 DEY                     ; decrement count
00954    C30E  A5 11              LDA   Itempl            ; get line # low byte
00955    C310  91 AA              STA   (Baslnl),Y        ; save it to program memory
00956    C312  88                 DEY                     ; decrement count
00957    C313  A9 FF              LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
00958                                  ; byte then a zero already here would stop the chain rebuild
00959                                  ; as it would think it was the [EOT] marker.
00960    C315  91 AA              STA   (Baslnl),Y        ; save it to program memory
00961    
00962    LAB_1319
00963    C317  20 6E C4           JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
00964    C31A  A6 79              LDX   Smeml             ; get start of mem low byte
00965    C31C  A5 7A              LDA   Smemh             ; get start of mem high byte
00966    C31E  A0 01              LDY   #$01              ; index to high byte of next line pointer
00967    LAB_1325
00968    C320  86 71              STX   ut1_pl            ; set line start pointer low byte
00969    C322  85 72              STA   ut1_ph            ; set line start pointer high byte
00970    C324  B1 71              LDA   (ut1_pl),Y        ; get it
00971    C326  F0 18              BEQ   LAB_133E          ; exit if end of program
00972    
00973    ; rebuild chaining of Basic lines
00974    
00975    C328  A0 04              LDY   #$04              ; point to first code byte of line
00976                                  ; there is always 1 byte + [EOL] as null entries are deleted
00977    LAB_1330
00978    C32A  C8                 INY                     ; next code byte
00979    C32B  B1 71              LDA   (ut1_pl),Y        ; get byte
00980    C32D  D0 FB              BNE   LAB_1330          ; loop if not [EOL]
00981    
00982    C32F  38                 SEC                     ; set carry for add + 1
00983    C330  98                 TYA                     ; copy end index
00984    C331  65 71              ADC   ut1_pl            ; add to line start pointer low byte
00985    C333  AA                 TAX                     ; copy to X
00986    C334  A0 00              LDY   #$00              ; clear index, point to this line's next line pointer
00987    C336  91 71              STA   (ut1_pl),Y        ; set next line pointer low byte
00988    C338  98                 TYA                     ; clear A
00989    C339  65 72              ADC   ut1_ph            ; add line start pointer high byte + carry
00990    C33B  C8                 INY                     ; increment index to high byte
00991    C33C  91 71              STA   (ut1_pl),Y        ; save next line pointer low byte
00992    C33E  90 E0              BCC   LAB_1325          ; go do next line, branch always, carry clear
00993    
00994    
00995    LAB_133E
00996    C340  4C 6A C2           JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
00997    
00998    ; print "? " and get BASIC input
00999    
01000    LAB_INLN
01001    C343  20 F2 C9           JSR   LAB_18E3          ; print "?" character
01002    C346  20 EF C9           JSR   LAB_18E0          ; print " "
01003    C349  D0 05              BNE   LAB_1357          ; call for BASIC input and return
01004    
01005    ; receive line from keyboard
01006    
01007                                  ; $08 as delete key (BACKSPACE on standard keyboard)
01008    LAB_134B
01009    C34B  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01010    C34E  CA                 DEX                     ; decrement the buffer counter (delete)
01011          .byte $2C               ; make LDX into BIT abs
01012    
01013    ; call for BASIC input (main entry point)
01014    
01015    LAB_1357
01016    C350  A2 00              LDX   #$00              ; clear BASIC line buffer pointer
01017    LAB_1359
01018    C352  20 FF E1           JSR   V_INPT            ; call scan input device
01019    C355  90 FB              BCC   LAB_1359          ; loop if no byte
01020    
01021    C357  F0 F9              BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
01022    
01023    C359  C9 07              CMP   #$07              ; compare with [BELL]
01024    C35B  F0 10              BEQ   LAB_1378          ; branch if [BELL]
01025    
01026    C35D  C9 0D              CMP   #$0D              ; compare with [CR]
01027    C35F  F0 19              BEQ   LAB_1384          ; do CR/LF exit if [CR]
01028    
01029    C361  E0 00              CPX   #$00              ; compare pointer with $00
01030    C363  D0 04              BNE   LAB_1374          ; branch if not empty
01031    
01032    ; next two lines ignore any non print character and [SPACE] if input buffer empty
01033    
01034    C365  C9 21              CMP   #$21              ; compare with [SP]+1
01035    C367  90 E9              BCC   LAB_1359          ; if < ignore character
01036    
01037    LAB_1374
01038    C369  C9 08              CMP   #$08              ; compare with [BACKSPACE] (delete last character)
01039    C36B  F0 DE              BEQ   LAB_134B          ; go delete last character
01040    
01041    LAB_1378
01042    C36D  E0 7F              CPX   #Ibuffe-Ibuffs    ; compare character count with max
01043    C36F  B0 0C              BCS   LAB_138E          ; skip store and do [BELL] if buffer full
01044    
01045    C371  9D 00 0B           STA   Ibuffs,X          ; else store in buffer
01046    C374  E8                 INX                     ; increment pointer
01047    LAB_137F
01048    C375  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01049    C378  D0 D8              BNE   LAB_1359          ; always loop for next character
01050    
01051    LAB_1384
01052    C37A  4C 90 C9           JMP   LAB_1866          ; do CR/LF exit to BASIC
01053    
01054    ; announce buffer full
01055    
01056    LAB_138E
01057    C37D  A9 07              LDA   #$07              ; [BELL] character into A
01058    C37F  D0 F4              BNE   LAB_137F          ; go print the [BELL] but ignore input character
01059                                  ; branch always
01060    
01061    ; crunch keywords into Basic tokens
01062    ; position independent buffer version ..
01063    ; faster, dictionary search version ....
01064    
01065    LAB_13A6
01066    C381  A0 FF              LDY   #$FF              ; set save index (makes for easy math later)
01067    
01068    C383  38                 SEC                     ; set carry for subtract
01069    C384  A5 C3              LDA   Bpntrl            ; get basic execute pointer low byte
01070    C386  E9 00              SBC   #<Ibuffs          ; subtract input buffer start pointer
01071    C388  AA                 TAX                     ; copy result to X (index past line # if any)
01072    
01073    C389  86 60              STX   Oquote            ; clear open quote/DATA flag
01074    LAB_13AC
01075    C38B  BD 00 0B           LDA   Ibuffs,X          ; get byte from input buffer
01076    C38E  F0 51              BEQ   LAB_13EC          ; if null save byte then exit
01077    
01078    C390  C9 5F              CMP   #'_'              ; compare with "_"
01079    C392  B0 4D              BCS   LAB_13EC          ; if >= go save byte then continue crunching
01080    
01081    C394  C9 3C              CMP   #'<'              ; compare with "<"
01082    C396  B0 0E              BCS   LAB_13CC          ; if >= go crunch now
01083    
01084    C398  C9 30              CMP   #'0'              ; compare with "0"
01085    C39A  B0 45              BCS   LAB_13EC          ; if >= go save byte then continue crunching
01086    
01087    C39C  85 5C              STA   Scnquo            ; save buffer byte as search character
01088    C39E  C9 22              CMP   #$22              ; is it quote character?
01089    C3A0  F0 61              BEQ   LAB_1410          ; branch if so (copy quoted string)
01090    
01091    C3A2  C9 2A              CMP   #'*'              ; compare with "*"
01092    C3A4  90 3B              BCC   LAB_13EC          ; if < go save byte then continue crunching
01093    
01094                                  ; else crunch now
01095    LAB_13CC
01096    C3A6  24 60              BIT   Oquote            ; get open quote/DATA token flag
01097    C3A8  70 37              BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
01098                                  ; go save byte then continue crunching
01099    
01100    C3AA  86 78              STX   TempB             ; save buffer read index
01101    C3AC  84 BA              STY   csidx             ; copy buffer save index
01102    C3AE  A0 2C              LDY   #<TAB_1STC        ; get keyword first character table low address
01103    C3B0  84 73              STY   ut2_pl            ; save pointer low byte
01104    C3B2  A0 E4              LDY   #>TAB_1STC        ; get keyword first character table high address
01105    C3B4  84 74              STY   ut2_ph            ; save pointer high byte
01106    C3B6  A0 00              LDY   #$00              ; clear table pointer
01107    
01108    LAB_13D0
01109    C3B8  D1 73              CMP   (ut2_pl),Y        ; compare with keyword first character table byte
01110    C3BA  F0 05              BEQ   LAB_13D1          ; go do word_table_chr if match
01111    
01112    C3BC  90 21              BCC   LAB_13EA          ; if < keyword first character table byte go restore
01113                                  ; Y and save to crunched
01114    
01115    C3BE  C8                 INY                     ; else increment pointer
01116    C3BF  D0 F7              BNE   LAB_13D0          ; and loop (branch always)
01117    
01118    ; have matched first character of some keyword
01119    
01120    LAB_13D1
01121    C3C1  98                 TYA                     ; copy matching index
01122    C3C2  0A                 ASL                     ; *2 (bytes per pointer)
01123    C3C3  AA                 TAX                     ; copy to new index
01124    C3C4  BD 4A E4           LDA   TAB_CHRT,X        ; get keyword table pointer low byte
01125    C3C7  85 73              STA   ut2_pl            ; save pointer low byte
01126    C3C9  BD 4B E4           LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
01127    C3CC  85 74              STA   ut2_ph            ; save pointer high byte
01128    
01129    C3CE  A0 FF              LDY   #$FF              ; clear table pointer (make -1 for start)
01130    
01131    C3D0  A6 78              LDX   TempB             ; restore buffer read index
01132    
01133    LAB_13D6
01134    C3D2  C8                 INY                     ; next table byte
01135    C3D3  B1 73              LDA   (ut2_pl),Y        ; get byte from table
01136    LAB_13D8
01137    C3D5  30 08              BMI   LAB_13EA          ; all bytes matched so go save token
01138    
01139    C3D7  E8                 INX                     ; next buffer byte
01140    C3D8  DD 00 0B           CMP   Ibuffs,X          ; compare with byte from input buffer
01141    C3DB  F0 F5              BEQ   LAB_13D6          ; go compare next if match
01142    
01143    C3DD  D0 2B              BNE   LAB_1417          ; branch if >< (not found keyword)
01144    
01145    LAB_13EA
01146    C3DF  A4 BA              LDY   csidx             ; restore save index
01147    
01148                                  ; save crunched to output
01149    LAB_13EC
01150    C3E1  E8                 INX                     ; increment buffer index (to next input byte)
01151    C3E2  C8                 INY                     ; increment save index (to next output byte)
01152    C3E3  99 00 0B           STA   Ibuffs,Y          ; save byte to output
01153    C3E6  C9 00              CMP   #$00              ; set the flags, set carry
01154    C3E8  F0 32              BEQ   LAB_142A          ; do exit if was null [EOL]
01155    
01156                                  ; A holds token or byte here
01157    C3EA  E9 3A              SBC   #':'              ; subtract ":" (carry set by CMP #00)
01158    C3EC  F0 04              BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
01159    
01160                                  ; A now holds token-$3A
01161    C3EE  C9 49              CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
01162    C3F0  D0 02              BNE   LAB_1401          ; branch if not DATA
01163    
01164                                  ; token was : or DATA
01165    LAB_13FF
01166    C3F2  85 60              STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
01167    LAB_1401
01168    C3F4  49 57              EOR   #TK_REM-$3A       ; effectively subtract REM token offset
01169    C3F6  D0 93              BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
01170    
01171    C3F8  85 5C              STA   Asrch             ; else was REM so set search for [EOL]
01172    
01173                                  ; loop for REM, "..." etc.
01174    LAB_1408
01175    C3FA  BD 00 0B           LDA   Ibuffs,X          ; get byte from input buffer
01176    C3FD  F0 E2              BEQ   LAB_13EC          ; branch if null [EOL]
01177    
01178    C3FF  C5 5C              CMP   Asrch             ; compare with stored character
01179    C401  F0 DE              BEQ   LAB_13EC          ; branch if match (end quote)
01180    
01181                                  ; entry for copy string in quotes, don't crunch
01182    LAB_1410
01183    C403  C8                 INY                     ; increment buffer save index
01184    C404  99 00 0B           STA   Ibuffs,Y          ; save byte to output
01185    C407  E8                 INX                     ; increment buffer read index
01186    C408  D0 F0              BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
01187    
01188                                  ; not found keyword this go
01189    LAB_1417
01190    C40A  A6 78              LDX   TempB             ; compare has failed, restore buffer index (start byte!)
01191    
01192                                  ; now find the end of this word in the table
01193    LAB_141B
01194    C40C  B1 73              LDA   (ut2_pl),Y        ; get table byte
01195    C40E  08                 PHP                     ; save status
01196    C40F  C8                 INY                     ; increment table index
01197    C410  28                 PLP                     ; restore byte status
01198    C411  10 F9              BPL   LAB_141B          ; if not end of keyword go do next
01199    
01200    C413  B1 73              LDA   (ut2_pl),Y        ; get byte from keyword table
01201    C415  D0 BE              BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
01202    
01203                                  ; reached end of table with no match
01204    C417  BD 00 0B           LDA   Ibuffs,X          ; restore byte from input buffer
01205    C41A  10 C3              BPL   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
01206                                  ; go save byte in output and continue crunching
01207    
01208                                  ; reached [EOL]
01209    LAB_142A
01210    C41C  C8                 INY                     ; increment pointer
01211    C41D  C8                 INY                     ; increment pointer (makes it next line pointer high byte)
01212    C41E  99 00 0B           STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
01213    C421  C8                 INY                     ; adjust for line copy
01214    C422  C8                 INY                     ; adjust for line copy
01215    C423  C8                 INY                     ; adjust for line copy
01216    ; *** begin patch for when Ibuffs is $xx00 - Daryl Rictor ***
01217    ; *** insert
01218          .IF   Ibuffs&$FF==0
01219    C424  A5 C3              LDA   Bpntrl            ; test for $00
01220    C426  D0 02              BNE   LAB_142P          ; not $00
01221    C428  C6 C4              DEC   Bpntrh            ; allow for increment when $xx00
01222    LAB_142P
01223          .ENDIF
01224    ; *** end   patch for when Ibuffs is $xx00 - Daryl Rictor ***
01225    ; end of patch
01226    C42A  C6 C3              DEC   Bpntrl            ; allow for increment
01227    C42C  60                 RTS
01228    
01229    ; search Basic for temp integer line number from start of mem
01230    
01231    LAB_SSLN
01232    C42D  A5 79              LDA   Smeml             ; get start of mem low byte
01233    C42F  A6 7A              LDX   Smemh             ; get start of mem high byte
01234    
01235    ; search Basic for temp integer line number from AX
01236    ; returns carry set if found
01237    ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
01238    
01239    ; old 541 new 507
01240    
01241    LAB_SHLN
01242    C431  A0 01              LDY   #$01              ; set index
01243    C433  85 AA              STA   Baslnl            ; save low byte as current
01244    C435  86 AB              STX   Baslnh            ; save high byte as current
01245    C437  B1 AA              LDA   (Baslnl),Y        ; get pointer high byte from addr
01246    C439  F0 1A              BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
01247    
01248    C43B  A0 03              LDY   #$03              ; set index to line # high byte
01249    C43D  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
01250    C43F  88                 DEY                     ; decrement index (point to low byte)
01251    C440  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01252    C442  D0 04              BNE   LAB_1455          ; if <> skip low byte check
01253    
01254    C444  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
01255    C446  C5 11              CMP   Itempl            ; compare with temporary integer low byte
01256    LAB_1455
01257    C448  B0 09              BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
01258    
01259    LAB_1456
01260    C44A  88                 DEY                     ; decrement index to next line ptr high byte
01261    C44B  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
01262    C44D  AA                 TAX                     ; copy to X
01263    C44E  88                 DEY                     ; decrement index to next line ptr low byte
01264    C44F  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
01265    C451  90 DE              BCC   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
01266                                  ; (carry always clear)
01267    
01268    LAB_145E
01269    C453  F0 01              BEQ   LAB_1460          ; exit if temp = found line #, carry is set
01270    
01271    LAB_145F
01272    C455  18                 CLC                     ; clear found flag
01273    LAB_1460
01274    C456  60                 RTS
01275    
01276    ; perform NEW
01277    
01278    LAB_NEW
01279    C457  D0 FD              BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
01280    
01281    LAB_1463
01282    C459  A9 00              LDA   #$00              ; clear A
01283    C45B  A8                 TAY                     ; clear Y
01284    C45C  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, low byte
01285    C45E  C8                 INY                     ; increment index
01286    C45F  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, high byte
01287    C461  18                 CLC                     ; clear carry
01288    C462  A5 79              LDA   Smeml             ; get start of mem low byte
01289    C464  69 02              ADC   #$02              ; calculate end of BASIC low byte
01290    C466  85 7B              STA   Svarl             ; save start of vars low byte
01291    C468  A5 7A              LDA   Smemh             ; get start of mem high byte
01292    C46A  69 00              ADC   #$00              ; add any carry
01293    C46C  85 7C              STA   Svarh             ; save start of vars high byte
01294    
01295    ; reset execution to start, clear vars and flush stack
01296    
01297    LAB_1477
01298    C46E  18                 CLC                     ; clear carry
01299    C46F  A5 79              LDA   Smeml             ; get start of mem low byte
01300    C471  69 FF              ADC   #$FF              ; -1
01301    C473  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01302    C475  A5 7A              LDA   Smemh             ; get start of mem high byte
01303    C477  69 FF              ADC   #$FF              ; -1+carry
01304    C479  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
01305    
01306    ; "CLEAR" command gets here
01307    
01308    LAB_147A
01309    C47B  A5 85              LDA   Ememl             ; get end of mem low byte
01310    C47D  A4 86              LDY   Ememh             ; get end of mem high byte
01311    C47F  85 81              STA   Sstorl            ; set bottom of string space low byte
01312    C481  84 82              STY   Sstorh            ; set bottom of string space high byte
01313    C483  A5 7B              LDA   Svarl             ; get start of vars low byte
01314    C485  A4 7C              LDY   Svarh             ; get start of vars high byte
01315    C487  85 7D              STA   Sarryl            ; save var mem end low byte
01316    C489  84 7E              STY   Sarryh            ; save var mem end high byte
01317    C48B  85 7F              STA   Earryl            ; save array mem end low byte
01318    C48D  84 80              STY   Earryh            ; save array mem end high byte
01319    C48F  20 46 C6           JSR   LAB_161A          ; perform RESTORE command
01320    
01321    ; flush stack and clear continue flag
01322    
01323    LAB_1491
01324    C492  A2 68              LDX   #des_sk           ; set descriptor stack pointer
01325    C494  86 65              STX   next_s            ; save descriptor stack pointer
01326    C496  68                 PLA                     ; pull return address low byte
01327    C497  AA                 TAX                     ; copy return address low byte
01328    C498  68                 PLA                     ; pull return address high byte
01329    C499  8E FE 01           STX   LAB_SKFE          ; save to cleared stack
01330    C49C  8D FF 01           STA   LAB_SKFF          ; save to cleared stack
01331    C49F  A2 FD              LDX   #$FD              ; new stack pointer
01332    C4A1  9A                 TXS                     ; reset stack
01333    C4A2  A9 00              LDA   #$00              ; clear byte
01334    ;*** fix p2: no longer necessary as the continue pointer is saved anyway
01335    ;      STA   Cpntrh            ; clear continue pointer high byte
01336    C4A4  85 61              STA   Sufnxf            ; clear subscript/FNX flag
01337    LAB_14A6
01338    C4A6  60                 RTS
01339    
01340    ; perform CLEAR
01341    
01342    LAB_CLEAR
01343    C4A7  F0 D2              BEQ   LAB_147A          ; if no following token go do "CLEAR"
01344    
01345                                  ; else there was a following token (go do syntax error)
01346    C4A9  60                 RTS
01347    
01348    ; perform LIST [n][-m]
01349    ; bigger, faster version (a _lot_ faster)
01350    
01351    LAB_LIST
01352    C4AA  90 06              BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
01353    
01354    C4AC  F0 04              BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
01355    
01356    C4AE  C9 B8              CMP   #TK_MINUS         ; compare with token for -
01357    C4B0  D0 F4              BNE   LAB_14A6          ; exit if not - (LIST -m)
01358    
01359                                  ; LIST [[n][-m]]
01360                                  ; this bit sets the n , if present, as the start and end
01361    LAB_14BD
01362    C4B2  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01363    C4B5  20 2D C4           JSR   LAB_SSLN          ; search BASIC for temp integer line number
01364                                  ; (pointer in Baslnl/Baslnh)
01365    C4B8  20 C2 00           JSR   LAB_GBYT          ; scan memory
01366    C4BB  F0 0C              BEQ   LAB_14D4          ; branch if no more characters
01367    
01368                                  ; this bit checks the - is present
01369    C4BD  C9 B8              CMP   #TK_MINUS         ; compare with token for -
01370    C4BF  D0 95              BNE   LAB_1460          ; return if not "-" (will be Syntax error)
01371    
01372                                  ; LIST [n]-m
01373                                  ; the - was there so set m as the end value
01374    C4C1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01375    C4C4  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01376    C4C7  D0 8D              BNE   LAB_1460          ; exit if not ok
01377    
01378    LAB_14D4
01379    C4C9  A5 11              LDA   Itempl            ; get temporary integer low byte
01380    C4CB  05 12              ORA   Itemph            ; OR temporary integer high byte
01381    C4CD  D0 06              BNE   LAB_14E2          ; branch if start set
01382    
01383    C4CF  A9 FF              LDA   #$FF              ; set for -1
01384    C4D1  85 11              STA   Itempl            ; set temporary integer low byte
01385    C4D3  85 12              STA   Itemph            ; set temporary integer high byte
01386    LAB_14E2
01387    C4D5  A0 01              LDY   #$01              ; set index for line
01388    C4D7  84 60              STY   Oquote            ; clear open quote flag
01389    C4D9  20 99 C9           JSR   LAB_CRLF          ; print CR/LF
01390    C4DC  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
01391                                  ; pointer initially set by search at LAB_14BD
01392    C4DE  F0 3E              BEQ   LAB_152B          ; if null all done so exit
01393    C4E0  20 1C C6           JSR   LAB_1629          ; do CRTL-C check vector
01394    
01395    C4E3  C8                 INY                     ; increment index for line
01396    C4E4  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
01397    C4E6  AA                 TAX                     ; copy to X
01398    C4E7  C8                 INY                     ; increment index
01399    C4E8  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
01400    C4EA  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01401    C4EC  D0 04              BNE   LAB_14FF          ; branch if no high byte match
01402    
01403    C4EE  E4 11              CPX   Itempl            ; compare with temporary integer low byte
01404    C4F0  F0 02              BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
01405    
01406    LAB_14FF                      ; else ..
01407    C4F2  B0 2A              BCS   LAB_152B          ; if greater all done so exit
01408    
01409    LAB_1501
01410    C4F4  84 97              STY   Tidx1             ; save index for line
01411    C4F6  20 95 DB           JSR   LAB_295E          ; print XA as unsigned integer
01412    C4F9  A9 20              LDA   #$20              ; space is the next character
01413    LAB_1508
01414    C4FB  A4 97              LDY   Tidx1             ; get index for line
01415    C4FD  29 7F              AND   #$7F              ; mask top out bit of character
01416    LAB_150C
01417    C4FF  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01418    C502  C9 22              CMP   #$22              ; was it " character
01419    C504  D0 06              BNE   LAB_1519          ; branch if not
01420    
01421                                  ; we are either entering or leaving a pair of quotes
01422    C506  A5 60              LDA   Oquote            ; get open quote flag
01423    C508  49 FF              EOR   #$FF              ; toggle it
01424    C50A  85 60              STA   Oquote            ; save it back
01425    LAB_1519
01426    C50C  C8                 INY                     ; increment index
01427    C50D  B1 AA              LDA   (Baslnl),Y        ; get next byte
01428    C50F  D0 0E              BNE   LAB_152E          ; branch if not [EOL] (go print character)
01429    C511  A8                 TAY                     ; else clear index
01430    C512  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
01431    C514  AA                 TAX                     ; copy to X
01432    C515  C8                 INY                     ; increment index
01433    C516  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
01434    C518  86 AA              STX   Baslnl            ; set pointer to line low byte
01435    C51A  85 AB              STA   Baslnh            ; set pointer to line high byte
01436    C51C  D0 B7              BNE   LAB_14E2          ; go do next line if not [EOT]
01437                                  ; else ..
01438    LAB_152B
01439    C51E  60                 RTS
01440    
01441    LAB_152E
01442    C51F  10 DE              BPL   LAB_150C          ; just go print it if not token byte
01443    
01444                                  ; else was token byte so uncrunch it (maybe)
01445    C521  24 60              BIT   Oquote            ; test the open quote flag
01446    C523  30 DA              BMI   LAB_150C          ; just go print character if open quote set
01447    
01448    C525  A2 E6              LDX   #>LAB_KEYT        ; get table address high byte
01449    C527  0A                 ASL                     ; *2
01450    C528  0A                 ASL                     ; *4
01451    C529  90 02              BCC   LAB_152F          ; branch if no carry
01452    
01453    C52B  E8                 INX                     ; else increment high byte
01454    C52C  18                 CLC                     ; clear carry for add
01455    LAB_152F
01456    C52D  69 33              ADC   #<LAB_KEYT        ; add low byte
01457    C52F  90 01              BCC   LAB_1530          ; branch if no carry
01458    
01459    C531  E8                 INX                     ; else increment high byte
01460    LAB_1530
01461    C532  85 73              STA   ut2_pl            ; save table pointer low byte
01462    C534  86 74              STX   ut2_ph            ; save table pointer high byte
01463    C536  84 97              STY   Tidx1             ; save index for line
01464    C538  A0 00              LDY   #$00              ; clear index
01465    C53A  B1 73              LDA   (ut2_pl),Y        ; get length
01466    C53C  AA                 TAX                     ; copy length
01467    C53D  C8                 INY                     ; increment index
01468    C53E  B1 73              LDA   (ut2_pl),Y        ; get 1st character
01469    C540  CA                 DEX                     ; decrement length
01470    C541  F0 B8              BEQ   LAB_1508          ; if no more characters exit and print
01471    
01472    C543  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01473    C546  C8                 INY                     ; increment index
01474    C547  B1 73              LDA   (ut2_pl),Y        ; get keyword address low byte
01475    C549  48                 PHA                     ; save it for now
01476    C54A  C8                 INY                     ; increment index
01477    C54B  B1 73              LDA   (ut2_pl),Y        ; get keyword address high byte
01478    C54D  A0 00              LDY   #$00
01479    C54F  85 74              STA   ut2_ph            ; save keyword pointer high byte
01480    C551  68                 PLA                     ; pull low byte
01481    C552  85 73              STA   ut2_pl            ; save keyword pointer low byte
01482    LAB_1540
01483    C554  B1 73              LDA   (ut2_pl),Y        ; get character
01484    C556  CA                 DEX                     ; decrement character count
01485    C557  F0 A2              BEQ   LAB_1508          ; if last character exit and print
01486    
01487    C559  20 F4 C9           JSR   LAB_PRNA          ; go print the character
01488    C55C  C8                 INY                     ; increment index
01489    C55D  D0 F5              BNE   LAB_1540          ; loop for next character
01490    
01491    ; perform FOR
01492    
01493    LAB_FOR
01494    C55F  A9 80              LDA   #$80              ; set FNX
01495    C561  85 61              STA   Sufnxf            ; set subscript/FNX flag
01496    C563  20 BB C8           JSR   LAB_LET           ; go do LET
01497    C566  68                 PLA                     ; pull return address
01498    C567  68                 PLA                     ; pull return address
01499    C568  A9 10              LDA   #$10              ; we need 16d bytes !
01500    C56A  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
01501    C56D  20 A1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
01502    C570  18                 CLC                     ; clear carry for add
01503    C571  98                 TYA                     ; copy index to A
01504    C572  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01505    C574  48                 PHA                     ; push onto stack
01506    C575  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
01507    C577  69 00              ADC   #$00              ; add carry
01508    C579  48                 PHA                     ; push onto stack
01509    C57A  A5 88              LDA   Clineh            ; get current line high byte
01510    C57C  48                 PHA                     ; push onto stack
01511    C57D  A5 87              LDA   Clinel            ; get current line low byte
01512    C57F  48                 PHA                     ; push onto stack
01513    C580  A9 AE              LDA   #TK_TO            ; get "TO" token
01514    C582  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
01515    C585  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
01516    C588  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
01517                                  ; else do type mismatch
01518    ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
01519    ; *** add
01520    C58B  20 EC D9           JSR   LAB_27BA          ; round FAC1
01521    ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
01522    C58E  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
01523    C590  09 7F              ORA   #$7F              ; set all non sign bits
01524    C592  25 AD              AND   FAC1_1            ; and FAC1 mantissa1
01525    C594  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
01526    C596  A9 A1              LDA   #<LAB_159F        ; set return address low byte
01527    C598  A0 C5              LDY   #>LAB_159F        ; set return address high byte
01528    C59A  85 71              STA   ut1_pl            ; save return address low byte
01529    C59C  84 72              STY   ut1_ph            ; save return address high byte
01530    C59E  4C 8D CC           JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
01531    
01532    LAB_159F
01533    C5A1  A9 FA              LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
01534    C5A3  A0 E2              LDY   #>LAB_259C        ; set 1 pointer high addr
01535    C5A5  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
01536    C5A8  20 C2 00           JSR   LAB_GBYT          ; scan memory
01537    C5AB  C9 B3              CMP   #TK_STEP          ; compare with STEP token
01538    C5AD  D0 06              BNE   LAB_15B3          ; jump if not "STEP"
01539    
01540                                  ;.was step so ..
01541    C5AF  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01542    C5B2  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
01543                                  ; else do type mismatch
01544    LAB_15B3
01545    C5B5  20 FC D9           JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
01546    C5B8  85 B0              STA   FAC1_s            ; set FAC1 sign (b7)
01547                                  ; this is +1 for +ve step and -1 for -ve step, in NEXT we
01548                                  ; compare the FOR value and the TO value and return +1 if
01549                                  ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
01550                                  ; here (+/-1) is then compared to that result and if they
01551                                  ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
01552                                  ; the loop is done
01553                                 
01554    ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
01555    ; *** add
01556       .IF [* & $FF] == $FD
01557    ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
01558    C5BA  20 7F CC           JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
01559    C5BD  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
01560    C5BF  48                 PHA                     ; push on stack
01561    C5C0  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
01562    C5C2  48                 PHA                     ; push on stack
01563    C5C3  A9 81              LDA   #TK_FOR           ; get FOR token
01564    C5C5  48                 PHA                     ; push on stack
01565    
01566    ; interpreter inner loop
01567    
01568    LAB_15C2
01569    C5C6  20 1C C6           JSR   LAB_1629          ; do CRTL-C check vector
01570    C5C9  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
01571    C5CB  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
01572    
01573    C5CD  A6 88              LDX   Clineh            ; continue line is $FFxx for immediate mode
01574                                  ; ($00xx for RUN from immediate mode)
01575    C5CF  E8                 INX                     ; increment it (now $00 if immediate mode)
01576    ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
01577    ;      BEQ   LAB_15D1          ; branch if null (immediate mode)
01578    
01579    C5D0  85 8B              STA   Cpntrl            ; save continue pointer low byte
01580    C5D2  84 8C              STY   Cpntrh            ; save continue pointer high byte
01581    LAB_15D1
01582    C5D4  A0 00              LDY   #$00              ; clear index
01583    C5D6  B1 C3              LDA   (Bpntrl),Y        ; get next byte
01584    C5D8  F0 07              BEQ   LAB_15DC          ; branch if null [EOL]
01585    
01586    C5DA  C9 3A              CMP   #':'              ; compare with ":"
01587    C5DC  F0 1D              BEQ   LAB_15F6          ; branch if = (statement separator)
01588    
01589    LAB_15D9
01590    C5DE  4C 08 CD           JMP   LAB_SNER          ; else syntax error then warm start
01591    
01592                                  ; have reached [EOL]
01593    LAB_15DC
01594    C5E1  A0 02              LDY   #$02              ; set index
01595    C5E3  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
01596    C5E5  18                 CLC                     ; clear carry for no "BREAK" message
01597    C5E6  F0 50              BEQ   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
01598                                  ; marker)
01599    
01600    C5E8  C8                 INY                     ; increment index
01601    C5E9  B1 C3              LDA   (Bpntrl),Y        ; get line # low byte
01602    C5EB  85 87              STA   Clinel            ; save current line low byte
01603    C5ED  C8                 INY                     ; increment index
01604    C5EE  B1 C3              LDA   (Bpntrl),Y        ; get line # high byte
01605    C5F0  85 88              STA   Clineh            ; save current line high byte
01606    C5F2  98                 TYA                     ; A now = 4
01607    C5F3  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01608    C5F5  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01609    C5F7  90 02              BCC   LAB_15F6          ; branch if no overflow
01610    
01611    C5F9  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
01612    LAB_15F6
01613    C5FB  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01614    
01615    LAB_15F9
01616    C5FE  20 04 C6           JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
01617    
01618    LAB_15FC
01619    C601  4C C6 C5           JMP   LAB_15C2          ; loop
01620    
01621    ; interpret BASIC code from (Bpntrl)
01622    
01623    LAB_15FF
01624    C604  F0 4E              BEQ   LAB_1628          ; exit if zero [EOL]
01625    
01626    LAB_1602
01627    C606  0A                 ASL                     ; *2 bytes per vector and normalise token
01628    C607  B0 03              BCS   LAB_1609          ; branch if was token
01629    
01630    C609  4C BB C8           JMP   LAB_LET           ; else go do implied LET
01631    
01632    LAB_1609
01633    C60C  C9 58              CMP   #[TK_TAB-$80]*2   ; compare normalised token * 2 with TAB
01634    C60E  B0 CE              BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
01635                                  ; only tokens before TAB can start a line
01636    C610  A8                 TAY                     ; copy to index
01637    C611  B9 22 E3           LDA   LAB_CTBL+1,Y      ; get vector high byte
01638    C614  48                 PHA                     ; onto stack
01639    C615  B9 21 E3           LDA   LAB_CTBL,Y        ; get vector low byte
01640    C618  48                 PHA                     ; onto stack
01641    C619  4C BC 00           JMP   LAB_IGBY          ; jump to increment and scan memory
01642                                  ; then "return" to vector
01643    
01644    ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
01645    ; key press is detected.
01646    
01647    LAB_1629
01648    C61C  6C 03 02           JMP   (VEC_CC)          ; ctrl c check vector
01649    
01650    ; if there was a key press it gets back here ..
01651    
01652    LAB_1636
01653    C61F  C9 03              CMP   #$03              ; compare with CTRL-C
01654    
01655    ; perform STOP
01656    
01657    LAB_STOP
01658    C621  B0 01              BCS   LAB_163B          ; branch if token follows STOP
01659                                  ; else just END
01660    ; END
01661    
01662    LAB_END
01663    C623  18                 CLC                     ; clear the carry, indicate a normal program end
01664    LAB_163B
01665    C624  D0 61              BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
01666    
01667    C626  A5 C4              LDA   Bpntrh            ; get the BASIC execute pointer high byte
01668    ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
01669    ;      EOR   #>Ibuffs          ; compare with buffer address high byte (Cb unchanged)
01670    ;      BEQ   LAB_164F          ; branch if the BASIC pointer is in the input buffer
01671    ;                              ; (can't continue in immediate mode)
01672    ;                              ; else ..
01673    ;      EOR   #>Ibuffs          ; correct the bits
01674    C628  A4 C3              LDY   Bpntrl            ; get BASIC execute pointer low byte
01675    C62A  84 8B              STY   Cpntrl            ; save continue pointer low byte
01676    C62C  85 8C              STA   Cpntrh            ; save continue pointer high byte
01677    LAB_1647
01678    C62E  A5 87              LDA   Clinel            ; get current line low byte
01679    C630  A4 88              LDY   Clineh            ; get current line high byte
01680    C632  85 89              STA   Blinel            ; save break line low byte
01681    C634  84 8A              STY   Blineh            ; save break line high byte
01682    LAB_164F
01683    C636  68                 PLA                     ; pull return address low
01684    C637  68                 PLA                     ; pull return address high
01685    LAB_1651
01686    C638  90 07              BCC   LAB_165E          ; if was program end just do warm start
01687    
01688                                  ; else ..
01689    C63A  A9 18              LDA   #<LAB_BMSG        ; point to "Break" low byte
01690    C63C  A0 E9              LDY   #>LAB_BMSG        ; point to "Break" high byte
01691    C63E  4C 52 C2           JMP   LAB_1269          ; print "Break" and do warm start
01692    
01693    LAB_165E
01694    C641  4C 5D C2           JMP   LAB_1274          ; go do warm start
01695    
01696    ; perform RESTORE
01697    
01698    LAB_RESTORE
01699    C644  D0 0F              BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
01700    
01701    LAB_161A
01702    C646  38                 SEC                     ; set carry for subtract
01703    C647  A5 79              LDA   Smeml             ; get start of mem low byte
01704    C649  E9 01              SBC   #$01              ; -1
01705    C64B  A4 7A              LDY   Smemh             ; get start of mem high byte
01706    C64D  B0 01              BCS   LAB_1624          ; branch if no underflow
01707    
01708    LAB_uflow
01709    C64F  88                 DEY                     ; else decrement high byte
01710    LAB_1624
01711    C650  85 8F              STA   Dptrl             ; save DATA pointer low byte
01712    C652  84 90              STY   Dptrh             ; save DATA pointer high byte
01713    LAB_1628
01714    C654  60                 RTS
01715    
01716                                  ; is RESTORE n
01717    LAB_RESTOREn
01718    C655  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01719    C658  20 A4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
01720    C65B  A5 88              LDA   Clineh            ; get current line high byte
01721    C65D  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01722    C65F  B0 0B              BCS   LAB_reset_search  ; branch if >= (start search from beginning)
01723    
01724    C661  98                 TYA                     ; else copy line index to A
01725    C662  38                 SEC                     ; set carry (+1)
01726    C663  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01727    C665  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
01728    C667  90 07              BCC   LAB_go_search     ; branch if no overflow to high byte
01729    
01730    C669  E8                 INX                     ; increment high byte
01731    C66A  B0 04              BCS   LAB_go_search     ; branch always (can never be carry clear)
01732    
01733    ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
01734    
01735    LAB_reset_search
01736    C66C  A5 79              LDA   Smeml             ; get start of mem low byte
01737    C66E  A6 7A              LDX   Smemh             ; get start of mem high byte
01738    
01739    ; search for line # in temp (Itempl/Itemph) from (AX)
01740    
01741    LAB_go_search
01742    
01743    C670  20 31 C4           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
01744    C673  B0 03              BCS   LAB_line_found    ; if carry set go set pointer
01745    
01746    C675  4C 76 C7           JMP   LAB_16F7          ; else go do "Undefined statement" error
01747    
01748    LAB_line_found
01749                                  ; carry already set for subtract
01750    C678  A5 AA              LDA   Baslnl            ; get pointer low byte
01751    C67A  E9 01              SBC   #$01              ; -1
01752    C67C  A4 AB              LDY   Baslnh            ; get pointer high byte
01753    C67E  B0 D0              BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
01754    
01755    C680  90 CD              BCC   LAB_uflow         ; else decrement high byte then save DATA pointer and
01756                                  ; return (branch always)
01757    
01758    ; perform NULL
01759    
01760    LAB_NULL
01761    C682  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
01762    C685  86 0D              STX   Nullct            ; save new NULL count
01763    LAB_167A
01764    C687  60                 RTS
01765    
01766    ; perform CONT
01767    
01768    LAB_CONT
01769    C688  D0 FD              BNE   LAB_167A          ; if following byte exit to do syntax error
01770    
01771    C68A  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
01772    C68C  C0 0B              CPY   #>Ibuffs          ; *** fix p2: test direct mode
01773    C68E  D0 05              BNE   LAB_166C          ; go do continue if we can
01774    
01775    C690  A2 1E              LDX   #$1E              ; error code $1E ("Can't continue" error)
01776    C692  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
01777    
01778                                  ; we can continue so ..
01779    LAB_166C
01780    C695  A9 93              LDA   #TK_ON            ; set token for ON
01781    C697  20 29 E0           JSR   LAB_IRQ           ; set IRQ flags
01782    C69A  A9 93              LDA   #TK_ON            ; set token for ON
01783    C69C  20 2C E0           JSR   LAB_NMI           ; set NMI flags
01784    
01785    C69F  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
01786    C6A1  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
01787    C6A3  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01788    C6A5  A5 89              LDA   Blinel            ; get break line low byte
01789    C6A7  A4 8A              LDY   Blineh            ; get break line high byte
01790    C6A9  85 87              STA   Clinel            ; set current line low byte
01791    C6AB  84 88              STY   Clineh            ; set current line high byte
01792    C6AD  60                 RTS
01793    
01794    ; perform RUN
01795    
01796    LAB_RUN
01797    C6AE  D0 03              BNE   LAB_1696          ; branch if RUN n
01798    C6B0  4C 6E C4           JMP   LAB_1477          ; reset execution to start, clear variables, flush stack and
01799                                  ; return
01800    
01801    ; does RUN n
01802    
01803    LAB_1696
01804    C6B3  20 7B C4           JSR   LAB_147A          ; go do "CLEAR"
01805    C6B6  F0 2E              BEQ   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
01806    
01807    ; perform DO
01808    
01809    LAB_DO
01810    C6B8  A9 05              LDA   #$05              ; need 5 bytes for DO
01811    C6BA  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
01812    C6BD  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
01813    C6BF  48                 PHA                     ; push on stack
01814    C6C0  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
01815    C6C2  48                 PHA                     ; push on stack
01816    C6C3  A5 88              LDA   Clineh            ; get current line high byte
01817    C6C5  48                 PHA                     ; push on stack
01818    C6C6  A5 87              LDA   Clinel            ; get current line low byte
01819    C6C8  48                 PHA                     ; push on stack
01820    C6C9  A9 9D              LDA   #TK_DO            ; token for DO
01821    C6CB  48                 PHA                     ; push on stack
01822    C6CC  20 C2 00           JSR   LAB_GBYT          ; scan memory
01823    C6CF  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
01824    
01825    ; perform GOSUB
01826    
01827    LAB_GOSUB
01828    C6D2  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
01829    C6D4  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
01830    C6D7  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
01831    C6D9  48                 PHA                     ; push on stack
01832    C6DA  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
01833    C6DC  48                 PHA                     ; push on stack
01834    C6DD  A5 88              LDA   Clineh            ; get current line high byte
01835    C6DF  48                 PHA                     ; push on stack
01836    C6E0  A5 87              LDA   Clinel            ; get current line low byte
01837    C6E2  48                 PHA                     ; push on stack
01838    C6E3  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
01839    C6E5  48                 PHA                     ; push on stack
01840    LAB_16B0
01841    C6E6  20 C2 00           JSR   LAB_GBYT          ; scan memory
01842    C6E9  20 EF C6           JSR   LAB_GOTO          ; perform GOTO n
01843    C6EC  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
01844                                  ; (can't RTS, we used the stack!)
01845    
01846    ; perform GOTO
01847    
01848    LAB_GOTO
01849    C6EF  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
01850    C6F2  20 A4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
01851    C6F5  A5 88              LDA   Clineh            ; get current line high byte
01852    C6F7  C5 12              CMP   Itemph            ; compare with temporary integer high byte
01853    C6F9  B0 0B              BCS   LAB_16D0          ; branch if >= (start search from beginning)
01854    
01855    C6FB  98                 TYA                     ; else copy line index to A
01856    C6FC  38                 SEC                     ; set carry (+1)
01857    C6FD  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
01858    C6FF  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
01859    C701  90 07              BCC   LAB_16D4          ; branch if no overflow to high byte
01860    
01861    C703  E8                 INX                     ; increment high byte
01862    C704  B0 04              BCS   LAB_16D4          ; branch always (can never be carry)
01863    
01864    ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
01865    
01866    LAB_16D0
01867    C706  A5 79              LDA   Smeml             ; get start of mem low byte
01868    C708  A6 7A              LDX   Smemh             ; get start of mem high byte
01869    
01870    ; search for line # in temp (Itempl/Itemph) from (AX)
01871    
01872    LAB_16D4
01873    C70A  20 31 C4           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
01874    C70D  90 67              BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
01875                                  ; (unspecified statement)
01876    
01877                                  ; carry already set for subtract
01878    C70F  A5 AA              LDA   Baslnl            ; get pointer low byte
01879    C711  E9 01              SBC   #$01              ; -1
01880    C713  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01881    C715  A5 AB              LDA   Baslnh            ; get pointer high byte
01882    C717  E9 00              SBC   #$00              ; subtract carry
01883    C719  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
01884    LAB_16E5
01885    C71B  60                 RTS
01886    
01887    LAB_DONOK
01888    C71C  A2 22              LDX   #$22              ; error code $22 ("LOOP without DO" error)
01889    C71E  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
01890    
01891    ; perform LOOP
01892    
01893    LAB_LOOP
01894    C721  A8                 TAY                     ; save following token
01895    C722  BA                 TSX                     ; copy stack pointer
01896    C723  BD 03 01           LDA   LAB_STAK+3,X      ; get token byte from stack
01897    C726  C9 9D              CMP   #TK_DO            ; compare with DO token
01898    C728  D0 F2              BNE   LAB_DONOK         ; branch if no matching DO
01899    
01900    C72A  E8                 INX                     ; dump calling routine return address
01901    C72B  E8                 INX                     ; dump calling routine return address
01902    C72C  9A                 TXS                     ; correct stack
01903    C72D  98                 TYA                     ; get saved following token back
01904    C72E  F0 20              BEQ   LoopAlways        ; if no following token loop forever
01905                                  ; (stack pointer in X)
01906    
01907    C730  C9 3A              CMP   #':'              ; could be ':'
01908    C732  F0 1C              BEQ   LoopAlways        ; if :... loop forever
01909    
01910    C734  E9 B4              SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
01911    C736  AA                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)
01912    C737  F0 04              BEQ   DoRest            ; branch if was UNTIL
01913    
01914    C739  CA                 DEX                     ; decrement result
01915    C73A  D0 62              BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
01916                                  ; only if the token was WHILE will this fail
01917    
01918    C73C  CA                 DEX                     ; set invert result byte
01919    DoRest
01920    C73D  86 98              STX   Frnxth            ; save invert result byte
01921    C73F  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
01922    C742  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
01923    C745  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
01924    C747  F0 02              BEQ   DoCmp             ; if =0 go do straight compare
01925    
01926    C749  A9 FF              LDA   #$FF              ; else set all bits
01927    DoCmp
01928    C74B  BA                 TSX                     ; copy stack pointer
01929    C74C  45 98              EOR   Frnxth            ; EOR with invert byte
01930    C74E  D0 1A              BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
01931    
01932                                  ; loop condition wasn't met so do it again
01933    LoopAlways
01934    C750  BD 02 01           LDA   LAB_STAK+2,X      ; get current line low byte
01935    C753  85 87              STA   Clinel            ; save current line low byte
01936    C755  BD 03 01           LDA   LAB_STAK+3,X      ; get current line high byte
01937    C758  85 88              STA   Clineh            ; save current line high byte
01938    C75A  BD 04 01           LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
01939    C75D  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01940    C75F  BD 05 01           LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
01941    C762  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
01942    C764  20 C2 00           JSR   LAB_GBYT          ; scan memory
01943    C767  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
01944    
01945                                  ; clear stack and back to interpreter loop
01946    LoopDone
01947    C76A  E8                 INX                     ; dump DO token
01948    C76B  E8                 INX                     ; dump current line low byte
01949    C76C  E8                 INX                     ; dump current line high byte
01950    C76D  E8                 INX                     ; dump BASIC execute pointer low byte
01951    C76E  E8                 INX                     ; dump BASIC execute pointer high byte
01952    C76F  9A                 TXS                     ; correct stack
01953    C770  4C 90 C7           JMP   LAB_DATA          ; go perform DATA (find : or [EOL])
01954    
01955    ; do the return without gosub error
01956    
01957    LAB_16F4
01958    C773  A2 04              LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
01959          .byte $2C               ; makes next line BIT LAB_0EA2
01960    
01961    LAB_16F7                      ; do undefined statement error
01962    C776  A2 0E              LDX   #$0E              ; error code $0E ("Undefined statement" error)
01963    C778  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
01964    
01965    ; perform RETURN
01966    
01967    LAB_RETURN
01968    C77B  D0 9E              BNE   LAB_16E5          ; exit if following token (to allow syntax error)
01969    
01970    LAB_16E8
01971    C77D  68                 PLA                     ; dump calling routine return address
01972    C77E  68                 PLA                     ; dump calling routine return address
01973    C77F  68                 PLA                     ; pull token
01974    C780  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
01975    C782  D0 EF              BNE   LAB_16F4          ; branch if no matching GOSUB
01976    
01977    LAB_16FF
01978    C784  68                 PLA                     ; pull current line low byte
01979    C785  85 87              STA   Clinel            ; save current line low byte
01980    C787  68                 PLA                     ; pull current line high byte
01981    C788  85 88              STA   Clineh            ; save current line high byte
01982    C78A  68                 PLA                     ; pull BASIC execute pointer low byte
01983    C78B  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
01984    C78D  68                 PLA                     ; pull BASIC execute pointer high byte
01985    C78E  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
01986    
01987                                  ; now do the DATA statement as we could be returning into
01988                                  ; the middle of an ON <var> GOSUB n,m,p,q line
01989                                  ; (the return address used by the DATA statement is the one
01990                                  ; pushed before the GOSUB was executed!)
01991    
01992    ; perform DATA
01993    
01994    LAB_DATA
01995    C790  20 A1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
01996    
01997                                  ; set BASIC execute pointer
01998    LAB_170F
01999    C793  98                 TYA                     ; copy index to A
02000    C794  18                 CLC                     ; clear carry for add
02001    C795  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
02002    C797  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
02003    C799  90 02              BCC   LAB_1719          ; skip next if no carry
02004    
02005    C79B  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
02006    LAB_1719
02007    C79D  60                 RTS
02008    
02009    LAB_16FC
02010    C79E  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
02011    
02012    ; scan for next BASIC statement ([:] or [EOL])
02013    ; returns Y as index to [:] or [EOL]
02014    
02015    LAB_SNBS
02016    C7A1  A2 3A              LDX   #':'              ; set look for character = ":"
02017          .byte $2C               ; makes next line BIT $00A2
02018    
02019    ; scan for next BASIC line
02020    ; returns Y as index to [EOL]
02021    
02022    LAB_SNBL
02023    C7A4  A2 00              LDX   #$00              ; set alt search character = [EOL]
02024    C7A6  A0 00              LDY   #$00              ; set search character = [EOL]
02025    C7A8  84 5C              STY   Asrch             ; store search character
02026    LAB_1725
02027    C7AA  8A                 TXA                     ; get alt search character
02028    C7AB  45 5C              EOR   Asrch             ; toggle search character, effectively swap with $00
02029    C7AD  85 5C              STA   Asrch             ; save swapped search character
02030    LAB_172D
02031    C7AF  B1 C3              LDA   (Bpntrl),Y        ; get next byte
02032    C7B1  F0 EA              BEQ   LAB_1719          ; exit if null [EOL]
02033    
02034    C7B3  C5 5C              CMP   Asrch             ; compare with search character
02035    C7B5  F0 E6              BEQ   LAB_1719          ; exit if found
02036    
02037    C7B7  C8                 INY                     ; increment index
02038    C7B8  C9 22              CMP   #$22              ; compare current character with open quote
02039    C7BA  D0 F3              BNE   LAB_172D          ; if not open quote go get next character
02040    
02041    C7BC  F0 EC              BEQ   LAB_1725          ; if found go swap search character for alt search character
02042    
02043    ; perform IF
02044    
02045    LAB_IF
02046    C7BE  20 E7 CB           JSR   LAB_EVEX          ; evaluate the expression
02047    C7C1  20 C2 00           JSR   LAB_GBYT          ; scan memory
02048    C7C4  C9 B1              CMP   #TK_THEN          ; compare with THEN token
02049    C7C6  F0 11              BEQ   LAB_174B          ; if it was THEN go do IF
02050    
02051                                  ; wasn't IF .. THEN so must be IF .. GOTO
02052    C7C8  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
02053    C7CA  D0 D2              BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
02054    
02055    C7CC  A6 C3              LDX   Bpntrl            ; save the basic pointer low byte
02056    C7CE  A4 C4              LDY   Bpntrh            ; save the basic pointer high byte
02057    C7D0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02058    C7D3  B0 C9              BCS   LAB_16FC          ; if not numeric go do syntax error
02059    
02060    C7D5  86 C3              STX   Bpntrl            ; restore the basic pointer low byte
02061    C7D7  84 C4              STY   Bpntrh            ; restore the basic pointer high byte
02062    LAB_174B
02063    C7D9  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
02064    C7DB  F0 1E              BEQ   LAB_174E          ; if the result was zero go look for an ELSE
02065    
02066    C7DD  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
02067    C7E0  B0 03              BCS   LAB_174D          ; if not numeric go do var or keyword
02068    
02069    LAB_174C
02070    C7E2  4C EF C6           JMP   LAB_GOTO          ; else was numeric so do GOTO n
02071    
02072                                  ; is var or keyword
02073    LAB_174D
02074    ; *** patch       allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
02075    ; *** replace
02076    ;      CMP   #TK_RETURN        ; compare the byte with the token for RETURN
02077    ;      BNE   LAB_174G          ; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
02078    ;                              ; and return to this code to process any following code
02079    ;
02080    ;      JMP   LAB_1602          ; else it was RETURN so interpret BASIC code from (Bpntrl)
02081    ;                              ; but don't return here
02082    ;
02083    ;LAB_174G
02084    ;      JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
02085    ;
02086    ;; the IF was executed and there may be a following ELSE so the code needs to return
02087    ;; here to check and ignore the ELSE if present
02088    ;
02089    ;      LDY   #$00              ; clear the index
02090    ;      LDA   (Bpntrl),Y        ; get the next BASIC byte
02091    ;      CMP   #TK_ELSE          ; compare it with the token for ELSE
02092    ;      BEQ   LAB_DATA          ; if ELSE ignore the following statement
02093    ;
02094    ;; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
02095    ;; following ELSE will, correctly, cause a syntax error
02096    ;
02097    ;      RTS                     ; else return to the interpreter inner loop
02098    ;
02099    ; *** with
02100    C7E5  68                 PLA                     ; discard interpreter loop return address
02101    C7E6  68                 PLA                     ; so data structures are at the correct stack offset
02102    C7E7  20 C2 00           JSR   LAB_GBYT          ; restore token or variable
02103    C7EA  20 04 C6           JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
02104    
02105    ; the IF was executed and there may be a following ELSE so the code needs to return
02106    ; here to check and ignore the ELSE if present
02107    
02108    C7ED  A0 00              LDY   #$00              ; clear the index
02109    C7EF  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
02110    C7F1  C9 AD              CMP   #TK_ELSE          ; compare it with the token for ELSE
02111    C7F3  D0 03              BNE   LAB_no_ELSE       ; no - continue on this line
02112    C7F5  20 90 C7           JSR   LAB_DATA          ; yes - skip the rest of the line
02113    
02114    ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
02115    ; following ELSE will, correctly, cause a syntax error
02116    
02117    LAB_no_ELSE
02118    C7F8  4C C6 C5           JMP LAB_15C2            ; return to the interpreter inner loop
02119    ; *** end patch  allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
02120    
02121    ; perform ELSE after IF
02122    
02123    LAB_174E
02124    C7FB  A0 00              LDY   #$00              ; clear the BASIC byte index
02125    C7FD  A2 01              LDX   #$01              ; clear the nesting depth
02126    LAB_1750
02127    C7FF  C8                 INY                     ; increment the BASIC byte index
02128    C800  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
02129    C802  F0 0F              BEQ   LAB_1753          ; if EOL go add the pointer and return
02130    
02131    C804  C9 8B              CMP   #TK_IF            ; compare the byte with the token for IF
02132    C806  D0 03              BNE   LAB_1752          ; if not IF token skip the depth increment
02133    
02134    C808  E8                 INX                     ; else increment the nesting depth ..
02135    C809  D0 F4              BNE   LAB_1750          ; .. and continue looking
02136    
02137    LAB_1752
02138    C80B  C9 AD              CMP   #TK_ELSE          ; compare the byte with the token for ELSE
02139    C80D  D0 F0              BNE   LAB_1750          ; if not ELSE token continue looking
02140    
02141    C80F  CA                 DEX                     ; was ELSE so decrement the nesting depth
02142    C810  D0 ED              BNE   LAB_1750          ; loop if still nested
02143    
02144    C812  C8                 INY                     ; increment the BASIC byte index past the ELSE
02145    
02146    ; found the matching ELSE, now do <{n|statement}>
02147    
02148    LAB_1753
02149    C813  98                 TYA                     ; else copy line index to A
02150    C814  18                 CLC                     ; clear carry for add
02151    C815  65 C3              ADC   Bpntrl            ; add the BASIC execute pointer low byte
02152    C817  85 C3              STA   Bpntrl            ; save the BASIC execute pointer low byte
02153    C819  90 02              BCC   LAB_1754          ; branch if no overflow to high byte
02154    
02155    C81B  E6 C4              INC   Bpntrh            ; else increment the BASIC execute pointer high byte
02156    LAB_1754
02157    C81D  20 C2 00           JSR   LAB_GBYT          ; scan memory
02158    C820  90 C0              BCC   LAB_174C          ; if numeric do GOTO n
02159                                  ; the code will return to the interpreter loop at the
02160                                  ; tail end of the GOTO <n>
02161    
02162    C822  4C 04 C6           JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
02163                                  ; the code will return to the interpreter loop at the
02164                                  ; tail end of the <statement>
02165    
02166    ; perform REM, skip (rest of) line
02167    
02168    LAB_REM
02169    C825  20 A4 C7           JSR   LAB_SNBL          ; scan for next BASIC line
02170    C828  4C 93 C7           JMP   LAB_170F          ; go set BASIC execute pointer and return, branch always
02171    
02172    LAB_16FD
02173    C82B  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
02174    
02175    ; perform ON
02176    
02177    LAB_ON
02178    C82E  C9 A9              CMP   #TK_IRQ           ; was it IRQ token ?
02179    C830  D0 03              BNE   LAB_NOIN          ; if not go check NMI
02180    
02181    C832  4C 4D E0           JMP   LAB_SIRQ          ; else go set-up IRQ
02182    
02183    LAB_NOIN
02184    C835  C9 AA              CMP   #TK_NMI           ; was it NMI token ?
02185    C837  D0 03              BNE   LAB_NONM          ; if not go do normal ON command
02186    
02187    C839  4C 51 E0           JMP   LAB_SNMI          ; else go set-up NMI
02188    
02189    LAB_NONM
02190    C83C  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
02191    C83F  48                 PHA                     ; push GOTO/GOSUB token
02192    C840  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
02193    C842  F0 04              BEQ   LAB_176B          ; branch if GOSUB
02194    
02195    C844  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
02196    LAB_1767
02197    C846  D0 E3              BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
02198    
02199    
02200    ; next character was GOTO or GOSUB
02201    
02202    LAB_176B
02203    C848  C6 AF              DEC   FAC1_3            ; decrement index (byte value)
02204    C84A  D0 04              BNE   LAB_1773          ; branch if not zero
02205    
02206    C84C  68                 PLA                     ; pull GOTO/GOSUB token
02207    C84D  4C 06 C6           JMP   LAB_1602          ; go execute it
02208    
02209    LAB_1773
02210    C850  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02211    C853  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
02212                                  ; (we could LDX #',' and JSR LAB_SNBL+2, then we
02213                                  ; just BNE LAB_176B for the loop. should be quicker ..
02214                                  ; no we can't, what if we meet a colon or [EOL]?)
02215    C856  C9 2C              CMP   #$2C              ; compare next character with ","
02216    C858  F0 EE              BEQ   LAB_176B          ; loop if ","
02217    
02218    LAB_177E
02219    C85A  68                 PLA                     ; else pull keyword token (run out of options)
02220                                  ; also dump +/-1 pointer low byte and exit
02221    LAB_177F
02222    C85B  60                 RTS
02223    
02224    ; takes n * 106 + 11 cycles where n is the number of digits
02225    
02226    ; get fixed-point number into temp integer
02227    
02228    LAB_GFPN
02229    C85C  A2 00              LDX   #$00              ; clear reg
02230    C85E  86 11              STX   Itempl            ; clear temporary integer low byte
02231    LAB_1785
02232    C860  86 12              STX   Itemph            ; save temporary integer high byte
02233    C862  B0 F7              BCS   LAB_177F          ; return if carry set, end of scan, character was
02234                                  ; not 0-9
02235    
02236    C864  E0 19              CPX   #$19              ; compare high byte with $19
02237    C866  A8                 TAY                     ; ensure Zb = 0 if the branch is taken
02238    C867  B0 DD              BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
02239                                  ; bit does *$0A, = 64000, compare at target will fail
02240                                  ; and do syntax error
02241    
02242    C869  E9 2F              SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
02243    C86B  A8                 TAY                     ; copy binary digit
02244    C86C  A5 11              LDA   Itempl            ; get temporary integer low byte
02245    C86E  0A                 ASL                     ; *2 low byte
02246    C86F  26 12              ROL   Itemph            ; *2 high byte
02247    C871  0A                 ASL                     ; *2 low byte
02248    C872  26 12              ROL   Itemph            ; *2 high byte, *4
02249    C874  65 11              ADC   Itempl            ; + low byte, *5
02250    C876  85 11              STA   Itempl            ; save it
02251    C878  8A                 TXA                     ; get high byte copy to A
02252    C879  65 12              ADC   Itemph            ; + high byte, *5
02253    C87B  06 11              ASL   Itempl            ; *2 low byte, *10d
02254    C87D  2A                 ROL                     ; *2 high byte, *10d
02255    C87E  AA                 TAX                     ; copy high byte back to X
02256    C87F  98                 TYA                     ; get binary digit back
02257    C880  65 11              ADC   Itempl            ; add number low byte
02258    C882  85 11              STA   Itempl            ; save number low byte
02259    C884  90 01              BCC   LAB_17B3          ; if no overflow to high byte get next character
02260    
02261    C886  E8                 INX                     ; else increment high byte
02262    LAB_17B3
02263    C887  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02264    C88A  4C 60 C8           JMP   LAB_1785          ; loop for next character
02265    
02266    ; perform DEC
02267    
02268    LAB_DEC
02269    C88D  A9 FE              LDA   #<LAB_2AFD        ; set -1 pointer low byte
02270          .byte $2C               ; BIT abs to skip the LDA below
02271    
02272    ; perform INC
02273    
02274    LAB_INC
02275    C890  A9 FA              LDA   #<LAB_259C        ; set 1 pointer low byte
02276    LAB_17B5
02277    C892  48                 PHA                     ; save +/-1 pointer low byte
02278    LAB_17B7
02279    C893  20 BE CE           JSR   LAB_GVAR          ; get var address
02280    C896  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
02281    C898  30 1E              BMI   IncrErr           ; exit if string
02282    
02283    C89A  85 97              STA   Lvarpl            ; save var address low byte
02284    C89C  84 98              STY   Lvarph            ; save var address high byte
02285    C89E  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
02286    C8A1  68                 PLA                     ; get +/-1 pointer low byte
02287    C8A2  48                 PHA                     ; save +/-1 pointer low byte
02288    C8A3  A0 E2              LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
02289    C8A5  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
02290    C8A8  20 B6 D9           JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
02291    
02292    C8AB  20 C2 00           JSR   LAB_GBYT          ; scan memory
02293    C8AE  C9 2C              CMP   #','              ; compare with ","
02294    C8B0  D0 A8              BNE   LAB_177E          ; exit if not "," (either end or error)
02295    
02296                                  ; was "," so another INCR variable to do
02297    C8B2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02298    C8B5  4C 93 C8           JMP   LAB_17B7          ; go do next var
02299    
02300    IncrErr
02301    C8B8  4C E2 CB           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
02302    
02303    ; perform LET
02304    
02305    LAB_LET
02306    C8BB  20 BE CE           JSR   LAB_GVAR          ; get var address
02307    C8BE  85 97              STA   Lvarpl            ; save var address low byte
02308    C8C0  84 98              STY   Lvarph            ; save var address high byte
02309    C8C2  A9 C2              LDA   #TK_EQUAL         ; get = token
02310    C8C4  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
02311    C8C7  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
02312    C8C9  48                 PHA                     ; push data type flag
02313    C8CA  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
02314    C8CD  68                 PLA                     ; pop data type flag
02315    C8CE  2A                 ROL                     ; set carry if type = string
02316    ; *** begin patch  result of a string compare stores string pointer to variable
02317    ;                  but should store FAC1 (true/false value)
02318    ; *** replace
02319    ;      JSR   LAB_CKTM          ; type match check, set C for string
02320    ;      BNE   LAB_17D5          ; branch if string
02321    ; *** with
02322    C8CF  20 D9 CB           JSR   LAB_CKTM          ; type match check, keep C (expected type)
02323    C8D2  B0 03              BCS   LAB_17D5          ; branch if string
02324    ; *** end patch
02325    
02326    C8D4  4C B6 D9           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
02327    
02328    ; string LET
02329    
02330    LAB_17D5
02331    C8D7  A0 02              LDY   #$02              ; set index to pointer high byte
02332    C8D9  B1 AE              LDA   (des_pl),Y        ; get string pointer high byte
02333    C8DB  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
02334    C8DD  90 17              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
02335    
02336    C8DF  D0 07              BNE   LAB_17E6          ; branch if >
02337                                  ; else was equal so compare low bytes
02338    C8E1  88                 DEY                     ; decrement index
02339    C8E2  B1 AE              LDA   (des_pl),Y        ; get pointer low byte
02340    C8E4  C5 81              CMP   Sstorl            ; compare bottom of string space low byte
02341    C8E6  90 0E              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
02342    
02343                                  ; pointer was >= to bottom of string space pointer
02344    LAB_17E6
02345    C8E8  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
02346    C8EA  C4 7C              CPY   Svarh             ; compare start of vars high byte
02347    C8EC  90 08              BCC   LAB_17F4          ; branch if less (descriptor is on stack)
02348    
02349    C8EE  D0 0D              BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
02350    
02351                                  ; else high bytes were equal so ..
02352    C8F0  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
02353    C8F2  C5 7B              CMP   Svarl             ; compare start of vars low byte
02354    C8F4  B0 07              BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
02355    
02356    LAB_17F4
02357    C8F6  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
02358    C8F8  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
02359    C8FA  4C 13 C9           JMP   LAB_1811          ; clean stack, copy descriptor to variable and return
02360    
02361                                  ; make space and copy string
02362    LAB_17FB
02363    C8FD  A0 00              LDY   #$00              ; index to length
02364    C8FF  B1 AE              LDA   (des_pl),Y        ; get string length
02365    C901  20 46 D2           JSR   LAB_209C          ; copy string
02366    C904  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
02367    C906  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
02368    C908  85 B8              STA   ssptr_l           ; save descriptor pointer low byte
02369    C90A  84 B9              STY   ssptr_h           ; save descriptor pointer high byte
02370    C90C  20 2B D4           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
02371    C90F  A9 AC              LDA   #<FAC1_e          ; set descriptor pointer low byte
02372    C911  A0 00              LDY   #>FAC1_e          ; get descriptor pointer high byte
02373    
02374                                  ; clean stack and assign value to string variable
02375    LAB_1811
02376    C913  85 9E              STA   des_2l            ; save descriptor_2 pointer low byte
02377    C915  84 9F              STY   des_2h            ; save descriptor_2 pointer high byte
02378    C917  20 8D D4           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
02379    C91A  A0 00              LDY   #$00              ; index to length
02380    C91C  B1 9E              LDA   (des_2l),Y        ; get string length
02381    C91E  91 97              STA   (Lvarpl),Y        ; copy to let string variable
02382    C920  C8                 INY                     ; index to string pointer low byte
02383    C921  B1 9E              LDA   (des_2l),Y        ; get string pointer low byte
02384    C923  91 97              STA   (Lvarpl),Y        ; copy to let string variable
02385    C925  C8                 INY                     ; index to string pointer high byte
02386    C926  B1 9E              LDA   (des_2l),Y        ; get string pointer high byte
02387    C928  91 97              STA   (Lvarpl),Y        ; copy to let string variable
02388    C92A  60                 RTS
02389    
02390    ; perform GET
02391    
02392    LAB_GET
02393    C92B  20 BE CE           JSR   LAB_GVAR          ; get var address
02394    C92E  85 97              STA   Lvarpl            ; save var address low byte
02395    C930  84 98              STY   Lvarph            ; save var address high byte
02396    C932  20 15 E0           JSR   INGET             ; get input byte
02397    C935  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
02398    C937  30 07              BMI   LAB_GETS          ; go get string character
02399    
02400                                  ; was numeric get
02401    C939  A8                 TAY                     ; copy character to Y
02402    C93A  20 7A D1           JSR   LAB_1FD0          ; convert Y to byte in FAC1
02403    C93D  4C B6 D9           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
02404    
02405    LAB_GETS
02406    C940  48                 PHA                     ; save character
02407    C941  A9 01              LDA   #$01              ; string is single byte
02408    C943  B0 01              BCS   LAB_IsByte        ; branch if byte received
02409    
02410    C945  68                 PLA                     ; string is null
02411    LAB_IsByte
02412    C946  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
02413                                  ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
02414    C949  F0 05              BEQ   LAB_NoSt          ; skip store if null string
02415    
02416    C94B  68                 PLA                     ; get character back
02417    C94C  A0 00              LDY   #$00              ; clear index
02418    C94E  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
02419    LAB_NoSt
02420    C950  20 9B D2           JSR   LAB_RTST          ; check for space on descriptor stack then put address
02421                                  ; and length on descriptor stack and update stack pointers
02422    
02423    C953  4C D7 C8           JMP   LAB_17D5          ; do string LET and return
02424    
02425    ; perform PRINT
02426    
02427    LAB_1829
02428    C956  20 DD C9           JSR   LAB_18C6          ; print string from Sutill/Sutilh
02429    LAB_182C
02430    C959  20 C2 00           JSR   LAB_GBYT          ; scan memory
02431    
02432    ; PRINT
02433    
02434    LAB_PRINT
02435    C95C  F0 3B              BEQ   LAB_CRLF          ; if nothing following just print CR/LF
02436    
02437    LAB_1831
02438    C95E  C9 AC              CMP   #TK_TAB           ; compare with TAB( token
02439    C960  F0 56              BEQ   LAB_18A2          ; go do TAB/SPC
02440    
02441    C962  C9 B0              CMP   #TK_SPC           ; compare with SPC( token
02442    C964  F0 52              BEQ   LAB_18A2          ; go do TAB/SPC
02443    
02444    C966  C9 2C              CMP   #','              ; compare with ","
02445    C968  F0 38              BEQ   LAB_188B          ; go do move to next TAB mark
02446    
02447    C96A  C9 3B              CMP   #';'              ; compare with ";"
02448    C96C  F0 66              BEQ   LAB_18BD          ; if ";" continue with PRINT processing
02449    
02450    C96E  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
02451    C971  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
02452    C973  30 E1              BMI   LAB_1829          ; branch if string
02453    
02454    C975  20 A8 DB           JSR   LAB_296E          ; convert FAC1 to string
02455    C978  20 58 D2           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
02456    C97B  A0 00              LDY   #$00              ; clear index
02457    
02458    ; don't check fit if terminal width byte is zero
02459    
02460    C97D  A5 0F              LDA   TWidth            ; get terminal width byte
02461    C97F  F0 0A              BEQ   LAB_185E          ; skip check if zero
02462    
02463    C981  38                 SEC                     ; set carry for subtract
02464    C982  E5 0E              SBC   TPos              ; subtract terminal position
02465    C984  F1 AE              SBC   (des_pl),Y        ; subtract string length
02466    C986  B0 03              BCS   LAB_185E          ; branch if less than terminal width
02467    
02468    C988  20 99 C9           JSR   LAB_CRLF          ; else print CR/LF
02469    LAB_185E
02470    C98B  20 DD C9           JSR   LAB_18C6          ; print string from Sutill/Sutilh
02471    C98E  F0 C9              BEQ   LAB_182C          ; always go continue processing line
02472    
02473    ; CR/LF return to BASIC from BASIC input handler
02474    
02475    LAB_1866
02476    C990  A9 00              LDA   #$00              ; clear byte
02477    C992  9D 00 0B           STA   Ibuffs,X          ; null terminate input
02478    C995  A2 00              LDX   #<Ibuffs          ; set X to buffer start-1 low byte
02479    C997  A0 0B              LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
02480    
02481    ; print CR/LF
02482    
02483    LAB_CRLF
02484    C999  A9 0D              LDA   #$0D              ; load [CR]
02485    C99B  20 F4 C9           JSR   LAB_PRNA          ; go print the character
02486    C99E  A9 0A              LDA   #$0A              ; load [LF]
02487    C9A0  D0 52              BNE   LAB_PRNA          ; go print the character and return, branch always
02488    
02489    LAB_188B
02490    C9A2  A5 0E              LDA   TPos              ; get terminal position
02491    C9A4  C5 10              CMP   Iclim             ; compare with input column limit
02492    C9A6  90 05              BCC   LAB_1897          ; branch if less
02493    
02494    C9A8  20 99 C9           JSR   LAB_CRLF          ; else print CR/LF (next line)
02495    C9AB  D0 27              BNE   LAB_18BD          ; continue with PRINT processing (branch always)
02496    
02497    LAB_1897
02498    C9AD  38                 SEC                     ; set carry for subtract
02499    LAB_1898
02500    C9AE  E5 64              SBC   TabSiz            ; subtract TAB size
02501    C9B0  B0 FC              BCS   LAB_1898          ; loop if result was +ve
02502    
02503    C9B2  49 FF              EOR   #$FF              ; complement it
02504    C9B4  69 01              ADC   #$01              ; +1 (twos complement)
02505    C9B6  D0 12              BNE   LAB_18B6          ; always print A spaces (result is never $00)
02506    
02507                                  ; do TAB/SPC
02508    LAB_18A2
02509    C9B8  48                 PHA                     ; save token
02510    C9B9  20 A3 D5           JSR   LAB_SGBY          ; scan and get byte parameter
02511    C9BC  C9 29              CMP   #$29              ; is next character )
02512    C9BE  D0 7B              BNE   LAB_1910          ; if not do syntax error then warm start
02513    
02514    C9C0  68                 PLA                     ; get token back
02515    C9C1  C9 AC              CMP   #TK_TAB           ; was it TAB ?
02516    C9C3  D0 06              BNE   LAB_18B7          ; if not go do SPC
02517    
02518                                  ; calculate TAB offset
02519    C9C5  8A                 TXA                     ; copy integer value to A
02520    C9C6  E5 0E              SBC   TPos              ; subtract terminal position
02521    C9C8  90 0A              BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
02522    
02523                                  ; print A spaces
02524    LAB_18B6
02525    C9CA  AA                 TAX                     ; copy result to X
02526    LAB_18B7
02527    C9CB  8A                 TXA                     ; set flags on size for SPC
02528    C9CC  F0 06              BEQ   LAB_18BD          ; branch if result was = $0, already here
02529    
02530                                  ; print X spaces
02531    LAB_18BA
02532    C9CE  20 EF C9           JSR   LAB_18E0          ; print " "
02533    C9D1  CA                 DEX                     ; decrement count
02534    C9D2  D0 FA              BNE   LAB_18BA          ; loop if not all done
02535    
02536                                  ; continue with PRINT processing
02537    LAB_18BD
02538    C9D4  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02539    C9D7  D0 85              BNE   LAB_1831          ; if more to print go do it
02540    
02541    C9D9  60                 RTS
02542    
02543    ; print null terminated string from memory
02544    
02545    LAB_18C3
02546    C9DA  20 58 D2           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
02547    
02548    ; print string from Sutill/Sutilh
02549    
02550    LAB_18C6
02551    C9DD  20 58 D4           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
02552                                  ; space returns with A = length, X=$71=pointer low byte,
02553                                  ; Y=$72=pointer high byte
02554    C9E0  A0 00              LDY   #$00              ; reset index
02555    C9E2  AA                 TAX                     ; copy length to X
02556    C9E3  F0 49              BEQ   LAB_188C          ; exit (RTS) if null string
02557    
02558    LAB_18CD
02559    
02560    C9E5  B1 71              LDA   (ut1_pl),Y        ; get next byte
02561    C9E7  20 F4 C9           JSR   LAB_PRNA          ; go print the character
02562    C9EA  C8                 INY                     ; increment index
02563    C9EB  CA                 DEX                     ; decrement count
02564    C9EC  D0 F7              BNE   LAB_18CD          ; loop if not done yet
02565    
02566    C9EE  60                 RTS
02567    
02568                                  ; Print single format character
02569    ; print " "
02570    
02571    LAB_18E0
02572    C9EF  A9 20              LDA   #$20              ; load " "
02573          .byte $2C               ; change next line to BIT LAB_3FA9
02574    
02575    ; print "?" character
02576    
02577    LAB_18E3
02578    C9F2  A9 3F              LDA   #$3F              ; load "?" character
02579    
02580    ; print character in A
02581    ; now includes the null handler
02582    ; also includes infinite line length code
02583    ; note! some routines expect this one to exit with Zb=0
02584    
02585    LAB_PRNA
02586    C9F4  C9 20              CMP   #' '              ; compare with " "
02587    C9F6  90 19              BCC   LAB_18F9          ; branch if less (non printing)
02588    
02589                                  ; else printable character
02590    C9F8  48                 PHA                     ; save the character
02591    
02592    ; don't check fit if terminal width byte is zero
02593    
02594    C9F9  A5 0F              LDA   TWidth            ; get terminal width
02595    C9FB  D0 0A              BNE   LAB_18F0          ; branch if not zero (not infinite length)
02596    
02597    ; is "infinite line" so check TAB position
02598    
02599    C9FD  A5 0E              LDA   TPos              ; get position
02600    C9FF  E5 64              SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
02601    CA01  D0 0B              BNE   LAB_18F7          ; skip reset if different
02602    
02603    CA03  85 0E              STA   TPos              ; else reset position
02604    CA05  F0 07              BEQ   LAB_18F7          ; go print character
02605    
02606    LAB_18F0
02607    CA07  C5 0E              CMP   TPos              ; compare with terminal character position
02608    CA09  D0 03              BNE   LAB_18F7          ; branch if not at end of line
02609    
02610    CA0B  20 99 C9           JSR   LAB_CRLF          ; else print CR/LF
02611    LAB_18F7
02612    CA0E  E6 0E              INC   TPos              ; increment terminal position
02613    CA10  68                 PLA                     ; get character back
02614    LAB_18F9
02615    CA11  20 02 E2           JSR   V_OUTP            ; output byte via output vector
02616    CA14  C9 0D              CMP   #$0D              ; compare with [CR]
02617    CA16  D0 14              BNE   LAB_188A          ; branch if not [CR]
02618    
02619                                  ; else print nullct nulls after the [CR]
02620    CA18  86 78              STX   TempB             ; save buffer index
02621    CA1A  A6 0D              LDX   Nullct            ; get null count
02622    CA1C  F0 0A              BEQ   LAB_1886          ; branch if no nulls
02623    
02624    CA1E  A9 00              LDA   #$00              ; load [NULL]
02625    LAB_1880
02626    CA20  20 F4 C9           JSR   LAB_PRNA          ; go print the character
02627    CA23  CA                 DEX                     ; decrement count
02628    CA24  D0 FA              BNE   LAB_1880          ; loop if not all done
02629    
02630    CA26  A9 0D              LDA   #$0D              ; restore the character (and set the flags)
02631    LAB_1886
02632    CA28  86 0E              STX   TPos              ; clear terminal position (X always = zero when we get here)
02633    CA2A  A6 78              LDX   TempB             ; restore buffer index
02634    LAB_188A
02635    CA2C  29 FF              AND   #$FF              ; set the flags
02636    LAB_188C
02637    CA2E  60                 RTS
02638    
02639    ; handle bad input data
02640    
02641    LAB_1904
02642    CA2F  A5 62              LDA   Imode             ; get input mode flag, $00=INPUT, $00=READ
02643    CA31  10 0B              BPL   LAB_1913          ; branch if INPUT (go do redo)
02644    
02645    CA33  A5 8D              LDA   Dlinel            ; get current DATA line low byte
02646    CA35  A4 8E              LDY   Dlineh            ; get current DATA line high byte
02647    CA37  85 87              STA   Clinel            ; save current line low byte
02648    CA39  84 88              STY   Clineh            ; save current line high byte
02649    LAB_1910
02650    CA3B  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
02651    
02652                                  ; mode was INPUT
02653    LAB_1913
02654    CA3E  A9 4C              LDA   #<LAB_REDO        ; point to redo message (low addr)
02655    CA40  A0 E9              LDY   #>LAB_REDO        ; point to redo message (high addr)
02656    CA42  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
02657    CA45  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
02658    CA47  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
02659    CA49  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
02660    CA4B  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
02661    CA4D  60                 RTS
02662    
02663    ; perform INPUT
02664    
02665    LAB_INPUT
02666    CA4E  C9 22              CMP   #$22              ; compare next byte with open quote
02667    CA50  D0 0B              BNE   LAB_1934          ; branch if no prompt string
02668    
02669    CA52  20 C4 CC           JSR   LAB_1BC1          ; print "..." string
02670    CA55  A9 3B              LDA   #$3B              ; load A with ";"
02671    CA57  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
02672    CA5A  20 DD C9           JSR   LAB_18C6          ; print string from Sutill/Sutilh
02673    
02674                                  ; done with prompt, now get data
02675    LAB_1934
02676    CA5D  20 7E D1           JSR   LAB_CKRN          ; check not Direct, back here if ok
02677    CA60  20 43 C3           JSR   LAB_INLN          ; print "? " and get BASIC input
02678    CA63  A9 00              LDA   #$00              ; set mode = INPUT
02679    CA65  CD 00 0B           CMP   Ibuffs            ; test first byte in buffer
02680    CA68  D0 09              BNE   LAB_1953          ; branch if not null input
02681    
02682    ; *** change p2: keep carry set to throw break message
02683    ;      CLC                     ; was null input so clear carry to exit program
02684    CA6A  4C 2E C6           JMP   LAB_1647          ; go do BREAK exit
02685    
02686    ; perform READ
02687    
02688    LAB_READ
02689    CA6D  A6 8F              LDX   Dptrl             ; get DATA pointer low byte
02690    CA6F  A4 90              LDY   Dptrh             ; get DATA pointer high byte
02691    CA71  A9 80              LDA   #$80              ; set mode = READ
02692    
02693    LAB_1953
02694    CA73  85 62              STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
02695    CA75  86 91              STX   Rdptrl            ; save READ pointer low byte
02696    CA77  84 92              STY   Rdptrh            ; save READ pointer high byte
02697    
02698                                  ; READ or INPUT next variable from list
02699    LAB_195B
02700    CA79  20 BE CE           JSR   LAB_GVAR          ; get (var) address
02701    CA7C  85 97              STA   Lvarpl            ; save address low byte
02702    CA7E  84 98              STY   Lvarph            ; save address high byte
02703    CA80  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
02704    CA82  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
02705    CA84  85 11              STA   Itempl            ; save as temporary integer low byte
02706    CA86  84 12              STY   Itemph            ; save as temporary integer high byte
02707    CA88  A6 91              LDX   Rdptrl            ; get READ pointer low byte
02708    CA8A  A4 92              LDY   Rdptrh            ; get READ pointer high byte
02709    CA8C  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
02710    CA8E  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
02711    CA90  20 C2 00           JSR   LAB_GBYT          ; scan memory
02712    CA93  D0 11              BNE   LAB_1988          ; branch if not null
02713    
02714                                  ; pointer was to null entry
02715    CA95  24 62              BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
02716    CA97  30 65              BMI   LAB_19DD          ; branch if READ
02717    
02718                                  ; mode was INPUT
02719    CA99  20 F2 C9           JSR   LAB_18E3          ; print "?" character (double ? for extended input)
02720    CA9C  20 43 C3           JSR   LAB_INLN          ; print "? " and get BASIC input
02721    CA9F  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
02722    CAA1  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
02723    LAB_1985
02724    CAA3  20 C2 00           JSR   LAB_GBYT          ; scan memory
02725    LAB_1988
02726    CAA6  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
02727    CAA8  10 24              BPL   LAB_19B0          ; branch if numeric
02728    
02729                                  ; else get string
02730    CAAA  85 5B              STA   Srchc             ; save search character
02731    CAAC  C9 22              CMP   #$22              ; was it " ?
02732    CAAE  F0 07              BEQ   LAB_1999          ; branch if so
02733    
02734    CAB0  A9 3A              LDA   #':'              ; else search character is ":"
02735    CAB2  85 5B              STA   Srchc             ; set new search character
02736    CAB4  A9 2C              LDA   #','              ; other search character is ","
02737    CAB6  18                 CLC                     ; clear carry for add
02738    LAB_1999
02739    CAB7  85 5C              STA   Asrch             ; set second search character
02740    CAB9  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
02741    CABB  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
02742    
02743    CABD  69 00              ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
02744    CABF  90 01              BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
02745    
02746    CAC1  C8                 INY                     ; else increment high byte
02747    LAB_19A4
02748    CAC2  20 5E D2           JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
02749    CAC5  20 E2 D5           JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
02750    CAC8  20 D7 C8           JSR   LAB_17D5          ; go do string LET
02751    CACB  4C D4 CA           JMP   LAB_19B6          ; go check string terminator
02752    
02753                                  ; get numeric INPUT
02754    LAB_19B0
02755    CACE  20 B9 DA           JSR   LAB_2887          ; get FAC1 from string
02756    CAD1  20 B6 D9           JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
02757    LAB_19B6
02758    CAD4  20 C2 00           JSR   LAB_GBYT          ; scan memory
02759    CAD7  F0 0A              BEQ   LAB_19C5          ; branch if null (last entry)
02760    
02761    CAD9  C9 2C              CMP   #','              ; else compare with ","
02762    CADB  F0 03              BEQ   LAB_19C2          ; branch if ","
02763    
02764    CADD  4C 2F CA           JMP   LAB_1904          ; else go handle bad input data
02765    
02766                                  ; got good input data
02767    LAB_19C2
02768    CAE0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
02769    LAB_19C5
02770    CAE3  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
02771    CAE5  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
02772    CAE7  85 91              STA   Rdptrl            ; save for now
02773    CAE9  84 92              STY   Rdptrh            ; save for now
02774    CAEB  A5 11              LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
02775    CAED  A4 12              LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
02776    CAEF  85 C3              STA   Bpntrl            ; set BASIC execute pointer low byte
02777    CAF1  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
02778    CAF3  20 C2 00           JSR   LAB_GBYT          ; scan memory
02779    CAF6  F0 2C              BEQ   LAB_1A03          ; if null go do extra ignored message
02780    
02781    CAF8  20 04 CD           JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
02782    CAFB  4C 79 CA           JMP   LAB_195B          ; go INPUT next variable from list
02783    
02784                                  ; find next DATA statement or do "Out of DATA" error
02785    LAB_19DD
02786    CAFE  20 A1 C7           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
02787    CB01  C8                 INY                     ; increment index
02788    CB02  AA                 TAX                     ; copy character ([:] or [EOL])
02789    CB03  D0 12              BNE   LAB_19F6          ; branch if [:]
02790    
02791    CB05  A2 06              LDX   #$06              ; set for "Out of DATA" error
02792    CB07  C8                 INY                     ; increment index, now points to next line pointer high byte
02793    CB08  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
02794    CB0A  F0 73              BEQ   LAB_1A54          ; branch if end (eventually does error X)
02795    
02796    CB0C  C8                 INY                     ; increment index
02797    CB0D  B1 C3              LDA   (Bpntrl),Y        ; get next line # low byte
02798    CB0F  85 8D              STA   Dlinel            ; save current DATA line low byte
02799    CB11  C8                 INY                     ; increment index
02800    CB12  B1 C3              LDA   (Bpntrl),Y        ; get next line # high byte
02801    CB14  C8                 INY                     ; increment index
02802    CB15  85 8E              STA   Dlineh            ; save current DATA line high byte
02803    LAB_19F6
02804    CB17  B1 C3              LDA   (Bpntrl),Y        ; get byte
02805    CB19  C8                 INY                     ; increment index
02806    CB1A  AA                 TAX                     ; copy to X
02807    CB1B  20 93 C7           JSR   LAB_170F          ; set BASIC execute pointer
02808    CB1E  E0 83              CPX   #TK_DATA          ; compare with "DATA" token
02809    CB20  F0 81              BEQ   LAB_1985          ; was "DATA" so go do next READ
02810    
02811    CB22  D0 DA              BNE   LAB_19DD          ; go find next statement if not "DATA"
02812    
02813    ; end of INPUT/READ routine
02814    
02815    LAB_1A03
02816    CB24  A5 91              LDA   Rdptrl            ; get temp READ pointer low byte
02817    CB26  A4 92              LDY   Rdptrh            ; get temp READ pointer high byte
02818    CB28  A6 62              LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
02819    CB2A  10 03              BPL   LAB_1A0E          ; branch if INPUT
02820    
02821    CB2C  4C 50 C6           JMP   LAB_1624          ; save AY as DATA pointer and return
02822    
02823                                  ; we were getting INPUT
02824    LAB_1A0E
02825    CB2F  A0 00              LDY   #$00              ; clear index
02826    CB31  B1 91              LDA   (Rdptrl),Y        ; get next byte
02827    CB33  D0 01              BNE   LAB_1A1B          ; error if not end of INPUT
02828    
02829    CB35  60                 RTS
02830    
02831                                  ; user typed too much
02832    LAB_1A1B
02833    CB36  A9 3B              LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
02834    CB38  A0 E9              LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
02835    CB3A  4C DA C9           JMP   LAB_18C3          ; print null terminated string from memory and return
02836    
02837    ; search the stack for FOR activity
02838    ; exit with z=1 if FOR else exit with z=0
02839    
02840    LAB_11A1
02841    CB3D  BA                 TSX                     ; copy stack pointer
02842    CB3E  E8                 INX                     ; +1 pass return address
02843    CB3F  E8                 INX                     ; +2 pass return address
02844    CB40  E8                 INX                     ; +3 pass calling routine return address
02845    CB41  E8                 INX                     ; +4 pass calling routine return address
02846    LAB_11A6
02847    CB42  BD 01 01           LDA   LAB_STAK+1,X      ; get token byte from stack
02848    CB45  C9 81              CMP   #TK_FOR           ; is it FOR token
02849    CB47  D0 21              BNE   LAB_11CE          ; exit if not FOR token
02850    
02851                                  ; was FOR token
02852    CB49  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
02853    CB4B  D0 0A              BNE   LAB_11BB          ; branch if not null
02854    
02855    CB4D  BD 02 01           LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
02856    CB50  85 97              STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
02857    CB52  BD 03 01           LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
02858    CB55  85 98              STA   Frnxth            ; save var pointer for FOR/NEXT high byte
02859    LAB_11BB
02860    CB57  DD 03 01           CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
02861    CB5A  D0 07              BNE   LAB_11C7          ; branch if no match
02862    
02863    CB5C  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
02864    CB5E  DD 02 01           CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
02865    CB61  F0 07              BEQ   LAB_11CE          ; exit if match found
02866    
02867    LAB_11C7
02868    CB63  8A                 TXA                     ; copy index
02869    CB64  18                 CLC                     ; clear carry for add
02870    CB65  69 10              ADC   #$10              ; add FOR stack use size
02871    CB67  AA                 TAX                     ; copy back to index
02872    CB68  D0 D8              BNE   LAB_11A6          ; loop if not at start of stack
02873    
02874    LAB_11CE
02875    CB6A  60                 RTS
02876    
02877    ; perform NEXT
02878    
02879    LAB_NEXT
02880    CB6B  D0 04              BNE   LAB_1A46          ; branch if NEXT var
02881    
02882    CB6D  A0 00              LDY   #$00              ; else clear Y
02883    CB6F  F0 03              BEQ   LAB_1A49          ; branch always (no variable to search for)
02884    
02885    ; NEXT var
02886    
02887    LAB_1A46
02888    CB71  20 BE CE           JSR   LAB_GVAR          ; get variable address
02889    LAB_1A49
02890    CB74  85 97              STA   Frnxtl            ; store variable pointer low byte
02891    CB76  84 98              STY   Frnxth            ; store variable pointer high byte
02892                                  ; (both cleared if no variable defined)
02893    CB78  20 3D CB           JSR   LAB_11A1          ; search the stack for FOR activity
02894    CB7B  F0 04              BEQ   LAB_1A56          ; branch if found
02895    
02896    CB7D  A2 00              LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
02897    LAB_1A54
02898    CB7F  F0 63              BEQ   LAB_1ABE          ; do error #X, then warm start
02899    
02900    LAB_1A56
02901    CB81  9A                 TXS                     ; set stack pointer, X set by search, dumps return addresses
02902    
02903    CB82  8A                 TXA                     ; copy stack pointer
02904    CB83  38                 SEC                     ; set carry for subtract
02905    CB84  E9 F7              SBC   #$F7              ; point to TO var
02906    CB86  85 73              STA   ut2_pl            ; save pointer to TO var for compare
02907    CB88  69 FB              ADC   #$FB              ; point to STEP var
02908    
02909    CB8A  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
02910    CB8C  20 90 D9           JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
02911    CB8F  BA                 TSX                     ; get stack pointer back
02912    CB90  BD 08 01           LDA   LAB_STAK+8,X      ; get step sign
02913    CB93  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
02914    CB95  A5 97              LDA   Frnxtl            ; get FOR variable pointer low byte
02915    CB97  A4 98              LDY   Frnxth            ; get FOR variable pointer high byte
02916    CB99  20 D1 D6           JSR   LAB_246C          ; add (FOR variable) to FAC1
02917    CB9C  20 B6 D9           JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
02918    CB9F  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
02919    CBA1  20 2C DA           JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
02920    CBA4  BA                 TSX                     ; get stack pointer back
02921    CBA5  DD 08 01           CMP   LAB_STAK+8,X      ; compare step sign
02922    CBA8  F0 17              BEQ   LAB_1A9B          ; branch if = (loop complete)
02923    
02924                                  ; loop back and do it all again
02925    CBAA  BD 0D 01           LDA   LAB_STAK+$0D,X    ; get FOR line low byte
02926    CBAD  85 87              STA   Clinel            ; save current line low byte
02927    CBAF  BD 0E 01           LDA   LAB_STAK+$0E,X    ; get FOR line high byte
02928    CBB2  85 88              STA   Clineh            ; save current line high byte
02929    CBB4  BD 10 01           LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
02930    CBB7  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
02931    CBB9  BD 0F 01           LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
02932    CBBC  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
02933    LAB_1A98
02934    CBBE  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
02935    
02936                                  ; loop complete so carry on
02937    LAB_1A9B
02938    CBC1  8A                 TXA                     ; stack copy to A
02939    CBC2  69 0F              ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
02940    CBC4  AA                 TAX                     ; copy back to index
02941    CBC5  9A                 TXS                     ; copy to stack pointer
02942    CBC6  20 C2 00           JSR   LAB_GBYT          ; scan memory
02943    CBC9  C9 2C              CMP   #','              ; compare with ","
02944    CBCB  D0 F1              BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
02945    
02946                                  ; was "," so another NEXT variable to do
02947    CBCD  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
02948    CBD0  20 71 CB           JSR   LAB_1A46          ; do NEXT (var)
02949    
02950    ; evaluate expression and check is numeric, else do type mismatch
02951    
02952    LAB_EVNM
02953    CBD3  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
02954    
02955    ; check if source is numeric, else do type mismatch
02956    
02957    LAB_CTNM
02958    CBD6  18                 CLC                     ; destination is numeric
02959          .byte $24               ; makes next line BIT $38
02960    
02961    ; check if source is string, else do type mismatch
02962    
02963    LAB_CTST
02964    CBD8  38                 SEC                     ; required type is string
02965    
02966    ; type match check, set C for string, clear C for numeric
02967    
02968    LAB_CKTM
02969    CBD9  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
02970    CBDB  30 03              BMI   LAB_1ABA          ; branch if data type is string
02971    
02972                                  ; else data type was numeric
02973    CBDD  B0 03              BCS   LAB_1ABC          ; if required type is string do type mismatch error
02974    LAB_1AB9
02975    CBDF  60                 RTS
02976    
02977                                  ; data type was string, now check required type
02978    LAB_1ABA
02979    CBE0  B0 FD              BCS   LAB_1AB9          ; exit if required type is string
02980    
02981                                  ; else do type mismatch error
02982    LAB_1ABC
02983    CBE2  A2 18              LDX   #$18              ; error code $18 ("Type mismatch" error)
02984    LAB_1ABE
02985    CBE4  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
02986    
02987    ; evaluate expression
02988    
02989    LAB_EVEX
02990    CBE7  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
02991    CBE9  D0 02              BNE   LAB_1AC7          ; skip next if not zero
02992    
02993    CBEB  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
02994    LAB_1AC7
02995    CBED  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
02996    
02997    LAB_EVEZ
02998    CBEF  A9 00              LDA   #$00              ; set null precedence (flag done)
02999    LAB_1ACC
03000    CBF1  48                 PHA                     ; push precedence byte
03001    CBF2  A9 02              LDA   #$02              ; 2 bytes
03002    CBF4  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
03003    CBF7  20 D3 CC           JSR   LAB_GVAL          ; get value from line
03004    CBFA  A9 00              LDA   #$00              ; clear A
03005    CBFC  85 9B              STA   comp_f            ; clear compare function flag
03006    LAB_1ADB
03007    CBFE  20 C2 00           JSR   LAB_GBYT          ; scan memory
03008    LAB_1ADE
03009    CC01  38                 SEC                     ; set carry for subtract
03010    CC02  E9 C1              SBC   #TK_GT            ; subtract token for > (lowest comparison function)
03011    CC04  90 17              BCC   LAB_1AFA          ; branch if < TK_GT
03012    
03013    CC06  C9 03              CMP   #$03              ; compare with ">" to "<" tokens
03014    CC08  B0 13              BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
03015    
03016                                  ; was token for > = or < (A = 0, 1 or 2)
03017    CC0A  C9 01              CMP   #$01              ; compare with token for =
03018    CC0C  2A                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
03019                                  ; (A = 0, 3 or 5)
03020    CC0D  49 01              EOR   #$01              ; toggle b0
03021                                  ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
03022    CC0F  45 9B              EOR   comp_f            ; EOR with compare function flag bits
03023    CC11  C5 9B              CMP   comp_f            ; compare with compare function flag
03024    CC13  90 67              BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
03025                                  ; was more than one <, = or >)
03026    
03027    CC15  85 9B              STA   comp_f            ; save new compare function flag
03028    CC17  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03029    CC1A  4C 01 CC           JMP   LAB_1ADE          ; go do next character
03030    
03031                                  ; token is < ">" or > "<" tokens
03032    LAB_1AFA
03033    CC1D  A6 9B              LDX   comp_f            ; get compare function flag
03034    CC1F  D0 2C              BNE   LAB_1B2A          ; branch if compare function
03035    
03036    CC21  B0 79              BCS   LAB_1B78          ; go do functions
03037    
03038                                  ; else was <  TK_GT so is operator or lower
03039    CC23  69 0A              ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
03040    CC25  90 75              BCC   LAB_1B78          ; branch if < + operator
03041    
03042                                  ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
03043    CC27  D0 07              BNE   LAB_1B0B          ; branch if not + token
03044    
03045    CC29  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
03046    CC2B  10 03              BPL   LAB_1B0B          ; branch if not string
03047    
03048                                  ; will only be $00 if type is string and token was +
03049    CC2D  4C EE D3           JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
03050                                  ; is in line, and return
03051    
03052    LAB_1B0B
03053    CC30  85 71              STA   ut1_pl            ; save it
03054    CC32  0A                 ASL                     ; *2
03055    CC33  65 71              ADC   ut1_pl            ; *3
03056    CC35  A8                 TAY                     ; copy to index
03057    LAB_1B13
03058    CC36  68                 PLA                     ; pull previous precedence
03059    CC37  D9 05 E4           CMP   LAB_OPPT,Y        ; compare with precedence byte
03060    CC3A  B0 65              BCS   LAB_1B7D          ; branch if A >=
03061    
03062    CC3C  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
03063    LAB_1B1C
03064    CC3F  48                 PHA                     ; save precedence
03065    LAB_1B1D
03066    CC40  20 68 CC           JSR   LAB_1B43          ; get vector, execute function then continue evaluation
03067    CC43  68                 PLA                     ; restore precedence
03068    CC44  A4 99              LDY   prstk             ; get precedence stacked flag
03069    CC46  10 19              BPL   LAB_1B3C          ; branch if stacked values
03070    
03071    CC48  AA                 TAX                     ; copy precedence (set flags)
03072    CC49  F0 76              BEQ   LAB_1B9D          ; exit if done
03073    
03074    CC4B  D0 5D              BNE   LAB_1B86          ; else pop FAC2 and return, branch always
03075    
03076    LAB_1B2A
03077    CC4D  26 5F              ROL   Dtypef            ; shift data type flag into Cb
03078    CC4F  8A                 TXA                     ; copy compare function flag
03079    CC50  85 5F              STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
03080    CC52  2A                 ROL                     ; shift data type into compare function byte b0
03081    CC53  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
03082    CC55  D0 02              BNE   LAB_1B34          ; branch if no underflow
03083    
03084    CC57  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
03085    LAB_1B34
03086    CC59  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
03087      000C             TK_LT_PLUS  = TK_LT-TK_PLUS
03088    CC5B  A0 24              LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
03089    CC5D  85 9B              STA   comp_f            ; save new compare function flag
03090    CC5F  D0 D5              BNE   LAB_1B13          ; branch always
03091    
03092    LAB_1B3C
03093    CC61  D9 05 E4           CMP   LAB_OPPT,Y        ;.compare with stacked function precedence
03094    CC64  B0 44              BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
03095    
03096    CC66  90 D7              BCC   LAB_1B1C          ; branch always
03097    
03098    ;.get vector, execute function then continue evaluation
03099    
03100    LAB_1B43
03101    CC68  B9 07 E4           LDA   LAB_OPPT+2,Y      ; get function vector high byte
03102    CC6B  48                 PHA                     ; onto stack
03103    CC6C  B9 06 E4           LDA   LAB_OPPT+1,Y      ; get function vector low byte
03104    CC6F  48                 PHA                     ; onto stack
03105                                  ; now push sign, round FAC1 and put on stack
03106    ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
03107    ; *** add
03108       .IF [* & $FF] == $FD
03109    ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
03110    CC70  20 7F CC           JSR   LAB_1B5B          ; function will return here, then the next RTS will call
03111                                  ; the function
03112    CC73  A5 9B              LDA   comp_f            ; get compare function flag
03113    CC75  48                 PHA                     ; push compare evaluation byte
03114    CC76  B9 05 E4           LDA   LAB_OPPT,Y        ; get precedence byte
03115    CC79  4C F1 CB           JMP   LAB_1ACC          ; continue evaluating expression
03116    
03117    LAB_1B53
03118    CC7C  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
03119    
03120    ; push sign, round FAC1 and put on stack
03121    
03122    LAB_1B5B
03123    CC7F  68                 PLA                     ; get return addr low byte
03124    CC80  85 71              STA   ut1_pl            ; save it
03125    CC82  E6 71              INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
03126                                  ; note! no check is made on the high byte! if the calling
03127                                  ; routine assembles to a page edge then this all goes
03128                                  ; horribly wrong !!!
03129    CC84  68                 PLA                     ; get return addr high byte
03130    CC85  85 72              STA   ut1_ph            ; save it
03131    CC87  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
03132    CC89  48                 PHA                     ; push sign
03133    
03134    ; round FAC1 and put on stack
03135    
03136    ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
03137    ; *** replace
03138    ;LAB_1B66
03139    ;      JSR   LAB_27BA          ; round FAC1
03140    ; *** with
03141    CC8A  20 EC D9           JSR   LAB_27BA          ; round FAC1
03142    LAB_1B66
03143    ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
03144    CC8D  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03145    CC8F  48                 PHA                     ; push on stack
03146    CC90  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03147    CC92  48                 PHA                     ; push on stack
03148    CC93  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
03149    CC95  48                 PHA                     ; push on stack
03150    CC96  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03151    CC98  48                 PHA                     ; push on stack
03152    CC99  6C 71 00           JMP   (ut1_pl)          ; return, sort of
03153    
03154    ; do functions
03155    
03156    LAB_1B78
03157    CC9C  A0 FF              LDY   #$FF              ; flag function
03158    CC9E  68                 PLA                     ; pull precedence byte
03159    LAB_1B7B
03160    CC9F  F0 20              BEQ   LAB_1B9D          ; exit if done
03161    
03162    LAB_1B7D
03163    CCA1  C9 64              CMP   #$64              ; compare previous precedence with $64
03164    CCA3  F0 03              BEQ   LAB_1B84          ; branch if was $64 (< function)
03165    
03166    CCA5  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
03167    LAB_1B84
03168    CCA8  84 99              STY   prstk             ; save precedence stacked flag
03169    
03170                                  ; pop FAC2 and return
03171    LAB_1B86
03172    CCAA  68                 PLA                     ; pop byte
03173    CCAB  4A                 LSR                     ; shift out comparison evaluation lowest bit
03174    CCAC  85 63              STA   Cflag             ; save comparison evaluation flag
03175    CCAE  68                 PLA                     ; pop exponent
03176    CCAF  85 B3              STA   FAC2_e            ; save FAC2 exponent
03177    CCB1  68                 PLA                     ; pop mantissa1
03178    CCB2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
03179    CCB4  68                 PLA                     ; pop mantissa2
03180    CCB5  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
03181    CCB7  68                 PLA                     ; pop mantissa3
03182    CCB8  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
03183    CCBA  68                 PLA                     ; pop sign
03184    CCBB  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
03185    CCBD  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
03186    CCBF  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
03187    LAB_1B9D
03188    CCC1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03189    CCC3  60                 RTS
03190    
03191    ; print "..." string to string util area
03192    
03193    LAB_1BC1
03194    CCC4  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
03195    CCC6  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
03196    CCC8  69 00              ADC   #$00              ; add carry to low byte
03197    CCCA  90 01              BCC   LAB_1BCA          ; branch if no overflow
03198    
03199    CCCC  C8                 INY                     ; increment high byte
03200    LAB_1BCA
03201    CCCD  20 58 D2           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
03202    CCD0  4C E2 D5           JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
03203    
03204    ; get value from line
03205    
03206    LAB_GVAL
03207    CCD3  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03208    CCD6  B0 03              BCS   LAB_1BAC          ; branch if not numeric character
03209    
03210                                  ; else numeric string found (e.g. 123)
03211    LAB_1BA9
03212    CCD8  4C B9 DA           JMP   LAB_2887          ; get FAC1 from string and return
03213    
03214    ; get value from line .. continued
03215    
03216                                  ; wasn't a number so ..
03217    LAB_1BAC
03218    CCDB  AA                 TAX                     ; set the flags
03219    CCDC  30 2F              BMI   LAB_1BD0          ; if -ve go test token values
03220    
03221                                  ; else it is either a string, number, variable or (<expr>)
03222    CCDE  C9 24              CMP   #'$'              ; compare with "$"
03223    CCE0  F0 F6              BEQ   LAB_1BA9          ; branch if "$", hex number
03224    
03225    CCE2  C9 25              CMP   #'%'              ; else compare with "%"
03226    CCE4  F0 F2              BEQ   LAB_1BA9          ; branch if "%", binary number
03227    
03228    CCE6  C9 2E              CMP   #'.'              ; compare with "."
03229    CCE8  F0 EE              BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
03230    
03231                                  ; it wasn't any sort of number so ..
03232    CCEA  C9 22              CMP   #$22              ; compare with "
03233    CCEC  F0 D6              BEQ   LAB_1BC1          ; branch if open quote
03234    
03235                                  ; wasn't any sort of number so ..
03236    
03237    ; evaluate expression within parentheses
03238    
03239    CCEE  C9 28              CMP   #'('              ; compare with "("
03240    CCF0  D0 5B              BNE   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
03241    
03242    LAB_1BF7
03243    CCF2  20 EF CB           JSR   LAB_EVEZ          ; evaluate expression, no decrement
03244    
03245    ; all the 'scan for' routines return the character after the sought character
03246    
03247    ; scan for ")" , else do syntax error then warm start
03248    
03249    LAB_1BFB
03250    CCF5  A9 29              LDA   #$29              ; load A with ")"
03251    
03252    ; scan for CHR$(A) , else do syntax error then warm start
03253    
03254    LAB_SCCA
03255    CCF7  A0 00              LDY   #$00              ; clear index
03256    CCF9  D1 C3              CMP   (Bpntrl),Y        ; check next byte is = A
03257    CCFB  D0 0B              BNE   LAB_SNER          ; if not do syntax error then warm start
03258    
03259    CCFD  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then return
03260    
03261    ; scan for "(" , else do syntax error then warm start
03262    
03263    LAB_1BFE
03264    CD00  A9 28              LDA   #$28              ; load A with "("
03265    CD02  D0 F3              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
03266                                  ; (branch always)
03267    
03268    ; scan for "," , else do syntax error then warm start
03269    
03270    LAB_1C01
03271    CD04  A9 2C              LDA   #$2C              ; load A with ","
03272    CD06  D0 EF              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
03273                                  ; (branch always)
03274    
03275    ; syntax error then warm start
03276    
03277    LAB_SNER
03278    CD08  A2 02              LDX   #$02              ; error code $02 ("Syntax" error)
03279    CD0A  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
03280    
03281    ; get value from line .. continued
03282    ; do tokens
03283    
03284    LAB_1BD0
03285    CD0D  C9 B8              CMP   #TK_MINUS         ; compare with token for -
03286    CD0F  F0 29              BEQ   LAB_1C11          ; branch if - token (do set-up for functions)
03287    
03288                                  ; wasn't -n so ..
03289    CD11  C9 B7              CMP   #TK_PLUS          ; compare with token for +
03290    CD13  F0 BE              BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
03291    
03292    CD15  C9 B2              CMP   #TK_NOT           ; compare with token for NOT
03293    CD17  D0 13              BNE   LAB_1BE7          ; branch if not token for NOT
03294    
03295                                  ; was NOT token
03296      000B             TK_EQUAL_PLUS     = TK_EQUAL-TK_PLUS
03297    CD19  A0 21              LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
03298    CD1B  D0 1F              BNE   LAB_1C13          ; do set-up for function then execute (branch always)
03299    
03300    ; do = compare
03301    
03302    LAB_EQUAL
03303    CD1D  20 BA CF           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
03304    CD20  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03305    CD22  49 FF              EOR   #$FF              ; invert it
03306    CD24  A8                 TAY                     ; copy it
03307    CD25  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03308    CD27  49 FF              EOR   #$FF              ; invert it
03309    CD29  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03310    
03311    ; get value from line .. continued
03312    
03313                                  ; wasn't +, -, or NOT so ..
03314    LAB_1BE7
03315    CD2C  C9 AF              CMP   #TK_FN            ; compare with token for FN
03316    CD2E  D0 03              BNE   LAB_1BEE          ; branch if not token for FN
03317    
03318    CD30  4C C8 D1           JMP   LAB_201E          ; go evaluate FNx
03319    
03320    ; get value from line .. continued
03321    
03322                                  ; wasn't +, -, NOT or FN so ..
03323    LAB_1BEE
03324    CD33  E9 C4              SBC   #TK_SGN           ; subtract with token for SGN
03325    CD35  B0 27              BCS   LAB_1C27          ; if a function token go do it
03326    
03327    CD37  4C 08 CD           JMP   LAB_SNER          ; else do syntax error
03328    
03329    ; set-up for functions
03330    
03331    LAB_1C11
03332      000A             TK_GT_PLUS  = TK_GT-TK_PLUS
03333    CD3A  A0 1E              LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
03334    LAB_1C13
03335    CD3C  68                 PLA                     ; dump return address low byte
03336    ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
03337    ; *** replace
03338    ;      PLA                     ; dump return address high byte
03339    ;      JMP   LAB_1B1D          ; execute function then continue evaluation
03340    ; *** with
03341    CD3D  AA                 TAX                     ; save to trap concatenate
03342    CD3E  68                 PLA                     ; dump return address high byte
03343    CD3F  E0 F6              CPX   #<[LAB_224Da+2]   ; from concatenate low return address?
03344    CD41  D0 04              BNE   LAB_1C13b         ; No - continue!
03345    CD43  C9 D3              CMP   #>[LAB_224Da+2]   ; from concatenate high return address?
03346    CD45  F0 03              BEQ   LAB_1C13a         ; Yes - error!
03347    LAB_1C13b
03348    CD47  4C 40 CC           JMP   LAB_1B1D          ; execute function then continue evaluation
03349    LAB_1C13a
03350    CD4A  4C E2 CB           JMP   LAB_1ABC          ; throw "type mismatch error" then warm start      
03351    ; *** end   patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
03352    
03353    ; variable name set-up
03354    ; get (var), return value in FAC_1 and $ flag
03355    
03356    LAB_1C18
03357    CD4D  20 BE CE           JSR   LAB_GVAR          ; get (var) address
03358    CD50  85 AE              STA   FAC1_2            ; save address low byte in FAC1 mantissa2
03359    CD52  84 AF              STY   FAC1_3            ; save address high byte in FAC1 mantissa3
03360    CD54  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
03361    CD56  30 03              BMI   LAB_1C25          ; if string then return (does RTS)
03362    
03363    LAB_1C24
03364    CD58  4C 90 D9           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
03365    
03366    LAB_1C25
03367    ; *** begin patch  string pointer high byte trashed when moved to stack
03368    ; *** add
03369    CD5B  46 B9              LSR   FAC1_r            ; clear bit 7 (<$80) = do not round up
03370    ; *** end patch 
03371    CD5D  60                 RTS
03372    
03373    ; get value from line .. continued
03374    ; only functions left so ..
03375    
03376    ; set up function references
03377    
03378    ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
03379    ; to process function calls. now the function vector is computed and pushed on the stack
03380    ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
03381    ; is calculated and the routine called, if not this routine just does RTS. whichever
03382    ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
03383    ; the function code
03384    
03385    ; this also removes some less than elegant code that was used to bypass type checking
03386    ; for functions that returned strings
03387    
03388    LAB_1C27
03389    CD5E  0A                 ASL                     ; *2 (2 bytes per function address)
03390    CD5F  A8                 TAY                     ; copy to index
03391    
03392    CD60  B9 C0 E3           LDA   LAB_FTBM,Y        ; get function jump vector high byte
03393    CD63  48                 PHA                     ; push functions jump vector high byte
03394    CD64  B9 BF E3           LDA   LAB_FTBL,Y        ; get function jump vector low byte
03395    CD67  48                 PHA                     ; push functions jump vector low byte
03396    
03397    CD68  B9 7A E3           LDA   LAB_FTPM,Y        ; get function pre process vector high byte
03398    CD6B  F0 05              BEQ   LAB_1C56          ; skip pre process if null vector
03399    
03400    CD6D  48                 PHA                     ; push functions pre process vector high byte
03401    CD6E  B9 79 E3           LDA   LAB_FTPL,Y        ; get function pre process vector low byte
03402    CD71  48                 PHA                     ; push functions pre process vector low byte
03403    
03404    LAB_1C56
03405    CD72  60                 RTS                     ; do function, or pre process, call
03406    
03407    ; process string expression in parenthesis
03408    
03409    LAB_PPFS
03410    CD73  20 F2 CC           JSR   LAB_1BF7          ; process expression in parenthesis
03411    CD76  4C D8 CB           JMP   LAB_CTST          ; check if source is string then do function,
03412                                  ; else do type mismatch
03413    
03414    ; process numeric expression in parenthesis
03415    
03416    LAB_PPFN
03417    CD79  20 F2 CC           JSR   LAB_1BF7          ; process expression in parenthesis
03418    CD7C  4C D6 CB           JMP   LAB_CTNM          ; check if source is numeric then do function,
03419                                  ; else do type mismatch
03420    
03421    ; set numeric data type and increment BASIC execute pointer
03422    
03423    LAB_PPBI
03424    CD7F  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
03425    CD81  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then do function
03426    
03427    ; process string for LEFT$, RIGHT$ or MID$
03428    
03429    LAB_LRMS
03430    CD84  20 EF CB           JSR   LAB_EVEZ          ; evaluate (should be string) expression
03431    CD87  20 04 CD           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
03432    CD8A  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
03433    
03434    CD8D  68                 PLA                     ; get function jump vector low byte
03435    CD8E  AA                 TAX                     ; save functions jump vector low byte
03436    CD8F  68                 PLA                     ; get function jump vector high byte
03437    CD90  A8                 TAY                     ; save functions jump vector high byte
03438    CD91  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
03439    CD93  48                 PHA                     ; push string pointer high byte
03440    CD94  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
03441    CD96  48                 PHA                     ; push string pointer low byte
03442    CD97  98                 TYA                     ; get function jump vector high byte back
03443    CD98  48                 PHA                     ; save functions jump vector high byte
03444    CD99  8A                 TXA                     ; get function jump vector low byte back
03445    CD9A  48                 PHA                     ; save functions jump vector low byte
03446    CD9B  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
03447    CD9E  8A                 TXA                     ; copy byte parameter to A
03448    CD9F  60                 RTS                     ; go do function
03449    
03450    ; process numeric expression(s) for BIN$ or HEX$
03451    
03452    LAB_BHSS
03453    CDA0  20 EF CB           JSR   LAB_EVEZ          ; process expression
03454    CDA3  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
03455    CDA6  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03456    CDA8  C9 98              CMP   #$98              ; compare with exponent = 2^24
03457    CDAA  B0 20              BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
03458    
03459    CDAC  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
03460    CDAF  A2 02              LDX   #$02              ; 3 bytes to do
03461    LAB_CFAC
03462    CDB1  B5 AD              LDA   FAC1_1,X          ; get byte from FAC1
03463    CDB3  95 11              STA   nums_1,X          ; save byte to temp
03464    CDB5  CA                 DEX                     ; decrement index
03465    CDB6  10 F9              BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
03466    
03467    CDB8  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
03468    CDBB  A2 00              LDX   #$00              ; set default to no leading "0"s
03469    CDBD  C9 29              CMP   #')'              ; compare with close bracket
03470    CDBF  F0 0A              BEQ   LAB_1C54          ; if ")" go do rest of function
03471    
03472    CDC1  20 F1 D5           JSR   LAB_SCGB          ; scan for "," and get byte
03473    CDC4  20 C2 00           JSR   LAB_GBYT          ; get last byte back
03474    CDC7  C9 29              CMP   #')'              ; is next character )
03475    CDC9  D0 01              BNE   LAB_BHER          ; if not ")" go do error
03476    
03477    LAB_1C54
03478    CDCB  60                 RTS                     ; else do function
03479    
03480    LAB_BHER
03481    CDCC  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
03482    
03483    ; perform EOR
03484    
03485    ; added operator format is the same as AND or OR, precedence is the same as OR
03486    
03487    ; this bit worked first time but it took a while to sort out the operator table
03488    ; pointers and offsets afterwards!
03489    
03490    LAB_EOR
03491    CDCF  20 F6 CD           JSR   GetFirst          ; get first integer expression (no sign check)
03492    CDD2  45 5B              EOR   XOAw_l            ; EOR with expression 1 low byte
03493    CDD4  A8                 TAY                     ; save in Y
03494    CDD5  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03495    CDD7  45 5C              EOR   XOAw_h            ; EOR with expression 1 high byte
03496    CDD9  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03497    
03498    ; perform OR
03499    
03500    LAB_OR
03501    CDDC  20 F6 CD           JSR   GetFirst          ; get first integer expression (no sign check)
03502    CDDF  05 5B              ORA   XOAw_l            ; OR with expression 1 low byte
03503    CDE1  A8                 TAY                     ; save in Y
03504    CDE2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03505    CDE4  05 5C              ORA   XOAw_h            ; OR with expression 1 high byte
03506    CDE6  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03507    
03508    ; perform AND
03509    
03510    LAB_AND
03511    CDE9  20 F6 CD           JSR   GetFirst          ; get first integer expression (no sign check)
03512    CDEC  25 5B              AND   XOAw_l            ; AND with expression 1 low byte
03513    CDEE  A8                 TAY                     ; save in Y
03514    CDEF  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03515    CDF1  25 5C              AND   XOAw_h            ; AND with expression 1 high byte
03516    CDF3  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03517    
03518    ; get first value for OR, AND or EOR
03519    
03520    GetFirst
03521    CDF6  20 BA CF           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
03522    CDF9  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
03523    CDFB  85 5C              STA   XOAw_h            ; save it
03524    CDFD  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03525    CDFF  85 5B              STA   XOAw_l            ; save it
03526    CE01  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
03527    CE04  20 BA CF           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
03528    CE07  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
03529    LAB_1C95
03530    CE09  60                 RTS
03531    
03532    ; perform comparisons
03533    
03534    ; do < compare
03535    
03536    LAB_LTHAN
03537    CE0A  20 D9 CB           JSR   LAB_CKTM          ; type match check, set C for string
03538    CE0D  B0 13              BCS   LAB_1CAE          ; branch if string
03539    
03540                                  ; do numeric < compare
03541    CE0F  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
03542    CE11  09 7F              ORA   #$7F              ; set all non sign bits
03543    CE13  25 B4              AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
03544    CE15  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
03545    CE17  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
03546    CE19  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
03547    CE1B  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
03548    CE1E  AA                 TAX                     ; copy result
03549    CE1F  4C 53 CE           JMP   LAB_1CE1          ; go evaluate result
03550    
03551                                  ; do string < compare
03552    LAB_1CAE
03553    CE22  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
03554    CE24  C6 9B              DEC   comp_f            ; clear < bit in compare function flag
03555    CE26  20 58 D4           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
03556                                  ; space returns with A = length, X=pointer low byte,
03557                                  ; Y=pointer high byte
03558    CE29  85 AC              STA   str_ln            ; save length
03559    CE2B  86 AD              STX   str_pl            ; save string pointer low byte
03560    CE2D  84 AE              STY   str_ph            ; save string pointer high byte
03561    CE2F  A5 B5              LDA   FAC2_2            ; get descriptor pointer low byte
03562    CE31  A4 B6              LDY   FAC2_3            ; get descriptor pointer high byte
03563    CE33  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
03564                                  ; returns with A = length, X=pointer low byte,
03565                                  ; Y=pointer high byte
03566    CE36  86 B5              STX   FAC2_2            ; save string pointer low byte
03567    CE38  84 B6              STY   FAC2_3            ; save string pointer high byte
03568    CE3A  AA                 TAX                     ; copy length
03569    CE3B  38                 SEC                     ; set carry for subtract
03570    CE3C  E5 AC              SBC   str_ln            ; subtract string 1 length
03571    CE3E  F0 08              BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
03572    
03573    CE40  A9 01              LDA   #$01              ; set str 1 length > string 2 length
03574    CE42  90 04              BCC   LAB_1CD6          ; branch if so
03575    
03576    CE44  A6 AC              LDX   str_ln            ; get string 1 length
03577    CE46  A9 FF              LDA   #$FF              ; set str 1 length < string 2 length
03578    LAB_1CD6
03579    CE48  85 B0              STA   FAC1_s            ; save length compare
03580    CE4A  A0 FF              LDY   #$FF              ; set index
03581    CE4C  E8                 INX                     ; adjust for loop
03582    LAB_1CDB
03583    CE4D  C8                 INY                     ; increment index
03584    CE4E  CA                 DEX                     ; decrement count
03585    CE4F  D0 07              BNE   LAB_1CE6          ; branch if still bytes to do
03586    
03587    CE51  A6 B0              LDX   FAC1_s            ; get length compare back
03588    LAB_1CE1
03589    CE53  30 0F              BMI   LAB_1CF2          ; branch if str 1 < str 2
03590    
03591    CE55  18                 CLC                     ; flag str 1 <= str 2
03592    CE56  90 0C              BCC   LAB_1CF2          ; go evaluate result
03593    
03594    LAB_1CE6
03595    CE58  B1 B5              LDA   (FAC2_2),Y        ; get string 2 byte
03596    CE5A  D1 AD              CMP   (FAC1_1),Y        ; compare with string 1 byte
03597    CE5C  F0 EF              BEQ   LAB_1CDB          ; loop if bytes =
03598    
03599    CE5E  A2 FF              LDX   #$FF              ; set str 1 < string 2
03600    CE60  B0 02              BCS   LAB_1CF2          ; branch if so
03601    
03602    CE62  A2 01              LDX   #$01              ;  set str 1 > string 2
03603    LAB_1CF2
03604    CE64  E8                 INX                     ; x = 0, 1 or 2
03605    CE65  8A                 TXA                     ; copy to A
03606    CE66  2A                 ROL                     ; *2 (1, 2 or 4)
03607    CE67  25 63              AND   Cflag             ; AND with comparison evaluation flag
03608    CE69  F0 02              BEQ   LAB_1CFB          ; branch if 0 (compare is false)
03609    
03610    CE6B  A9 FF              LDA   #$FF              ; else set result true
03611    LAB_1CFB
03612    CE6D  4C 0D DA           JMP   LAB_27DB          ; save A as integer byte and return
03613    
03614    LAB_1CFE
03615    CE70  20 04 CD           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
03616    
03617    ; perform DIM
03618    
03619    LAB_DIM
03620    CE73  AA                 TAX                     ; copy "DIM" flag to X
03621    CE74  20 C3 CE           JSR   LAB_1D10          ; search for variable
03622    CE77  20 C2 00           JSR   LAB_GBYT          ; scan memory
03623    CE7A  D0 F4              BNE   LAB_1CFE          ; scan for "," and loop if not null
03624    
03625    CE7C  60                 RTS
03626    
03627    ; perform << (left shift)
03628    
03629    LAB_LSHIFT
03630    CE7D  20 B3 CE           JSR   GetPair           ; get integer expression and byte (no sign check)
03631    CE80  A5 AE              LDA   FAC1_2            ; get expression high byte
03632    CE82  A6 78              LDX   TempB             ; get shift count
03633    CE84  F0 22              BEQ   NoShift           ; branch if zero
03634    
03635    CE86  E0 10              CPX   #$10              ; compare bit count with 16d
03636    CE88  B0 23              BCS   TooBig            ; branch if >=
03637    
03638    Ls_loop
03639    CE8A  06 AF              ASL   FAC1_3            ; shift low byte
03640    CE8C  2A                 ROL                     ; shift high byte
03641    CE8D  CA                 DEX                     ; decrement bit count
03642    CE8E  D0 FA              BNE   Ls_loop           ; loop if shift not complete
03643    
03644    CE90  A4 AF              LDY   FAC1_3            ; get expression low byte
03645    CE92  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03646    
03647    ; perform >> (right shift)
03648    
03649    LAB_RSHIFT
03650    CE95  20 B3 CE           JSR   GetPair           ; get integer expression and byte (no sign check)
03651    CE98  A5 AE              LDA   FAC1_2            ; get expression high byte
03652    CE9A  A6 78              LDX   TempB             ; get shift count
03653    CE9C  F0 0A              BEQ   NoShift           ; branch if zero
03654    
03655    CE9E  E0 10              CPX   #$10              ; compare bit count with 16d
03656    CEA0  B0 0B              BCS   TooBig            ; branch if >=
03657    
03658    Rs_loop
03659    CEA2  4A                 LSR                     ; shift high byte
03660    CEA3  66 AF              ROR   FAC1_3            ; shift low byte
03661    CEA5  CA                 DEX                     ; decrement bit count
03662    CEA6  D0 FA              BNE   Rs_loop           ; loop if shift not complete
03663    
03664    NoShift
03665    CEA8  A4 AF              LDY   FAC1_3            ; get expression low byte
03666    CEAA  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03667    
03668    TooBig
03669    CEAD  A9 00              LDA   #$00              ; clear high byte
03670    CEAF  A8                 TAY                     ; copy to low byte
03671    CEB0  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
03672    
03673    GetPair
03674    CEB3  20 A9 D5           JSR   LAB_EVBY          ; evaluate byte expression, result in X
03675    CEB6  86 78              STX   TempB             ; save it
03676    CEB8  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
03677    CEBB  4C BA CF           JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
03678    
03679    ; search for variable
03680    
03681    ; return pointer to variable in Cvaral/Cvarah
03682    
03683    LAB_GVAR
03684    CEBE  A2 00              LDX   #$00              ; set DIM flag = $00
03685    CEC0  20 C2 00           JSR   LAB_GBYT          ; scan memory (1st character)
03686    LAB_1D10
03687    CEC3  86 5E              STX   Defdim            ; save DIM flag
03688    LAB_1D12
03689    CEC5  85 93              STA   Varnm1            ; save 1st character
03690    CEC7  29 7F              AND   #$7F              ; clear FN flag bit
03691    CEC9  20 32 CF           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
03692    CECC  B0 03              BCS   LAB_1D1F          ; branch if ok
03693    
03694    CECE  4C 08 CD           JMP   LAB_SNER          ; else syntax error then warm start
03695    
03696                                  ; was variable name so ..
03697    LAB_1D1F
03698    CED1  A2 00              LDX   #$00              ; clear 2nd character temp
03699    CED3  86 5F              STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
03700    CED5  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (2nd character)
03701    CED8  90 05              BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
03702    
03703                                  ; 2nd character wasn't "0" to "9" so ..
03704    CEDA  20 32 CF           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
03705    CEDD  90 0B              BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
03706    
03707    LAB_1D2D
03708    CEDF  AA                 TAX                     ; copy 2nd character
03709    
03710                                  ; ignore further (valid) characters in the variable name
03711    LAB_1D2E
03712    CEE0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (3rd character)
03713    CEE3  90 FB              BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
03714    
03715    CEE5  20 32 CF           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
03716    CEE8  B0 F6              BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
03717    
03718                                  ; check if string variable
03719    LAB_1D38
03720    CEEA  C9 24              CMP   #'$'              ; compare with "$"
03721    CEEC  D0 0B              BNE   LAB_1D47          ; branch if not string
03722    
03723    ; to introduce a new variable type (% suffix for integers say) then this branch
03724    ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
03725    
03726                                  ; type is string
03727    CEEE  A9 FF              LDA   #$FF              ; set data type = string
03728    CEF0  85 5F              STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
03729    CEF2  8A                 TXA                     ; get 2nd character back
03730    CEF3  09 80              ORA   #$80              ; set top bit (indicate string var)
03731    CEF5  AA                 TAX                     ; copy back to 2nd character temp
03732    CEF6  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03733    
03734    ; after we have determined the variable type we need to come back here to determine
03735    ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
03736    
03737    
03738    LAB_1D47                      ; gets here with character after var name in A
03739    CEF9  86 94              STX   Varnm2            ; save 2nd character
03740    CEFB  05 61              ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
03741    CEFD  C9 28              CMP   #'('              ; compare with "("
03742    CEFF  D0 03              BNE   LAB_1D53          ; branch if not "("
03743    
03744    CF01  4C CC CF           JMP   LAB_1E17          ; go find, or make, array
03745    
03746    ; either find or create var
03747    ; var name (1st two characters only!) is in Varnm1,Varnm2
03748    
03749                                  ; variable name wasn't var(... so look for plain var
03750    LAB_1D53
03751    CF04  A9 00              LDA   #$00              ; clear A
03752    CF06  85 61              STA   Sufnxf            ; clear subscript/FNX flag
03753    CF08  A5 7B              LDA   Svarl             ; get start of vars low byte
03754    CF0A  A6 7C              LDX   Svarh             ; get start of vars high byte
03755    CF0C  A0 00              LDY   #$00              ; clear index
03756    LAB_1D5D
03757    CF0E  86 AB              STX   Vrschh            ; save search address high byte
03758    LAB_1D5F
03759    CF10  85 AA              STA   Vrschl            ; save search address low byte
03760    CF12  E4 7E              CPX   Sarryh            ; compare high address with var space end
03761    CF14  D0 04              BNE   LAB_1D69          ; skip next compare if <>
03762    
03763                                  ; high addresses were = so compare low addresses
03764    CF16  C5 7D              CMP   Sarryl            ; compare low address with var space end
03765    CF18  F0 2C              BEQ   LAB_1D8B          ; if not found go make new var
03766    
03767    LAB_1D69
03768    CF1A  A5 93              LDA   Varnm1            ; get 1st character of var to find
03769    CF1C  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 1st character
03770    CF1E  D0 08              BNE   LAB_1D77          ; branch if no match
03771    
03772                                  ; 1st characters match so compare 2nd characters
03773    CF20  A5 94              LDA   Varnm2            ; get 2nd character of var to find
03774    CF22  C8                 INY                     ; index to point to variable name 2nd character
03775    CF23  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 2nd character
03776    CF25  F0 69              BEQ   LAB_1DD7          ; branch if match (found var)
03777    
03778    CF27  88                 DEY                     ; else decrement index (now = $00)
03779    LAB_1D77
03780    CF28  18                 CLC                     ; clear carry for add
03781    CF29  A5 AA              LDA   Vrschl            ; get search address low byte
03782    CF2B  69 06              ADC   #$06              ; +6 (offset to next var name)
03783    CF2D  90 E1              BCC   LAB_1D5F          ; loop if no overflow to high byte
03784    
03785    CF2F  E8                 INX                     ; else increment high byte
03786    CF30  D0 DC              BNE   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
03787    
03788    ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
03789    
03790    LAB_CASC
03791    CF32  C9 61              CMP   #'a'              ; compare with "a"
03792    CF34  B0 0A              BCS   LAB_1D83          ; go check <"z"+1
03793    
03794    ; check byte, return C=0 if<"A" or >"Z"
03795    
03796    LAB_1D82
03797    CF36  C9 41              CMP   #'A'              ; compare with "A"
03798    CF38  90 05              BCC   LAB_1D8A          ; exit if less
03799    
03800                                  ; carry is set
03801    CF3A  E9 5B              SBC   #$5B              ; subtract "Z"+1
03802    CF3C  38                 SEC                     ; set carry
03803    CF3D  E9 A5              SBC   #$A5              ; subtract $A5 (restore byte)
03804                                  ; carry clear if byte>$5A
03805    LAB_1D8A
03806    CF3F  60                 RTS
03807    
03808    LAB_1D83
03809    CF40  E9 7B              SBC   #$7B              ; subtract "z"+1
03810    CF42  38                 SEC                     ; set carry
03811    CF43  E9 85              SBC   #$85              ; subtract $85 (restore byte)
03812                                  ; carry clear if byte>$7A
03813    CF45  60                 RTS
03814    
03815                                  ; reached end of variable mem without match
03816                                  ; .. so create new variable
03817    LAB_1D8B
03818    CF46  68                 PLA                     ; pop return address low byte
03819    CF47  48                 PHA                     ; push return address low byte
03820      CD4F             LAB_1C18p2  = LAB_1C18+2
03821    CF48  C9 4F              CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
03822    CF4A  D0 05              BNE   LAB_1D98          ; if not get (var) go create new var
03823    
03824    ; This will only drop through if the call was from LAB_1C18 and is only called
03825    ; from there if it is searching for a variable from the RHS of a LET a=b statement
03826    ; it prevents the creation of variables not assigned a value.
03827    
03828    ; value returned by this is either numeric zero (exponent byte is $00) or null string
03829    ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
03830    
03831    ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
03832    
03833    ; this is where you would put the undefined variable error call e.g.
03834    
03835    ;                             ; variable doesn't exist so flag error
03836    ;     LDX   #$24              ; error code $24 ("undefined variable" error)
03837    ;     JMP   LAB_XERR          ; do error #X then warm start
03838    
03839    ; the above code has been tested and works a treat! (it replaces the three code lines
03840    ; below)
03841    
03842                                  ; else return dummy null value
03843    CF4C  A9 FB              LDA   #<LAB_1D96        ; low byte point to $00,$00
03844                                  ; (uses part of misc constants table)
03845    CF4E  A0 E2              LDY   #>LAB_1D96        ; high byte point to $00,$00
03846    CF50  60                 RTS
03847    
03848                                  ; create new numeric variable
03849    LAB_1D98
03850    CF51  A5 7D              LDA   Sarryl            ; get var mem end low byte
03851    CF53  A4 7E              LDY   Sarryh            ; get var mem end high byte
03852    CF55  85 AA              STA   Ostrtl            ; save old block start low byte
03853    CF57  84 AB              STY   Ostrth            ; save old block start high byte
03854    CF59  A5 7F              LDA   Earryl            ; get array mem end low byte
03855    CF5B  A4 80              LDY   Earryh            ; get array mem end high byte
03856    CF5D  85 A6              STA   Obendl            ; save old block end low byte
03857    CF5F  84 A7              STY   Obendh            ; save old block end high byte
03858    CF61  18                 CLC                     ; clear carry for add
03859    CF62  69 06              ADC   #$06              ; +6 (space for one var)
03860    CF64  90 01              BCC   LAB_1DAE          ; branch if no overflow to high byte
03861    
03862    CF66  C8                 INY                     ; else increment high byte
03863    LAB_1DAE
03864    CF67  85 A4              STA   Nbendl            ; set new block end low byte
03865    CF69  84 A5              STY   Nbendh            ; set new block end high byte
03866    CF6B  20 C1 C1           JSR   LAB_11CF          ; open up space in memory
03867    CF6E  A5 A4              LDA   Nbendl            ; get new start low byte
03868    CF70  A4 A5              LDY   Nbendh            ; get new start high byte (-$100)
03869    CF72  C8                 INY                     ; correct high byte
03870    CF73  85 7D              STA   Sarryl            ; save new var mem end low byte
03871    CF75  84 7E              STY   Sarryh            ; save new var mem end high byte
03872    CF77  A0 00              LDY   #$00              ; clear index
03873    CF79  A5 93              LDA   Varnm1            ; get var name 1st character
03874    CF7B  91 AA              STA   (Vrschl),Y        ; save var name 1st character
03875    CF7D  C8                 INY                     ; increment index
03876    CF7E  A5 94              LDA   Varnm2            ; get var name 2nd character
03877    CF80  91 AA              STA   (Vrschl),Y        ; save var name 2nd character
03878    CF82  A9 00              LDA   #$00              ; clear A
03879    CF84  C8                 INY                     ; increment index
03880    CF85  91 AA              STA   (Vrschl),Y        ; initialise var byte
03881    CF87  C8                 INY                     ; increment index
03882    CF88  91 AA              STA   (Vrschl),Y        ; initialise var byte
03883    CF8A  C8                 INY                     ; increment index
03884    CF8B  91 AA              STA   (Vrschl),Y        ; initialise var byte
03885    CF8D  C8                 INY                     ; increment index
03886    CF8E  91 AA              STA   (Vrschl),Y        ; initialise var byte
03887    
03888                                  ; found a match for var ((Vrschl) = ptr)
03889    LAB_1DD7
03890    CF90  A5 AA              LDA   Vrschl            ; get var address low byte
03891    CF92  18                 CLC                     ; clear carry for add
03892    CF93  69 02              ADC   #$02              ; +2 (offset past var name bytes)
03893    CF95  A4 AB              LDY   Vrschh            ; get var address high byte
03894    CF97  90 01              BCC   LAB_1DE1          ; branch if no overflow from add
03895    
03896    CF99  C8                 INY                     ; else increment high byte
03897    LAB_1DE1
03898    CF9A  85 95              STA   Cvaral            ; save current var address low byte
03899    CF9C  84 96              STY   Cvarah            ; save current var address high byte
03900    CF9E  60                 RTS
03901    
03902    ; set-up array pointer (Adatal/h) to first element in array
03903    ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
03904    
03905    LAB_1DE6
03906    CF9F  A5 5D              LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
03907    CFA1  0A                 ASL                     ; *2 (also clears the carry !)
03908    CFA2  69 05              ADC   #$05              ; +5 (result is 7, 9 or 11 here)
03909    CFA4  65 AA              ADC   Astrtl            ; add array start pointer low byte
03910    CFA6  A4 AB              LDY   Astrth            ; get array pointer high byte
03911    CFA8  90 01              BCC   LAB_1DF2          ; branch if no overflow
03912    
03913    CFAA  C8                 INY                     ; else increment high byte
03914    LAB_1DF2
03915    CFAB  85 A4              STA   Adatal            ; save array data pointer low byte
03916    CFAD  84 A5              STY   Adatah            ; save array data pointer high byte
03917    CFAF  60                 RTS
03918    
03919    ; evaluate integer expression
03920    
03921    LAB_EVIN
03922    CFB0  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
03923    CFB3  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
03924                                  ; else do type mismatch
03925    
03926    ; evaluate integer expression (no check)
03927    
03928    LAB_EVPI
03929    CFB6  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
03930    CFB8  30 0D              BMI   LAB_1E12          ; do function call error if -ve
03931    
03932    ; evaluate integer expression (no sign check)
03933    
03934    LAB_EVIR
03935    CFBA  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
03936    CFBC  C9 90              CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
03937    CFBE  90 09              BCC   LAB_1E14          ; branch if n<2^16 (is ok)
03938    
03939    CFC0  A9 02              LDA   #<LAB_1DF7        ; set pointer low byte to -32768
03940    CFC2  A0 E3              LDY   #>LAB_1DF7        ; set pointer high byte to -32768
03941    CFC4  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
03942    LAB_1E12
03943    CFC7  D0 74              BNE   LAB_FCER          ; if <> do function call error then warm start
03944    
03945    LAB_1E14
03946    CFC9  4C 63 DA           JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
03947    
03948    ; find or make array
03949    
03950    LAB_1E17
03951    CFCC  A5 5E              LDA   Defdim            ; get DIM flag
03952    CFCE  48                 PHA                     ; push it
03953    CFCF  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
03954    CFD1  48                 PHA                     ; push it
03955    CFD2  A0 00              LDY   #$00              ; clear dimensions count
03956    
03957    ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
03958    
03959    LAB_1E1F
03960    CFD4  98                 TYA                     ; copy dimensions count
03961    CFD5  48                 PHA                     ; save it
03962    CFD6  A5 94              LDA   Varnm2            ; get array name 2nd byte
03963    CFD8  48                 PHA                     ; save it
03964    CFD9  A5 93              LDA   Varnm1            ; get array name 1st byte
03965    CFDB  48                 PHA                     ; save it
03966    CFDC  20 B0 CF           JSR   LAB_EVIN          ; evaluate integer expression
03967    CFDF  68                 PLA                     ; pull array name 1st byte
03968    CFE0  85 93              STA   Varnm1            ; restore array name 1st byte
03969    CFE2  68                 PLA                     ; pull array name 2nd byte
03970    CFE3  85 94              STA   Varnm2            ; restore array name 2nd byte
03971    CFE5  68                 PLA                     ; pull dimensions count
03972    CFE6  A8                 TAY                     ; restore it
03973    CFE7  BA                 TSX                     ; copy stack pointer
03974    CFE8  BD 02 01           LDA   LAB_STAK+2,X      ; get DIM flag
03975    CFEB  48                 PHA                     ; push it
03976    CFEC  BD 01 01           LDA   LAB_STAK+1,X      ; get data type flag
03977    CFEF  48                 PHA                     ; push it
03978    CFF0  A5 AE              LDA   FAC1_2            ; get this dimension size high byte
03979    CFF2  9D 02 01           STA   LAB_STAK+2,X      ; stack before flag bytes
03980    CFF5  A5 AF              LDA   FAC1_3            ; get this dimension size low byte
03981    CFF7  9D 01 01           STA   LAB_STAK+1,X      ; stack before flag bytes
03982    CFFA  C8                 INY                     ; increment dimensions count
03983    CFFB  20 C2 00           JSR   LAB_GBYT          ; scan memory
03984    CFFE  C9 2C              CMP   #','              ; compare with ","
03985    D000  F0 D2              BEQ   LAB_1E1F          ; if found go do next dimension
03986    
03987    D002  84 5D              STY   Dimcnt            ; store dimensions count
03988    D004  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
03989    D007  68                 PLA                     ; pull data type flag
03990    D008  85 5F              STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
03991    D00A  68                 PLA                     ; pull DIM flag
03992    D00B  85 5E              STA   Defdim            ; restore DIM flag
03993    D00D  A6 7D              LDX   Sarryl            ; get array mem start low byte
03994    D00F  A5 7E              LDA   Sarryh            ; get array mem start high byte
03995    
03996    ; now check to see if we are at the end of array memory (we would be if there were
03997    ; no arrays).
03998    
03999    LAB_1E5C
04000    D011  86 AA              STX   Astrtl            ; save as array start pointer low byte
04001    D013  85 AB              STA   Astrth            ; save as array start pointer high byte
04002    D015  C5 80              CMP   Earryh            ; compare with array mem end high byte
04003    D017  D0 04              BNE   LAB_1E68          ; branch if not reached array mem end
04004    
04005    D019  E4 7F              CPX   Earryl            ; else compare with array mem end low byte
04006    D01B  F0 39              BEQ   LAB_1EA1          ; go build array if not found
04007    
04008                                  ; search for array
04009    LAB_1E68
04010    D01D  A0 00              LDY   #$00              ; clear index
04011    D01F  B1 AA              LDA   (Astrtl),Y        ; get array name first byte
04012    D021  C8                 INY                     ; increment index to second name byte
04013    D022  C5 93              CMP   Varnm1            ; compare with this array name first byte
04014    D024  D0 06              BNE   LAB_1E77          ; branch if no match
04015    
04016    D026  A5 94              LDA   Varnm2            ; else get this array name second byte
04017    D028  D1 AA              CMP   (Astrtl),Y        ; compare with array name second byte
04018    D02A  F0 16              BEQ   LAB_1E8D          ; array found so branch
04019    
04020                                  ; no match
04021    LAB_1E77
04022    D02C  C8                 INY                     ; increment index
04023    D02D  B1 AA              LDA   (Astrtl),Y        ; get array size low byte
04024    D02F  18                 CLC                     ; clear carry for add
04025    D030  65 AA              ADC   Astrtl            ; add array start pointer low byte
04026    D032  AA                 TAX                     ; copy low byte to X
04027    D033  C8                 INY                     ; increment index
04028    D034  B1 AA              LDA   (Astrtl),Y        ; get array size high byte
04029    D036  65 AB              ADC   Astrth            ; add array mem pointer high byte
04030    D038  90 D7              BCC   LAB_1E5C          ; if no overflow go check next array
04031    
04032    ; do array bounds error
04033    
04034    LAB_1E85
04035    D03A  A2 10              LDX   #$10              ; error code $10 ("Array bounds" error)
04036          .byte $2C               ; makes next bit BIT LAB_08A2
04037    
04038    ; do function call error
04039    
04040    LAB_FCER
04041    D03D  A2 08              LDX   #$08              ; error code $08 ("Function call" error)
04042    LAB_1E8A
04043    D03F  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
04044    
04045                                  ; found array, are we trying to dimension it?
04046    LAB_1E8D
04047    D042  A2 12              LDX   #$12              ; set error $12 ("Double dimension" error)
04048    D044  A5 5E              LDA   Defdim            ; get DIM flag
04049    D046  D0 F7              BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
04050                                  ; start
04051    
04052    ; found the array and we're not dimensioning it so we must find an element in it
04053    
04054    D048  20 9F CF           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
04055                                  ; (Astrtl,Astrth points to start of array)
04056    D04B  A5 5D              LDA   Dimcnt            ; get dimensions count
04057    D04D  A0 04              LDY   #$04              ; set index to array's # of dimensions
04058    D04F  D1 AA              CMP   (Astrtl),Y        ; compare with no of dimensions
04059    D051  D0 E7              BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
04060                                  ; dimensions" error here .. if we want a different
04061                                  ; error message
04062    
04063    D053  4C D9 D0           JMP   LAB_1F28          ; found array so go get element
04064                                  ; (could jump to LAB_1F28 as all LAB_1F24 does is take
04065                                  ; Dimcnt and save it at (Astrtl),Y which is already the
04066                                  ; same or we would have taken the BNE)
04067    
04068                                  ; array not found, so build it
04069    LAB_1EA1
04070    D056  20 9F CF           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
04071                                  ; (Astrtl,Astrth points to start of array)
04072    D059  20 0E C2           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
04073                                  ; addr to check is in AY (low/high)
04074    D05C  A0 00              LDY   #$00              ; clear Y (don't need to clear A)
04075    D05E  84 BB              STY   Aspth             ; clear array data size high byte
04076    D060  A5 93              LDA   Varnm1            ; get variable name 1st byte
04077    D062  91 AA              STA   (Astrtl),Y        ; save array name 1st byte
04078    D064  C8                 INY                     ; increment index
04079    D065  A5 94              LDA   Varnm2            ; get variable name 2nd byte
04080    D067  91 AA              STA   (Astrtl),Y        ; save array name 2nd byte
04081    D069  A5 5D              LDA   Dimcnt            ; get dimensions count
04082    D06B  A0 04              LDY   #$04              ; index to dimension count
04083    D06D  84 BA              STY   Asptl             ; set array data size low byte (four bytes per element)
04084    D06F  91 AA              STA   (Astrtl),Y        ; set array's dimensions count
04085    
04086                                  ; now calculate the size of the data space for the array
04087    D071  18                 CLC                     ; clear carry for add (clear on subsequent loops)
04088    LAB_1EC0
04089    D072  A2 0B              LDX   #$0B              ; set default dimension value low byte
04090    D074  A9 00              LDA   #$00              ; set default dimension value high byte
04091    D076  24 5E              BIT   Defdim            ; test default DIM flag
04092    D078  50 07              BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
04093    
04094    D07A  68                 PLA                     ; else pull dimension value low byte
04095    D07B  69 01              ADC   #$01              ; +1 (allow for zeroeth element)
04096    D07D  AA                 TAX                     ; copy low byte to X
04097    D07E  68                 PLA                     ; pull dimension value high byte
04098    D07F  69 00              ADC   #$00              ; add carry from low byte
04099    
04100    LAB_1ED0
04101    D081  C8                 INY                     ; index to dimension value high byte
04102    D082  91 AA              STA   (Astrtl),Y        ; save dimension value high byte
04103    D084  C8                 INY                     ; index to dimension value high byte
04104    D085  8A                 TXA                     ; get dimension value low byte
04105    D086  91 AA              STA   (Astrtl),Y        ; save dimension value low byte
04106    D088  20 28 D1           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
04107    D08B  86 BA              STX   Asptl             ; save array data size low byte
04108    D08D  85 BB              STA   Aspth             ; save array data size high byte
04109    D08F  A4 71              LDY   ut1_pl            ; restore index (saved by subroutine)
04110    D091  C6 5D              DEC   Dimcnt            ; decrement dimensions count
04111    D093  D0 DD              BNE   LAB_1EC0          ; loop while not = 0
04112    
04113    D095  65 A5              ADC   Adatah            ; add size high byte to first element high byte
04114                                  ; (carry is always clear here)
04115    D097  B0 5D              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
04116    
04117    D099  85 A5              STA   Adatah            ; save end of array high byte
04118    D09B  A8                 TAY                     ; copy end high byte to Y
04119    D09C  8A                 TXA                     ; get array size low byte
04120    D09D  65 A4              ADC   Adatal            ; add array start low byte
04121    D09F  90 03              BCC   LAB_1EF3          ; branch if no carry
04122    
04123    D0A1  C8                 INY                     ; else increment end of array high byte
04124    D0A2  F0 52              BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
04125    
04126                                  ; set-up mostly complete, now zero the array
04127    LAB_1EF3
04128    D0A4  20 0E C2           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
04129                                  ; addr to check is in AY (low/high)
04130    D0A7  85 7F              STA   Earryl            ; save array mem end low byte
04131    D0A9  84 80              STY   Earryh            ; save array mem end high byte
04132    D0AB  A9 00              LDA   #$00              ; clear byte for array clear
04133    D0AD  E6 BB              INC   Aspth             ; increment array size high byte (now block count)
04134    D0AF  A4 BA              LDY   Asptl             ; get array size low byte (now index to block)
04135    D0B1  F0 05              BEQ   LAB_1F07          ; branch if low byte = $00
04136    
04137    LAB_1F02
04138    D0B3  88                 DEY                     ; decrement index (do 0 to n-1)
04139    D0B4  91 A4              STA   (Adatal),Y        ; zero byte
04140    D0B6  D0 FB              BNE   LAB_1F02          ; loop until this block done
04141    
04142    LAB_1F07
04143    D0B8  C6 A5              DEC   Adatah            ; decrement array pointer high byte
04144    D0BA  C6 BB              DEC   Aspth             ; decrement block count high byte
04145    D0BC  D0 F5              BNE   LAB_1F02          ; loop until all blocks done
04146    
04147    D0BE  E6 A5              INC   Adatah            ; correct for last loop
04148    D0C0  38                 SEC                     ; set carry for subtract
04149    D0C1  A0 02              LDY   #$02              ; index to array size low byte
04150    D0C3  A5 7F              LDA   Earryl            ; get array mem end low byte
04151    D0C5  E5 AA              SBC   Astrtl            ; subtract array start low byte
04152    D0C7  91 AA              STA   (Astrtl),Y        ; save array size low byte
04153    D0C9  C8                 INY                     ; index to array size high byte
04154    D0CA  A5 80              LDA   Earryh            ; get array mem end high byte
04155    D0CC  E5 AB              SBC   Astrth            ; subtract array start high byte
04156    D0CE  91 AA              STA   (Astrtl),Y        ; save array size high byte
04157    D0D0  A5 5E              LDA   Defdim            ; get default DIM flag
04158    D0D2  D0 53              BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
04159    
04160                                  ; else, find element
04161    D0D4  C8                 INY                     ; index to # of dimensions
04162    
04163    LAB_1F24
04164    D0D5  B1 AA              LDA   (Astrtl),Y        ; get array's dimension count
04165    D0D7  85 5D              STA   Dimcnt            ; save it
04166    
04167    ; we have found, or built, the array. now we need to find the element
04168    
04169    LAB_1F28
04170    D0D9  A9 00              LDA   #$00              ; clear byte
04171    D0DB  85 BA              STA   Asptl             ; clear array data pointer low byte
04172    LAB_1F2C
04173    D0DD  85 BB              STA   Aspth             ; save array data pointer high byte
04174    D0DF  C8                 INY                     ; increment index (point to array bound high byte)
04175    D0E0  68                 PLA                     ; pull array index low byte
04176    D0E1  AA                 TAX                     ; copy to X
04177    D0E2  85 AE              STA   FAC1_2            ; save index low byte to FAC1 mantissa2
04178    D0E4  68                 PLA                     ; pull array index high byte
04179    D0E5  85 AF              STA   FAC1_3            ; save index high byte to FAC1 mantissa3
04180    D0E7  D1 AA              CMP   (Astrtl),Y        ; compare with array bound high byte
04181    D0E9  90 0E              BCC   LAB_1F48          ; branch if within bounds
04182    
04183    D0EB  D0 06              BNE   LAB_1F42          ; if outside bounds do array bounds error
04184    
04185                                  ; else high byte was = so test low bytes
04186    D0ED  C8                 INY                     ; index to array bound low byte
04187    D0EE  8A                 TXA                     ; get array index low byte
04188    D0EF  D1 AA              CMP   (Astrtl),Y        ; compare with array bound low byte
04189    D0F1  90 07              BCC   LAB_1F49          ; branch if within bounds
04190    
04191    LAB_1F42
04192    D0F3  4C 3A D0           JMP   LAB_1E85          ; else do array bounds error
04193    
04194    LAB_1F45
04195    D0F6  4C 3D C2           JMP   LAB_OMER          ; do "Out of memory" error then warm start
04196    
04197    LAB_1F48
04198    D0F9  C8                 INY                     ; index to array bound low byte
04199    LAB_1F49
04200    D0FA  A5 BB              LDA   Aspth             ; get array data pointer high byte
04201    D0FC  05 BA              ORA   Asptl             ; OR with array data pointer low byte
04202    D0FE  F0 0A              BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
04203    
04204    D100  20 28 D1           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
04205    D103  8A                 TXA                     ; get result low byte
04206    D104  65 AE              ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
04207    D106  AA                 TAX                     ; save result low byte
04208    D107  98                 TYA                     ; get result high byte
04209    D108  A4 71              LDY   ut1_pl            ; restore index
04210    LAB_1F5A
04211    D10A  65 AF              ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
04212    D10C  86 BA              STX   Asptl             ; save array data pointer low byte
04213    D10E  C6 5D              DEC   Dimcnt            ; decrement dimensions count
04214    D110  D0 CB              BNE   LAB_1F2C          ; loop if dimensions still to do
04215    
04216    D112  06 BA              ASL   Asptl             ; array data pointer low byte * 2
04217    D114  2A                 ROL                     ; array data pointer high byte * 2
04218    D115  06 BA              ASL   Asptl             ; array data pointer low byte * 4
04219    D117  2A                 ROL                     ; array data pointer high byte * 4
04220    D118  A8                 TAY                     ; copy high byte
04221    D119  A5 BA              LDA   Asptl             ; get low byte
04222    D11B  65 A4              ADC   Adatal            ; add array data start pointer low byte
04223    D11D  85 95              STA   Cvaral            ; save as current var address low byte
04224    D11F  98                 TYA                     ; get high byte back
04225    D120  65 A5              ADC   Adatah            ; add array data start pointer high byte
04226    D122  85 96              STA   Cvarah            ; save as current var address high byte
04227    D124  A8                 TAY                     ; copy high byte to Y
04228    D125  A5 95              LDA   Cvaral            ; get current var address low byte
04229    LAB_1F7B
04230    D127  60                 RTS
04231    
04232    ; does XY = (Astrtl),Y * (Asptl)
04233    
04234    LAB_1F7C
04235    D128  84 71              STY   ut1_pl            ; save index
04236    D12A  B1 AA              LDA   (Astrtl),Y        ; get dimension size low byte
04237    D12C  85 76              STA   dims_l            ; save dimension size low byte
04238    D12E  88                 DEY                     ; decrement index
04239    D12F  B1 AA              LDA   (Astrtl),Y        ; get dimension size high byte
04240    D131  85 77              STA   dims_h            ; save dimension size high byte
04241    
04242    D133  A9 10              LDA   #$10              ; count = $10 (16 bit multiply)
04243    D135  85 A8              STA   numbit            ; save bit count
04244    D137  A2 00              LDX   #$00              ; clear result low byte
04245    D139  A0 00              LDY   #$00              ; clear result high byte
04246    LAB_1F8F
04247    D13B  8A                 TXA                     ; get result low byte
04248    D13C  0A                 ASL                     ; *2
04249    D13D  AA                 TAX                     ; save result low byte
04250    D13E  98                 TYA                     ; get result high byte
04251    D13F  2A                 ROL                     ; *2
04252    D140  A8                 TAY                     ; save result high byte
04253    D141  B0 B3              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
04254    
04255    D143  06 BA              ASL   Asptl             ; shift multiplier low byte
04256    D145  26 BB              ROL   Aspth             ; shift multiplier high byte
04257    D147  90 0B              BCC   LAB_1FA8          ; skip add if no carry
04258    
04259    D149  18                 CLC                     ; else clear carry for add
04260    D14A  8A                 TXA                     ; get result low byte
04261    D14B  65 76              ADC   dims_l            ; add dimension size low byte
04262    D14D  AA                 TAX                     ; save result low byte
04263    D14E  98                 TYA                     ; get result high byte
04264    D14F  65 77              ADC   dims_h            ; add dimension size high byte
04265    D151  A8                 TAY                     ; save result high byte
04266    D152  B0 A2              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
04267    
04268    LAB_1FA8
04269    D154  C6 A8              DEC   numbit            ; decrement bit count
04270    D156  D0 E3              BNE   LAB_1F8F          ; loop until all done
04271    
04272    D158  60                 RTS
04273    
04274    ; perform FRE()
04275    
04276    LAB_FRE
04277    D159  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
04278    D15B  10 03              BPL   LAB_1FB4          ; branch if numeric
04279    
04280    D15D  20 58 D4           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
04281                                  ; space returns with A = length, X=$71=pointer low byte,
04282                                  ; Y=$72=pointer high byte
04283    
04284                                  ; FRE(n) was numeric so do this
04285    LAB_1FB4
04286    D160  20 F5 D2           JSR   LAB_GARB          ; go do garbage collection
04287    D163  38                 SEC                     ; set carry for subtract
04288    D164  A5 81              LDA   Sstorl            ; get bottom of string space low byte
04289    D166  E5 7F              SBC   Earryl            ; subtract array mem end low byte
04290    D168  A8                 TAY                     ; copy result to Y
04291    D169  A5 82              LDA   Sstorh            ; get bottom of string space high byte
04292    D16B  E5 80              SBC   Earryh            ; subtract array mem end high byte
04293    
04294    ; save and convert integer AY to FAC1
04295    
04296    LAB_AYFC
04297    D16D  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
04298    D16F  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
04299    D171  84 AE              STY   FAC1_2            ; save FAC1 mantissa2
04300    D173  A2 90              LDX   #$90              ; set exponent=2^16 (integer)
04301    D175  4C 15 DA           JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
04302    
04303    ; perform POS()
04304    
04305    LAB_POS
04306    D178  A4 0E              LDY   TPos              ; get terminal position
04307    
04308    ; convert Y to byte in FAC1
04309    
04310    LAB_1FD0
04311    D17A  A9 00              LDA   #$00              ; clear high byte
04312    D17C  F0 EF              BEQ   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
04313    
04314    ; check not Direct (used by DEF and INPUT)
04315    
04316    LAB_CKRN
04317    D17E  A6 88              LDX   Clineh            ; get current line high byte
04318    D180  E8                 INX                     ; increment it
04319    D181  D0 A4              BNE   LAB_1F7B          ; return if can continue not direct mode
04320    
04321                                  ; else do illegal direct error
04322    LAB_1FD9
04323    D183  A2 16              LDX   #$16              ; error code $16 ("Illegal direct" error)
04324    LAB_1FDB
04325    D185  4C 3F C2           JMP   LAB_XERR          ; go do error #X, then warm start
04326    
04327    ; perform DEF
04328    
04329    LAB_DEF
04330    D188  20 B9 D1           JSR   LAB_200B          ; check FNx syntax
04331    D18B  85 9C              STA   func_l            ; save function pointer low byte
04332    D18D  84 9D              STY   func_h            ; save function pointer high byte
04333    D18F  20 7E D1           JSR   LAB_CKRN          ; check not Direct (back here if ok)
04334    D192  20 00 CD           JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
04335    D195  A9 80              LDA   #$80              ; set flag for FNx
04336    D197  85 61              STA   Sufnxf            ; save subscript/FNx flag
04337    D199  20 BE CE           JSR   LAB_GVAR          ; get (var) address
04338    D19C  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
04339    D19F  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
04340    D1A2  A9 C2              LDA   #TK_EQUAL         ; get = token
04341    D1A4  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
04342    D1A7  A5 96              LDA   Cvarah            ; get current var address high byte
04343    D1A9  48                 PHA                     ; push it
04344    D1AA  A5 95              LDA   Cvaral            ; get current var address low byte
04345    D1AC  48                 PHA                     ; push it
04346    D1AD  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
04347    D1AF  48                 PHA                     ; push it
04348    D1B0  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
04349    D1B2  48                 PHA                     ; push it
04350    D1B3  20 90 C7           JSR   LAB_DATA          ; go perform DATA
04351    D1B6  4C 28 D2           JMP   LAB_207A          ; put execute pointer and variable pointer into function
04352                                  ; and return
04353    
04354    ; check FNx syntax
04355    
04356    LAB_200B
04357    D1B9  A9 AF              LDA   #TK_FN            ; get FN" token
04358    D1BB  20 F7 CC           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
04359                                  ; return character after A
04360    D1BE  09 80              ORA   #$80              ; set FN flag bit
04361    D1C0  85 61              STA   Sufnxf            ; save FN flag so array variable test fails
04362    D1C2  20 C5 CE           JSR   LAB_1D12          ; search for FN variable
04363    D1C5  4C D6 CB           JMP   LAB_CTNM          ; check if source is numeric and return, else do type
04364                                  ; mismatch
04365    
04366                                  ; Evaluate FNx
04367    LAB_201E
04368    D1C8  20 B9 D1           JSR   LAB_200B          ; check FNx syntax
04369    D1CB  48                 PHA                     ; push function pointer low byte
04370    D1CC  98                 TYA                     ; copy function pointer high byte
04371    D1CD  48                 PHA                     ; push function pointer high byte
04372    D1CE  20 00 CD           JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
04373    D1D1  20 E7 CB           JSR   LAB_EVEX          ; evaluate expression
04374    D1D4  20 F5 CC           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
04375    D1D7  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
04376    D1DA  68                 PLA                     ; pop function pointer high byte
04377    D1DB  85 9D              STA   func_h            ; restore it
04378    D1DD  68                 PLA                     ; pop function pointer low byte
04379    D1DE  85 9C              STA   func_l            ; restore it
04380    D1E0  A2 20              LDX   #$20              ; error code $20 ("Undefined function" error)
04381    D1E2  A0 03              LDY   #$03              ; index to variable pointer high byte
04382    D1E4  B1 9C              LDA   (func_l),Y        ; get variable pointer high byte
04383    D1E6  F0 9D              BEQ   LAB_1FDB          ; if zero go do undefined function error
04384    
04385    D1E8  85 96              STA   Cvarah            ; save variable address high byte
04386    D1EA  88                 DEY                     ; index to variable address low byte
04387    D1EB  B1 9C              LDA   (func_l),Y        ; get variable address low byte
04388    D1ED  85 95              STA   Cvaral            ; save variable address low byte
04389    D1EF  AA                 TAX                     ; copy address low byte
04390    
04391                                  ; now stack the function variable value before use
04392    D1F0  C8                 INY                     ; index to mantissa_3
04393    LAB_2043
04394    D1F1  B1 95              LDA   (Cvaral),Y        ; get byte from variable
04395    D1F3  48                 PHA                     ; stack it
04396    D1F4  88                 DEY                     ; decrement index
04397    D1F5  10 FA              BPL   LAB_2043          ; loop until variable stacked
04398    
04399    D1F7  A4 96              LDY   Cvarah            ; get variable address high byte
04400    D1F9  20 BA D9           JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
04401                                  ; (function variable), return Y=0, always
04402    D1FC  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
04403    D1FE  48                 PHA                     ; push it
04404    D1FF  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
04405    D201  48                 PHA                     ; push it
04406    D202  B1 9C              LDA   (func_l),Y        ; get function execute pointer low byte
04407    D204  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
04408    D206  C8                 INY                     ; index to high byte
04409    D207  B1 9C              LDA   (func_l),Y        ; get function execute pointer high byte
04410    D209  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
04411    D20B  A5 96              LDA   Cvarah            ; get variable address high byte
04412    D20D  48                 PHA                     ; push it
04413    D20E  A5 95              LDA   Cvaral            ; get variable address low byte
04414    D210  48                 PHA                     ; push it
04415    D211  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
04416                                  ; else do type mismatch
04417    D214  68                 PLA                     ; pull variable address low byte
04418    D215  85 9C              STA   func_l            ; save variable address low byte
04419    D217  68                 PLA                     ; pull variable address high byte
04420    D218  85 9D              STA   func_h            ; save variable address high byte
04421    D21A  20 C2 00           JSR   LAB_GBYT          ; scan memory
04422    D21D  F0 03              BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
04423    
04424    D21F  4C 08 CD           JMP   LAB_SNER          ; else syntax error then warm start
04425    
04426    ; restore Bpntrl,Bpntrh and function variable from stack
04427    
04428    LAB_2074
04429    D222  68                 PLA                     ; pull BASIC execute pointer low byte
04430    D223  85 C3              STA   Bpntrl            ; restore BASIC execute pointer low byte
04431    D225  68                 PLA                     ; pull BASIC execute pointer high byte
04432    D226  85 C4              STA   Bpntrh            ; restore BASIC execute pointer high byte
04433    
04434    ; put execute pointer and variable pointer into function
04435    
04436    LAB_207A
04437    D228  A0 00              LDY   #$00              ; clear index
04438    D22A  68                 PLA                     ; pull BASIC execute pointer low byte
04439    D22B  91 9C              STA   (func_l),Y        ; save to function
04440    D22D  C8                 INY                     ; increment index
04441    D22E  68                 PLA                     ; pull BASIC execute pointer high byte
04442    D22F  91 9C              STA   (func_l),Y        ; save to function
04443    D231  C8                 INY                     ; increment index
04444    D232  68                 PLA                     ; pull current var address low byte
04445    D233  91 9C              STA   (func_l),Y        ; save to function
04446    D235  C8                 INY                     ; increment index
04447    D236  68                 PLA                     ; pull current var address high byte
04448    D237  91 9C              STA   (func_l),Y        ; save to function
04449    D239  60                 RTS
04450    
04451    ; perform STR$()
04452    
04453    LAB_STRS
04454    D23A  20 D6 CB           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
04455    D23D  20 A8 DB           JSR   LAB_296E          ; convert FAC1 to string
04456    D240  A9 F0              LDA   #<Decssp1         ; set result string low pointer
04457    D242  A0 00              LDY   #>Decssp1         ; set result string high pointer
04458    D244  F0 12              BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
04459    
04460    ; Do string vector
04461    ; copy des_pl/h to des_2l/h and make string space A bytes long
04462    
04463    LAB_209C
04464    D246  A6 AE              LDX   des_pl            ; get descriptor pointer low byte
04465    D248  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
04466    D24A  86 9E              STX   des_2l            ; save descriptor pointer low byte
04467    D24C  84 9F              STY   des_2h            ; save descriptor pointer high byte
04468    
04469    ; make string space A bytes long
04470    ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
04471    
04472    LAB_MSSP
04473    D24E  20 C3 D2           JSR   LAB_2115          ; make space in string memory for string A long
04474                                  ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
04475    D251  86 AD              STX   str_pl            ; save string pointer low byte
04476    D253  84 AE              STY   str_ph            ; save string pointer high byte
04477    D255  85 AC              STA   str_ln            ; save length
04478    D257  60                 RTS
04479    
04480    ; Scan, set up string
04481    ; print " terminated string to Sutill/Sutilh
04482    
04483    LAB_20AE
04484    D258  A2 22              LDX   #$22              ; set terminator to "
04485    D25A  86 5B              STX   Srchc             ; set search character (terminator 1)
04486    D25C  86 5C              STX   Asrch             ; set terminator 2
04487    
04488    ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
04489    ; source is AY
04490    
04491    LAB_20B4
04492    D25E  85 B8              STA   ssptr_l           ; store string start low byte
04493    D260  84 B9              STY   ssptr_h           ; store string start high byte
04494    D262  85 AD              STA   str_pl            ; save string pointer low byte
04495    D264  84 AE              STY   str_ph            ; save string pointer high byte
04496    D266  A0 FF              LDY   #$FF              ; set length to -1
04497    LAB_20BE
04498    D268  C8                 INY                     ; increment length
04499    D269  B1 B8              LDA   (ssptr_l),Y       ; get byte from string
04500    D26B  F0 0C              BEQ   LAB_20CF          ; exit loop if null byte [EOS]
04501    
04502    D26D  C5 5B              CMP   Srchc             ; compare with search character (terminator 1)
04503    D26F  F0 04              BEQ   LAB_20CB          ; branch if terminator
04504    
04505    D271  C5 5C              CMP   Asrch             ; compare with terminator 2
04506    D273  D0 F3              BNE   LAB_20BE          ; loop if not terminator 2
04507    
04508    LAB_20CB
04509    D275  C9 22              CMP   #$22              ; compare with "
04510    D277  F0 01              BEQ   LAB_20D0          ; branch if " (carry set if = !)
04511    
04512    LAB_20CF
04513    D279  18                 CLC                     ; clear carry for add (only if [EOL] terminated string)
04514    LAB_20D0
04515    D27A  84 AC              STY   str_ln            ; save length in FAC1 exponent
04516    D27C  98                 TYA                     ; copy length to A
04517    D27D  65 B8              ADC   ssptr_l           ; add string start low byte
04518    D27F  85 BA              STA   Sendl             ; save string end low byte
04519    D281  A6 B9              LDX   ssptr_h           ; get string start high byte
04520    D283  90 01              BCC   LAB_20DC          ; branch if no low byte overflow
04521    
04522    D285  E8                 INX                     ; else increment high byte
04523    LAB_20DC
04524    D286  86 BB              STX   Sendh             ; save string end high byte
04525    D288  A5 B9              LDA   ssptr_h           ; get string start high byte
04526    ; *** begin RAM above code / Ibuff above EhBASIC patch V2 ***
04527    ; *** replace
04528    ;      CMP   #>Ram_base        ; compare with start of program memory
04529    ;      BCS   LAB_RTST          ; branch if not in utility area
04530    ; *** with
04531    D28A  F0 04              BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
04532    D28C  C9 0B              CMP   #>Ibuffs          ; compare with location of input buffer page
04533    D28E  D0 0B              BNE   LAB_RTST          ; branch if not in utility area
04534    LAB_MVST      
04535    ; *** end   RAM above code / Ibuff above EhBASIC patch V2 ***
04536    
04537                                  ; string in utility area, move to string memory
04538    D290  98                 TYA                     ; copy length to A
04539    D291  20 46 D2           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
04540                                  ; long
04541    D294  A6 B8              LDX   ssptr_l           ; get string start low byte
04542    D296  A4 B9              LDY   ssptr_h           ; get string start high byte
04543    D298  20 39 D4           JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
04544    
04545    ; check for space on descriptor stack then ..
04546    ; put string address and length on descriptor stack and update stack pointers
04547    
04548    LAB_RTST
04549    D29B  A6 65              LDX   next_s            ; get string stack pointer
04550    D29D  E0 71              CPX   #des_sk+$09       ; compare with max+1
04551    D29F  D0 05              BNE   LAB_20F8          ; branch if space on string stack
04552    
04553                                  ; else do string too complex error
04554    D2A1  A2 1C              LDX   #$1C              ; error code $1C ("String too complex" error)
04555    LAB_20F5
04556    D2A3  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
04557    
04558    ; put string address and length on descriptor stack and update stack pointers
04559    
04560    LAB_20F8
04561    D2A6  A5 AC              LDA   str_ln            ; get string length
04562    D2A8  95 00              STA   PLUS_0,X          ; put on string stack
04563    D2AA  A5 AD              LDA   str_pl            ; get string pointer low byte
04564    D2AC  95 01              STA   PLUS_1,X          ; put on string stack
04565    D2AE  A5 AE              LDA   str_ph            ; get string pointer high byte
04566    D2B0  95 02              STA   PLUS_2,X          ; put on string stack
04567    D2B2  A0 00              LDY   #$00              ; clear Y
04568    D2B4  86 AE              STX   des_pl            ; save string descriptor pointer low byte
04569    D2B6  84 AF              STY   des_ph            ; save string descriptor pointer high byte (always $00)
04570    D2B8  88                 DEY                     ; Y = $FF
04571    D2B9  84 5F              STY   Dtypef            ; save data type flag, $FF=string
04572    D2BB  86 66              STX   last_sl           ; save old stack pointer (current top item)
04573    D2BD  E8                 INX                     ; update stack pointer
04574    D2BE  E8                 INX                     ; update stack pointer
04575    D2BF  E8                 INX                     ; update stack pointer
04576    D2C0  86 65              STX   next_s            ; save new top item value
04577    D2C2  60                 RTS
04578    
04579    ; Build descriptor
04580    ; make space in string memory for string A long
04581    ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
04582    
04583    LAB_2115
04584    D2C3  46 60              LSR   Gclctd            ; clear garbage collected flag (b7)
04585    
04586                                  ; make space for string A long
04587    LAB_2117
04588    D2C5  48                 PHA                     ; save string length
04589    D2C6  49 FF              EOR   #$FF              ; complement it
04590    D2C8  38                 SEC                     ; set carry for subtract (twos comp add)
04591    D2C9  65 81              ADC   Sstorl            ; add bottom of string space low byte (subtract length)
04592    D2CB  A4 82              LDY   Sstorh            ; get bottom of string space high byte
04593    D2CD  B0 01              BCS   LAB_2122          ; skip decrement if no underflow
04594    
04595    D2CF  88                 DEY                     ; decrement bottom of string space high byte
04596    LAB_2122
04597    D2D0  C4 80              CPY   Earryh            ; compare with array mem end high byte
04598    D2D2  90 11              BCC   LAB_2137          ; do out of memory error if less
04599    
04600    D2D4  D0 04              BNE   LAB_212C          ; if not = skip next test
04601    
04602    D2D6  C5 7F              CMP   Earryl            ; compare with array mem end low byte
04603    D2D8  90 0B              BCC   LAB_2137          ; do out of memory error if less
04604    
04605    LAB_212C
04606    D2DA  85 81              STA   Sstorl            ; save bottom of string space low byte
04607    D2DC  84 82              STY   Sstorh            ; save bottom of string space high byte
04608    D2DE  85 83              STA   Sutill            ; save string utility ptr low byte
04609    D2E0  84 84              STY   Sutilh            ; save string utility ptr high byte
04610    D2E2  AA                 TAX                     ; copy low byte to X
04611    D2E3  68                 PLA                     ; get string length back
04612    D2E4  60                 RTS
04613    
04614    LAB_2137
04615    D2E5  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
04616    D2E7  A5 60              LDA   Gclctd            ; get garbage collected flag
04617    D2E9  30 B8              BMI   LAB_20F5          ; if set then do error code X
04618    
04619    D2EB  20 F5 D2           JSR   LAB_GARB          ; else go do garbage collection
04620    D2EE  A9 80              LDA   #$80              ; flag for garbage collected
04621    D2F0  85 60              STA   Gclctd            ; set garbage collected flag
04622    D2F2  68                 PLA                     ; pull length
04623    D2F3  D0 D0              BNE   LAB_2117          ; go try again (loop always, length should never be = $00)
04624    
04625    ; garbage collection routine
04626    
04627    LAB_GARB
04628    D2F5  A6 85              LDX   Ememl             ; get end of mem low byte
04629    D2F7  A5 86              LDA   Ememh             ; get end of mem high byte
04630    
04631    ; re-run routine from last ending
04632    
04633    LAB_214B
04634    D2F9  86 81              STX   Sstorl            ; set string storage low byte
04635    D2FB  85 82              STA   Sstorh            ; set string storage high byte
04636    D2FD  A0 00              LDY   #$00              ; clear index
04637    D2FF  84 9D              STY   garb_h            ; clear working pointer high byte (flag no strings to move)
04638    ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
04639    ; *** add
04640    D301  84 9C              STY   garb_l            ; clear working pointer low byte (flag no strings to move)
04641    ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
04642    D303  A5 7F              LDA   Earryl            ; get array mem end low byte
04643    D305  A6 80              LDX   Earryh            ; get array mem end high byte
04644    D307  85 AA              STA   Histrl            ; save as highest string low byte
04645    D309  86 AB              STX   Histrh            ; save as highest string high byte
04646    D30B  A9 68              LDA   #des_sk           ; set descriptor stack pointer
04647    D30D  85 71              STA   ut1_pl            ; save descriptor stack pointer low byte
04648    D30F  84 72              STY   ut1_ph            ; save descriptor stack pointer high byte ($00)
04649    LAB_2161
04650    D311  C5 65              CMP   next_s            ; compare with descriptor stack pointer
04651    D313  F0 05              BEQ   LAB_216A          ; branch if =
04652    
04653    D315  20 7B D3           JSR   LAB_21D7          ; go garbage collect descriptor stack
04654    D318  F0 F7              BEQ   LAB_2161          ; loop always
04655    
04656                                  ; done stacked strings, now do string vars
04657    LAB_216A
04658    D31A  06 A0              ASL   g_step            ; set step size = $06
04659    D31C  A5 7B              LDA   Svarl             ; get start of vars low byte
04660    D31E  A6 7C              LDX   Svarh             ; get start of vars high byte
04661    D320  85 71              STA   ut1_pl            ; save as pointer low byte
04662    D322  86 72              STX   ut1_ph            ; save as pointer high byte
04663    LAB_2176
04664    D324  E4 7E              CPX   Sarryh            ; compare start of arrays high byte
04665    D326  D0 04              BNE   LAB_217E          ; branch if no high byte match
04666    
04667    D328  C5 7D              CMP   Sarryl            ; else compare start of arrays low byte
04668    D32A  F0 05              BEQ   LAB_2183          ; branch if = var mem end
04669    
04670    LAB_217E
04671    D32C  20 75 D3           JSR   LAB_21D1          ; go garbage collect strings
04672    D32F  F0 F3              BEQ   LAB_2176          ; loop always
04673    
04674                                  ; done string vars, now do string arrays
04675    LAB_2183
04676    D331  85 A4              STA   Nbendl            ; save start of arrays low byte as working pointer
04677    D333  86 A5              STX   Nbendh            ; save start of arrays high byte as working pointer
04678    D335  A9 04              LDA   #$04              ; set step size
04679    D337  85 A0              STA   g_step            ; save step size
04680    LAB_218B
04681    D339  A5 A4              LDA   Nbendl            ; get pointer low byte
04682    D33B  A6 A5              LDX   Nbendh            ; get pointer high byte
04683    LAB_218F
04684    D33D  E4 80              CPX   Earryh            ; compare with array mem end high byte
04685    D33F  D0 04              BNE   LAB_219A          ; branch if not at end
04686    
04687    D341  C5 7F              CMP   Earryl            ; else compare with array mem end low byte
04688    D343  F0 75              BEQ   LAB_2216          ; tidy up and exit if at end
04689    
04690    LAB_219A
04691    D345  85 71              STA   ut1_pl            ; save pointer low byte
04692    D347  86 72              STX   ut1_ph            ; save pointer high byte
04693    D349  A0 02              LDY   #$02              ; set index
04694    D34B  B1 71              LDA   (ut1_pl),Y        ; get array size low byte
04695    D34D  65 A4              ADC   Nbendl            ; add start of this array low byte
04696    D34F  85 A4              STA   Nbendl            ; save start of next array low byte
04697    D351  C8                 INY                     ; increment index
04698    D352  B1 71              LDA   (ut1_pl),Y        ; get array size high byte
04699    D354  65 A5              ADC   Nbendh            ; add start of this array high byte
04700    D356  85 A5              STA   Nbendh            ; save start of next array high byte
04701    D358  A0 01              LDY   #$01              ; set index
04702    D35A  B1 71              LDA   (ut1_pl),Y        ; get name second byte
04703    D35C  10 DB              BPL   LAB_218B          ; skip if not string array
04704    
04705    ; was string array so ..
04706    
04707    D35E  A0 04              LDY   #$04              ; set index
04708    D360  B1 71              LDA   (ut1_pl),Y        ; get # of dimensions
04709    D362  0A                 ASL                     ; *2
04710    D363  69 05              ADC   #$05              ; +5 (array header size)
04711    D365  20 AD D3           JSR   LAB_2208          ; go set up for first element
04712    LAB_21C4
04713    D368  E4 A5              CPX   Nbendh            ; compare with start of next array high byte
04714    D36A  D0 04              BNE   LAB_21CC          ; branch if <> (go do this array)
04715    
04716    D36C  C5 A4              CMP   Nbendl            ; else compare element pointer low byte with next array
04717                                  ; low byte
04718    D36E  F0 CD              BEQ   LAB_218F          ; if equal then go do next array
04719    
04720    LAB_21CC
04721    D370  20 7B D3           JSR   LAB_21D7          ; go defrag array strings
04722    D373  F0 F3              BEQ   LAB_21C4          ; go do next array string (loop always)
04723    
04724    ; defrag string variables
04725    ; enter with XA = variable pointer
04726    ; return with XA = next variable pointer
04727    
04728    LAB_21D1
04729    D375  C8                 INY                     ; increment index (Y was $00)
04730    D376  B1 71              LDA   (ut1_pl),Y        ; get var name byte 2
04731    D378  10 30              BPL   LAB_2206          ; if not string, step pointer to next var and return
04732    
04733    D37A  C8                 INY                     ; else increment index
04734    LAB_21D7
04735    D37B  B1 71              LDA   (ut1_pl),Y        ; get string length
04736    D37D  F0 2B              BEQ   LAB_2206          ; if null, step pointer to next string and return
04737    
04738    D37F  C8                 INY                     ; else increment index
04739    D380  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte
04740    D382  AA                 TAX                     ; copy to X
04741    D383  C8                 INY                     ; increment index
04742    D384  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte
04743    D386  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
04744    D388  90 06              BCC   LAB_21EC          ; branch if less
04745    
04746    D38A  D0 1E              BNE   LAB_2206          ; if greater, step pointer to next string and return
04747    
04748                                  ; high bytes were = so compare low bytes
04749    D38C  E4 81              CPX   Sstorl            ; compare bottom of string space low byte
04750    D38E  B0 1A              BCS   LAB_2206          ; if >=, step pointer to next string and return
04751    
04752                                  ; string pointer is < string storage pointer (pos in mem)
04753    LAB_21EC
04754    D390  C5 AB              CMP   Histrh            ; compare to highest string high byte
04755    D392  90 17              BCC   LAB_2207          ; if <, step pointer to next string and return
04756    
04757    D394  D0 04              BNE   LAB_21F6          ; if > update pointers, step to next and return
04758    
04759                                  ; high bytes were = so compare low bytes
04760    D396  E4 AA              CPX   Histrl            ; compare to highest string low byte
04761    D398  90 11              BCC   LAB_2207          ; if <, step pointer to next string and return
04762    
04763                                  ; string is in string memory space
04764    LAB_21F6
04765    D39A  86 AA              STX   Histrl            ; save as new highest string low byte
04766    D39C  85 AB              STA   Histrh            ; save as new highest string high byte
04767    D39E  A5 71              LDA   ut1_pl            ; get start of vars(descriptors) low byte
04768    D3A0  A6 72              LDX   ut1_ph            ; get start of vars(descriptors) high byte
04769    D3A2  85 9C              STA   garb_l            ; save as working pointer low byte
04770    D3A4  86 9D              STX   garb_h            ; save as working pointer high byte
04771    D3A6  88                 DEY                     ; decrement index DIFFERS
04772    D3A7  88                 DEY                     ; decrement index (should point to descriptor start)
04773    D3A8  84 A2              STY   g_indx            ; save index pointer
04774    
04775                                  ; step pointer to next string
04776    LAB_2206
04777    D3AA  18                 CLC                     ; clear carry for add
04778    LAB_2207
04779    D3AB  A5 A0              LDA   g_step            ; get step size
04780    LAB_2208
04781    D3AD  65 71              ADC   ut1_pl            ; add pointer low byte
04782    D3AF  85 71              STA   ut1_pl            ; save pointer low byte
04783    D3B1  90 02              BCC   LAB_2211          ; branch if no overflow
04784    
04785    D3B3  E6 72              INC   ut1_ph            ; else increment high byte
04786    LAB_2211
04787    D3B5  A6 72              LDX   ut1_ph            ; get pointer high byte
04788    D3B7  A0 00              LDY   #$00              ; clear Y
04789    D3B9  60                 RTS
04790    
04791    ; search complete, now either exit or set-up and move string
04792    
04793    LAB_2216
04794    D3BA  C6 A0              DEC   g_step            ; decrement step size (now $03 for descriptor stack)
04795    ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
04796    ; *** replace
04797    ;      LDX   garb_h            ; get string to move high byte
04798    ; *** with
04799    D3BC  A5 9D              LDA   garb_h            ; any string to move?
04800    D3BE  05 9C              ORA   garb_l
04801    ; *** end   patch  2.22p5.5  garbage collection may overlap temporary strings
04802    D3C0  F0 F3              BEQ   LAB_2211          ; exit if nothing to move
04803    
04804    D3C2  A4 A2              LDY   g_indx            ; get index byte back (points to descriptor)
04805    D3C4  18                 CLC                     ; clear carry for add
04806    D3C5  B1 9C              LDA   (garb_l),Y        ; get string length
04807    D3C7  65 AA              ADC   Histrl            ; add highest string low byte
04808    D3C9  85 A6              STA   Obendl            ; save old block end low pointer
04809    D3CB  A5 AB              LDA   Histrh            ; get highest string high byte
04810    D3CD  69 00              ADC   #$00              ; add any carry
04811    D3CF  85 A7              STA   Obendh            ; save old block end high byte
04812    D3D1  A5 81              LDA   Sstorl            ; get bottom of string space low byte
04813    D3D3  A6 82              LDX   Sstorh            ; get bottom of string space high byte
04814    D3D5  85 A4              STA   Nbendl            ; save new block end low byte
04815    D3D7  86 A5              STX   Nbendh            ; save new block end high byte
04816    D3D9  20 C8 C1           JSR   LAB_11D6          ; open up space in memory, don't set array end
04817    D3DC  A4 A2              LDY   g_indx            ; get index byte
04818    D3DE  C8                 INY                     ; point to descriptor low byte
04819    D3DF  A5 A4              LDA   Nbendl            ; get string pointer low byte
04820    D3E1  91 9C              STA   (garb_l),Y        ; save new string pointer low byte
04821    D3E3  AA                 TAX                     ; copy string pointer low byte
04822    D3E4  E6 A5              INC   Nbendh            ; correct high byte (move sets high byte -1)
04823    D3E6  A5 A5              LDA   Nbendh            ; get new string pointer high byte
04824    D3E8  C8                 INY                     ; point to descriptor high byte
04825    D3E9  91 9C              STA   (garb_l),Y        ; save new string pointer high byte
04826    D3EB  4C F9 D2           JMP   LAB_214B          ; re-run routine from last ending
04827                                  ; (but don't collect this string)
04828    
04829    ; concatenate
04830    ; add strings, string 1 is in descriptor des_pl, string 2 is in line
04831    
04832    LAB_224D
04833    D3EE  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
04834    D3F0  48                 PHA                     ; put on stack
04835    D3F1  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
04836    D3F3  48                 PHA                     ; put on stack
04837    ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
04838    ; *** add extra label to verify originating function
04839    LAB_224Da
04840    ; *** end patch    2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
04841    D3F4  20 D3 CC           JSR   LAB_GVAL          ; get value from line
04842    D3F7  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
04843    D3FA  68                 PLA                     ; get descriptor pointer low byte back
04844    D3FB  85 B8              STA   ssptr_l           ; set pointer low byte
04845    D3FD  68                 PLA                     ; get descriptor pointer high byte back
04846    D3FE  85 B9              STA   ssptr_h           ; set pointer high byte
04847    D400  A0 00              LDY   #$00              ; clear index
04848    D402  B1 B8              LDA   (ssptr_l),Y       ; get length_1 from descriptor
04849    D404  18                 CLC                     ; clear carry for add
04850    D405  71 AE              ADC   (des_pl),Y        ; add length_2
04851    D407  90 05              BCC   LAB_226D          ; branch if no overflow
04852    
04853    D409  A2 1A              LDX   #$1A              ; else set error code $1A ("String too long" error)
04854    D40B  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
04855    
04856    LAB_226D
04857    D40E  20 46 D2           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
04858                                  ; long
04859    D411  20 2B D4           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
04860    D414  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
04861    D416  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
04862    D418  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
04863                                  ; returns with A = length, ut1_pl = pointer low byte,
04864                                  ; ut1_ph = pointer high byte
04865    D41B  20 3D D4           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
04866    D41E  A5 B8              LDA   ssptr_l           ;.set descriptor pointer low byte
04867    D420  A4 B9              LDY   ssptr_h           ;.set descriptor pointer high byte
04868    D422  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
04869                                  ; returns with A = length, X=ut1_pl=pointer low byte,
04870                                  ; Y=ut1_ph=pointer high byte
04871    D425  20 9B D2           JSR   LAB_RTST          ; check for space on descriptor stack then put string
04872                                  ; address and length on descriptor stack and update stack
04873                                  ; pointers
04874    D428  4C FE CB           JMP   LAB_1ADB          ;.continue evaluation
04875    
04876    ; copy string from descriptor (sdescr) to (Sutill)
04877    
04878    LAB_228A
04879    D42B  A0 00              LDY   #$00              ; clear index
04880    D42D  B1 B8              LDA   (sdescr),Y        ; get string length
04881    D42F  48                 PHA                     ; save on stack
04882    D430  C8                 INY                     ; increment index
04883    D431  B1 B8              LDA   (sdescr),Y        ; get source string pointer low byte
04884    D433  AA                 TAX                     ; copy to X
04885    D434  C8                 INY                     ; increment index
04886    D435  B1 B8              LDA   (sdescr),Y        ; get source string pointer high byte
04887    D437  A8                 TAY                     ; copy to Y
04888    D438  68                 PLA                     ; get length back
04889    
04890    ; store string A bytes long from YX to (Sutill)
04891    
04892    LAB_2298
04893    D439  86 71              STX   ut1_pl            ; save source string pointer low byte
04894    D43B  84 72              STY   ut1_ph            ; save source string pointer high byte
04895    
04896    ; store string A bytes long from (ut1_pl) to (Sutill)
04897    
04898    LAB_229C
04899    D43D  AA                 TAX                     ; copy length to index (don't count with Y)
04900    D43E  F0 14              BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
04901    
04902    D440  A0 00              LDY   #$00              ; zero pointer (copy forward)
04903    LAB_22A0
04904    D442  B1 71              LDA   (ut1_pl),Y        ; get source byte
04905    D444  91 83              STA   (Sutill),Y        ; save destination byte
04906    
04907    D446  C8                 INY                     ; increment index
04908    D447  CA                 DEX                     ; decrement counter
04909    D448  D0 F8              BNE   LAB_22A0          ; loop while <> 0
04910    
04911    D44A  98                 TYA                     ; restore length from Y
04912    LAB_22A9
04913    D44B  18                 CLC                     ; clear carry for add
04914    D44C  65 83              ADC   Sutill            ; add string utility ptr low byte
04915    D44E  85 83              STA   Sutill            ; save string utility ptr low byte
04916    D450  90 02              BCC   LAB_22B2          ; branch if no carry
04917    
04918    D452  E6 84              INC   Sutilh            ; else increment string utility ptr high byte
04919    LAB_22B2
04920    D454  60                 RTS
04921    
04922    ; evaluate string
04923    
04924    LAB_EVST
04925    D455  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
04926    
04927    ; pop string off descriptor stack, or from top of string space
04928    ; returns with A = length, X=pointer low byte, Y=pointer high byte
04929    
04930    LAB_22B6
04931    D458  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
04932    D45A  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
04933    
04934    ; pop (YA) descriptor off stack or from top of string space
04935    ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
04936    
04937    LAB_22BA
04938    D45C  85 71              STA   ut1_pl            ; save descriptor pointer low byte
04939    D45E  84 72              STY   ut1_ph            ; save descriptor pointer high byte
04940    D460  20 8D D4           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
04941    D463  08                 PHP                     ; save status flags
04942    D464  A0 00              LDY   #$00              ; clear index
04943    D466  B1 71              LDA   (ut1_pl),Y        ; get length from string descriptor
04944    D468  48                 PHA                     ; put on stack
04945    D469  C8                 INY                     ; increment index
04946    D46A  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
04947    D46C  AA                 TAX                     ; copy to X
04948    D46D  C8                 INY                     ; increment index
04949    D46E  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
04950    D470  A8                 TAY                     ; copy to Y
04951    D471  68                 PLA                     ; get string length back
04952    D472  28                 PLP                     ; restore status
04953    D473  D0 13              BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
04954    
04955    D475  C4 82              CPY   Sstorh            ; compare bottom of string space high byte
04956    D477  D0 0F              BNE   LAB_22E6          ; branch if <>
04957    
04958    D479  E4 81              CPX   Sstorl            ; else compare bottom of string space low byte
04959    D47B  D0 0B              BNE   LAB_22E6          ; branch if <>
04960    
04961    D47D  48                 PHA                     ; save string length
04962    D47E  18                 CLC                     ; clear carry for add
04963    D47F  65 81              ADC   Sstorl            ; add bottom of string space low byte
04964    D481  85 81              STA   Sstorl            ; save bottom of string space low byte
04965    D483  90 02              BCC   LAB_22E5          ; skip increment if no overflow
04966    
04967    D485  E6 82              INC   Sstorh            ; increment bottom of string space high byte
04968    LAB_22E5
04969    D487  68                 PLA                     ; restore string length
04970    LAB_22E6
04971    D488  86 71              STX   ut1_pl            ; save string pointer low byte
04972    D48A  84 72              STY   ut1_ph            ; save string pointer high byte
04973    D48C  60                 RTS
04974    
04975    ; clean descriptor stack, YA = pointer
04976    ; checks if AY is on the descriptor stack, if so does a stack discard
04977    
04978    LAB_22EB
04979    D48D  C4 67              CPY   last_sh           ; compare pointer high byte
04980    D48F  D0 0C              BNE   LAB_22FB          ; exit if <>
04981    
04982    D491  C5 66              CMP   last_sl           ; compare pointer low byte
04983    D493  D0 08              BNE   LAB_22FB          ; exit if <>
04984    
04985    D495  85 65              STA   next_s            ; save descriptor stack pointer
04986    D497  E9 03              SBC   #$03              ; -3
04987    D499  85 66              STA   last_sl           ; save low byte -3
04988    D49B  A0 00              LDY   #$00              ; clear high byte
04989    LAB_22FB
04990    D49D  60                 RTS
04991    
04992    ; perform CHR$()
04993    
04994    LAB_CHRS
04995    D49E  20 A9 D5           JSR   LAB_EVBY          ; evaluate byte expression, result in X
04996    D4A1  8A                 TXA                     ; copy to A
04997    D4A2  48                 PHA                     ; save character
04998    D4A3  A9 01              LDA   #$01              ; string is single byte
04999    D4A5  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
05000                                  ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
05001    D4A8  68                 PLA                     ; get character back
05002    D4A9  A0 00              LDY   #$00              ; clear index
05003    D4AB  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
05004    D4AD  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put string
05005                                  ; address and length on descriptor stack and update stack
05006                                  ; pointers
05007    
05008    ; perform LEFT$()
05009    
05010    LAB_LEFT
05011    D4B0  48                 PHA                     ; push byte parameter
05012    D4B1  20 11 D5           JSR   LAB_236F          ; pull string data and byte parameter from stack
05013                                  ; return pointer in des_2l/h, byte in A (and X), Y=0
05014    D4B4  D1 9E              CMP   (des_2l),Y        ; compare byte parameter with string length
05015    D4B6  98                 TYA                     ; clear A
05016    D4B7  F0 09              BEQ   LAB_2316          ; go do string copy (branch always)
05017    
05018    ; perform RIGHT$()
05019    
05020    LAB_RIGHT
05021    D4B9  48                 PHA                     ; push byte parameter
05022    D4BA  20 11 D5           JSR   LAB_236F          ; pull string data and byte parameter from stack
05023                                  ; return pointer in des_2l/h, byte in A (and X), Y=0
05024    D4BD  18                 CLC                     ; clear carry for add-1
05025    D4BE  F1 9E              SBC   (des_2l),Y        ; subtract string length
05026    D4C0  49 FF              EOR   #$FF              ; invert it (A=LEN(expression$)-l)
05027    
05028    LAB_2316
05029    D4C2  90 04              BCC   LAB_231C          ; branch if string length > byte parameter
05030    
05031    D4C4  B1 9E              LDA   (des_2l),Y        ; else make parameter = length
05032    D4C6  AA                 TAX                     ; copy to byte parameter copy
05033    D4C7  98                 TYA                     ; clear string start offset
05034    LAB_231C
05035    D4C8  48                 PHA                     ; save string start offset
05036    LAB_231D
05037    D4C9  8A                 TXA                     ; copy byte parameter (or string length if <)
05038    LAB_231E
05039    D4CA  48                 PHA                     ; save string length
05040    D4CB  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
05041                                  ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
05042    D4CE  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
05043    D4D0  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
05044    D4D2  20 5C D4           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
05045                                  ; returns with A = length, X=ut1_pl=pointer low byte,
05046                                  ; Y=ut1_ph=pointer high byte
05047    D4D5  68                 PLA                     ; get string length back
05048    D4D6  A8                 TAY                     ; copy length to Y
05049    D4D7  68                 PLA                     ; get string start offset back
05050    D4D8  18                 CLC                     ; clear carry for add
05051    D4D9  65 71              ADC   ut1_pl            ; add start offset to string start pointer low byte
05052    D4DB  85 71              STA   ut1_pl            ; save string start pointer low byte
05053    D4DD  90 02              BCC   LAB_2335          ; branch if no overflow
05054    
05055    D4DF  E6 72              INC   ut1_ph            ; else increment string start pointer high byte
05056    LAB_2335
05057    D4E1  98                 TYA                     ; copy length to A
05058    D4E2  20 3D D4           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
05059    D4E5  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put string
05060                                  ; address and length on descriptor stack and update stack
05061                                  ; pointers
05062    
05063    ; perform MID$()
05064    
05065    LAB_MIDS
05066    D4E8  48                 PHA                     ; push byte parameter
05067    D4E9  A9 FF              LDA   #$FF              ; set default length = 255
05068    D4EB  85 AF              STA   mids_l            ; save default length
05069    D4ED  20 C2 00           JSR   LAB_GBYT          ; scan memory
05070    D4F0  C9 29              CMP   #')'              ; compare with ")"
05071    D4F2  F0 06              BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
05072    
05073    D4F4  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05074    D4F7  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
05075    LAB_2358
05076    D4FA  20 11 D5           JSR   LAB_236F          ; pull string data and byte parameter from stack
05077                                  ; return pointer in des_2l/h, byte in A (and X), Y=0
05078    D4FD  CA                 DEX                     ; decrement start index
05079    D4FE  8A                 TXA                     ; copy to A
05080    D4FF  48                 PHA                     ; save string start offset
05081    D500  18                 CLC                     ; clear carry for sub-1
05082    D501  A2 00              LDX   #$00              ; clear output string length
05083    D503  F1 9E              SBC   (des_2l),Y        ; subtract string length
05084    D505  B0 C2              BCS   LAB_231D          ; if start>string length go do null string
05085    
05086    D507  49 FF              EOR   #$FF              ; complement -length
05087    D509  C5 AF              CMP   mids_l            ; compare byte parameter
05088    D50B  90 BD              BCC   LAB_231E          ; if length>remaining string go do RIGHT$
05089    
05090    D50D  A5 AF              LDA   mids_l            ; get length byte
05091    D50F  B0 B9              BCS   LAB_231E          ; go do string copy (branch always)
05092    
05093    ; pull string data and byte parameter from stack
05094    ; return pointer in des_2l/h, byte in A (and X), Y=0
05095    
05096    LAB_236F
05097    D511  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
05098    D514  68                 PLA                     ; pull return address low byte (return address)
05099    D515  85 A2              STA   Fnxjpl            ; save functions jump vector low byte
05100    D517  68                 PLA                     ; pull return address high byte (return address)
05101    D518  85 A3              STA   Fnxjph            ; save functions jump vector high byte
05102    D51A  68                 PLA                     ; pull byte parameter
05103    D51B  AA                 TAX                     ; copy byte parameter to X
05104    D51C  68                 PLA                     ; pull string pointer low byte
05105    D51D  85 9E              STA   des_2l            ; save it
05106    D51F  68                 PLA                     ; pull string pointer high byte
05107    D520  85 9F              STA   des_2h            ; save it
05108    D522  A0 00              LDY   #$00              ; clear index
05109    D524  8A                 TXA                     ; copy byte parameter
05110    D525  F0 79              BEQ   LAB_23A8          ; if null do function call error then warm start
05111    
05112    D527  E6 A2              INC   Fnxjpl            ; increment function jump vector low byte
05113                                  ; (JSR pushes return addr-1. this is all very nice
05114                                  ; but will go tits up if either call is on a page
05115                                  ; boundary!)
05116    D529  6C A2 00           JMP   (Fnxjpl)          ; in effect, RTS
05117    
05118    ; perform LCASE$()
05119    
05120    LAB_LCASE
05121    D52C  20 55 D4           JSR   LAB_EVST          ; evaluate string
05122    D52F  85 AC              STA   str_ln            ; set string length
05123    D531  A8                 TAY                     ; copy length to Y
05124    D532  F0 38              BEQ   NoString          ; branch if null string
05125    
05126    D534  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=length,
05127                                  ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
05128    D537  86 AD              STX   str_pl            ; save string pointer low byte
05129    D539  84 AE              STY   str_ph            ; save string pointer high byte
05130    D53B  A8                 TAY                     ; get string length back
05131    
05132    LC_loop
05133    D53C  88                 DEY                     ; decrement index
05134    D53D  B1 71              LDA   (ut1_pl),Y        ; get byte from string
05135    D53F  20 36 CF           JSR   LAB_1D82          ; is character "A" to "Z"
05136    D542  90 02              BCC   NoUcase           ; branch if not upper case alpha
05137    
05138    D544  09 20              ORA   #$20              ; convert upper to lower case
05139    NoUcase
05140    D546  91 83              STA   (Sutill),Y        ; save byte back to string
05141    D548  98                 TYA                     ; test index
05142    D549  D0 F1              BNE   LC_loop           ; loop if not all done
05143    
05144    D54B  F0 1F              BEQ   NoString          ; tidy up and exit, branch always
05145    
05146    ; perform UCASE$()
05147    
05148    LAB_UCASE
05149    D54D  20 55 D4           JSR   LAB_EVST          ; evaluate string
05150    D550  85 AC              STA   str_ln            ; set string length
05151    D552  A8                 TAY                     ; copy length to Y
05152    D553  F0 17              BEQ   NoString          ; branch if null string
05153    
05154    D555  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long A=length,
05155                                  ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
05156    D558  86 AD              STX   str_pl            ; save string pointer low byte
05157    D55A  84 AE              STY   str_ph            ; save string pointer high byte
05158    D55C  A8                 TAY                     ; get string length back
05159    
05160    UC_loop
05161    D55D  88                 DEY                     ; decrement index
05162    D55E  B1 71              LDA   (ut1_pl),Y        ; get byte from string
05163    D560  20 32 CF           JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
05164    D563  90 02              BCC   NoLcase           ; branch if not alpha
05165    
05166    D565  29 DF              AND   #$DF              ; convert lower to upper case
05167    NoLcase
05168    D567  91 83              STA   (Sutill),Y        ; save byte back to string
05169    D569  98                 TYA                     ; test index
05170    D56A  D0 F1              BNE   UC_loop           ; loop if not all done
05171    
05172    NoString
05173    D56C  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put string
05174                                  ; address and length on descriptor stack and update stack
05175                                  ; pointers
05176    
05177    ; perform SADD()
05178    
05179    LAB_SADD
05180    D56F  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
05181    D572  20 BE CE           JSR   LAB_GVAR          ; get var address
05182    
05183    D575  20 F5 CC           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
05184    D578  20 D8 CB           JSR   LAB_CTST          ; check if source is string, else do type mismatch
05185    
05186    D57B  A0 02              LDY   #$02              ; index to string pointer high byte
05187    D57D  B1 95              LDA   (Cvaral),Y        ; get string pointer high byte
05188    D57F  AA                 TAX                     ; copy string pointer high byte to X
05189    D580  88                 DEY                     ; index to string pointer low byte
05190    D581  B1 95              LDA   (Cvaral),Y        ; get string pointer low byte
05191    D583  A8                 TAY                     ; copy string pointer low byte to Y
05192    D584  8A                 TXA                     ; copy string pointer high byte to A
05193    D585  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
05194    
05195    ; perform LEN()
05196    
05197    LAB_LENS
05198    D588  20 8E D5           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
05199    D58B  4C 7A D1           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
05200    
05201    ; evaluate string, get length in Y
05202    
05203    LAB_ESGL
05204    D58E  20 55 D4           JSR   LAB_EVST          ; evaluate string
05205    D591  A8                 TAY                     ; copy length to Y
05206    D592  60                 RTS
05207    
05208    ; perform ASC()
05209    
05210    LAB_ASC
05211    D593  20 8E D5           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
05212    D596  F0 08              BEQ   LAB_23A8          ; if null do function call error then warm start
05213    
05214    D598  A0 00              LDY   #$00              ; set index to first character
05215    D59A  B1 71              LDA   (ut1_pl),Y        ; get byte
05216    D59C  A8                 TAY                     ; copy to Y
05217    D59D  4C 7A D1           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
05218    
05219    ; do function call error then warm start
05220    
05221    LAB_23A8
05222    D5A0  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
05223    
05224    ; scan and get byte parameter
05225    
05226    LAB_SGBY
05227    D5A3  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
05228    
05229    ; get byte parameter
05230    
05231    LAB_GTBY
05232    D5A6  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05233                                  ; else do type mismatch
05234    
05235    ; evaluate byte expression, result in X
05236    
05237    LAB_EVBY
05238    D5A9  20 B6 CF           JSR   LAB_EVPI          ; evaluate integer expression (no check)
05239    
05240    D5AC  A4 AE              LDY   FAC1_2            ; get FAC1 mantissa2
05241    D5AE  D0 F0              BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
05242    
05243    D5B0  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
05244    D5B2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
05245    
05246    ; perform VAL()
05247    
05248    LAB_VAL
05249    D5B5  20 8E D5           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
05250    D5B8  D0 03              BNE   LAB_23C5          ; branch if not null string
05251    
05252                                  ; string was null so set result = $00
05253    D5BA  4C 63 D7           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
05254    
05255    LAB_23C5
05256    ; *** begin patch  2.22p5.7  VAL() may cause string variables to be trashed
05257    ; *** replace     
05258    ;      LDX   Bpntrl            ; get BASIC execute pointer low byte
05259    ;      LDY   Bpntrh            ; get BASIC execute pointer high byte
05260    ;      STX   Btmpl             ; save BASIC execute pointer low byte
05261    ;      STY   Btmph             ; save BASIC execute pointer high byte
05262    ;      LDX   ut1_pl            ; get string pointer low byte
05263    ;      STX   Bpntrl            ; save as BASIC execute pointer low byte
05264    ;      CLC                     ; clear carry
05265    ;      ADC   ut1_pl            ; add string length
05266    ;      STA   ut2_pl            ; save string end low byte
05267    ;      LDA   ut1_ph            ; get string pointer high byte
05268    ;      STA   Bpntrh            ; save as BASIC execute pointer high byte
05269    ;      ADC   #$00              ; add carry to high byte
05270    ;      STA   ut2_ph            ; save string end high byte
05271    ;      LDY   #$00              ; set index to $00
05272    ;      LDA   (ut2_pl),Y        ; get string end +1 byte
05273    ;      PHA                     ; push it
05274    ;      TYA                     ; clear A
05275    ;      STA   (ut2_pl),Y        ; terminate string with $00
05276    ;      JSR   LAB_GBYT          ; scan memory
05277    ;      JSR   LAB_2887          ; get FAC1 from string
05278    ;      PLA                     ; restore string end +1 byte
05279    ;      LDY   #$00              ; set index to zero
05280    ;      STA   (ut2_pl),Y        ; put string end byte back
05281    ; *** with
05282    D5BD  48                 PHA                     ; save length
05283    D5BE  C8                 INY                     ; string length +1
05284    D5BF  98                 TYA
05285    D5C0  20 4E D2           JSR   LAB_MSSP          ; allocate temp string +1 bytes long
05286    D5C3  68                 PLA                     ; get length back
05287    D5C4  20 3D D4           JSR   LAB_229C          ; copy string (ut1_pl) -> (Sutill) for A bytes
05288    D5C7  A9 00              LDA   #0                ; add delimiter to end of string
05289    D5C9  A8                 TAY
05290    D5CA  91 83              STA   (Sutill),Y
05291    D5CC  A6 C3              LDX   Bpntrl            ; save BASIC execute pointer low byte
05292    D5CE  A4 C4              LDY   Bpntrh
05293    D5D0  86 BA              STX   Btmpl
05294    D5D2  84 BB              STY   Btmph
05295    D5D4  A6 AD              LDX   str_pl            ; point to temporary string
05296    D5D6  A4 AE              LDY   str_ph
05297    D5D8  86 C3              STX   Bpntrl
05298    D5DA  84 C4              STY   Bpntrh
05299    D5DC  20 C2 00           JSR   LAB_GBYT          ; scan memory
05300    D5DF  20 B9 DA           JSR   LAB_2887          ; get FAC1 from string
05301    ; *** end patch    2.22p5.7  VAL() may cause string variables to be trashed
05302    
05303    ; restore BASIC execute pointer from temp (Btmpl/Btmph)
05304    
05305    LAB_23F3
05306    D5E2  A6 BA              LDX   Btmpl             ; get BASIC execute pointer low byte back
05307    D5E4  A4 BB              LDY   Btmph             ; get BASIC execute pointer high byte back
05308    D5E6  86 C3              STX   Bpntrl            ; save BASIC execute pointer low byte
05309    D5E8  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
05310    D5EA  60                 RTS
05311    
05312    ; get two parameters for POKE or WAIT
05313    
05314    LAB_GADB
05315    D5EB  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05316                                  ; else do type mismatch
05317    D5EE  20 04 D6           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
05318    
05319    ; scan for "," and get byte, else do Syntax error then warm start
05320    
05321    LAB_SCGB
05322    D5F1  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05323    D5F4  A5 12              LDA   Itemph            ; save temporary integer high byte
05324    D5F6  48                 PHA                     ; on stack
05325    D5F7  A5 11              LDA   Itempl            ; save temporary integer low byte
05326    D5F9  48                 PHA                     ; on stack
05327    D5FA  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
05328    D5FD  68                 PLA                     ; pull low byte
05329    D5FE  85 11              STA   Itempl            ; restore temporary integer low byte
05330    D600  68                 PLA                     ; pull high byte
05331    D601  85 12              STA   Itemph            ; restore temporary integer high byte
05332    D603  60                 RTS
05333    
05334    ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
05335    ; -ve and converts it into a right truncated integer in Itempl and Itemph
05336    
05337    ; save unsigned 16 bit integer part of FAC1 in temporary integer
05338    
05339    LAB_F2FX
05340    D604  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05341    D606  C9 98              CMP   #$98              ; compare with exponent = 2^24
05342    D608  B0 96              BCS   LAB_23A8          ; if >= do function call error then warm start
05343    
05344    LAB_F2FU
05345    D60A  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
05346    D60D  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05347    D60F  A4 AF              LDY   FAC1_3            ; get FAC1 mantissa3
05348    D611  84 11              STY   Itempl            ; save temporary integer low byte
05349    D613  85 12              STA   Itemph            ; save temporary integer high byte
05350    D615  60                 RTS
05351    
05352    ; perform PEEK()
05353    
05354    LAB_PEEK
05355    D616  20 04 D6           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
05356    D619  A2 00              LDX   #$00              ; clear index
05357    D61B  A1 11              LDA   (Itempl,X)        ; get byte via temporary integer (addr)
05358    D61D  A8                 TAY                     ; copy byte to Y
05359    D61E  4C 7A D1           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
05360    
05361    ; perform POKE
05362    
05363    LAB_POKE
05364    D621  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
05365    D624  8A                 TXA                     ; copy byte argument to A
05366    D625  A2 00              LDX   #$00              ; clear index
05367    D627  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
05368    D629  60                 RTS
05369    
05370    ; perform DEEK()
05371    
05372    LAB_DEEK
05373    D62A  20 04 D6           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
05374    D62D  A2 00              LDX   #$00              ; clear index
05375    D62F  A1 11              LDA   (Itempl,X)        ; PEEK low byte
05376    D631  A8                 TAY                     ; copy to Y
05377    D632  E6 11              INC   Itempl            ; increment pointer low byte
05378    D634  D0 02              BNE   Deekh             ; skip high increment if no rollover
05379    
05380    D636  E6 12              INC   Itemph            ; increment pointer high byte
05381    Deekh
05382    D638  A1 11              LDA   (Itempl,X)        ; PEEK high byte
05383    D63A  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
05384    
05385    ; perform DOKE
05386    
05387    LAB_DOKE
05388    D63D  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05389                                  ; else do type mismatch
05390    D640  20 04 D6           JSR   LAB_F2FX          ; convert floating-to-fixed
05391    
05392    D643  84 97              STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
05393    D645  85 98              STA   Frnxth            ; save pointer high byte
05394    
05395    D647  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05396    D64A  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05397                                  ; else do type mismatch
05398    D64D  20 04 D6           JSR   LAB_F2FX          ; convert floating-to-fixed
05399    
05400    D650  98                 TYA                     ; copy value low byte (float to fixed returns word in AY)
05401    D651  A2 00              LDX   #$00              ; clear index
05402    D653  81 97              STA   (Frnxtl,X)        ; POKE low byte
05403    D655  E6 97              INC   Frnxtl            ; increment pointer low byte
05404    D657  D0 02              BNE   Dokeh             ; skip high increment if no rollover
05405    
05406    D659  E6 98              INC   Frnxth            ; increment pointer high byte
05407    Dokeh
05408    D65B  A5 12              LDA   Itemph            ; get value high byte
05409    D65D  81 97              STA   (Frnxtl,X)        ; POKE high byte
05410    D65F  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
05411    
05412    ; perform SWAP
05413    
05414    LAB_SWAP
05415    D662  20 BE CE           JSR   LAB_GVAR          ; get var1 address
05416    D665  85 97              STA   Lvarpl            ; save var1 address low byte
05417    D667  84 98              STY   Lvarph            ; save var1 address high byte
05418    D669  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
05419    D66B  48                 PHA                     ; save data type flag
05420    
05421    D66C  20 04 CD           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
05422    D66F  20 BE CE           JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
05423    D672  68                 PLA                     ; pull var1 data type flag
05424    D673  45 5F              EOR   Dtypef            ; compare with var2 data type
05425    D675  10 10              BPL   SwapErr           ; exit if not both the same type
05426    
05427    D677  A0 03              LDY   #$03              ; four bytes to swap (either value or descriptor+1)
05428    SwapLp
05429    D679  B1 97              LDA   (Lvarpl),Y        ; get byte from var1
05430    D67B  AA                 TAX                     ; save var1 byte
05431    D67C  B1 95              LDA   (Cvaral),Y        ; get byte from var2
05432    D67E  91 97              STA   (Lvarpl),Y        ; save byte to var1
05433    D680  8A                 TXA                     ; restore var1 byte
05434    D681  91 95              STA   (Cvaral),Y        ; save byte to var2
05435    D683  88                 DEY                     ; decrement index
05436    D684  10 F3              BPL   SwapLp            ; loop until done
05437    
05438    D686  60                 RTS
05439    
05440    SwapErr
05441    D687  4C E2 CB           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
05442    
05443    ; perform CALL
05444    
05445    LAB_CALL
05446    D68A  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
05447                                  ; else do type mismatch
05448    D68D  20 04 D6           JSR   LAB_F2FX          ; convert floating-to-fixed
05449    D690  A9 D6              LDA   #>CallExit        ; set return address high byte
05450    D692  48                 PHA                     ; put on stack
05451    D693  A9 98              LDA   #<CallExit-1      ; set return address low byte
05452    D695  48                 PHA                     ; put on stack
05453    D696  6C 11 00           JMP   (Itempl)          ; do indirect jump to user routine
05454    
05455    ; if the called routine exits correctly then it will return to here. this will then get
05456    ; the next byte for the interpreter and return
05457    
05458    CallExit
05459    D699  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
05460    
05461    ; perform WAIT
05462    
05463    LAB_WAIT
05464    D69C  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
05465    D69F  86 97              STX   Frnxtl            ; save byte
05466    D6A1  A2 00              LDX   #$00              ; clear mask
05467    D6A3  20 C2 00           JSR   LAB_GBYT          ; scan memory
05468    D6A6  F0 03              BEQ   LAB_2441          ; skip if no third argument
05469    
05470    D6A8  20 F1 D5           JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
05471    LAB_2441
05472    D6AB  86 98              STX   Frnxth            ; save EOR argument
05473    LAB_2445
05474    D6AD  B1 11              LDA   (Itempl),Y        ; get byte via temporary integer (addr)
05475    D6AF  45 98              EOR   Frnxth            ; EOR with second argument (mask)
05476    D6B1  25 97              AND   Frnxtl            ; AND with first argument (byte)
05477    D6B3  F0 F8              BEQ   LAB_2445          ; loop if result is zero
05478    
05479    LAB_244D
05480    D6B5  60                 RTS
05481    
05482    ; perform subtraction, FAC1 from (AY)
05483    
05484    LAB_2455
05485    D6B6  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
05486    
05487    ; perform subtraction, FAC1 from FAC2
05488    
05489    LAB_SUBTRACT
05490    D6B9  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
05491    D6BB  49 FF              EOR   #$FF              ; complement it
05492    D6BD  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05493    D6BF  45 B7              EOR   FAC2_s            ; EOR with FAC2 sign (b7)
05494    D6C1  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
05495    D6C3  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05496    D6C5  4C D4 D6           JMP   LAB_ADD           ; go add FAC2 to FAC1
05497    
05498    ; perform addition
05499    
05500    LAB_2467
05501    D6C8  20 ED D7           JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
05502    D6CB  90 4D              BCC   LAB_24A8          ;.go subtract mantissas
05503    
05504    ; add 0.5 to FAC1
05505    
05506    LAB_244E
05507    D6CD  A9 03              LDA   #<LAB_2A96        ; set 0.5 pointer low byte
05508    D6CF  A0 E3              LDY   #>LAB_2A96        ; set 0.5 pointer high byte
05509    
05510    ; add (AY) to FAC1
05511    
05512    LAB_246C
05513    D6D1  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
05514    
05515    ; add FAC2 to FAC1
05516    
05517    LAB_ADD
05518    D6D4  D0 10              BNE   LAB_2474          ; branch if FAC1 was not zero
05519    
05520    ; copy FAC2 to FAC1
05521    
05522    LAB_279B
05523    D6D6  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
05524    
05525    ; save FAC1 sign and copy ABS(FAC2) to FAC1
05526    
05527    LAB_279D
05528    D6D8  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05529    D6DA  A2 04              LDX   #$04              ; 4 bytes to copy
05530    LAB_27A1
05531    D6DC  B5 B2              LDA   FAC1_o,X          ; get byte from FAC2,X
05532    D6DE  95 AB              STA   FAC1_e-1,X        ; save byte at FAC1,X
05533    D6E0  CA                 DEX                     ; decrement count
05534    D6E1  D0 F9              BNE   LAB_27A1          ; loop if not all done
05535    
05536    D6E3  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
05537    D6E5  60                 RTS
05538    
05539                                  ; FAC1 is non zero
05540    LAB_2474
05541    D6E6  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
05542    D6E8  86 A3              STX   FAC2_r            ; save as FAC2 rounding byte
05543    D6EA  A2 B3              LDX   #FAC2_e           ; set index to FAC2 exponent addr
05544    D6EC  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
05545    LAB_247C
05546    D6EE  A8                 TAY                     ; copy exponent
05547    D6EF  F0 C4              BEQ   LAB_244D          ; exit if zero
05548    
05549    D6F1  38                 SEC                     ; set carry for subtract
05550    D6F2  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
05551    D6F4  F0 24              BEQ   LAB_24A8          ; branch if = (go add mantissa)
05552    
05553    D6F6  90 12              BCC   LAB_2498          ; branch if <
05554    
05555                                  ; FAC2>FAC1
05556    D6F8  84 AC              STY   FAC1_e            ; save FAC1 exponent
05557    D6FA  A4 B7              LDY   FAC2_s            ; get FAC2 sign (b7)
05558    D6FC  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
05559    D6FE  49 FF              EOR   #$FF              ; complement A
05560    D700  69 00              ADC   #$00              ; +1 (twos complement, carry is set)
05561    D702  A0 00              LDY   #$00              ; clear Y
05562    D704  84 A3              STY   FAC2_r            ; clear FAC2 rounding byte
05563    D706  A2 AC              LDX   #FAC1_e           ; set index to FAC1 exponent addr
05564    D708  D0 04              BNE   LAB_249C          ; branch always
05565    
05566    LAB_2498
05567    D70A  A0 00              LDY   #$00              ; clear Y
05568    D70C  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
05569    LAB_249C
05570    D70E  C9 F9              CMP   #$F9              ; compare exponent diff with $F9
05571    D710  30 B6              BMI   LAB_2467          ; branch if range $79-$F8
05572    
05573    D712  A8                 TAY                     ; copy exponent difference to Y
05574    D713  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05575    D715  56 01              LSR   PLUS_1,X          ; shift FAC? mantissa1
05576    D717  20 04 D8           JSR   LAB_2592          ; shift FACX Y times right
05577    
05578                                  ; exponents are equal now do mantissa subtract
05579    LAB_24A8
05580    D71A  24 B8              BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
05581    D71C  10 4C              BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
05582    
05583    D71E  A0 AC              LDY   #FAC1_e           ; set index to FAC1 exponent addr
05584    D720  E0 B3              CPX   #FAC2_e           ; compare X to FAC2 exponent addr
05585    D722  F0 02              BEQ   LAB_24B4          ; branch if =
05586    
05587    D724  A0 B3              LDY   #FAC2_e           ; else set index to FAC2 exponent addr
05588    
05589                                  ; subtract smaller from bigger (take sign of bigger)
05590    LAB_24B4
05591    D726  38                 SEC                     ; set carry for subtract
05592    D727  49 FF              EOR   #$FF              ; ones complement A
05593    D729  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
05594    D72B  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
05595    D72D  B9 03 00           LDA   PLUS_3,Y          ; get FACY mantissa3
05596    D730  F5 03              SBC   PLUS_3,X          ; subtract FACX mantissa3
05597    D732  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
05598    D734  B9 02 00           LDA   PLUS_2,Y          ; get FACY mantissa2
05599    D737  F5 02              SBC   PLUS_2,X          ; subtract FACX mantissa2
05600    D739  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
05601    D73B  B9 01 00           LDA   PLUS_1,Y          ; get FACY mantissa1
05602    D73E  F5 01              SBC   PLUS_1,X          ; subtract FACX mantissa1
05603    D740  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
05604    
05605    ; do ABS and normalise FAC1
05606    
05607    LAB_24D0
05608    D742  B0 03              BCS   LAB_24D5          ; branch if number is +ve
05609    
05610    D744  20 A9 D7           JSR   LAB_2537          ; negate FAC1
05611    
05612    ; normalise FAC1
05613    
05614    LAB_24D5
05615    D747  A0 00              LDY   #$00              ; clear Y
05616    D749  98                 TYA                     ; clear A
05617    D74A  18                 CLC                     ; clear carry for add
05618    LAB_24D9
05619    D74B  A6 AD              LDX   FAC1_1            ; get FAC1 mantissa1
05620    D74D  D0 3E              BNE   LAB_251B          ; if not zero normalise FAC1
05621    
05622    D74F  A6 AE              LDX   FAC1_2            ; get FAC1 mantissa2
05623    D751  86 AD              STX   FAC1_1            ; save FAC1 mantissa1
05624    D753  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
05625    D755  86 AE              STX   FAC1_2            ; save FAC1 mantissa2
05626    D757  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
05627    D759  86 AF              STX   FAC1_3            ; save FAC1 mantissa3
05628    D75B  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
05629    D75D  69 08              ADC   #$08              ; add x to exponent offset
05630    D75F  C9 18              CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
05631    D761  D0 E8              BNE   LAB_24D9          ; loop if not max
05632    
05633    ; clear FAC1 exponent and sign
05634    
05635    LAB_24F1
05636    D763  A9 00              LDA   #$00              ; clear A
05637    LAB_24F3
05638    D765  85 AC              STA   FAC1_e            ; set FAC1 exponent
05639    
05640    ; save FAC1 sign
05641    
05642    LAB_24F5
05643    D767  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05644    D769  60                 RTS
05645    
05646    ; add FAC2 mantissa to FAC1 mantissa
05647    
05648    LAB_24F8
05649    D76A  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
05650    D76C  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
05651    D76E  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
05652    D770  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
05653    D772  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
05654    D774  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05655    D776  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
05656    D778  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
05657    D77A  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
05658    D77C  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
05659    D77E  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
05660    D780  B0 1A              BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
05661    
05662    D782  60                 RTS                     ; else just exit
05663    
05664    LAB_2511
05665    D783  69 01              ADC   #$01              ; add 1 to exponent offset
05666    D785  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
05667    D787  26 AF              ROL   FAC1_3            ; shift FAC1 mantissa3
05668    D789  26 AE              ROL   FAC1_2            ; shift FAC1 mantissa2
05669    D78B  26 AD              ROL   FAC1_1            ; shift FAC1 mantissa1
05670    
05671    ; normalise FAC1
05672    
05673    LAB_251B
05674    D78D  10 F4              BPL   LAB_2511          ; loop if not normalised
05675    
05676    D78F  38                 SEC                     ; set carry for subtract
05677    D790  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
05678    D792  B0 CF              BCS   LAB_24F1          ; branch if underflow (set result = $0)
05679    
05680    D794  49 FF              EOR   #$FF              ; complement exponent
05681    D796  69 01              ADC   #$01              ; +1 (twos complement)
05682    D798  85 AC              STA   FAC1_e            ; save FAC1 exponent
05683    
05684    ; test and normalise FAC1 for C=0/1
05685    
05686    LAB_2528
05687    D79A  90 0C              BCC   LAB_2536          ; exit if no overflow
05688    
05689    ; normalise FAC1 for C=1
05690    
05691    LAB_252A
05692    D79C  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
05693    D79E  F0 36              BEQ   LAB_2564          ; if zero do overflow error and warm start
05694    
05695    D7A0  66 AD              ROR   FAC1_1            ; shift FAC1 mantissa1
05696    D7A2  66 AE              ROR   FAC1_2            ; shift FAC1 mantissa2
05697    D7A4  66 AF              ROR   FAC1_3            ; shift FAC1 mantissa3
05698    D7A6  66 B9              ROR   FAC1_r            ; shift FAC1 rounding byte
05699    LAB_2536
05700    D7A8  60                 RTS
05701    
05702    ; negate FAC1
05703    
05704    LAB_2537
05705    D7A9  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
05706    D7AB  49 FF              EOR   #$FF              ; complement it
05707    D7AD  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05708    
05709    ; twos complement FAC1 mantissa
05710    
05711    LAB_253D
05712    D7AF  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
05713    D7B1  49 FF              EOR   #$FF              ; complement it
05714    D7B3  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
05715    D7B5  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05716    D7B7  49 FF              EOR   #$FF              ; complement it
05717    D7B9  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
05718    D7BB  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
05719    D7BD  49 FF              EOR   #$FF              ; complement it
05720    D7BF  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
05721    D7C1  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05722    D7C3  49 FF              EOR   #$FF              ; complement it
05723    D7C5  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
05724    D7C7  E6 B9              INC   FAC1_r            ; increment FAC1 rounding byte
05725    D7C9  D0 0A              BNE   LAB_2563          ; exit if no overflow
05726    
05727    ; increment FAC1 mantissa
05728    
05729    LAB_2559
05730    D7CB  E6 AF              INC   FAC1_3            ; increment FAC1 mantissa3
05731    D7CD  D0 06              BNE   LAB_2563          ; finished if no rollover
05732    
05733    D7CF  E6 AE              INC   FAC1_2            ; increment FAC1 mantissa2
05734    D7D1  D0 02              BNE   LAB_2563          ; finished if no rollover
05735    
05736    D7D3  E6 AD              INC   FAC1_1            ; increment FAC1 mantissa1
05737    LAB_2563
05738    D7D5  60                 RTS
05739    
05740    ; do overflow error (overflow exit)
05741    
05742    LAB_2564
05743    D7D6  A2 0A              LDX   #$0A              ; error code $0A ("Overflow" error)
05744    D7D8  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
05745    
05746    ; shift FCAtemp << A+8 times
05747    
05748    LAB_2569
05749    D7DB  A2 74              LDX   #FACt_1-1         ; set offset to FACtemp
05750    LAB_256B
05751    D7DD  B4 03              LDY   PLUS_3,X          ; get FACX mantissa3
05752    D7DF  84 B9              STY   FAC1_r            ; save as FAC1 rounding byte
05753    D7E1  B4 02              LDY   PLUS_2,X          ; get FACX mantissa2
05754    D7E3  94 03              STY   PLUS_3,X          ; save FACX mantissa3
05755    D7E5  B4 01              LDY   PLUS_1,X          ; get FACX mantissa1
05756    D7E7  94 02              STY   PLUS_2,X          ; save FACX mantissa2
05757    D7E9  A4 B2              LDY   FAC1_o            ; get FAC1 overflow byte
05758    D7EB  94 01              STY   PLUS_1,X          ; save FACX mantissa1
05759    
05760    ; shift FACX -A times right (> 8 shifts)
05761    
05762    LAB_257B
05763    D7ED  69 08              ADC   #$08              ; add 8 to shift count
05764    D7EF  30 EC              BMI   LAB_256B          ; go do 8 shift if still -ve
05765    
05766    D7F1  F0 EA              BEQ   LAB_256B          ; go do 8 shift if zero
05767    
05768    D7F3  E9 08              SBC   #$08              ; else subtract 8 again
05769    D7F5  A8                 TAY                     ; save count to Y
05770    D7F6  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05771    D7F8  B0 12              BCS   LAB_259A          ;.
05772    
05773    LAB_2588
05774    D7FA  16 01              ASL   PLUS_1,X          ; shift FACX mantissa1
05775    D7FC  90 02              BCC   LAB_258E          ; branch if +ve
05776    
05777    D7FE  F6 01              INC   PLUS_1,X          ; this sets b7 eventually
05778    LAB_258E
05779    D800  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
05780    D802  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
05781    
05782    ; shift FACX Y times right
05783    
05784    LAB_2592
05785    D804  76 02              ROR   PLUS_2,X          ; shift FACX mantissa2
05786    D806  76 03              ROR   PLUS_3,X          ; shift FACX mantissa3
05787    D808  6A                 ROR                     ; shift FACX rounding byte
05788    D809  C8                 INY                     ; increment exponent diff
05789    D80A  D0 EE              BNE   LAB_2588          ; branch if range adjust not complete
05790    
05791    LAB_259A
05792    D80C  18                 CLC                     ; just clear it
05793    D80D  60                 RTS
05794    
05795    ; perform LOG()
05796    
05797    LAB_LOG
05798    D80E  20 FC D9           JSR   LAB_27CA          ; test sign and zero
05799    D811  F0 02              BEQ   LAB_25C4          ; if zero do function call error then warm start
05800    
05801    D813  10 03              BPL   LAB_25C7          ; skip error if +ve
05802    
05803    LAB_25C4
05804    D815  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start (-ve)
05805    
05806    LAB_25C7
05807    D818  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05808    D81A  E9 7F              SBC   #$7F              ; normalise it
05809    D81C  48                 PHA                     ; save it
05810    D81D  A9 80              LDA   #$80              ; set exponent to zero
05811    D81F  85 AC              STA   FAC1_e            ; save FAC1 exponent
05812    D821  A9 83              LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
05813    D823  A0 E2              LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
05814    D825  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
05815    D828  A9 87              LDA   #<LAB_25B1        ; set root2 pointer low byte
05816    D82A  A0 E2              LDY   #>LAB_25B1        ; set root2 pointer high byte
05817    D82C  20 14 D9           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
05818    D82F  A9 FA              LDA   #<LAB_259C        ; set 1 pointer low byte
05819    D831  A0 E2              LDY   #>LAB_259C        ; set 1 pointer high byte
05820    D833  20 B6 D6           JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
05821    D836  A9 76              LDA   #<LAB_25A0        ; set pointer low byte to counter
05822    D838  A0 E2              LDY   #>LAB_25A0        ; set pointer high byte to counter
05823    D83A  20 64 DD           JSR   LAB_2B6E          ; ^2 then series evaluation
05824    D83D  A9 8B              LDA   #<LAB_25B5        ; set -0.5 pointer low byte
05825    D83F  A0 E2              LDY   #>LAB_25B5        ; set -0.5 pointer high byte
05826    D841  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
05827    D844  68                 PLA                     ; restore FAC1 exponent
05828    D845  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
05829    D848  A9 8F              LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
05830    D84A  A0 E2              LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
05831    
05832    ; do convert AY, FCA1*(AY)
05833    
05834    LAB_25FB
05835    D84C  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
05836    LAB_MULTIPLY
05837    D84F  F0 4C              BEQ   LAB_264C          ; exit if zero
05838    
05839    D851  20 C4 D8           JSR   LAB_2673          ; test and adjust accumulators
05840    D854  A9 00              LDA   #$00              ; clear A
05841    D856  85 75              STA   FACt_1            ; clear temp mantissa1
05842    D858  85 76              STA   FACt_2            ; clear temp mantissa2
05843    D85A  85 77              STA   FACt_3            ; clear temp mantissa3
05844    D85C  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
05845    D85E  20 73 D8           JSR   LAB_2622          ; go do shift/add FAC2
05846    D861  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
05847    D863  20 73 D8           JSR   LAB_2622          ; go do shift/add FAC2
05848    D866  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
05849    D868  20 73 D8           JSR   LAB_2622          ; go do shift/add FAC2
05850    D86B  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
05851    D86D  20 79 D8           JSR   LAB_2627          ; go do shift/add FAC2
05852    D870  4C 81 D9           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
05853    
05854    LAB_2622
05855    D873  D0 04              BNE   LAB_2627          ; branch if byte <> zero
05856    ; *** begin patch  2.22p5.6  floating point multiply rounding bug
05857    ; *** replace
05858    ;      JMP   LAB_2569          ; shift FCAtemp << A+8 times
05859    ;
05860    ;                              ; else do shift and add
05861    ;LAB_2627
05862    ;      LSR                     ; shift byte
05863    ;      ORA   #$80              ; set top bit (mark for 8 times)
05864    ; *** with
05865    D875  38                 SEC
05866    D876  4C DB D7           JMP   LAB_2569          ; shift FACtemp << A+8 times
05867    
05868                                  ; else do shift and add
05869    LAB_2627
05870    D879  38                 SEC                     ; set top bit (mark for 8 times)
05871    D87A  6A                 ROR
05872    ; *** end patch    2.22p5.6  floating point multiply rounding bug
05873    LAB_262A
05874    D87B  A8                 TAY                     ; copy result
05875    D87C  90 13              BCC   LAB_2640          ; skip next if bit was zero
05876    
05877    D87E  18                 CLC                     ; clear carry for add
05878    D87F  A5 77              LDA   FACt_3            ; get temp mantissa3
05879    D881  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
05880    D883  85 77              STA   FACt_3            ; save temp mantissa3
05881    D885  A5 76              LDA   FACt_2            ; get temp mantissa2
05882    D887  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
05883    D889  85 76              STA   FACt_2            ; save temp mantissa2
05884    D88B  A5 75              LDA   FACt_1            ; get temp mantissa1
05885    D88D  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
05886    D88F  85 75              STA   FACt_1            ; save temp mantissa1
05887    LAB_2640
05888    D891  66 75              ROR   FACt_1            ; shift temp mantissa1
05889    D893  66 76              ROR   FACt_2            ; shift temp mantissa2
05890    D895  66 77              ROR   FACt_3            ; shift temp mantissa3
05891    D897  66 B9              ROR   FAC1_r            ; shift temp rounding byte
05892    D899  98                 TYA                     ; get byte back
05893    D89A  4A                 LSR                     ; shift byte
05894    D89B  D0 DE              BNE   LAB_262A          ; loop if all bits not done
05895    
05896    LAB_264C
05897    D89D  60                 RTS
05898    
05899    ; unpack memory (AY) into FAC2
05900    
05901    LAB_264D
05902    D89E  85 71              STA   ut1_pl            ; save pointer low byte
05903    D8A0  84 72              STY   ut1_ph            ; save pointer high byte
05904    D8A2  A0 03              LDY   #$03              ; 4 bytes to get (0-3)
05905    D8A4  B1 71              LDA   (ut1_pl),Y        ; get mantissa3
05906    D8A6  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
05907    D8A8  88                 DEY                     ; decrement index
05908    D8A9  B1 71              LDA   (ut1_pl),Y        ; get mantissa2
05909    D8AB  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
05910    D8AD  88                 DEY                     ; decrement index
05911    D8AE  B1 71              LDA   (ut1_pl),Y        ; get mantissa1+sign
05912    D8B0  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
05913    D8B2  45 B0              EOR   FAC1_s            ; EOR with FAC1 sign (b7)
05914    D8B4  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
05915    D8B6  A5 B7              LDA   FAC2_s            ; recover FAC2 sign (b7)
05916    D8B8  09 80              ORA   #$80              ; set 1xxx xxx (set normal bit)
05917    D8BA  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
05918    D8BC  88                 DEY                     ; decrement index
05919    D8BD  B1 71              LDA   (ut1_pl),Y        ; get exponent byte
05920    D8BF  85 B3              STA   FAC2_e            ; save FAC2 exponent
05921    D8C1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
05922    D8C3  60                 RTS
05923    
05924    ; test and adjust accumulators
05925    
05926    LAB_2673
05927    D8C4  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
05928    LAB_2675
05929    D8C6  F0 1D              BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
05930    
05931    D8C8  18                 CLC                     ; clear carry for add
05932    D8C9  65 AC              ADC   FAC1_e            ; add FAC1 exponent
05933    D8CB  90 04              BCC   LAB_2680          ; branch if sum of exponents <$0100
05934    
05935    D8CD  30 31              BMI   LAB_269B          ; do overflow error
05936    
05937    D8CF  18                 CLC                     ; clear carry for the add
05938          .byte $2C               ; makes next line BIT $1410
05939    LAB_2680
05940    D8D1  10 12              BPL   LAB_2696          ; if +ve go handle underflow
05941    
05942    D8D3  69 80              ADC   #$80              ; adjust exponent
05943    D8D5  85 AC              STA   FAC1_e            ; save FAC1 exponent
05944    D8D7  D0 03              BNE   LAB_268B          ; branch if not zero
05945    
05946    D8D9  4C 67 D7           JMP   LAB_24F5          ; save FAC1 sign and return
05947    
05948    LAB_268B
05949    D8DC  A5 B8              LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
05950    D8DE  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
05951    LAB_268F
05952    D8E0  60                 RTS
05953    
05954    ; handle overflow and underflow
05955    
05956    LAB_2690
05957    D8E1  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
05958    D8E3  10 1B              BPL   LAB_269B          ; do overflow error
05959    
05960                                  ; handle underflow
05961    LAB_2696
05962    D8E5  68                 PLA                     ; pop return address low byte
05963    D8E6  68                 PLA                     ; pop return address high byte
05964    D8E7  4C 63 D7           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
05965    
05966    ; multiply by 10
05967    
05968    LAB_269E
05969    D8EA  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
05970    D8ED  AA                 TAX                     ; copy exponent (set the flags)
05971    D8EE  F0 F0              BEQ   LAB_268F          ; exit if zero
05972    
05973    D8F0  18                 CLC                     ; clear carry for add
05974    D8F1  69 02              ADC   #$02              ; add two to exponent (*4)
05975    D8F3  B0 0B              BCS   LAB_269B          ; do overflow error if > $FF
05976    
05977    D8F5  A2 00              LDX   #$00              ; clear byte
05978    D8F7  86 B8              STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
05979    D8F9  20 EE D6           JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
05980    D8FC  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*10)
05981    D8FE  D0 E0              BNE   LAB_268F          ; if non zero just do RTS
05982    
05983    LAB_269B
05984    D900  4C D6 D7           JMP   LAB_2564          ; do overflow error and warm start
05985    
05986    ; divide by 10
05987    
05988    LAB_26B9
05989    D903  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
05990    D906  A9 0B              LDA   #<LAB_26B5        ; set pointer to 10d low addr
05991    D908  A0 E3              LDY   #>LAB_26B5        ; set pointer to 10d high addr
05992    D90A  A2 00              LDX   #$00              ; clear sign
05993    
05994    ; divide by (AY) (X=sign)
05995    
05996    LAB_26C2
05997    D90C  86 B8              STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
05998    D90E  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
05999    D911  4C 17 D9           JMP   LAB_DIVIDE        ; do FAC2/FAC1
06000    
06001                                  ; Perform divide-by
06002    ; convert AY and do (AY)/FAC1
06003    
06004    LAB_26CA
06005    D914  20 9E D8           JSR   LAB_264D          ; unpack memory (AY) into FAC2
06006    
06007                                  ; Perform divide-into
06008    LAB_DIVIDE
06009    D917  F0 63              BEQ   LAB_2737          ; if zero go do /0 error
06010    
06011    D919  20 EC D9           JSR   LAB_27BA          ; round FAC1
06012    D91C  A9 00              LDA   #$00              ; clear A
06013    D91E  38                 SEC                     ; set carry for subtract
06014    D91F  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
06015    D921  85 AC              STA   FAC1_e            ; save FAC1 exponent
06016    D923  20 C4 D8           JSR   LAB_2673          ; test and adjust accumulators
06017    D926  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
06018    D928  F0 D6              BEQ   LAB_269B          ; if zero do overflow error
06019    
06020    D92A  A2 FF              LDX   #$FF              ; set index for pre increment
06021    D92C  A9 01              LDA   #$01              ; set bit to flag byte save
06022    LAB_26E4
06023    D92E  A4 B4              LDY   FAC2_1            ; get FAC2 mantissa1
06024    D930  C4 AD              CPY   FAC1_1            ; compare FAC1 mantissa1
06025    D932  D0 0A              BNE   LAB_26F4          ; branch if <>
06026    
06027    D934  A4 B5              LDY   FAC2_2            ; get FAC2 mantissa2
06028    D936  C4 AE              CPY   FAC1_2            ; compare FAC1 mantissa2
06029    D938  D0 04              BNE   LAB_26F4          ; branch if <>
06030    
06031    D93A  A4 B6              LDY   FAC2_3            ; get FAC2 mantissa3
06032    D93C  C4 AF              CPY   FAC1_3            ; compare FAC1 mantissa3
06033    LAB_26F4
06034    D93E  08                 PHP                     ; save FAC2-FAC1 compare status
06035    D93F  2A                 ROL                     ; shift the result byte
06036    D940  90 0E              BCC   LAB_2702          ; if no carry skip the byte save
06037    
06038    D942  A0 01              LDY   #$01              ; set bit to flag byte save
06039    D944  E8                 INX                     ; else increment the index to FACt
06040    D945  E0 02              CPX   #$02              ; compare with the index to FACt_3
06041    D947  30 04              BMI   LAB_2701          ; if not last byte just go save it
06042    
06043    D949  D0 28              BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
06044                                  ; return
06045    
06046    D94B  A0 40              LDY   #$40              ; set bit to flag byte save for the rounding byte
06047    LAB_2701
06048    D94D  95 75              STA   FACt_1,X          ; write result byte to FACt_1 + index
06049    D94F  98                 TYA                     ; copy the next save byte flag
06050    LAB_2702
06051    D950  28                 PLP                     ; restore FAC2-FAC1 compare status
06052    D951  90 14              BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
06053    
06054    D953  A8                 TAY                     ; save FAC2-FAC1 compare status
06055    D954  A5 B6              LDA   FAC2_3            ; get FAC2 mantissa3
06056    D956  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
06057    D958  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
06058    D95A  A5 B5              LDA   FAC2_2            ; get FAC2 mantissa2
06059    D95C  E5 AE              SBC   FAC1_2            ; subtract FAC1 mantissa2
06060    D95E  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
06061    D960  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
06062    D962  E5 AD              SBC   FAC1_1            ; subtract FAC1 mantissa1
06063    D964  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
06064    D966  98                 TYA                     ; restore FAC2-FAC1 compare status
06065    
06066                                  ; FAC2 = FAC2*2
06067    LAB_2704
06068    D967  06 B6              ASL   FAC2_3            ; shift FAC2 mantissa3
06069    D969  26 B5              ROL   FAC2_2            ; shift FAC2 mantissa2
06070    D96B  26 B4              ROL   FAC2_1            ; shift FAC2 mantissa1
06071    D96D  B0 CF              BCS   LAB_26F4          ; loop with no compare
06072    
06073    D96F  30 BD              BMI   LAB_26E4          ; loop with compare
06074    
06075    D971  10 CB              BPL   LAB_26F4          ; loop always with no compare
06076    
06077    ; do A<<6, save as FAC1 rounding byte, normalise and return
06078    
06079    LAB_272B
06080    D973  4A                 LSR                     ; shift b1 - b0 ..
06081    D974  6A                 ROR                     ; ..
06082    D975  6A                 ROR                     ; .. to b7 - b6
06083    D976  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
06084    D978  28                 PLP                     ; dump FAC2-FAC1 compare status
06085    D979  4C 81 D9           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
06086    
06087    ; do "Divide by zero" error
06088    
06089    LAB_2737
06090    D97C  A2 14              LDX   #$14              ; error code $14 ("Divide by zero" error)
06091    D97E  4C 3F C2           JMP   LAB_XERR          ; do error #X, then warm start
06092    
06093    ; copy temp to FAC1 and normalise
06094    
06095    LAB_273C
06096    D981  A5 75              LDA   FACt_1            ; get temp mantissa1
06097    D983  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06098    D985  A5 76              LDA   FACt_2            ; get temp mantissa2
06099    D987  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
06100    D989  A5 77              LDA   FACt_3            ; get temp mantissa3
06101    D98B  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
06102    D98D  4C 47 D7           JMP   LAB_24D5          ; normalise FAC1 and return
06103    
06104    ; unpack memory (AY) into FAC1
06105    
06106    LAB_UFAC
06107    D990  85 71              STA   ut1_pl            ; save pointer low byte
06108    D992  84 72              STY   ut1_ph            ; save pointer high byte
06109    D994  A0 03              LDY   #$03              ; 4 bytes to do
06110    D996  B1 71              LDA   (ut1_pl),Y        ; get last byte
06111    D998  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
06112    D99A  88                 DEY                     ; decrement index
06113    D99B  B1 71              LDA   (ut1_pl),Y        ; get last-1 byte
06114    D99D  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
06115    D99F  88                 DEY                     ; decrement index
06116    D9A0  B1 71              LDA   (ut1_pl),Y        ; get second byte
06117    D9A2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
06118    D9A4  09 80              ORA   #$80              ; set 1xxx xxxx (add normal bit)
06119    D9A6  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06120    D9A8  88                 DEY                     ; decrement index
06121    D9A9  B1 71              LDA   (ut1_pl),Y        ; get first byte (exponent)
06122    D9AB  85 AC              STA   FAC1_e            ; save FAC1 exponent
06123    D9AD  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
06124    D9AF  60                 RTS
06125    
06126    ; pack FAC1 into Adatal
06127    
06128    LAB_276E
06129    D9B0  A2 A4              LDX   #<Adatal          ; set pointer low byte
06130    LAB_2770
06131    D9B2  A0 00              LDY   #>Adatal          ; set pointer high byte
06132    D9B4  F0 04              BEQ   LAB_2778          ; pack FAC1 into (XY) and return
06133    
06134    ; pack FAC1 into (Lvarpl)
06135    
06136    LAB_PFAC
06137    D9B6  A6 97              LDX   Lvarpl            ; get destination pointer low byte
06138    D9B8  A4 98              LDY   Lvarph            ; get destination pointer high byte
06139    
06140    ; pack FAC1 into (XY)
06141    
06142    LAB_2778
06143    D9BA  20 EC D9           JSR   LAB_27BA          ; round FAC1
06144    D9BD  86 71              STX   ut1_pl            ; save pointer low byte
06145    D9BF  84 72              STY   ut1_ph            ; save pointer high byte
06146    D9C1  A0 03              LDY   #$03              ; set index
06147    D9C3  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
06148    D9C5  91 71              STA   (ut1_pl),Y        ; store in destination
06149    D9C7  88                 DEY                     ; decrement index
06150    D9C8  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
06151    D9CA  91 71              STA   (ut1_pl),Y        ; store in destination
06152    D9CC  88                 DEY                     ; decrement index
06153    D9CD  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06154    D9CF  09 7F              ORA   #$7F              ; set bits x111 1111
06155    D9D1  25 AD              AND   FAC1_1            ; AND in FAC1 mantissa1
06156    D9D3  91 71              STA   (ut1_pl),Y        ; store in destination
06157    D9D5  88                 DEY                     ; decrement index
06158    D9D6  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06159    D9D8  91 71              STA   (ut1_pl),Y        ; store in destination
06160    D9DA  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
06161    D9DC  60                 RTS
06162    
06163    ; round and copy FAC1 to FAC2
06164    
06165    LAB_27AB
06166    D9DD  20 EC D9           JSR   LAB_27BA          ; round FAC1
06167    
06168    ; copy FAC1 to FAC2
06169    
06170    LAB_27AE
06171    D9E0  A2 05              LDX   #$05              ; 5 bytes to copy
06172    LAB_27B0
06173    D9E2  B5 AB              LDA   FAC1_e-1,X        ; get byte from FAC1,X
06174    D9E4  95 B2              STA   FAC1_o,X          ; save byte at FAC2,X
06175    D9E6  CA                 DEX                     ; decrement count
06176    D9E7  D0 F9              BNE   LAB_27B0          ; loop if not all done
06177    
06178    D9E9  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
06179    LAB_27B9
06180    D9EB  60                 RTS
06181    
06182    ; round FAC1
06183    
06184    LAB_27BA
06185    D9EC  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06186    D9EE  F0 FB              BEQ   LAB_27B9          ; exit if zero
06187    
06188    D9F0  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
06189    D9F2  90 F7              BCC   LAB_27B9          ; exit if no overflow
06190    
06191    ; round FAC1 (no check)
06192    
06193    LAB_27C2
06194    D9F4  20 CB D7           JSR   LAB_2559          ; increment FAC1 mantissa
06195    D9F7  D0 F2              BNE   LAB_27B9          ; branch if no overflow
06196    
06197    D9F9  4C 9C D7           JMP   LAB_252A          ; normalise FAC1 for C=1 and return
06198    
06199    ; get FAC1 sign
06200    ; return A=FF,C=1/-ve A=01,C=0/+ve
06201    
06202    LAB_27CA
06203    D9FC  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06204    D9FE  F0 09              BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
06205    
06206    ; return A=FF,C=1/-ve A=01,C=0/+ve
06207    ; no = 0 check
06208    
06209    LAB_27CE
06210    DA00  A5 B0              LDA   FAC1_s            ; else get FAC1 sign (b7)
06211    
06212    ; return A=FF,C=1/-ve A=01,C=0/+ve
06213    ; no = 0 check, sign in A
06214    
06215    LAB_27D0
06216    DA02  2A                 ROL                     ; move sign bit to carry
06217    DA03  A9 FF              LDA   #$FF              ; set byte for -ve result
06218    DA05  B0 02              BCS   LAB_27D7          ; return if sign was set (-ve)
06219    
06220    DA07  A9 01              LDA   #$01              ; else set byte for +ve result
06221    LAB_27D7
06222    DA09  60                 RTS
06223    
06224    ; perform SGN()
06225    
06226    LAB_SGN
06227    DA0A  20 FC D9           JSR   LAB_27CA          ; get FAC1 sign
06228                                  ; return A=$FF/-ve A=$01/+ve
06229    ; save A as integer byte
06230    
06231    LAB_27DB
06232    DA0D  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06233    DA0F  A9 00              LDA   #$00              ; clear A
06234    DA11  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
06235    DA13  A2 88              LDX   #$88              ; set exponent
06236    
06237    ; set exp=X, clearFAC1 mantissa3 and normalise
06238    
06239    LAB_27E3
06240    DA15  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
06241    DA17  49 FF              EOR   #$FF              ; complement it
06242    DA19  2A                 ROL                     ; sign bit into carry
06243    
06244    ; set exp=X, clearFAC1 mantissa3 and normalise
06245    
06246    LAB_STFA
06247    DA1A  A9 00              LDA   #$00              ; clear A
06248    DA1C  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
06249    DA1E  86 AC              STX   FAC1_e            ; set FAC1 exponent
06250    DA20  85 B9              STA   FAC1_r            ; clear FAC1 rounding byte
06251    DA22  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
06252    DA24  4C 42 D7           JMP   LAB_24D0          ; do ABS and normalise FAC1
06253    
06254    ; perform ABS()
06255    
06256    LAB_ABS
06257    DA27  46 B0              LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
06258    DA29  60                 RTS
06259    
06260    ; compare FAC1 with (AY)
06261    ; returns A=$00 if FAC1 = (AY)
06262    ; returns A=$01 if FAC1 > (AY)
06263    ; returns A=$FF if FAC1 < (AY)
06264    
06265    LAB_27F8
06266    DA2A  85 73              STA   ut2_pl            ; save pointer low byte
06267    LAB_27FA
06268    DA2C  84 74              STY   ut2_ph            ; save pointer high byte
06269    DA2E  A0 00              LDY   #$00              ; clear index
06270    DA30  B1 73              LDA   (ut2_pl),Y        ; get exponent
06271    DA32  C8                 INY                     ; increment index
06272    DA33  AA                 TAX                     ; copy (AY) exponent to X
06273    DA34  F0 C6              BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
06274                                  ; A=FF,C=1/-ve A=01,C=0/+ve
06275    
06276    DA36  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
06277    DA38  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
06278    DA3A  30 C4              BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
06279                                  ; A=01,C=0/+ve and return
06280    
06281    DA3C  E4 AC              CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
06282    DA3E  D0 1A              BNE   LAB_2828          ; branch if different
06283    
06284    DA40  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
06285    DA42  09 80              ORA   #$80              ; normalise top bit
06286    DA44  C5 AD              CMP   FAC1_1            ; compare with FAC1 mantissa1
06287    DA46  D0 12              BNE   LAB_2828          ; branch if different
06288    
06289    DA48  C8                 INY                     ; increment index
06290    DA49  B1 73              LDA   (ut2_pl),Y        ; get mantissa2
06291    DA4B  C5 AE              CMP   FAC1_2            ; compare with FAC1 mantissa2
06292    DA4D  D0 0B              BNE   LAB_2828          ; branch if different
06293    
06294    DA4F  C8                 INY                     ; increment index
06295    DA50  A9 7F              LDA   #$7F              ; set for 1/2 value rounding byte
06296    DA52  C5 B9              CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
06297    DA54  B1 73              LDA   (ut2_pl),Y        ; get mantissa3
06298    DA56  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
06299    DA58  F0 28              BEQ   LAB_2850          ; exit if mantissa3 equal
06300    
06301    ; gets here if number <> FAC1
06302    
06303    LAB_2828
06304    DA5A  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06305    DA5C  90 02              BCC   LAB_282E          ; branch if FAC1 > (AY)
06306    
06307    DA5E  49 FF              EOR   #$FF              ; else toggle FAC1 sign
06308    LAB_282E
06309    DA60  4C 02 DA           JMP   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
06310    
06311    ; convert FAC1 floating-to-fixed
06312    
06313    LAB_2831
06314    DA63  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06315    DA65  F0 4A              BEQ   LAB_287F          ; if zero go clear FAC1 and return
06316    
06317    DA67  38                 SEC                     ; set carry for subtract
06318    DA68  E9 98              SBC   #$98              ; subtract maximum integer range exponent
06319    DA6A  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
06320    DA6C  10 09              BPL   LAB_2845          ; branch if FAC1 +ve
06321    
06322                                  ; FAC1 was -ve
06323    DA6E  AA                 TAX                     ; copy subtracted exponent
06324    DA6F  A9 FF              LDA   #$FF              ; overflow for -ve number
06325    DA71  85 B2              STA   FAC1_o            ; set FAC1 overflow byte
06326    DA73  20 AF D7           JSR   LAB_253D          ; twos complement FAC1 mantissa
06327    DA76  8A                 TXA                     ; restore subtracted exponent
06328    LAB_2845
06329    DA77  A2 AC              LDX   #FAC1_e           ; set index to FAC1
06330    DA79  C9 F9              CMP   #$F9              ; compare exponent result
06331    DA7B  10 06              BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
06332    
06333    DA7D  20 ED D7           JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
06334    DA80  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
06335    LAB_2850
06336    DA82  60                 RTS
06337    
06338    ; shift FAC1 A times right
06339    
06340    LAB_2851
06341    DA83  A8                 TAY                     ; copy shift count
06342    DA84  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06343    DA86  29 80              AND   #$80              ; mask sign bit only (x000 0000)
06344    DA88  46 AD              LSR   FAC1_1            ; shift FAC1 mantissa1
06345    DA8A  05 AD              ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
06346    DA8C  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06347    DA8E  20 04 D8           JSR   LAB_2592          ; shift FAC1 Y times right
06348    DA91  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
06349    DA93  60                 RTS
06350    
06351    ; perform INT()
06352    
06353    LAB_INT
06354    DA94  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06355    DA96  C9 98              CMP   #$98              ; compare with max int
06356    DA98  B0 1E              BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
06357    
06358    DA9A  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
06359    DA9D  84 B9              STY   FAC1_r            ; save FAC1 rounding byte
06360    DA9F  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06361    DAA1  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
06362    DAA3  49 80              EOR   #$80              ; toggle FAC1 sign
06363    DAA5  2A                 ROL                     ; shift into carry
06364    DAA6  A9 98              LDA   #$98              ; set new exponent
06365    DAA8  85 AC              STA   FAC1_e            ; save FAC1 exponent
06366    DAAA  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
06367    DAAC  85 5B              STA   Temp3             ; save for EXP() function
06368    DAAE  4C 42 D7           JMP   LAB_24D0          ; do ABS and normalise FAC1
06369    
06370    ; clear FAC1 and return
06371    
06372    LAB_287F
06373    DAB1  85 AD              STA   FAC1_1            ; clear FAC1 mantissa1
06374    DAB3  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
06375    DAB5  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
06376    DAB7  A8                 TAY                     ; clear Y
06377    LAB_2886
06378    DAB8  60                 RTS
06379    
06380    ; get FAC1 from string
06381    ; this routine now handles hex and binary values from strings
06382    ; starting with "$" and "%" respectively
06383    
06384    LAB_2887
06385    DAB9  A0 00              LDY   #$00              ; clear Y
06386    DABB  84 5F              STY   Dtypef            ; clear data type flag, $FF=string, $00=numeric
06387    DABD  A2 09              LDX   #$09              ; set index
06388    LAB_288B
06389    DABF  94 A8              STY   numexp,X          ; clear byte
06390    DAC1  CA                 DEX                     ; decrement index
06391    DAC2  10 FB              BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
06392    
06393    DAC4  90 7F              BCC   LAB_28FE          ; branch if 1st character numeric
06394    
06395    ; get FAC1 from string .. first character wasn't numeric
06396    
06397    DAC6  C9 2D              CMP   #'-'              ; else compare with "-"
06398    DAC8  D0 04              BNE   LAB_289A          ; branch if not "-"
06399    
06400    DACA  86 B1              STX   negnum            ; set flag for -ve number (X = $FF)
06401    DACC  F0 04              BEQ   LAB_289C          ; branch always (go scan and check for hex/bin)
06402    
06403    ; get FAC1 from string .. first character wasn't numeric or -
06404    
06405    LAB_289A
06406    DACE  C9 2B              CMP   #'+'              ; else compare with "+"
06407    DAD0  D0 05              BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
06408    
06409    ; was "+" or "-" to start, so get next character
06410    
06411    LAB_289C
06412    DAD2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
06413    DAD5  90 6E              BCC   LAB_28FE          ; branch if numeric character
06414    
06415    ; code here for hex and binary numbers
06416    
06417    LAB_289D
06418    DAD7  C9 24              CMP   #'$'              ; else compare with "$"
06419    DAD9  D0 03              BNE   LAB_NHEX          ; branch if not "$"
06420    
06421    DADB  4C 83 DF           JMP   LAB_CHEX          ; branch if "$"
06422    
06423    LAB_NHEX
06424    DADE  C9 25              CMP   #'%'              ; else compare with "%"
06425    DAE0  D0 08              BNE   LAB_28A3          ; branch if not "%" (continue original code)
06426    
06427    DAE2  4C B1 DF           JMP   LAB_CBIN          ; branch if "%"
06428    
06429    LAB_289E
06430    DAE5  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
06431    LAB_28A1
06432    DAE8  90 5B              BCC   LAB_28FE          ; branch if numeric character
06433    
06434    ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
06435    
06436    LAB_28A3
06437    DAEA  C9 2E              CMP   #'.'              ; else compare with "."
06438    DAEC  F0 2E              BEQ   LAB_28D5          ; branch if "."
06439    
06440    ; get FAC1 from string .. character wasn't numeric, -, + or .
06441    
06442    DAEE  C9 45              CMP   #'E'              ; else compare with "E"
06443    DAF0  D0 30              BNE   LAB_28DB          ; branch if not "E"
06444    
06445                                  ; was "E" so evaluate exponential part
06446    DAF2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
06447    DAF5  90 17              BCC   LAB_28C7          ; branch if numeric character
06448    
06449    DAF7  C9 B8              CMP   #TK_MINUS         ; else compare with token for -
06450    DAF9  F0 0E              BEQ   LAB_28C2          ; branch if token for -
06451    
06452    DAFB  C9 2D              CMP   #'-'              ; else compare with "-"
06453    DAFD  F0 0A              BEQ   LAB_28C2          ; branch if "-"
06454    
06455    DAFF  C9 B7              CMP   #TK_PLUS          ; else compare with token for +
06456    DB01  F0 08              BEQ   LAB_28C4          ; branch if token for +
06457    
06458    DB03  C9 2B              CMP   #'+'              ; else compare with "+"
06459    DB05  F0 04              BEQ   LAB_28C4          ; branch if "+"
06460    
06461    DB07  D0 07              BNE   LAB_28C9          ; branch always
06462    
06463    LAB_28C2
06464    DB09  66 AB              ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
06465    LAB_28C4
06466    DB0B  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
06467    LAB_28C7
06468    DB0E  90 5B              BCC   LAB_2925          ; branch if numeric character
06469    
06470    LAB_28C9
06471    DB10  24 AB              BIT   expneg            ; test exponent -ve flag
06472    DB12  10 0E              BPL   LAB_28DB          ; if +ve go evaluate exponent
06473    
06474                                  ; else do exponent = -exponent 
06475    DB14  A9 00              LDA   #$00              ; clear result
06476    DB16  38                 SEC                     ; set carry for subtract
06477    DB17  E5 A9              SBC   expcnt            ; subtract exponent byte
06478    DB19  4C 24 DB           JMP   LAB_28DD          ; go evaluate exponent
06479    
06480    LAB_28D5
06481    DB1C  66 AA              ROR   numdpf            ; set decimal point flag
06482    DB1E  24 AA              BIT   numdpf            ; test decimal point flag
06483    DB20  50 C3              BVC   LAB_289E          ; branch if only one decimal point so far
06484    
06485                                  ; evaluate exponent
06486    LAB_28DB
06487    DB22  A5 A9              LDA   expcnt            ; get exponent count byte
06488    LAB_28DD
06489    DB24  38                 SEC                     ; set carry for subtract
06490    DB25  E5 A8              SBC   numexp            ; subtract numerator exponent
06491    DB27  85 A9              STA   expcnt            ; save exponent count byte
06492    DB29  F0 12              BEQ   LAB_28F6          ; branch if no adjustment
06493    
06494    DB2B  10 09              BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
06495    
06496                                  ; else go do FAC1/10^(0-expcnt)
06497    LAB_28E6
06498    DB2D  20 03 D9           JSR   LAB_26B9          ; divide by 10
06499    DB30  E6 A9              INC   expcnt            ; increment exponent count byte
06500    DB32  D0 F9              BNE   LAB_28E6          ; loop until all done
06501    
06502    DB34  F0 07              BEQ   LAB_28F6          ; branch always
06503    
06504    LAB_28EF
06505    DB36  20 EA D8           JSR   LAB_269E          ; multiply by 10
06506    DB39  C6 A9              DEC   expcnt            ; decrement exponent count byte
06507    DB3B  D0 F9              BNE   LAB_28EF          ; loop until all done
06508    
06509    LAB_28F6
06510    DB3D  A5 B1              LDA   negnum            ; get -ve flag
06511    DB3F  30 01              BMI   LAB_28FB          ; if -ve do - FAC1 and return
06512    
06513    DB41  60                 RTS
06514    
06515    ; do - FAC1 and return
06516    
06517    LAB_28FB
06518    DB42  4C 07 DD           JMP   LAB_GTHAN         ; do - FAC1 and return
06519    
06520    ; do unsigned FAC1*10+number
06521    
06522    LAB_28FE
06523    DB45  48                 PHA                     ; save character
06524    DB46  24 AA              BIT   numdpf            ; test decimal point flag
06525    DB48  10 02              BPL   LAB_2905          ; skip exponent increment if not set
06526    
06527    DB4A  E6 A8              INC   numexp            ; else increment number exponent
06528    LAB_2905
06529    DB4C  20 EA D8           JSR   LAB_269E          ; multiply FAC1 by 10
06530    DB4F  68                 PLA                     ; restore character
06531    DB50  29 0F              AND   #$0F              ; convert to binary
06532    DB52  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
06533    DB55  4C E5 DA           JMP   LAB_289E          ; go do next character
06534    
06535    ; evaluate new ASCII digit
06536    
06537    LAB_2912
06538    DB58  48                 PHA                     ; save digit
06539    DB59  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
06540    DB5C  68                 PLA                     ; restore digit
06541    DB5D  20 0D DA           JSR   LAB_27DB          ; save A as integer byte
06542    DB60  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
06543    DB62  45 B0              EOR   FAC1_s            ; toggle with FAC1 sign (b7)
06544    DB64  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
06545    DB66  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
06546    DB68  4C D4 D6           JMP   LAB_ADD           ; add FAC2 to FAC1 and return
06547    
06548    ; evaluate next character of exponential part of number
06549    
06550    LAB_2925
06551    DB6B  A5 A9              LDA   expcnt            ; get exponent count byte
06552    DB6D  C9 0A              CMP   #$0A              ; compare with 10 decimal
06553    DB6F  90 09              BCC   LAB_2934          ; branch if less
06554    
06555    DB71  A9 64              LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
06556    DB73  24 AB              BIT   expneg            ; test exponent -ve flag
06557    DB75  30 0E              BMI   LAB_2942          ; branch if -ve
06558    
06559    DB77  4C D6 D7           JMP   LAB_2564          ; else do overflow error
06560    
06561    LAB_2934
06562    DB7A  0A                 ASL                     ; * 2
06563    DB7B  0A                 ASL                     ; * 4
06564    DB7C  65 A9              ADC   expcnt            ; * 5
06565    DB7E  0A                 ASL                     ; * 10
06566    DB7F  A0 00              LDY   #$00              ; set index
06567    DB81  71 C3              ADC   (Bpntrl),Y        ; add character (will be $30 too much!)
06568    DB83  E9 2F              SBC   #'0'-1            ; convert character to binary
06569    LAB_2942
06570    DB85  85 A9              STA   expcnt            ; save exponent count byte
06571    DB87  4C 0B DB           JMP   LAB_28C4          ; go get next character
06572    
06573    ; print " in line [LINE #]"
06574    
06575    LAB_2953
06576    DB8A  A9 27              LDA   #<LAB_LMSG        ; point to " in line " message low byte
06577    DB8C  A0 E9              LDY   #>LAB_LMSG        ; point to " in line " message high byte
06578    DB8E  20 DA C9           JSR   LAB_18C3          ; print null terminated string from memory
06579    
06580                                  ; print Basic line #
06581    DB91  A5 88              LDA   Clineh            ; get current line high byte
06582    DB93  A6 87              LDX   Clinel            ; get current line low byte
06583    
06584    ; print XA as unsigned integer
06585    
06586    LAB_295E
06587    DB95  85 AD              STA   FAC1_1            ; save low byte as FAC1 mantissa1
06588    DB97  86 AE              STX   FAC1_2            ; save high byte as FAC1 mantissa2
06589    DB99  A2 90              LDX   #$90              ; set exponent to 16d bits
06590    DB9B  38                 SEC                     ; set integer is +ve flag
06591    DB9C  20 1A DA           JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
06592    DB9F  A0 00              LDY   #$00              ; clear index
06593    DBA1  98                 TYA                     ; clear A
06594    DBA2  20 B5 DB           JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
06595    DBA5  4C DA C9           JMP   LAB_18C3          ; print null terminated string from memory and return
06596    
06597    ; convert FAC1 to ASCII string result in (AY)
06598    ; not any more, moved scratchpad to page 0
06599    
06600    LAB_296E
06601    DBA8  A0 01              LDY   #$01              ; set index = 1
06602    DBAA  A9 20              LDA   #$20              ; character = " " (assume +ve)
06603    DBAC  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
06604    DBAE  10 02              BPL   LAB_2978          ; branch if +ve
06605    
06606    DBB0  A9 2D              LDA   #$2D              ; else character = "-"
06607    LAB_2978
06608    DBB2  99 EF 00           STA   Decss,Y           ; save leading character (" " or "-")
06609    LAB_297B
06610    DBB5  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
06611    DBB7  84 BA              STY   Sendl             ; save index
06612    DBB9  C8                 INY                     ; increment index
06613    DBBA  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
06614    DBBC  D0 05              BNE   LAB_2989          ; branch if FAC1<>0
06615    
06616                                  ; exponent was $00 so FAC1 is 0
06617    DBBE  A9 30              LDA   #'0'              ; set character = "0"
06618    DBC0  4C C1 DC           JMP   LAB_2A89          ; save last character, [EOT] and exit
06619    
06620                                  ; FAC1 is some non zero value
06621    LAB_2989
06622    DBC3  A9 00              LDA   #$00              ; clear (number exponent count)
06623    DBC5  E0 81              CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
06624    
06625    DBC7  B0 09              BCS   LAB_299A          ; branch if FAC1=>1
06626    
06627                                  ; FAC1<1
06628    DBC9  A9 9B              LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
06629    DBCB  A0 E2              LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
06630    DBCD  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06631    DBD0  A9 FA              LDA   #$FA              ; set number exponent count (-6)
06632    LAB_299A
06633    DBD2  85 A8              STA   numexp            ; save number exponent count
06634    LAB_299C
06635    DBD4  A9 97              LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
06636    DBD6  A0 E2              LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
06637    DBD8  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
06638    DBDB  F0 1E              BEQ   LAB_29C3          ; exit if FAC1 = (AY)
06639    
06640    DBDD  10 12              BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
06641    
06642                                  ; FAC1 < (AY)
06643    LAB_29A7
06644    DBDF  A9 93              LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
06645    DBE1  A0 E2              LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
06646    DBE3  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
06647    DBE6  F0 02              BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
06648    
06649    DBE8  10 0E              BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
06650    
06651                                  ; FAC1 <= (AY)
06652    LAB_29B2
06653    DBEA  20 EA D8           JSR   LAB_269E          ; multiply by 10
06654    DBED  C6 A8              DEC   numexp            ; decrement number exponent count
06655    DBEF  D0 EE              BNE   LAB_29A7          ; go test again (branch always)
06656    
06657    LAB_29B9
06658    DBF1  20 03 D9           JSR   LAB_26B9          ; divide by 10
06659    DBF4  E6 A8              INC   numexp            ; increment number exponent count
06660    DBF6  D0 DC              BNE   LAB_299C          ; go test again (branch always)
06661    
06662    ; now we have just the digits to do
06663    
06664    LAB_29C0
06665    DBF8  20 CD D6           JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
06666    LAB_29C3
06667    DBFB  20 63 DA           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
06668    DBFE  A2 01              LDX   #$01              ; set default digits before dp = 1
06669    DC00  A5 A8              LDA   numexp            ; get number exponent count
06670    DC02  18                 CLC                     ; clear carry for add
06671    DC03  69 07              ADC   #$07              ; up to 6 digits before point
06672    DC05  30 09              BMI   LAB_29D8          ; if -ve then 1 digit before dp
06673    
06674    DC07  C9 08              CMP   #$08              ; A>=8 if n>=1E6
06675    DC09  B0 06              BCS   LAB_29D9          ; branch if >= $08
06676    
06677                                  ; carry is clear
06678    DC0B  69 FF              ADC   #$FF              ; take 1 from digit count
06679    DC0D  AA                 TAX                     ; copy to A
06680    DC0E  A9 02              LDA   #$02              ;.set exponent adjust
06681    LAB_29D8
06682    DC10  38                 SEC                     ; set carry for subtract
06683    LAB_29D9
06684    DC11  E9 02              SBC   #$02              ; -2
06685    DC13  85 A9              STA   expcnt            ;.save exponent adjust
06686    DC15  86 A8              STX   numexp            ; save digits before dp count
06687    DC17  8A                 TXA                     ; copy to A
06688    DC18  F0 02              BEQ   LAB_29E4          ; branch if no digits before dp
06689    
06690    DC1A  10 13              BPL   LAB_29F7          ; branch if digits before dp
06691    
06692    LAB_29E4
06693    DC1C  A4 BA              LDY   Sendl             ; get output string index
06694    DC1E  A9 2E              LDA   #$2E              ; character "."
06695    DC20  C8                 INY                     ; increment index
06696    DC21  99 EF 00           STA   Decss,Y           ; save to output string
06697    DC24  8A                 TXA                     ;.
06698    DC25  F0 06              BEQ   LAB_29F5          ;.
06699    
06700    DC27  A9 30              LDA   #'0'              ; character "0"
06701    DC29  C8                 INY                     ; increment index
06702    DC2A  99 EF 00           STA   Decss,Y           ; save to output string
06703    LAB_29F5
06704    DC2D  84 BA              STY   Sendl             ; save output string index
06705    LAB_29F7
06706    DC2F  A0 00              LDY   #$00              ; clear index (point to 100,000)
06707    DC31  A2 80              LDX   #$80              ; 
06708    LAB_29FB
06709    DC33  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
06710    DC35  18                 CLC                     ; clear carry for add
06711    DC36  79 11 E3           ADC   LAB_2A9C,Y        ; add -ve LSB
06712    DC39  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
06713    DC3B  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
06714    DC3D  79 10 E3           ADC   LAB_2A9B,Y        ; add -ve NMSB
06715    DC40  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
06716    DC42  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
06717    DC44  79 0F E3           ADC   LAB_2A9A,Y        ; add -ve MSB
06718    DC47  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
06719    DC49  E8                 INX                     ; 
06720    DC4A  B0 04              BCS   LAB_2A18          ; 
06721    
06722    DC4C  10 E5              BPL   LAB_29FB          ; not -ve so try again
06723    
06724    DC4E  30 02              BMI   LAB_2A1A          ; 
06725    
06726    LAB_2A18
06727    DC50  30 E1              BMI   LAB_29FB          ; 
06728    
06729    LAB_2A1A
06730    DC52  8A                 TXA                     ; 
06731    DC53  90 04              BCC   LAB_2A21          ; 
06732    
06733    DC55  49 FF              EOR   #$FF              ; 
06734    DC57  69 0A              ADC   #$0A              ; 
06735    LAB_2A21
06736    DC59  69 2F              ADC   #'0'-1            ; add "0"-1 to result
06737    DC5B  C8                 INY                     ; increment index ..
06738    DC5C  C8                 INY                     ; .. to next less ..
06739    DC5D  C8                 INY                     ; .. power of ten
06740    DC5E  84 95              STY   Cvaral            ; save as current var address low byte
06741    DC60  A4 BA              LDY   Sendl             ; get output string index
06742    DC62  C8                 INY                     ; increment output string index
06743    DC63  AA                 TAX                     ; copy character to X
06744    DC64  29 7F              AND   #$7F              ; mask out top bit
06745    DC66  99 EF 00           STA   Decss,Y           ; save to output string
06746    DC69  C6 A8              DEC   numexp            ; decrement # of characters before the dp
06747    DC6B  D0 06              BNE   LAB_2A3B          ; branch if still characters to do
06748    
06749                                  ; else output the point
06750    DC6D  A9 2E              LDA   #$2E              ; character "."
06751    DC6F  C8                 INY                     ; increment output string index
06752    DC70  99 EF 00           STA   Decss,Y           ; save to output string
06753    LAB_2A3B
06754    DC73  84 BA              STY   Sendl             ; save output string index
06755    DC75  A4 95              LDY   Cvaral            ; get current var address low byte
06756    DC77  8A                 TXA                     ; get character back
06757    DC78  49 FF              EOR   #$FF              ; 
06758    DC7A  29 80              AND   #$80              ; 
06759    DC7C  AA                 TAX                     ; 
06760    DC7D  C0 12              CPY   #$12              ; compare index with max
06761    DC7F  D0 B2              BNE   LAB_29FB          ; loop if not max
06762    
06763                                  ; now remove trailing zeroes
06764    DC81  A4 BA              LDY   Sendl             ; get output string index
06765    LAB_2A4B
06766    DC83  B9 EF 00           LDA   Decss,Y           ; get character from output string
06767    DC86  88                 DEY                     ; decrement output string index
06768    DC87  C9 30              CMP   #'0'              ; compare with "0"
06769    DC89  F0 F8              BEQ   LAB_2A4B          ; loop until non "0" character found
06770    
06771    DC8B  C9 2E              CMP   #'.'              ; compare with "."
06772    DC8D  F0 01              BEQ   LAB_2A58          ; branch if was dp
06773    
06774                                  ; restore last character
06775    DC8F  C8                 INY                     ; increment output string index
06776    LAB_2A58
06777    DC90  A9 2B              LDA   #$2B              ; character "+"
06778    DC92  A6 A9              LDX   expcnt            ; get exponent count
06779    DC94  F0 2E              BEQ   LAB_2A8C          ; if zero go set null terminator and exit
06780    
06781                                  ; exponent isn't zero so write exponent
06782    DC96  10 08              BPL   LAB_2A68          ; branch if exponent count +ve
06783    
06784    DC98  A9 00              LDA   #$00              ; clear A
06785    DC9A  38                 SEC                     ; set carry for subtract
06786    DC9B  E5 A9              SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
06787    DC9D  AA                 TAX                     ; copy exponent count to X
06788    DC9E  A9 2D              LDA   #'-'              ; character "-"
06789    LAB_2A68
06790    DCA0  99 F1 00           STA   Decss+2,Y         ; save to output string
06791    DCA3  A9 45              LDA   #$45              ; character "E"
06792    DCA5  99 F0 00           STA   Decss+1,Y         ; save exponent sign to output string
06793    DCA8  8A                 TXA                     ; get exponent count back
06794    DCA9  A2 2F              LDX   #'0'-1            ; one less than "0" character
06795    DCAB  38                 SEC                     ; set carry for subtract
06796    LAB_2A74
06797    DCAC  E8                 INX                     ; increment 10's character
06798    DCAD  E9 0A              SBC   #$0A              ;.subtract 10 from exponent count
06799    DCAF  B0 FB              BCS   LAB_2A74          ; loop while still >= 0
06800    
06801    DCB1  69 3A              ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
06802    DCB3  99 F3 00           STA   Decss+4,Y         ; save to output string
06803    DCB6  8A                 TXA                     ; copy 10's character
06804    DCB7  99 F2 00           STA   Decss+3,Y         ; save to output string
06805    DCBA  A9 00              LDA   #$00              ; set null terminator
06806    DCBC  99 F4 00           STA   Decss+5,Y         ; save to output string
06807    DCBF  F0 08              BEQ   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
06808    
06809                                  ; save last character, [EOT] and exit
06810    LAB_2A89
06811    DCC1  99 EF 00           STA   Decss,Y           ; save last character to output string
06812    
06813                                  ; set null terminator and exit
06814    LAB_2A8C
06815    DCC4  A9 00              LDA   #$00              ; set null terminator
06816    DCC6  99 F0 00           STA   Decss+1,Y         ; save after last character
06817    
06818                                  ; set string pointer (AY) and exit
06819    LAB_2A91
06820    DCC9  A9 F0              LDA   #<Decssp1         ; set result string low pointer
06821    DCCB  A0 00              LDY   #>Decssp1         ; set result string high pointer
06822    DCCD  60                 RTS
06823    
06824    ; perform power function
06825    
06826    LAB_POWER
06827    DCCE  F0 42              BEQ   LAB_EXP           ; go do  EXP()
06828    
06829    DCD0  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
06830    DCD2  D0 03              BNE   LAB_2ABF          ; branch if FAC2<>0
06831    
06832    DCD4  4C 65 D7           JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
06833    
06834    LAB_2ABF
06835    DCD7  A2 9C              LDX   #<func_l          ; set destination pointer low byte
06836    DCD9  A0 00              LDY   #>func_l          ; set destination pointer high byte
06837    DCDB  20 BA D9           JSR   LAB_2778          ; pack FAC1 into (XY)
06838    DCDE  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
06839    DCE0  10 0F              BPL   LAB_2AD9          ; branch if FAC2>0
06840    
06841                                  ; else FAC2 is -ve and can only be raised to an
06842                                  ; integer power which gives an x +j0 result
06843    DCE2  20 94 DA           JSR   LAB_INT           ; perform INT
06844    DCE5  A9 9C              LDA   #<func_l          ; set source pointer low byte
06845    DCE7  A0 00              LDY   #>func_l          ; set source pointer high byte
06846    DCE9  20 2A DA           JSR   LAB_27F8          ; compare FAC1 with (AY)
06847    DCEC  D0 03              BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
06848                                  ; this will leave FAC1 -ve and cause a Function Call
06849                                  ; error when LOG() is called
06850    
06851    DCEE  98                 TYA                     ; clear sign b7
06852    DCEF  A4 5B              LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
06853                                  ; for possible later negation, b0
06854    LAB_2AD9
06855    DCF1  20 D8 D6           JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
06856    DCF4  98                 TYA                     ; copy sign back ..
06857    DCF5  48                 PHA                     ; .. and save it
06858    DCF6  20 0E D8           JSR   LAB_LOG           ; do LOG(n)
06859    DCF9  A9 9C              LDA   #<garb_l          ; set pointer low byte
06860    DCFB  A0 00              LDY   #>garb_l          ; set pointer high byte
06861    DCFD  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
06862    DD00  20 12 DD           JSR   LAB_EXP           ; go do EXP(n)
06863    DD03  68                 PLA                     ; pull sign from stack
06864    DD04  4A                 LSR                     ; b0 is to be tested, shift to Cb
06865    DD05  90 0A              BCC   LAB_2AF9          ; if no bit then exit
06866    
06867                                  ; Perform negation
06868    ; do - FAC1
06869    
06870    LAB_GTHAN
06871    DD07  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06872    DD09  F0 06              BEQ   LAB_2AF9          ; exit if FAC1_e = $00
06873    
06874    DD0B  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
06875    DD0D  49 FF              EOR   #$FF              ; complement it
06876    DD0F  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
06877    LAB_2AF9
06878    DD11  60                 RTS
06879    
06880    ; perform EXP()   (x^e)
06881    
06882    LAB_EXP
06883    DD12  A9 9F              LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
06884    DD14  A0 E2              LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
06885    DD16  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06886    DD19  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
06887    DD1B  69 50              ADC   #$50              ; +$50/$100
06888    DD1D  90 03              BCC   LAB_2B2B          ; skip rounding if no carry
06889    
06890    DD1F  20 F4 D9           JSR   LAB_27C2          ; round FAC1 (no check)
06891    LAB_2B2B
06892    DD22  85 A3              STA   FAC2_r            ; save FAC2 rounding byte
06893    DD24  20 E0 D9           JSR   LAB_27AE          ; copy FAC1 to FAC2
06894    DD27  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
06895    DD29  C9 88              CMP   #$88              ; compare with EXP limit (256d)
06896    DD2B  90 03              BCC   LAB_2B39          ; branch if less
06897    
06898    LAB_2B36
06899    DD2D  20 E1 D8           JSR   LAB_2690          ; handle overflow and underflow
06900    LAB_2B39
06901    DD30  20 94 DA           JSR   LAB_INT           ; perform INT
06902    DD33  A5 5B              LDA   Temp3             ; get mantissa 3 from INT() function
06903    DD35  18                 CLC                     ; clear carry for add
06904    DD36  69 81              ADC   #$81              ; normalise +1
06905    DD38  F0 F3              BEQ   LAB_2B36          ; if $00 go handle overflow
06906    
06907    DD3A  38                 SEC                     ; set carry for subtract
06908    DD3B  E9 01              SBC   #$01              ; now correct for exponent
06909    DD3D  48                 PHA                     ; save FAC2 exponent
06910    
06911                                  ; swap FAC1 and FAC2
06912    DD3E  A2 04              LDX   #$04              ; 4 bytes to do
06913    LAB_2B49
06914    DD40  B5 B3              LDA   FAC2_e,X          ; get FAC2,X
06915    DD42  B4 AC              LDY   FAC1_e,X          ; get FAC1,X
06916    DD44  95 AC              STA   FAC1_e,X          ; save FAC1,X
06917    DD46  94 B3              STY   FAC2_e,X          ; save FAC2,X
06918    DD48  CA                 DEX                     ; decrement count/index
06919    DD49  10 F5              BPL   LAB_2B49          ; loop if not all done
06920    
06921    DD4B  A5 A3              LDA   FAC2_r            ; get FAC2 rounding byte
06922    DD4D  85 B9              STA   FAC1_r            ; save as FAC1 rounding byte
06923    DD4F  20 B9 D6           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
06924    DD52  20 07 DD           JSR   LAB_GTHAN         ; do - FAC1
06925    DD55  A9 A3              LDA   #<LAB_2AFE        ; set counter pointer low byte
06926    DD57  A0 E2              LDY   #>LAB_2AFE        ; set counter pointer high byte
06927    DD59  20 7A DD           JSR   LAB_2B84          ; go do series evaluation
06928    DD5C  A9 00              LDA   #$00              ; clear A
06929    DD5E  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
06930    DD60  68                 PLA                     ;.get saved FAC2 exponent
06931    DD61  4C C6 D8           JMP   LAB_2675          ; test and adjust accumulators and return
06932    
06933    ; ^2 then series evaluation
06934    
06935    LAB_2B6E
06936    DD64  85 BA              STA   Cptrl             ; save count pointer low byte
06937    DD66  84 BB              STY   Cptrh             ; save count pointer high byte
06938    DD68  20 B0 D9           JSR   LAB_276E          ; pack FAC1 into Adatal
06939    DD6B  A9 A4              LDA   #<Adatal          ; set pointer low byte (Y already $00)
06940    DD6D  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06941    DD70  20 7E DD           JSR   LAB_2B88          ; go do series evaluation
06942    DD73  A9 A4              LDA   #<Adatal          ; pointer to original # low byte
06943    DD75  A0 00              LDY   #>Adatal          ; pointer to original # high byte
06944    DD77  4C 4C D8           JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
06945    
06946    ; series evaluation
06947    
06948    LAB_2B84
06949    DD7A  85 BA              STA   Cptrl             ; save count pointer low byte
06950    DD7C  84 BB              STY   Cptrh             ; save count pointer high byte
06951    LAB_2B88
06952    DD7E  A2 A8              LDX   #<numexp          ; set pointer low byte
06953    DD80  20 B2 D9           JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
06954    DD83  B1 BA              LDA   (Cptrl),Y         ; get constants count
06955    DD85  85 B1              STA   numcon            ; save constants count
06956    DD87  A4 BA              LDY   Cptrl             ; get count pointer low byte
06957    DD89  C8                 INY                     ; increment it (now constants pointer)
06958    DD8A  98                 TYA                     ; copy it
06959    DD8B  D0 02              BNE   LAB_2B97          ; skip next if no overflow
06960    
06961    DD8D  E6 BB              INC   Cptrh             ; else increment high byte
06962    LAB_2B97
06963    DD8F  85 BA              STA   Cptrl             ; save low byte
06964    DD91  A4 BB              LDY   Cptrh             ; get high byte
06965    LAB_2B9B
06966    DD93  20 4C D8           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
06967    DD96  A5 BA              LDA   Cptrl             ; get constants pointer low byte
06968    DD98  A4 BB              LDY   Cptrh             ; get constants pointer high byte
06969    DD9A  18                 CLC                     ; clear carry for add
06970    DD9B  69 04              ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
06971    DD9D  90 01              BCC   LAB_2BA8          ; skip next if no overflow
06972    
06973    DD9F  C8                 INY                     ; increment high byte
06974    LAB_2BA8
06975    DDA0  85 BA              STA   Cptrl             ; save pointer low byte
06976    DDA2  84 BB              STY   Cptrh             ; save pointer high byte
06977    DDA4  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
06978    DDA7  A9 A8              LDA   #<numexp          ; set pointer low byte to partial @ numexp
06979    DDA9  A0 00              LDY   #>numexp          ; set pointer high byte to partial @ numexp
06980    DDAB  C6 B1              DEC   numcon            ; decrement constants count
06981    DDAD  D0 E4              BNE   LAB_2B9B          ; loop until all done
06982    
06983    DDAF  60                 RTS
06984    
06985    ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
06986    ; to get 19th next number in sequence after seed n. This version of the PRNG uses
06987    ; the Galois method and a sample of 65536 bytes produced gives the following values.
06988    
06989    ; Entropy = 7.997442 bits per byte
06990    ; Optimum compression would reduce these 65536 bytes by 0 percent
06991    
06992    ; Chi square distribution for 65536 samples is 232.01, and
06993    ; randomly would exceed this value 75.00 percent of the time
06994    
06995    ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
06996    ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
06997    ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
06998    
06999    LAB_RND
07000    DDB0  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07001    DDB2  F0 07              BEQ   NextPRN           ; do next random # if zero
07002    
07003                                  ; else get seed into random number store
07004    DDB4  A2 D8              LDX   #Rbyte4           ; set PRNG pointer low byte
07005    DDB6  A0 00              LDY   #$00              ; set PRNG pointer high byte
07006    DDB8  20 BA D9           JSR   LAB_2778          ; pack FAC1 into (XY)
07007    NextPRN
07008    DDBB  A2 AF              LDX   #$AF              ; set EOR byte
07009    DDBD  A0 13              LDY   #$13              ; do this nineteen times
07010    LoopPRN
07011    DDBF  06 D9              ASL   Rbyte1            ; shift PRNG most significant byte
07012    DDC1  26 DA              ROL   Rbyte2            ; shift PRNG middle byte
07013    DDC3  26 DB              ROL   Rbyte3            ; shift PRNG least significant byte
07014    DDC5  26 D8              ROL   Rbyte4            ; shift PRNG extra byte
07015    DDC7  90 05              BCC   Ninc1             ; branch if bit 32 clear
07016    
07017    DDC9  8A                 TXA                     ; set EOR byte
07018    DDCA  45 D9              EOR   Rbyte1            ; EOR PRNG extra byte
07019    DDCC  85 D9              STA   Rbyte1            ; save new PRNG extra byte
07020    Ninc1
07021    DDCE  88                 DEY                     ; decrement loop count
07022    DDCF  D0 EE              BNE   LoopPRN           ; loop if not all done
07023    
07024    DDD1  A2 02              LDX   #$02              ; three bytes to copy
07025    CopyPRNG
07026    DDD3  B5 D9              LDA   Rbyte1,X          ; get PRNG byte
07027    DDD5  95 AD              STA   FAC1_1,X          ; save FAC1 byte
07028    DDD7  CA                 DEX
07029    DDD8  10 F9              BPL   CopyPRNG          ; loop if not complete
07030    
07031    DDDA  A9 80              LDA   #$80              ; set the exponent
07032    DDDC  85 AC              STA   FAC1_e            ; save FAC1 exponent
07033    
07034    DDDE  0A                 ASL                     ; clear A
07035    DDDF  85 B0              STA   FAC1_s            ; save FAC1 sign
07036    
07037    DDE1  4C 47 D7           JMP   LAB_24D5          ; normalise FAC1 and return
07038    
07039    ; perform COS()
07040    
07041    LAB_COS
07042    DDE4  A9 C0              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
07043    DDE6  A0 E2              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
07044    DDE8  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
07045    
07046    ; perform SIN()
07047    
07048    LAB_SIN
07049    DDEB  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
07050    DDEE  A9 D5              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
07051    DDF0  A0 E2              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
07052    DDF2  A6 B7              LDX   FAC2_s            ; get FAC2 sign (b7)
07053    DDF4  20 0C D9           JSR   LAB_26C2          ; divide by (AY) (X=sign)
07054    DDF7  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
07055    DDFA  20 94 DA           JSR   LAB_INT           ; perform INT
07056    DDFD  A9 00              LDA   #$00              ; clear byte
07057    DDFF  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
07058    DE01  20 B9 D6           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
07059    DE04  A9 07              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
07060    DE06  A0 E3              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
07061    DE08  20 B6 D6           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
07062    DE0B  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
07063    DE0D  48                 PHA                     ; save FAC1 sign
07064    DE0E  10 0D              BPL   LAB_2C35          ; branch if +ve
07065    
07066                                  ; FAC1 sign was -ve
07067    DE10  20 CD D6           JSR   LAB_244E          ; add 0.5 to FAC1
07068    DE13  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
07069    DE15  30 09              BMI   LAB_2C38          ; branch if -ve
07070    
07071    DE17  A5 63              LDA   Cflag             ; get comparison evaluation flag
07072    DE19  49 FF              EOR   #$FF              ; toggle flag
07073    DE1B  85 63              STA   Cflag             ; save comparison evaluation flag
07074    LAB_2C35
07075    DE1D  20 07 DD           JSR   LAB_GTHAN         ; do - FAC1
07076    LAB_2C38
07077    DE20  A9 07              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
07078    DE22  A0 E3              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
07079    DE24  20 D1 D6           JSR   LAB_246C          ; add (AY) to FAC1
07080    DE27  68                 PLA                     ; restore FAC1 sign
07081    DE28  10 03              BPL   LAB_2C45          ; branch if was +ve
07082    
07083                                  ; else correct FAC1
07084    DE2A  20 07 DD           JSR   LAB_GTHAN         ; do - FAC1
07085    LAB_2C45
07086    DE2D  A9 C4              LDA   #<LAB_2C84        ; set pointer low byte to counter
07087    DE2F  A0 E2              LDY   #>LAB_2C84        ; set pointer high byte to counter
07088    DE31  4C 64 DD           JMP   LAB_2B6E          ; ^2 then series evaluation and return
07089    
07090    ; perform TAN()
07091    
07092    LAB_TAN
07093    DE34  20 B0 D9           JSR   LAB_276E          ; pack FAC1 into Adatal
07094    DE37  A9 00              LDA   #$00              ; clear byte
07095    DE39  85 63              STA   Cflag             ; clear comparison evaluation flag
07096    DE3B  20 EB DD           JSR   LAB_SIN           ; go do SIN(n)
07097    DE3E  A2 9C              LDX   #<func_l          ; set sin(n) pointer low byte
07098    DE40  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
07099    DE42  20 BA D9           JSR   LAB_2778          ; pack FAC1 into (XY)
07100    DE45  A9 A4              LDA   #<Adatal          ; set n pointer low addr
07101    DE47  A0 00              LDY   #>Adatal          ; set n pointer high addr
07102    DE49  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
07103    DE4C  A9 00              LDA   #$00              ; clear byte
07104    DE4E  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
07105    DE50  A5 63              LDA   Cflag             ; get comparison evaluation flag
07106    DE52  20 5C DE           JSR   LAB_2C74          ; save flag and go do series evaluation
07107    
07108    DE55  A9 9C              LDA   #<func_l          ; set sin(n) pointer low byte
07109    DE57  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
07110    DE59  4C 14 D9           JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
07111    
07112    LAB_2C74
07113    DE5C  48                 PHA                     ; save comparison evaluation flag
07114    DE5D  4C 1D DE           JMP   LAB_2C35          ; go do series evaluation
07115    
07116    ; perform USR()
07117    
07118    LAB_USR
07119    DE60  20 0A 00           JSR   Usrjmp            ; call user code
07120    DE63  4C F5 CC           JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
07121    
07122    ; perform ATN()
07123    
07124    LAB_ATN
07125    DE66  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
07126    DE68  48                 PHA                     ; save sign
07127    DE69  10 03              BPL   LAB_2CA1          ; branch if +ve
07128    
07129    DE6B  20 07 DD           JSR   LAB_GTHAN         ; else do - FAC1
07130    LAB_2CA1
07131    DE6E  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07132    DE70  48                 PHA                     ; push exponent
07133    DE71  C9 81              CMP   #$81              ; compare with 1
07134    DE73  90 07              BCC   LAB_2CAF          ; branch if FAC1<1
07135    
07136    DE75  A9 FA              LDA   #<LAB_259C        ; set 1 pointer low byte
07137    DE77  A0 E2              LDY   #>LAB_259C        ; set 1 pointer high byte
07138    DE79  20 14 D9           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
07139    LAB_2CAF
07140    DE7C  A9 D9              LDA   #<LAB_2CC9        ; set pointer low byte to counter
07141    DE7E  A0 E2              LDY   #>LAB_2CC9        ; set pointer high byte to counter
07142    DE80  20 64 DD           JSR   LAB_2B6E          ; ^2 then series evaluation
07143    DE83  68                 PLA                     ; restore old FAC1 exponent
07144    DE84  C9 81              CMP   #$81              ; compare with 1
07145    DE86  90 07              BCC   LAB_2CC2          ; branch if FAC1<1
07146    
07147    DE88  A9 C0              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
07148    DE8A  A0 E2              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
07149    DE8C  20 B6 D6           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
07150    LAB_2CC2
07151    DE8F  68                 PLA                     ; restore FAC1 sign
07152    DE90  10 16              BPL   LAB_2D04          ; exit if was +ve
07153    
07154    DE92  4C 07 DD           JMP   LAB_GTHAN         ; else do - FAC1 and return
07155    
07156    ; perform BITSET
07157    
07158    LAB_BITSET
07159    DE95  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
07160    DE98  E0 08              CPX   #$08              ; only 0 to 7 are allowed
07161    DE9A  B0 20              BCS   FCError           ; branch if > 7
07162    
07163    DE9C  A9 00              LDA   #$00              ; clear A
07164    DE9E  38                 SEC                     ; set the carry
07165    S_Bits
07166    DE9F  2A                 ROL                     ; shift bit
07167    DEA0  CA                 DEX                     ; decrement bit number
07168    DEA1  10 FC              BPL   S_Bits            ; loop if still +ve
07169    
07170    DEA3  E8                 INX                     ; make X = $00
07171    DEA4  01 11              ORA   (Itempl,X)        ; or with byte via temporary integer (addr)
07172    DEA6  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
07173    LAB_2D04
07174    DEA8  60                 RTS
07175    
07176    ; perform BITCLR
07177    
07178    LAB_BITCLR
07179    DEA9  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
07180    DEAC  E0 08              CPX   #$08              ; only 0 to 7 are allowed
07181    DEAE  B0 0C              BCS   FCError           ; branch if > 7
07182    
07183    DEB0  A9 FF              LDA   #$FF              ; set A
07184    S_Bitc
07185    DEB2  2A                 ROL                     ; shift bit
07186    DEB3  CA                 DEX                     ; decrement bit number
07187    DEB4  10 FC              BPL   S_Bitc            ; loop if still +ve
07188    
07189    DEB6  E8                 INX                     ; make X = $00
07190    DEB7  21 11              AND   (Itempl,X)        ; and with byte via temporary integer (addr)
07191    DEB9  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
07192    DEBB  60                 RTS
07193    
07194    FCError
07195    DEBC  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
07196    
07197    ; perform BITTST()
07198    
07199    LAB_BTST
07200    DEBF  20 BC 00           JSR   LAB_IGBY          ; increment BASIC pointer
07201    DEC2  20 EB D5           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
07202    DEC5  E0 08              CPX   #$08              ; only 0 to 7 are allowed
07203    DEC7  B0 F3              BCS   FCError           ; branch if > 7
07204    
07205    DEC9  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
07206    DECC  C9 29              CMP   #')'              ; is next character ")"
07207    DECE  F0 03              BEQ   TST_OK            ; if ")" go do rest of function
07208    
07209    DED0  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
07210    
07211    TST_OK
07212    DED3  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
07213    DED6  A9 00              LDA   #$00              ; clear A
07214    DED8  38                 SEC                     ; set the carry
07215    T_Bits
07216    DED9  2A                 ROL                     ; shift bit
07217    DEDA  CA                 DEX                     ; decrement bit number
07218    DEDB  10 FC              BPL   T_Bits            ; loop if still +ve
07219    
07220    DEDD  E8                 INX                     ; make X = $00
07221    DEDE  21 11              AND   (Itempl,X)        ; AND with byte via temporary integer (addr)
07222    DEE0  F0 02              BEQ   LAB_NOTT          ; branch if zero (already correct)
07223    
07224    DEE2  A9 FF              LDA   #$FF              ; set for -1 result
07225    LAB_NOTT
07226    DEE4  4C 0D DA           JMP   LAB_27DB          ; go do SGN tail
07227    
07228    ; perform BIN$()
07229    
07230    LAB_BINS
07231    DEE7  E0 19              CPX   #$19              ; max + 1
07232    DEE9  B0 48              BCS   BinFErr           ; exit if too big ( > or = )
07233    
07234    DEEB  86 78              STX   TempB             ; save # of characters ($00 = leading zero remove)
07235    DEED  A9 18              LDA   #$18              ; need A byte long space
07236    DEEF  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long
07237    DEF2  A0 17              LDY   #$17              ; set index
07238    DEF4  A2 18              LDX   #$18              ; character count
07239    NextB1
07240    DEF6  46 11              LSR   nums_1            ; shift highest byte
07241    DEF8  66 12              ROR   nums_2            ; shift middle byte
07242    DEFA  66 13              ROR   nums_3            ; shift lowest byte bit 0 to carry
07243    DEFC  8A                 TXA                     ; load with "0"/2
07244    DEFD  2A                 ROL                     ; shift in carry
07245    DEFE  91 AD              STA   (str_pl),Y        ; save to temp string + index
07246    DF00  88                 DEY                     ; decrement index
07247    DF01  10 F3              BPL   NextB1            ; loop if not done
07248    
07249    DF03  A5 78              LDA   TempB             ; get # of characters
07250    DF05  F0 0A              BEQ   EndBHS            ; branch if truncate
07251    
07252    DF07  AA                 TAX                     ; copy length to X
07253    DF08  38                 SEC                     ; set carry for add !
07254    DF09  49 FF              EOR   #$FF              ; 1's complement
07255    DF0B  69 18              ADC   #$18              ; add 24d
07256    DF0D  F0 1C              BEQ   GoPr2             ; if zero print whole string
07257    
07258    DF0F  D0 0F              BNE   GoPr1             ; else go make output string
07259          
07260    ; this is the exit code and is also used by HEX$()
07261    ; truncate string to remove leading "0"s
07262    
07263    EndBHS
07264    DF11  A8                 TAY                     ; clear index (A=0, X=length here)
07265    NextB2
07266    DF12  B1 AD              LDA   (str_pl),Y        ; get character from string
07267    DF14  C9 30              CMP   #'0'              ; compare with "0"
07268    DF16  D0 07              BNE   GoPr              ; if not "0" then go print string from here
07269    
07270    DF18  CA                 DEX                     ; decrement character count
07271    DF19  F0 03              BEQ   GoPr3             ; if zero then end of string so go print it
07272    
07273    DF1B  C8                 INY                     ; else increment index
07274    DF1C  10 F4              BPL   NextB2            ; loop always
07275    
07276    ; make fixed length output string - ignore overflows!
07277    
07278    GoPr3
07279    DF1E  E8                 INX                     ; need at least 1 character
07280    GoPr
07281    DF1F  98                 TYA                     ; copy result
07282    GoPr1
07283    DF20  18                 CLC                     ; clear carry for add
07284    DF21  65 AD              ADC   str_pl            ; add low address
07285    DF23  85 AD              STA   str_pl            ; save low address
07286    DF25  A9 00              LDA   #$00              ; do high byte
07287    DF27  65 AE              ADC   str_ph            ; add high address
07288    DF29  85 AE              STA   str_ph            ; save high address
07289    GoPr2
07290    DF2B  86 AC              STX   str_ln            ; X holds string length
07291    DF2D  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
07292    DF30  4C 9B D2           JMP   LAB_RTST          ; check for space on descriptor stack then put address
07293                                  ; and length on descriptor stack and update stack pointers
07294    
07295    BinFErr
07296    DF33  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
07297    
07298    ; perform HEX$()
07299    
07300    LAB_HEXS
07301    DF36  E0 07              CPX   #$07              ; max + 1
07302    DF38  B0 F9              BCS   BinFErr           ; exit if too big ( > or = )
07303    
07304    DF3A  86 78              STX   TempB             ; save # of characters
07305    
07306    DF3C  A9 06              LDA   #$06              ; need 6 bytes for string
07307    DF3E  20 4E D2           JSR   LAB_MSSP          ; make string space A bytes long
07308    DF41  A0 05              LDY   #$05              ; set string index
07309    
07310    ; *** disable decimal mode patch - comment next line ***
07311    ;      SED                     ; need decimal mode for nibble convert
07312    DF43  A5 13              LDA   nums_3            ; get lowest byte
07313    DF45  20 62 DF           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
07314    DF48  A5 12              LDA   nums_2            ; get middle byte
07315    DF4A  20 62 DF           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
07316    DF4D  A5 11              LDA   nums_1            ; get highest byte
07317    DF4F  20 62 DF           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
07318    ; *** disable decimal mode patch - comment next line ***
07319    ;      CLD                     ; back to binary
07320    
07321    DF52  A2 06              LDX   #$06              ; character count
07322    DF54  A5 78              LDA   TempB             ; get # of characters
07323    DF56  F0 B9              BEQ   EndBHS            ; branch if truncate
07324    
07325    DF58  AA                 TAX                     ; copy length to X
07326    DF59  38                 SEC                     ; set carry for add !
07327    DF5A  49 FF              EOR   #$FF              ; 1's complement
07328    DF5C  69 06              ADC   #$06              ; add 6d
07329    DF5E  F0 CB              BEQ   GoPr2             ; if zero print whole string
07330    
07331    DF60  D0 BE              BNE   GoPr1             ; else go make output string (branch always)
07332    
07333    ; convert A to ASCII hex byte and output .. note set decimal mode before calling
07334    
07335    LAB_A2HX
07336    DF62  AA                 TAX                     ; save byte
07337    DF63  29 0F              AND   #$0F              ; mask off top bits
07338    DF65  20 6D DF           JSR   LAB_AL2X          ; convert low nibble to ASCII and output
07339    DF68  8A                 TXA                     ; get byte back
07340    DF69  4A                 LSR                     ; /2  shift high nibble to low nibble
07341    DF6A  4A                 LSR                     ; /4
07342    DF6B  4A                 LSR                     ; /8
07343    DF6C  4A                 LSR                     ; /16
07344    LAB_AL2X
07345    DF6D  C9 0A              CMP   #$0A              ; set carry for +1 if >9
07346    ; *** begin disable decimal mode patch ***
07347    ; *** insert
07348    DF6F  90 02              BCC   LAB_AL20          ; skip adjust if <= 9
07349    DF71  69 06              ADC   #$06              ; adjust for A to F
07350    LAB_AL20
07351    ; *** end   disable decimal mode patch ***
07352    DF73  69 30              ADC   #'0'              ; add ASCII "0"
07353    DF75  91 AD              STA   (str_pl),Y        ; save to temp string
07354    DF77  88                 DEY                     ; decrement counter
07355    DF78  60                 RTS
07356    
07357    LAB_NLTO
07358    DF79  85 AC              STA   FAC1_e            ; save FAC1 exponent
07359    DF7B  A9 00              LDA   #$00              ; clear sign compare
07360    LAB_MLTE
07361    DF7D  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
07362    DF7F  8A                 TXA                     ; restore character
07363    DF80  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
07364    
07365    ; gets here if the first character was "$" for hex
07366    ; get hex number
07367    
07368    LAB_CHEX
07369    DF83  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
07370    DF86  90 0A              BCC   LAB_ISHN          ; branch if numeric character
07371    
07372    DF88  09 20              ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
07373    DF8A  E9 61              SBC   #'a'              ; subtract "a" (carry set here)
07374    DF8C  C9 06              CMP   #$06              ; compare normalised with $06 (max+1)
07375    DF8E  B0 2A              BCS   LAB_EXCH          ; exit if >"f" or <"0"
07376    
07377    DF90  69 0A              ADC   #$0A              ; convert to nibble
07378    LAB_ISHN
07379    DF92  29 0F              AND   #$0F              ; convert to binary
07380    DF94  AA                 TAX                     ; save nibble
07381    DF95  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07382    DF97  F0 E4              BEQ   LAB_MLTE          ; skip multiply if zero
07383    
07384    DF99  69 04              ADC   #$04              ; add four to exponent (*16 - carry clear here)
07385    DF9B  90 DC              BCC   LAB_NLTO          ; if no overflow do evaluate digit
07386    
07387    LAB_MLTO
07388    DF9D  4C D6 D7           JMP   LAB_2564          ; do overflow error and warm start
07389    
07390    LAB_NXCH
07391    DFA0  AA                 TAX                     ; save bit
07392    DFA1  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07393    DFA3  F0 06              BEQ   LAB_MLBT          ; skip multiply if zero
07394    
07395    DFA5  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*2)
07396    DFA7  F0 F4              BEQ   LAB_MLTO          ; do overflow error if = $00
07397    
07398    DFA9  A9 00              LDA   #$00              ; clear sign compare
07399    LAB_MLBT
07400    DFAB  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
07401    DFAD  8A                 TXA                     ; restore bit
07402    DFAE  20 58 DB           JSR   LAB_2912          ; evaluate new ASCII digit
07403    
07404    ; gets here if the first character was  "%" for binary
07405    ; get binary number
07406    
07407    LAB_CBIN
07408    DFB1  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
07409    DFB4  49 30              EOR   #'0'              ; convert "0" to 0 etc.
07410    DFB6  C9 02              CMP   #$02              ; compare with max+1
07411    DFB8  90 E6              BCC   LAB_NXCH          ; branch exit if < 2
07412    
07413    LAB_EXCH
07414    DFBA  4C 3D DB           JMP   LAB_28F6          ; evaluate -ve flag and return
07415    
07416    ; ctrl-c check routine. includes limited "life" byte save for INGET routine
07417    ; now also the code that checks to see if an interrupt has occurred
07418    
07419    CTRLC
07420    DFBD  AD 00 02           LDA   ccflag            ; get [CTRL-C] check flag
07421    DFC0  D0 18              BNE   LAB_FBA2          ; exit if inhibited
07422    
07423    DFC2  20 FF E1           JSR   V_INPT            ; scan input device
07424    DFC5  90 0B              BCC   LAB_FBA0          ; exit if buffer empty
07425    
07426    DFC7  8D 01 02           STA   ccbyte            ; save received byte
07427    DFCA  A2 20              LDX   #$20              ; "life" timer for bytes
07428    DFCC  8E 02 02           STX   ccnull            ; set countdown
07429    DFCF  4C 1F C6           JMP   LAB_1636          ; return to BASIC
07430    
07431    LAB_FBA0
07432    DFD2  AE 02 02           LDX   ccnull            ; get countdown byte
07433    DFD5  F0 03              BEQ   LAB_FBA2          ; exit if finished
07434    
07435    DFD7  CE 02 02           DEC   ccnull            ; else decrement countdown
07436    LAB_FBA2
07437    DFDA  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
07438    DFDC  20 E5 DF           JSR   LAB_CKIN          ; go check interrupt
07439    DFDF  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
07440    DFE1  20 E5 DF           JSR   LAB_CKIN          ; go check interrupt
07441    LAB_CRTS
07442    DFE4  60                 RTS
07443    
07444    ; check whichever interrupt is indexed by X
07445    
07446    LAB_CKIN
07447    DFE5  B5 00              LDA   PLUS_0,X          ; get interrupt flag byte
07448    DFE7  10 FB              BPL   LAB_CRTS          ; branch if interrupt not enabled
07449    
07450    ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
07451    ; automatically enable the interrupt when we exit
07452    
07453    DFE9  0A                 ASL                     ; move happened bit to setup bit
07454    DFEA  29 40              AND   #$40              ; mask happened bits
07455    DFEC  F0 F6              BEQ   LAB_CRTS          ; if no interrupt then exit
07456    
07457    DFEE  95 00              STA   PLUS_0,X          ; save interrupt flag byte
07458    
07459    DFF0  8A                 TXA                     ; copy index ..
07460    DFF1  A8                 TAY                     ; .. to Y
07461    
07462    DFF2  68                 PLA                     ; dump return address low byte, call from CTRL-C
07463    DFF3  68                 PLA                     ; dump return address high byte
07464    
07465    DFF4  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
07466    DFF6  20 03 C2           JSR   LAB_1212          ; check room on stack for A bytes
07467    DFF9  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
07468    DFFB  48                 PHA                     ; push on stack
07469    DFFC  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
07470    DFFE  48                 PHA                     ; push on stack
07471    DFFF  A5 88              LDA   Clineh            ; get current line high byte
07472    E001  48                 PHA                     ; push on stack
07473    E002  A5 87              LDA   Clinel            ; get current line low byte
07474    E004  48                 PHA                     ; push on stack
07475    E005  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
07476    E007  48                 PHA                     ; push on stack
07477    
07478    E008  B9 01 00           LDA   PLUS_1,Y          ; get interrupt code pointer low byte
07479    E00B  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
07480    E00D  B9 02 00           LDA   PLUS_2,Y          ; get interrupt code pointer high byte
07481    E010  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
07482    
07483    E012  4C C6 C5           JMP   LAB_15C2          ; go do interpreter inner loop
07484                                  ; can't RTS, we used the stack! the RTS from the ctrl-c
07485                                  ; check will be taken when the RETIRQ/RETNMI/RETURN is
07486                                  ; executed at the end of the subroutine
07487    
07488    ; get byte from input device, no waiting
07489    ; returns with carry set if byte in A
07490    
07491    INGET
07492    E015  20 FF E1           JSR   V_INPT            ; call scan input device
07493    E018  B0 09              BCS   LAB_FB95          ; if byte go reset timer
07494    
07495    E01A  AD 02 02           LDA   ccnull            ; get countdown
07496    E01D  F0 09              BEQ   LAB_FB96          ; exit if empty
07497    
07498    E01F  AD 01 02           LDA   ccbyte            ; get last received byte
07499    E022  38                 SEC                     ; flag we got a byte
07500    LAB_FB95
07501    E023  A2 00              LDX   #$00              ; clear X
07502    E025  8E 02 02           STX   ccnull            ; clear timer because we got a byte
07503    LAB_FB96
07504    E028  60                 RTS
07505    
07506    ; these routines only enable the interrupts if the set-up flag is set
07507    ; if not they have no effect
07508    
07509    ; perform IRQ {ON|OFF|CLEAR}
07510    
07511    LAB_IRQ
07512    E029  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
07513          .byte $2C               ; make next line BIT abs.
07514    
07515    ; perform NMI {ON|OFF|CLEAR}
07516    
07517    LAB_NMI
07518    E02C  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
07519    E02E  C9 93              CMP   #TK_ON            ; compare with token for ON
07520    E030  F0 11              BEQ   LAB_INON          ; go turn on interrupt
07521    
07522    E032  C9 B6              CMP   #TK_OFF           ; compare with token for OFF
07523    E034  F0 07              BEQ   LAB_IOFF          ; go turn off interrupt
07524    
07525    E036  49 A2              EOR   #TK_CLEAR         ; compare with token for CLEAR, A = $00 if = TK_CLEAR
07526    E038  F0 0E              BEQ   LAB_INEX          ; go clear interrupt flags and return
07527    
07528    E03A  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
07529    
07530    LAB_IOFF
07531    E03D  A9 7F              LDA   #$7F              ; clear A
07532    E03F  35 00              AND   PLUS_0,X          ; AND with interrupt setup flag
07533    E041  10 05              BPL   LAB_INEX          ; go clear interrupt enabled flag and return
07534    
07535    LAB_INON
07536    E043  B5 00              LDA   PLUS_0,X          ; get interrupt setup flag
07537    E045  0A                 ASL                     ; Shift bit to enabled flag
07538    E046  15 00              ORA   PLUS_0,X          ; OR with flag byte
07539    LAB_INEX
07540    E048  95 00              STA   PLUS_0,X          ; save interrupt flag byte
07541    E04A  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer and return
07542    
07543    ; these routines set up the pointers and flags for the interrupt routines
07544    ; note that the interrupts are also enabled by these commands
07545    
07546    ; perform ON IRQ
07547    
07548    LAB_SIRQ
07549    E04D  58                 CLI                     ; enable interrupts
07550    E04E  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
07551          .byte $2C               ; make next line BIT abs.
07552    
07553    ; perform ON NMI
07554    
07555    LAB_SNMI
07556    E051  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
07557    
07558    E053  86 78              STX   TempB             ; save interrupt pointer
07559    E055  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (past token)
07560    E058  20 5C C8           JSR   LAB_GFPN          ; get fixed-point number into temp integer
07561    E05B  A5 79              LDA   Smeml             ; get start of mem low byte
07562    E05D  A6 7A              LDX   Smemh             ; get start of mem high byte
07563    E05F  20 31 C4           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
07564    E062  B0 03              BCS   LAB_LFND          ; if carry set go set-up interrupt
07565    
07566    E064  4C 76 C7           JMP   LAB_16F7          ; else go do "Undefined statement" error and warm start
07567    
07568    LAB_LFND
07569    E067  A6 78              LDX   TempB             ; get interrupt pointer
07570    E069  A5 AA              LDA   Baslnl            ; get pointer low byte
07571    E06B  E9 01              SBC   #$01              ; -1 (carry already set for subtract)
07572    E06D  95 01              STA   PLUS_1,X          ; save as interrupt pointer low byte
07573    E06F  A5 AB              LDA   Baslnh            ; get pointer high byte
07574    E071  E9 00              SBC   #$00              ; subtract carry
07575    E073  95 02              STA   PLUS_2,X          ; save as interrupt pointer high byte
07576    
07577    E075  A9 C0              LDA   #$C0              ; set interrupt enabled/setup bits
07578    E077  95 00              STA   PLUS_0,X          ; set interrupt flags
07579    LAB_IRTS
07580    E079  60                 RTS
07581    
07582    ; return from IRQ service, restores the enabled flag.
07583    
07584    ; perform RETIRQ
07585    
07586    LAB_RETIRQ
07587    E07A  D0 FD              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
07588    
07589    E07C  A5 DF              LDA   IrqBase           ; get interrupt flags
07590    E07E  0A                 ASL                     ; copy setup to enabled (b7)
07591    E07F  05 DF              ORA   IrqBase           ; OR in setup flag
07592    E081  85 DF              STA   IrqBase           ; save enabled flag
07593    E083  4C 7D C7           JMP   LAB_16E8          ; go do rest of RETURN
07594    
07595    ; return from NMI service, restores the enabled flag.
07596    
07597    ; perform RETNMI
07598    
07599    LAB_RETNMI
07600    E086  D0 F1              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
07601    
07602    E088  A5 DC              LDA   NmiBase           ; get set-up flag
07603    E08A  0A                 ASL                     ; copy setup to enabled (b7)
07604    E08B  05 DC              ORA   NmiBase           ; OR in setup flag
07605    E08D  85 DC              STA   NmiBase           ; save enabled flag
07606    E08F  4C 7D C7           JMP   LAB_16E8          ; go do rest of RETURN
07607    
07608    ; MAX() MIN() pre process
07609    
07610    LAB_MMPP
07611    E092  20 EF CB           JSR   LAB_EVEZ          ; process expression
07612    E095  4C D6 CB           JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
07613    
07614    ; perform MAX()
07615    
07616    LAB_MAX
07617    E098  20 C6 E0           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
07618                                  ; pull FAC2 and compare with FAC1
07619    E09B  10 FB              BPL   LAB_MAX           ; branch if no swap to do
07620    
07621    E09D  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
07622    E09F  09 80              ORA   #$80              ; set top bit (clear sign from compare)
07623    E0A1  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
07624    E0A3  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1
07625    E0A6  F0 F0              BEQ   LAB_MAX           ; go do next (branch always)
07626    
07627    ; perform MIN()
07628    
07629    LAB_MIN
07630    E0A8  20 C6 E0           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
07631                                  ; pull FAC2 and compare with FAC1
07632    E0AB  30 FB              BMI   LAB_MIN           ; branch if no swap to do
07633    
07634    E0AD  F0 F9              BEQ   LAB_MIN           ; branch if no swap to do
07635    
07636    E0AF  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
07637    E0B1  09 80              ORA   #$80              ; set top bit (clear sign from compare)
07638    E0B3  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
07639    E0B5  20 D6 D6           JSR   LAB_279B          ; copy FAC2 to FAC1
07640    E0B8  F0 EE              BEQ   LAB_MIN           ; go do next (branch always)
07641    
07642    ; exit routine. don't bother returning to the loop code
07643    ; check for correct exit, else so syntax error
07644    
07645    LAB_MMEC
07646    E0BA  C9 29              CMP   #')'              ; is it end of function?
07647    E0BC  D0 05              BNE   LAB_MMSE          ; if not do MAX MIN syntax error
07648    
07649    E0BE  68                 PLA                     ; dump return address low byte
07650    E0BF  68                 PLA                     ; dump return address high byte
07651    E0C0  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
07652    
07653    LAB_MMSE
07654    E0C3  4C 08 CD           JMP   LAB_SNER          ; do syntax error then warm start
07655    
07656    ; check for next, evaluate and return or exit
07657    ; this is the routine that does most of the work
07658    
07659    LAB_PHFA
07660    E0C6  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
07661    E0C9  C9 2C              CMP   #','              ; is there more ?
07662    E0CB  D0 ED              BNE   LAB_MMEC          ; if not go do end check
07663    
07664                                  ; push FAC1
07665    E0CD  20 EC D9           JSR   LAB_27BA          ; round FAC1
07666    E0D0  A5 B0              LDA   FAC1_s            ; get FAC1 sign
07667    E0D2  09 7F              ORA   #$7F              ; set all non sign bits
07668    E0D4  25 AD              AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
07669    E0D6  48                 PHA                     ; push on stack
07670    E0D7  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
07671    E0D9  48                 PHA                     ; push on stack
07672    E0DA  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
07673    E0DC  48                 PHA                     ; push on stack
07674    E0DD  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
07675    E0DF  48                 PHA                     ; push on stack
07676    
07677    E0E0  20 BC 00           JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
07678    E0E3  20 D3 CB           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
07679                                  ; else do type mismatch
07680    
07681                                  ; pop FAC2 (MAX/MIN expression so far)
07682    E0E6  68                 PLA                     ; pop exponent
07683    E0E7  85 B3              STA   FAC2_e            ; save FAC2 exponent
07684    E0E9  68                 PLA                     ; pop mantissa3
07685    E0EA  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
07686    E0EC  68                 PLA                     ; pop mantissa1
07687    E0ED  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
07688    E0EF  68                 PLA                     ; pop sign/mantissa1
07689    E0F0  85 B4              STA   FAC2_1            ; save FAC2 sign/mantissa1
07690    E0F2  85 B7              STA   FAC2_s            ; save FAC2 sign
07691    
07692                                  ; compare FAC1 with (packed) FAC2
07693    E0F4  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
07694    E0F6  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
07695    E0F8  4C 2A DA           JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
07696                                  ; returns A=$00 if FAC1 = (AY)
07697                                  ; returns A=$01 if FAC1 > (AY)
07698                                  ; returns A=$FF if FAC1 < (AY)
07699    
07700    ; perform WIDTH
07701    
07702    LAB_WDTH
07703    E0FB  C9 2C              CMP   #','              ; is next byte ","
07704    E0FD  F0 1B              BEQ   LAB_TBSZ          ; if so do tab size
07705    
07706    E0FF  20 A6 D5           JSR   LAB_GTBY          ; get byte parameter
07707    E102  8A                 TXA                     ; copy width to A
07708    E103  F0 0A              BEQ   LAB_NSTT          ; branch if set for infinite line
07709    
07710    E105  E0 10              CPX   #$10              ; else make min width = 16d
07711    E107  90 45              BCC   TabErr            ; if less do function call error and exit
07712    
07713    ; this next compare ensures that we can't exit WIDTH via an error leaving the
07714    ; tab size greater than the line length.
07715    
07716    E109  E4 64              CPX   TabSiz            ; compare with tab size
07717    E10B  B0 02              BCS   LAB_NSTT          ; branch if >= tab size
07718    
07719    E10D  86 64              STX   TabSiz            ; else make tab size = terminal width
07720    LAB_NSTT
07721    E10F  86 0F              STX   TWidth            ; set the terminal width
07722    E111  20 C2 00           JSR   LAB_GBYT          ; get BASIC byte back
07723    E114  F0 1A              BEQ   WExit             ; exit if no following
07724    
07725    E116  C9 2C              CMP   #','              ; else is it ","
07726    E118  D0 A9              BNE   LAB_MMSE          ; if not do syntax error
07727    
07728    LAB_TBSZ
07729    E11A  20 A3 D5           JSR   LAB_SGBY          ; scan and get byte parameter
07730    E11D  8A                 TXA                     ; copy TAB size
07731    E11E  30 2E              BMI   TabErr            ; if >127 do function call error and exit
07732    
07733    E120  E0 01              CPX   #$01              ; compare with min-1
07734    E122  90 2A              BCC   TabErr            ; if <=1 do function call error and exit
07735    
07736    E124  A5 0F              LDA   TWidth            ; set flags for width
07737    E126  F0 06              BEQ   LAB_SVTB          ; skip check if infinite line
07738    
07739    E128  E4 0F              CPX   TWidth            ; compare TAB with width
07740    E12A  F0 02              BEQ   LAB_SVTB          ; ok if =
07741    
07742    E12C  B0 20              BCS   TabErr            ; branch if too big
07743    
07744    LAB_SVTB
07745    E12E  86 64              STX   TabSiz            ; save TAB size
07746    
07747    ; calculate tab column limit from TAB size. The Iclim is set to the last tab
07748    ; position on a line that still has at least one whole tab width between it
07749    ; and the end of the line.
07750    
07751    WExit
07752    E130  A5 0F              LDA   TWidth            ; get width
07753    E132  F0 06              BEQ   LAB_SULP          ; branch if infinite line
07754    
07755    E134  C5 64              CMP   TabSiz            ; compare with tab size
07756    E136  B0 03              BCS   LAB_WDLP          ; branch if >= tab size
07757    
07758    E138  85 64              STA   TabSiz            ; else make tab size = terminal width
07759    LAB_SULP
07760    E13A  38                 SEC                     ; set carry for subtract
07761    LAB_WDLP
07762    E13B  E5 64              SBC   TabSiz            ; subtract tab size
07763    E13D  B0 FC              BCS   LAB_WDLP          ; loop while no borrow
07764    
07765    E13F  65 64              ADC   TabSiz            ; add tab size back
07766    E141  18                 CLC                     ; clear carry for add
07767    E142  65 64              ADC   TabSiz            ; add tab size back again
07768    E144  85 10              STA   Iclim             ; save for now
07769    E146  A5 0F              LDA   TWidth            ; get width back
07770    E148  38                 SEC                     ; set carry for subtract
07771    E149  E5 10              SBC   Iclim             ; subtract remainder
07772    E14B  85 10              STA   Iclim             ; save tab column limit
07773    LAB_NOSQ
07774    E14D  60                 RTS
07775    
07776    TabErr
07777    E14E  4C 3D D0           JMP   LAB_FCER          ; do function call error then warm start
07778    
07779    ; perform SQR()
07780    
07781    LAB_SQR
07782    E151  A5 B0              LDA   FAC1_s            ; get FAC1 sign
07783    E153  30 F9              BMI   TabErr            ; if -ve do function call error
07784    
07785    E155  A5 AC              LDA   FAC1_e            ; get exponent
07786    E157  F0 F4              BEQ   LAB_NOSQ          ; if zero just return
07787    
07788                                  ; else do root
07789    E159  20 DD D9           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
07790    E15C  A9 00              LDA   #$00              ; clear A
07791    
07792    E15E  85 77              STA   FACt_3            ; clear remainder
07793    E160  85 76              STA   FACt_2            ; ..
07794    E162  85 75              STA   FACt_1            ; ..
07795    E164  85 78              STA   TempB             ; ..
07796    
07797    E166  85 AF              STA   FAC1_3            ; clear root
07798    E168  85 AE              STA   FAC1_2            ; ..
07799    E16A  85 AD              STA   FAC1_1            ; ..
07800    
07801    E16C  A2 18              LDX   #$18              ; 24 pairs of bits to do
07802    E16E  A5 B3              LDA   FAC2_e            ; get exponent
07803    E170  4A                 LSR                     ; check odd/even
07804    E171  B0 0E              BCS   LAB_SQE2          ; if odd only 1 shift first time
07805    
07806    LAB_SQE1
07807    E173  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
07808    E175  26 B5              ROL   FAC2_2            ; ..
07809    E177  26 B4              ROL   FAC2_1            ; ..
07810    E179  26 77              ROL   FACt_3            ; .. into remainder
07811    E17B  26 76              ROL   FACt_2            ; ..
07812    E17D  26 75              ROL   FACt_1            ; ..
07813    E17F  26 78              ROL   TempB             ; .. never overflows
07814    LAB_SQE2
07815    E181  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
07816    E183  26 B5              ROL   FAC2_2            ; ..
07817    E185  26 B4              ROL   FAC2_1            ; ..
07818    E187  26 77              ROL   FACt_3            ; .. into remainder
07819    E189  26 76              ROL   FACt_2            ; ..
07820    E18B  26 75              ROL   FACt_1            ; ..
07821    E18D  26 78              ROL   TempB             ; .. never overflows
07822    
07823    E18F  06 AF              ASL   FAC1_3            ; root = root * 2
07824    E191  26 AE              ROL   FAC1_2            ; ..
07825    E193  26 AD              ROL   FAC1_1            ; .. never overflows
07826    
07827    E195  A5 AF              LDA   FAC1_3            ; get root low byte
07828    E197  2A                 ROL                     ; *2
07829    E198  85 5B              STA   Temp3             ; save partial low byte
07830    E19A  A5 AE              LDA   FAC1_2            ; get root low mid byte
07831    E19C  2A                 ROL                     ; *2
07832    E19D  85 5C              STA   Temp3+1           ; save partial low mid byte
07833    E19F  A5 AD              LDA   FAC1_1            ; get root high mid byte
07834    E1A1  2A                 ROL                     ; *2
07835    E1A2  85 5D              STA   Temp3+2           ; save partial high mid byte
07836    E1A4  A9 00              LDA   #$00              ; get root high byte (always $00)
07837    E1A6  2A                 ROL                     ; *2
07838    E1A7  85 5E              STA   Temp3+3           ; save partial high byte
07839    
07840                                  ; carry clear for subtract +1
07841    E1A9  A5 77              LDA   FACt_3            ; get remainder low byte
07842    E1AB  E5 5B              SBC   Temp3             ; subtract partial low byte
07843    E1AD  85 5B              STA   Temp3             ; save partial low byte
07844    
07845    E1AF  A5 76              LDA   FACt_2            ; get remainder low mid byte
07846    E1B1  E5 5C              SBC   Temp3+1           ; subtract partial low mid byte
07847    E1B3  85 5C              STA   Temp3+1           ; save partial low mid byte
07848    
07849    E1B5  A5 75              LDA   FACt_1            ; get remainder high mid byte
07850    E1B7  E5 5D              SBC   Temp3+2           ; subtract partial high mid byte
07851    E1B9  A8                 TAY                     ; copy partial high mid byte
07852    
07853    E1BA  A5 78              LDA   TempB             ; get remainder high byte
07854    E1BC  E5 5E              SBC   Temp3+3           ; subtract partial high byte
07855    E1BE  90 0E              BCC   LAB_SQNS          ; skip sub if remainder smaller
07856    
07857    E1C0  85 78              STA   TempB             ; save remainder high byte
07858    
07859    E1C2  84 75              STY   FACt_1            ; save remainder high mid byte
07860    
07861    E1C4  A5 5C              LDA   Temp3+1           ; get remainder low mid byte
07862    E1C6  85 76              STA   FACt_2            ; save remainder low mid byte
07863    
07864    E1C8  A5 5B              LDA   Temp3             ; get partial low byte
07865    E1CA  85 77              STA   FACt_3            ; save remainder low byte
07866    
07867    E1CC  E6 AF              INC   FAC1_3            ; increment root low byte (never any rollover)
07868    LAB_SQNS
07869    E1CE  CA                 DEX                     ; decrement bit pair count
07870    E1CF  D0 A2              BNE   LAB_SQE1          ; loop if not all done
07871    
07872    E1D1  38                 SEC                     ; set carry for subtract
07873    E1D2  A5 B3              LDA   FAC2_e            ; get exponent
07874    E1D4  E9 80              SBC   #$80              ; normalise
07875    E1D6  6A                 ROR                     ; /2 and re-bias to $80
07876    E1D7  69 00              ADC   #$00              ; add bit zero back in (allow for half shift)
07877    E1D9  85 AC              STA   FAC1_e            ; save it
07878    E1DB  4C 47 D7           JMP   LAB_24D5          ; normalise FAC1 and return
07879    
07880    ; perform VARPTR()
07881    
07882    LAB_VARPTR
07883    E1DE  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
07884    E1E1  20 BE CE           JSR   LAB_GVAR          ; get var address
07885    E1E4  20 F5 CC           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
07886    E1E7  A4 95              LDY   Cvaral            ; get var address low byte
07887    E1E9  A5 96              LDA   Cvarah            ; get var address high byte
07888    E1EB  4C 6D D1           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
07889    
07890    ; perform PI
07891    
07892    LAB_PI
07893    E1EE  A9 D5              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
07894    E1F0  A0 E2              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
07895    E1F2  20 90 D9           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
07896    E1F5  C6 AC              DEC   FAC1_e            ; make result = PI
07897    E1F7  60                 RTS
07898    
07899    ; perform TWOPI
07900    
07901    LAB_TWOPI
07902    E1F8  A9 D5              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
07903    E1FA  A0 E2              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
07904    E1FC  4C 90 D9           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
07905    
07906    ; system dependant i/o vectors
07907    ; these are in RAM and are set by the monitor at start-up
07908    
07909    V_INPT
07910    E1FF  6C 05 02           JMP   (VEC_IN)          ; non halting scan input device
07911    V_OUTP
07912    E202  6C 07 02           JMP   (VEC_OUT)         ; send byte to output device
07913    V_LOAD
07914    E205  6C 09 02           JMP   (VEC_LD)          ; load BASIC program
07915    V_SAVE
07916    E208  6C 0B 02           JMP   (VEC_SV)          ; save BASIC program
07917    V_VERIFY
07918    E20B  6C 0D 02           JMP   (VEC_VERIFY)
07919    
07920    ; The rest are tables messages and code for RAM
07921    
07922    ; the rest of the code is tables and BASIC start-up code
07923    
07924    PG2_TABS
07925          .byte $00               ; ctrl-c flag           -     $00 = enabled
07926          .byte $00               ; ctrl-c byte           -     GET needs this
07927          .byte $00               ; ctrl-c byte timeout   -     GET needs this
07928          .word CTRLC             ; ctrl c check vector
07929    ;     .word xxxx              ; non halting key input -     monitor to set this
07930    ;     .word xxxx              ; output vector         -     monitor to set this
07931    ;     .word xxxx              ; load vector           -     monitor to set this
07932    ;     .word xxxx              ; save vector           -     monitor to set this
07933    PG2_TABE
07934    
07935    ; character get subroutine for zero page
07936    
07937    ; For a 1.8432MHz 6502 including the JSR and RTS
07938    ; fastest (>=":") =  29 cycles =  15.7uS
07939    ; slowest (<":")  =  40 cycles =  21.7uS
07940    ; space skip      = +21 cycles = +11.4uS
07941    ; inc across page =  +4 cycles =  +2.2uS
07942    
07943    ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
07944    ; block is copied to it's destination, any non zero page address will do at assembly
07945    ; time, to assemble a three byte instruction.
07946    
07947    ; page 0 initialisation table from $BC
07948    ; increment and scan memory
07949    
07950    LAB_2CEE
07951    E213  E6 C3              INC   Bpntrl            ; increment BASIC execute pointer low byte
07952    E215  D0 02              BNE   LAB_2CF4          ; branch if no carry
07953                                  ; else
07954    E217  E6 C4              INC   Bpntrh            ; increment BASIC execute pointer high byte
07955    
07956    ; page 0 initialisation table from $C2
07957    ; scan memory
07958    
07959    LAB_2CF4
07960    E219  AD FF FF           LDA   $FFFF             ; get byte to scan (addr set by call routine)
07961    E21C  C9 AD              CMP   #TK_ELSE          ; compare with the token for ELSE
07962    E21E  F0 0E              BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
07963    
07964    E220  C9 3A              CMP   #':'              ; compare with ":"
07965    E222  B0 0A              BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
07966    
07967    E224  C9 20              CMP   #' '              ; compare with " "
07968    E226  F0 EB              BEQ   LAB_2CEE          ; if " " go do next
07969    
07970    E228  38                 SEC                     ; set carry for SBC
07971    E229  E9 30              SBC   #'0'              ; subtract "0"
07972    E22B  38                 SEC                     ; set carry for SBC
07973    E22C  E9 D0              SBC   #$D0              ; subtract -"0"
07974                                  ; clear carry if byte = "0"-"9"
07975    LAB_2D05
07976    E22E  60                 RTS
07977    
07978    ; page zero initialisation table $00-$12 inclusive
07979    
07980    StrTab
07981          .byte $4C               ; JMP opcode
07982          .word LAB_COLD          ; initial warm start vector (cold start)
07983    
07984          .byte $00               ; these bytes are not used by BASIC
07985          .word $0000             ; 
07986          .word $0000             ; 
07987          .word $0000             ; 
07988    
07989          .byte $4C               ; JMP opcode
07990          .word LAB_FCER          ; initial user function vector ("Function call" error)
07991          .byte $00               ; default NULL count
07992          .byte $00               ; clear terminal position
07993          .byte $00               ; default terminal width byte
07994          .byte $F2               ; default limit for TAB = 14
07995          .word Ram_base          ; start of user RAM
07996    EndTab
07997    
07998    LAB_MSZM
07999          .byte $0D,$0A,"Memory size ",$00
08000    
08001    LAB_SMSG
08002          .byte " Bytes free",$0D,$0A,$0A
08003          .byte "Enhanced BASIC 2.22p5",$0A,$00
08004    
08005    ; numeric constants and series
08006    
08007                                  ; constants and series for LOG(n)
08008    LAB_25A0
08009          .byte $02               ; counter
08010          .byte $80,$19,$56,$62   ; 0.59898
08011          .byte $80,$76,$22,$F3   ; 0.96147
08012    ;##   .byte $80,$76,$22,$F1   ; 0.96147
08013          .byte $82,$38,$AA,$40   ; 2.88539
08014    ;##   .byte $82,$38,$AA,$45   ; 2.88539
08015    
08016    LAB_25AD
08017          .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
08018    LAB_25B1
08019          .byte $81,$35,$04,$F3   ; 1.41421   root 2
08020    LAB_25B5
08021          .byte $80,$80,$00,$00   ; -0.5
08022    LAB_25B9
08023          .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
08024    
08025                                  ; numeric PRINT constants
08026    LAB_2947
08027          .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
08028    LAB_294B
08029          .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
08030    LAB_294F
08031          .byte $94,$74,$24,$00   ; 1000000
08032    
08033                                  ; EXP(n) constants and series
08034    LAB_2AFA
08035          .byte $81,$38,$AA,$3B   ; 1.4427    (1/LOG base 2 e)
08036    LAB_2AFE
08037          .byte $06               ; counter
08038          .byte $74,$63,$90,$8C   ; 2.17023e-4
08039          .byte $77,$23,$0C,$AB   ; 0.00124
08040          .byte $7A,$1E,$94,$00   ; 0.00968
08041          .byte $7C,$63,$42,$80   ; 0.05548
08042          .byte $7E,$75,$FE,$D0   ; 0.24023
08043          .byte $80,$31,$72,$15   ; 0.69315
08044          .byte $81,$00,$00,$00   ; 1.00000
08045    
08046    ;##   .byte $07               ; counter
08047    ;##   .byte $74,$94,$2E,$40   ; -1/7! (-1/5040)
08048    ;##   .byte $77,$2E,$4F,$70   ;  1/6! ( 1/720)
08049    ;##   .byte $7A,$88,$02,$6E   ; -1/5! (-1/120)
08050    ;##   .byte $7C,$2A,$A0,$E6   ;  1/4! ( 1/24)
08051    ;##   .byte $7E,$AA,$AA,$50   ; -1/3! (-1/6)
08052    ;##   .byte $7F,$7F,$FF,$FF   ;  1/2! ( 1/2)
08053    ;##   .byte $81,$80,$00,$00   ; -1/1! (-1/1)
08054    ;##   .byte $81,$00,$00,$00   ;  1/0! ( 1/1)
08055    
08056                                  ; trigonometric constants and series
08057    LAB_2C78
08058          .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
08059    LAB_2C84
08060          .byte $04               ; counter
08061          .byte $86,$1E,$D7,$FB   ; 39.7109
08062    ;##   .byte $86,$1E,$D7,$BA   ; 39.7109
08063          .byte $87,$99,$26,$65   ;-76.575
08064    ;##   .byte $87,$99,$26,$64   ;-76.575
08065          .byte $87,$23,$34,$58   ; 81.6022
08066          .byte $86,$A5,$5D,$E1   ;-41.3417
08067    ;##   .byte $86,$A5,$5D,$E0   ;-41.3417
08068    LAB_2C7C
08069          .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
08070    ;##   .byte $83,$49,$0F,$DA   ; 6.28319 (2*pi) as floating #
08071    
08072    LAB_2CC9
08073          .byte $08               ; counter
08074          .byte $78,$3A,$C5,$37   ; 0.00285
08075          .byte $7B,$83,$A2,$5C   ;-0.0160686
08076          .byte $7C,$2E,$DD,$4D   ; 0.0426915
08077          .byte $7D,$99,$B0,$1E   ;-0.0750429
08078          .byte $7D,$59,$ED,$24   ; 0.106409
08079          .byte $7E,$91,$72,$00   ;-0.142036
08080          .byte $7E,$4C,$B9,$73   ; 0.199926
08081          .byte $7F,$AA,$AA,$53   ;-0.333331
08082    
08083    ;##   .byte $08               ; counter
08084    ;##   .byte $78,$3B,$D7,$4A   ; 1/17
08085    ;##   .byte $7B,$84,$6E,$02   ;-1/15
08086    ;##   .byte $7C,$2F,$C1,$FE   ; 1/13
08087    ;##   .byte $7D,$9A,$31,$74   ;-1/11
08088    ;##   .byte $7D,$5A,$3D,$84   ; 1/9
08089    ;##   .byte $7E,$91,$7F,$C8   ;-1/7
08090    ;##   .byte $7E,$4C,$BB,$E4   ; 1/5
08091    ;##   .byte $7F,$AA,$AA,$6C   ;-1/3
08092    
08093      E2FB             LAB_1D96    = *+1             ; $00,$00 used for undefined variables
08094    LAB_259C
08095          .byte $81,$00,$00,$00   ; 1.000000, used for INC
08096    LAB_2AFD
08097          .byte $81,$80,$00,$00   ; -1.00000, used for DEC. must be on the same page as +1.00
08098    
08099                                  ; misc constants
08100    LAB_1DF7
08101          .byte $90               ;-32768 (uses first three bytes from 0.5)
08102    LAB_2A96
08103          .byte $80,$00,$00,$00   ; 0.5
08104    LAB_2C80
08105          .byte $7F,$00,$00,$00   ; 0.25
08106    LAB_26B5
08107          .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
08108    
08109    ; This table is used in converting numbers to ASCII.
08110    
08111    LAB_2A9A
08112      E310             LAB_2A9B = LAB_2A9A+1
08113      E311             LAB_2A9C = LAB_2A9B+1
08114          .byte $FE,$79,$60       ; -100000
08115          .byte $00,$27,$10       ; 10000
08116          .byte $FF,$FC,$18       ; -1000
08117          .byte $00,$00,$64       ; 100
08118          .byte $FF,$FF,$F6       ; -10
08119          .byte $00,$00,$01       ; 1
08120    
08121    LAB_CTBL
08122          .word LAB_END-1         ; END
08123          .word LAB_FOR-1         ; FOR
08124          .word LAB_NEXT-1        ; NEXT
08125          .word LAB_DATA-1        ; DATA
08126          .word LAB_INPUT-1       ; INPUT
08127          .word LAB_DIM-1         ; DIM
08128          .word LAB_READ-1        ; READ
08129          .word LAB_LET-1         ; LET
08130          .word LAB_DEC-1         ; DEC             new command
08131          .word LAB_GOTO-1        ; GOTO
08132          .word LAB_RUN-1         ; RUN
08133          .word LAB_IF-1          ; IF
08134          .word LAB_RESTORE-1     ; RESTORE         modified command
08135          .word LAB_GOSUB-1       ; GOSUB
08136          .word LAB_RETIRQ-1      ; RETIRQ          new command
08137          .word LAB_RETNMI-1      ; RETNMI          new command
08138          .word LAB_RETURN-1      ; RETURN
08139          .word LAB_REM-1         ; REM
08140          .word LAB_STOP-1        ; STOP
08141          .word LAB_ON-1          ; ON              modified command
08142          .word LAB_NULL-1        ; NULL            modified command
08143          .word LAB_INC-1         ; INC             new command
08144          .word LAB_WAIT-1        ; WAIT
08145          .word V_LOAD-1          ; LOAD
08146          .word V_SAVE-1          ; SAVE
08147          .word LAB_DEF-1         ; DEF
08148          .word LAB_POKE-1        ; POKE
08149          .word LAB_DOKE-1        ; DOKE            new command
08150          .word LAB_CALL-1        ; CALL            new command
08151          .word LAB_DO-1          ; DO              new command
08152          .word LAB_LOOP-1        ; LOOP            new command
08153          .word LAB_PRINT-1       ; PRINT
08154          .word LAB_CONT-1        ; CONT
08155          .word LAB_LIST-1        ; LIST
08156          .word LAB_CLEAR-1       ; CLEAR
08157          .word LAB_NEW-1         ; NEW
08158          .word LAB_WDTH-1        ; WIDTH           new command
08159          .word LAB_GET-1         ; GET             new command
08160          .word LAB_SWAP-1        ; SWAP            new command
08161          .word LAB_BITSET-1      ; BITSET          new command
08162          .word LAB_BITCLR-1      ; BITCLR          new command
08163          .word LAB_IRQ-1         ; IRQ             new command
08164          .word LAB_NMI-1         ; NMI             new command
08165          .word TAPE_VERIFY_BASIC_vec-1      ; VERIFY          new command
08166    
08167    ; function pre process routine table
08168    
08169    LAB_FTPL
08170      E37A             LAB_FTPM    = LAB_FTPL+$01
08171          .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
08172          .word LAB_PPFN-1        ; INT(n)          "
08173          .word LAB_PPFN-1        ; ABS(n)          "
08174          .word LAB_EVEZ-1        ; USR(x)    process any expression
08175          .word LAB_1BF7-1        ; FRE(x)          "
08176          .word LAB_1BF7-1        ; POS(x)          "
08177          .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
08178          .word LAB_PPFN-1        ; RND(n)          "
08179          .word LAB_PPFN-1        ; LOG(n)          "
08180          .word LAB_PPFN-1        ; EXP(n)          "
08181          .word LAB_PPFN-1        ; COS(n)          "
08182          .word LAB_PPFN-1        ; SIN(n)          "
08183          .word LAB_PPFN-1        ; TAN(n)          "
08184          .word LAB_PPFN-1        ; ATN(n)          "
08185          .word LAB_PPFN-1        ; PEEK(n)         "
08186          .word LAB_PPFN-1        ; DEEK(n)         "
08187          .word $0000             ; SADD()    none
08188          .word LAB_PPFS-1        ; LEN($)    process string expression in ()
08189          .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
08190          .word LAB_PPFS-1        ; VAL($)    process string expression in ()
08191          .word LAB_PPFS-1        ; ASC($)          "
08192          .word LAB_PPFS-1        ; UCASE$($)       "
08193          .word LAB_PPFS-1        ; LCASE$($)       "
08194          .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
08195          .word LAB_BHSS-1        ; HEX$(n)         "
08196          .word LAB_BHSS-1        ; BIN$(n)         "
08197          .word $0000             ; BITTST()  none
08198          .word LAB_MMPP-1        ; MAX()     process numeric expression
08199          .word LAB_MMPP-1        ; MIN()           "
08200          .word LAB_PPBI-1        ; PI        advance pointer
08201          .word LAB_PPBI-1        ; TWOPI           "
08202          .word $0000             ; VARPTR()  none
08203          .word LAB_LRMS-1        ; LEFT$()   process string expression
08204          .word LAB_LRMS-1        ; RIGHT$()        "
08205          .word LAB_LRMS-1        ; MID$()          "
08206    
08207    ; action addresses for functions
08208    
08209    LAB_FTBL
08210      E3C0             LAB_FTBM    = LAB_FTBL+$01
08211          .word LAB_SGN-1         ; SGN()
08212          .word LAB_INT-1         ; INT()
08213          .word LAB_ABS-1         ; ABS()
08214          .word LAB_USR-1         ; USR()
08215          .word LAB_FRE-1         ; FRE()
08216          .word LAB_POS-1         ; POS()
08217          .word LAB_SQR-1         ; SQR()
08218          .word LAB_RND-1         ; RND()           modified function
08219          .word LAB_LOG-1         ; LOG()
08220          .word LAB_EXP-1         ; EXP()
08221          .word LAB_COS-1         ; COS()
08222          .word LAB_SIN-1         ; SIN()
08223          .word LAB_TAN-1         ; TAN()
08224          .word LAB_ATN-1         ; ATN()
08225          .word LAB_PEEK-1        ; PEEK()
08226          .word LAB_DEEK-1        ; DEEK()          new function
08227          .word LAB_SADD-1        ; SADD()          new function
08228          .word LAB_LENS-1        ; LEN()
08229          .word LAB_STRS-1        ; STR$()
08230          .word LAB_VAL-1         ; VAL()
08231          .word LAB_ASC-1         ; ASC()
08232          .word LAB_UCASE-1       ; UCASE$()        new function
08233          .word LAB_LCASE-1       ; LCASE$()        new function
08234          .word LAB_CHRS-1        ; CHR$()
08235          .word LAB_HEXS-1        ; HEX$()          new function
08236          .word LAB_BINS-1        ; BIN$()          new function
08237          .word LAB_BTST-1        ; BITTST()        new function
08238          .word LAB_MAX-1         ; MAX()           new function
08239          .word LAB_MIN-1         ; MIN()           new function
08240          .word LAB_PI-1          ; PI              new function
08241          .word LAB_TWOPI-1       ; TWOPI           new function
08242          .word LAB_VARPTR-1      ; VARPTR()        new function
08243          .word LAB_LEFT-1        ; LEFT$()
08244          .word LAB_RIGHT-1       ; RIGHT$()
08245          .word LAB_MIDS-1        ; MID$()
08246    
08247    ; hierarchy and action addresses for operator
08248    
08249    LAB_OPPT
08250          .byte $79               ; +
08251          .word LAB_ADD-1
08252          .byte $79               ; -
08253          .word LAB_SUBTRACT-1
08254          .byte $7B               ; *
08255          .word LAB_MULTIPLY-1
08256          .byte $7B               ; /
08257          .word LAB_DIVIDE-1
08258          .byte $7F               ; ^
08259          .word LAB_POWER-1
08260          .byte $50               ; AND
08261          .word LAB_AND-1
08262          .byte $46               ; EOR             new operator
08263          .word LAB_EOR-1
08264          .byte $46               ; OR
08265          .word LAB_OR-1
08266          .byte $56               ; >>              new operator
08267          .word LAB_RSHIFT-1
08268          .byte $56               ; <<              new operator
08269          .word LAB_LSHIFT-1
08270          .byte $7D               ; >
08271          .word LAB_GTHAN-1
08272          .byte $5A               ; =
08273          .word LAB_EQUAL-1
08274          .byte $64               ; <
08275          .word LAB_LTHAN-1
08276    
08277    ; keywords start with ..
08278    ; this is the first character table and must be in alphabetic order
08279    
08280    TAB_1STC
08281          .byte "*"
08282          .byte "+"
08283          .byte "-"
08284          .byte "/"
08285          .byte "<"
08286          .byte "="
08287          .byte ">"
08288          .byte "?"
08289          .byte "A"
08290          .byte "B"
08291          .byte "C"
08292          .byte "D"
08293          .byte "E"
08294          .byte "F"
08295          .byte "G"
08296          .byte "H"
08297          .byte "I"
08298          .byte "L"
08299          .byte "M"
08300          .byte "N"
08301          .byte "O"
08302          .byte "P"
08303          .byte "R"
08304          .byte "S"
08305          .byte "T"
08306          .byte "U"
08307          .byte "V"
08308          .byte "W"
08309          .byte "^"
08310          .byte $00               ; table terminator
08311    
08312    ; pointers to keyword tables
08313    
08314    TAB_CHRT
08315          .word TAB_STAR          ; table for "*"
08316          .word TAB_PLUS          ; table for "+"
08317          .word TAB_MNUS          ; table for "-"
08318          .word TAB_SLAS          ; table for "/"
08319          .word TAB_LESS          ; table for "<"
08320          .word TAB_EQUL          ; table for "="
08321          .word TAB_MORE          ; table for ">"
08322          .word TAB_QEST          ; table for "?"
08323          .word TAB_ASCA          ; table for "A"
08324          .word TAB_ASCB          ; table for "B"
08325          .word TAB_ASCC          ; table for "C"
08326          .word TAB_ASCD          ; table for "D"
08327          .word TAB_ASCE          ; table for "E"
08328          .word TAB_ASCF          ; table for "F"
08329          .word TAB_ASCG          ; table for "G"
08330          .word TAB_ASCH          ; table for "H"
08331          .word TAB_ASCI          ; table for "I"
08332          .word TAB_ASCL          ; table for "L"
08333          .word TAB_ASCM          ; table for "M"
08334          .word TAB_ASCN          ; table for "N"
08335          .word TAB_ASCO          ; table for "O"
08336          .word TAB_ASCP          ; table for "P"
08337          .word TAB_ASCR          ; table for "R"
08338          .word TAB_ASCS          ; table for "S"
08339          .word TAB_ASCT          ; table for "T"
08340          .word TAB_ASCU          ; table for "U"
08341          .word TAB_ASCV          ; table for "V"
08342          .word TAB_ASCW          ; table for "W"
08343          .word TAB_POWR          ; table for "^"
08344    
08345    ; tables for each start character, note if a longer keyword with the same start
08346    ; letters as a shorter one exists then it must come first, else the list is in
08347    ; alphabetical order as follows ..
08348    
08349    ; [keyword,token
08350    ; [keyword,token]]
08351    ; end marker (#$00)
08352    
08353    TAB_STAR
08354          .byte TK_MUL,$00        ; *
08355    TAB_PLUS
08356          .byte TK_PLUS,$00       ; +
08357    TAB_MNUS
08358          .byte TK_MINUS,$00      ; -
08359    TAB_SLAS
08360          .byte TK_DIV,$00        ; /
08361    TAB_LESS
08362    LBB_LSHIFT
08363          .byte "<",TK_LSHIFT     ; <<  note - "<<" must come before "<"
08364          .byte TK_LT             ; <
08365          .byte $00
08366    TAB_EQUL
08367          .byte TK_EQUAL,$00      ; =
08368    TAB_MORE
08369    LBB_RSHIFT
08370          .byte ">",TK_RSHIFT     ; >>  note - ">>" must come before ">"
08371          .byte TK_GT             ; >
08372          .byte $00
08373    TAB_QEST
08374          .byte TK_PRINT,$00      ; ?
08375    TAB_ASCA
08376    LBB_ABS
08377          .byte "BS(",TK_ABS      ; ABS(
08378    LBB_AND
08379          .byte "ND",TK_AND       ; AND
08380    LBB_ASC
08381          .byte "SC(",TK_ASC      ; ASC(
08382    LBB_ATN
08383          .byte "TN(",TK_ATN      ; ATN(
08384          .byte $00
08385    TAB_ASCB
08386    LBB_BINS
08387          .byte "IN$(",TK_BINS    ; BIN$(
08388    LBB_BITCLR
08389          .byte "ITCLR",TK_BITCLR ; BITCLR
08390    LBB_BITSET
08391          .byte "ITSET",TK_BITSET ; BITSET
08392    LBB_BITTST
08393          .byte "ITTST(",TK_BITTST
08394                                  ; BITTST(
08395          .byte $00
08396    TAB_ASCC
08397    LBB_CALL
08398          .byte "ALL",TK_CALL     ; CALL
08399    LBB_CHRS
08400          .byte "HR$(",TK_CHRS    ; CHR$(
08401    LBB_CLEAR
08402          .byte "LEAR",TK_CLEAR   ; CLEAR
08403    LBB_CONT
08404          .byte "ONT",TK_CONT     ; CONT
08405    LBB_COS
08406          .byte "OS(",TK_COS      ; COS(
08407          .byte $00
08408    TAB_ASCD
08409    LBB_DATA
08410          .byte "ATA",TK_DATA     ; DATA
08411    LBB_DEC
08412          .byte "EC",TK_DEC       ; DEC
08413    LBB_DEEK
08414          .byte "EEK(",TK_DEEK    ; DEEK(
08415    LBB_DEF
08416          .byte "EF",TK_DEF       ; DEF
08417    LBB_DIM
08418          .byte "IM",TK_DIM       ; DIM
08419    LBB_DOKE
08420          .byte "OKE",TK_DOKE     ; DOKE note - "DOKE" must come before "DO"
08421    LBB_DO
08422          .byte "O",TK_DO         ; DO
08423          .byte $00
08424    TAB_ASCE
08425    LBB_ELSE
08426          .byte "LSE",TK_ELSE     ; ELSE
08427    LBB_END
08428          .byte "ND",TK_END       ; END
08429    LBB_EOR
08430          .byte "OR",TK_EOR       ; EOR
08431    LBB_EXP
08432          .byte "XP(",TK_EXP      ; EXP(
08433          .byte $00
08434    TAB_ASCF
08435    LBB_FN
08436          .byte "N",TK_FN         ; FN
08437    LBB_FOR
08438          .byte "OR",TK_FOR       ; FOR
08439    LBB_FRE
08440          .byte "RE(",TK_FRE      ; FRE(
08441          .byte $00
08442    TAB_ASCG
08443    LBB_GET
08444          .byte "ET",TK_GET       ; GET
08445    LBB_GOSUB
08446          .byte "OSUB",TK_GOSUB   ; GOSUB
08447    LBB_GOTO
08448          .byte "OTO",TK_GOTO     ; GOTO
08449          .byte $00
08450    TAB_ASCH
08451    LBB_HEXS
08452          .byte "EX$(",TK_HEXS    ; HEX$(
08453          .byte $00
08454    TAB_ASCI
08455    LBB_IF
08456          .byte "F",TK_IF         ; IF
08457    LBB_INC
08458          .byte "NC",TK_INC       ; INC
08459    LBB_INPUT
08460          .byte "NPUT",TK_INPUT   ; INPUT
08461    LBB_INT
08462          .byte "NT(",TK_INT      ; INT(
08463    LBB_IRQ
08464          .byte "RQ",TK_IRQ       ; IRQ
08465          .byte $00
08466    TAB_ASCL
08467    LBB_LCASES
08468          .byte "CASE$(",TK_LCASES
08469                                  ; LCASE$(
08470    LBB_LEFTS
08471          .byte "EFT$(",TK_LEFTS  ; LEFT$(
08472    LBB_LEN
08473          .byte "EN(",TK_LEN      ; LEN(
08474    LBB_LET
08475          .byte "ET",TK_LET       ; LET
08476    LBB_LIST
08477          .byte "IST",TK_LIST     ; LIST
08478    LBB_LOAD
08479          .byte "OAD",TK_LOAD     ; LOAD
08480    LBB_LOG
08481          .byte "OG(",TK_LOG      ; LOG(
08482    LBB_LOOP
08483          .byte "OOP",TK_LOOP     ; LOOP
08484          .byte $00
08485    TAB_ASCM
08486    LBB_MAX
08487          .byte "AX(",TK_MAX      ; MAX(
08488    LBB_MIDS
08489          .byte "ID$(",TK_MIDS    ; MID$(
08490    LBB_MIN
08491          .byte "IN(",TK_MIN      ; MIN(
08492          .byte $00
08493    TAB_ASCN
08494    LBB_NEW
08495          .byte "EW",TK_NEW       ; NEW
08496    LBB_NEXT
08497          .byte "EXT",TK_NEXT     ; NEXT
08498    LBB_NMI
08499          .byte "MI",TK_NMI       ; NMI
08500    LBB_NOT
08501          .byte "OT",TK_NOT       ; NOT
08502    LBB_NULL
08503          .byte "ULL",TK_NULL     ; NULL
08504          .byte $00
08505    TAB_ASCO
08506    LBB_OFF
08507          .byte "FF",TK_OFF       ; OFF
08508    LBB_ON
08509          .byte "N",TK_ON         ; ON
08510    LBB_OR
08511          .byte "R",TK_OR         ; OR
08512          .byte $00
08513    TAB_ASCP
08514    LBB_PEEK
08515          .byte "EEK(",TK_PEEK    ; PEEK(
08516    LBB_PI
08517          .byte "I",TK_PI         ; PI
08518    LBB_POKE
08519          .byte "OKE",TK_POKE     ; POKE
08520    LBB_POS
08521          .byte "OS(",TK_POS      ; POS(
08522    LBB_PRINT
08523          .byte "RINT",TK_PRINT   ; PRINT
08524          .byte $00
08525    TAB_ASCR
08526    LBB_READ
08527          .byte "EAD",TK_READ     ; READ
08528    LBB_REM
08529          .byte "EM",TK_REM       ; REM
08530    LBB_RESTORE
08531          .byte "ESTORE",TK_RESTORE
08532                                  ; RESTORE
08533    LBB_RETIRQ
08534          .byte "ETIRQ",TK_RETIRQ ; RETIRQ
08535    LBB_RETNMI
08536          .byte "ETNMI",TK_RETNMI ; RETNMI
08537    LBB_RETURN
08538          .byte "ETURN",TK_RETURN ; RETURN
08539    LBB_RIGHTS
08540          .byte "IGHT$(",TK_RIGHTS
08541                                  ; RIGHT$(
08542    LBB_RND
08543          .byte "ND(",TK_RND      ; RND(
08544    LBB_RUN
08545          .byte "UN",TK_RUN       ; RUN
08546          .byte $00
08547    TAB_ASCS
08548    LBB_SADD
08549          .byte "ADD(",TK_SADD    ; SADD(
08550    LBB_SAVE
08551          .byte "AVE",TK_SAVE     ; SAVE
08552    LBB_SGN
08553          .byte "GN(",TK_SGN      ; SGN(
08554    LBB_SIN
08555          .byte "IN(",TK_SIN      ; SIN(
08556    LBB_SPC
08557          .byte "PC(",TK_SPC      ; SPC(
08558    LBB_SQR
08559          .byte "QR(",TK_SQR      ; SQR(
08560    LBB_STEP
08561          .byte "TEP",TK_STEP     ; STEP
08562    LBB_STOP
08563          .byte "TOP",TK_STOP     ; STOP
08564    LBB_STRS
08565          .byte "TR$(",TK_STRS    ; STR$(
08566    LBB_SWAP
08567          .byte "WAP",TK_SWAP     ; SWAP
08568          .byte $00
08569    TAB_ASCT
08570    LBB_TAB
08571          .byte "AB(",TK_TAB      ; TAB(
08572    LBB_TAN
08573          .byte "AN(",TK_TAN      ; TAN(
08574    LBB_THEN
08575          .byte "HEN",TK_THEN     ; THEN
08576    LBB_TO
08577          .byte "O",TK_TO         ; TO
08578    LBB_TWOPI
08579          .byte "WOPI",TK_TWOPI   ; TWOPI
08580          .byte $00
08581    TAB_ASCU
08582    LBB_UCASES
08583          .byte "CASE$(",TK_UCASES
08584                                  ; UCASE$(
08585    LBB_UNTIL
08586          .byte "NTIL",TK_UNTIL   ; UNTIL
08587    LBB_USR
08588          .byte "SR(",TK_USR      ; USR(
08589          .byte $00
08590    TAB_ASCV
08591    LBB_VAL
08592          .BYTE "AL(",TK_VAL      ; VAL(
08593    LBB_VPTR
08594          .byte "ARPTR(",TK_VPTR  ; VARPTR(
08595    LBB_VERIFY
08596          .BYTE "ERIFY",TK_VERIFY ; VERIFY
08597          .byte $00
08598    TAB_ASCW
08599    LBB_WAIT
08600          .byte "AIT",TK_WAIT     ; WAIT
08601    LBB_WHILE
08602          .byte "HILE",TK_WHILE   ; WHILE
08603    LBB_WIDTH
08604          .byte "IDTH",TK_WIDTH   ; WIDTH
08605          .byte $00
08606    TAB_POWR
08607          .byte TK_POWER,$00      ; ^
08608    
08609    ; new decode table for LIST
08610    ; Table is ..
08611    ; byte - keyword length, keyword first character
08612    ; word - pointer to rest of keyword from dictionary
08613    
08614    ; note if length is 1 then the pointer is ignored
08615    
08616    LAB_KEYT
08617          .byte 3,'E'
08618          .word LBB_END           ; END
08619          .byte 3,'F'
08620          .word LBB_FOR           ; FOR
08621          .byte 4,'N'
08622          .word LBB_NEXT          ; NEXT
08623          .byte 4,'D'
08624          .word LBB_DATA          ; DATA
08625          .byte 5,'I'
08626          .word LBB_INPUT         ; INPUT
08627          .byte 3,'D'
08628          .word LBB_DIM           ; DIM
08629          .byte 4,'R'
08630          .word LBB_READ          ; READ
08631          .byte 3,'L'
08632          .word LBB_LET           ; LET
08633          .byte 3,'D'
08634          .word LBB_DEC           ; DEC
08635          .byte 4,'G'
08636          .word LBB_GOTO          ; GOTO
08637          .byte 3,'R'
08638          .word LBB_RUN           ; RUN
08639          .byte 2,'I'
08640          .word LBB_IF            ; IF
08641          .byte 7,'R'
08642          .word LBB_RESTORE       ; RESTORE
08643          .byte 5,'G'
08644          .word LBB_GOSUB         ; GOSUB
08645          .byte 6,'R'
08646          .word LBB_RETIRQ        ; RETIRQ
08647          .byte 6,'R'
08648          .word LBB_RETNMI        ; RETNMI
08649          .byte 6,'R'
08650          .word LBB_RETURN        ; RETURN
08651          .byte 3,'R'
08652          .word LBB_REM           ; REM
08653          .byte 4,'S'
08654          .word LBB_STOP          ; STOP
08655          .byte 2,'O'
08656          .word LBB_ON            ; ON
08657          .byte 4,'N'
08658          .word LBB_NULL          ; NULL
08659          .byte 3,'I'
08660          .word LBB_INC           ; INC
08661          .byte 4,'W'
08662          .word LBB_WAIT          ; WAIT
08663          .byte 4,'L'
08664          .word LBB_LOAD          ; LOAD
08665          .byte 4,'S'
08666          .word LBB_SAVE          ; SAVE
08667          .byte 3,'D'
08668          .word LBB_DEF           ; DEF
08669          .byte 4,'P'
08670          .word LBB_POKE          ; POKE
08671          .byte 4,'D'
08672          .word LBB_DOKE          ; DOKE
08673          .byte 4,'C'
08674          .word LBB_CALL          ; CALL
08675          .byte 2,'D'
08676          .word LBB_DO            ; DO
08677          .byte 4,'L'
08678          .word LBB_LOOP          ; LOOP
08679          .byte 5,'P'
08680          .word LBB_PRINT         ; PRINT
08681          .byte 4,'C'
08682          .word LBB_CONT          ; CONT
08683          .byte 4,'L'
08684          .word LBB_LIST          ; LIST
08685          .byte 5,'C'
08686          .word LBB_CLEAR         ; CLEAR
08687          .byte 3,'N'
08688          .word LBB_NEW           ; NEW
08689          .byte 5,'W'
08690          .word LBB_WIDTH         ; WIDTH
08691          .byte 3,'G'
08692          .word LBB_GET           ; GET
08693          .byte 4,'S'
08694          .word LBB_SWAP          ; SWAP
08695          .byte 6,'B'
08696          .word LBB_BITSET        ; BITSET
08697          .byte 6,'B'
08698          .word LBB_BITCLR        ; BITCLR
08699          .byte 3,'I'
08700          .word LBB_IRQ           ; IRQ
08701          .byte 3,'N'
08702          .word LBB_NMI           ; NMI
08703          .byte 7,'V'
08704          .word LBB_VERIFY        ; VERIFY
08705    
08706    
08707    ; secondary commands (can't start a statement)
08708    
08709          .byte 4,'T'
08710          .word LBB_TAB           ; TAB
08711          .byte 4,'E'
08712          .word LBB_ELSE          ; ELSE
08713          .byte 2,'T'
08714          .word LBB_TO            ; TO
08715          .byte 2,'F'
08716          .word LBB_FN            ; FN
08717          .byte 4,'S'
08718          .word LBB_SPC           ; SPC
08719          .byte 4,'T'
08720          .word LBB_THEN          ; THEN
08721          .byte 3,'N'
08722          .word LBB_NOT           ; NOT
08723          .byte 4,'S'
08724          .word LBB_STEP          ; STEP
08725          .byte 5,'U'
08726          .word LBB_UNTIL         ; UNTIL
08727          .byte 5,'W'
08728          .word LBB_WHILE         ; WHILE
08729          .byte 3,'O'
08730          .word LBB_OFF           ; OFF
08731    
08732    ; opperators
08733    
08734          .byte 1,'+'
08735          .word $0000             ; +
08736          .byte 1,'-'
08737          .word $0000             ; -
08738          .byte 1,'*'
08739          .word $0000             ; *
08740          .byte 1,'/'
08741          .word $0000             ; /
08742          .byte 1,'^'
08743          .word $0000             ; ^
08744          .byte 3,'A'
08745          .word LBB_AND           ; AND
08746          .byte 3,'E'
08747          .word LBB_EOR           ; EOR
08748          .byte 2,'O'
08749          .word LBB_OR            ; OR
08750          .byte 2,'>'
08751          .word LBB_RSHIFT        ; >>
08752          .byte 2,'<'
08753          .word LBB_LSHIFT        ; <<
08754          .byte 1,'>'
08755          .word $0000             ; >
08756          .byte 1,'='
08757          .word $0000             ; =
08758          .byte 1,'<'
08759          .word $0000             ; <
08760    
08761    ; functions
08762    
08763          .byte 4,'S'             ;
08764          .word LBB_SGN           ; SGN
08765          .byte 4,'I'             ;
08766          .word LBB_INT           ; INT
08767          .byte 4,'A'             ;
08768          .word LBB_ABS           ; ABS
08769          .byte 4,'U'             ;
08770          .word LBB_USR           ; USR
08771          .byte 4,'F'             ;
08772          .word LBB_FRE           ; FRE
08773          .byte 4,'P'             ;
08774          .word LBB_POS           ; POS
08775          .byte 4,'S'             ;
08776          .word LBB_SQR           ; SQR
08777          .byte 4,'R'             ;
08778          .word LBB_RND           ; RND
08779          .byte 4,'L'             ;
08780          .word LBB_LOG           ; LOG
08781          .byte 4,'E'             ;
08782          .word LBB_EXP           ; EXP
08783          .byte 4,'C'             ;
08784          .word LBB_COS           ; COS
08785          .byte 4,'S'             ;
08786          .word LBB_SIN           ; SIN
08787          .byte 4,'T'             ;
08788          .word LBB_TAN           ; TAN
08789          .byte 4,'A'             ;
08790          .word LBB_ATN           ; ATN
08791          .byte 5,'P'             ;
08792          .word LBB_PEEK          ; PEEK
08793          .byte 5,'D'             ;
08794          .word LBB_DEEK          ; DEEK
08795          .byte 5,'S'             ;
08796          .word LBB_SADD          ; SADD
08797          .byte 4,'L'             ;
08798          .word LBB_LEN           ; LEN
08799          .byte 5,'S'             ;
08800          .word LBB_STRS          ; STR$
08801          .byte 4,'V'             ;
08802          .word LBB_VAL           ; VAL
08803          .byte 4,'A'             ;
08804          .word LBB_ASC           ; ASC
08805          .byte 7,'U'             ;
08806          .word LBB_UCASES        ; UCASE$
08807          .byte 7,'L'             ;
08808          .word LBB_LCASES        ; LCASE$
08809          .byte 5,'C'             ;
08810          .word LBB_CHRS          ; CHR$
08811          .byte 5,'H'             ;
08812          .word LBB_HEXS          ; HEX$
08813          .byte 5,'B'             ;
08814          .word LBB_BINS          ; BIN$
08815          .byte 7,'B'             ;
08816          .word LBB_BITTST        ; BITTST
08817          .byte 4,'M'             ;
08818          .word LBB_MAX           ; MAX
08819          .byte 4,'M'             ;
08820          .word LBB_MIN           ; MIN
08821          .byte 2,'P'             ;
08822          .word LBB_PI            ; PI
08823          .byte 5,'T'             ;
08824          .word LBB_TWOPI         ; TWOPI
08825          .byte 7,'V'             ;
08826          .word LBB_VPTR          ; VARPTR
08827          .byte 6,'L'             ;
08828          .word LBB_LEFTS         ; LEFT$
08829          .byte 7,'R'             ;
08830          .word LBB_RIGHTS        ; RIGHT$
08831          .byte 5,'M'             ;
08832          .word LBB_MIDS          ; MID$
08833    
08834    ; BASIC messages, mostly error messages
08835    
08836    LAB_BAER
08837          .word ERR_NF            ;$00 NEXT without FOR
08838          .word ERR_SN            ;$02 syntax
08839          .word ERR_RG            ;$04 RETURN without GOSUB
08840          .word ERR_OD            ;$06 out of data
08841          .word ERR_FC            ;$08 function call
08842          .word ERR_OV            ;$0A overflow
08843          .word ERR_OM            ;$0C out of memory
08844          .word ERR_US            ;$0E undefined statement
08845          .word ERR_BS            ;$10 array bounds
08846          .word ERR_DD            ;$12 double dimension array
08847          .word ERR_D0            ;$14 divide by 0
08848          .word ERR_ID            ;$16 illegal direct
08849          .word ERR_TM            ;$18 type mismatch
08850          .word ERR_LS            ;$1A long string
08851          .word ERR_ST            ;$1C string too complex
08852          .word ERR_CN            ;$1E continue error
08853          .word ERR_UF            ;$20 undefined function
08854          .word ERR_LD            ;$22 LOOP without DO
08855          .word ERR_BF            ;$24 Filename too long
08856    
08857    ; I may implement these two errors to force definition of variables and
08858    ; dimensioning of arrays before use.
08859    
08860    ;     .word ERR_UV            ;$24 undefined variable
08861    
08862    ; the above error has been tested and works (see code and comments below LAB_1D8B)
08863    
08864    ;     .word ERR_UA            ;$26 undimensioned array
08865    
08866    ERR_NF      .byte "NEXT without FOR",$00
08867    ERR_SN      .byte "Syntax",$00
08868    ERR_RG      .byte "RETURN without GOSUB",$00
08869    ERR_OD      .byte "Out of DATA",$00
08870    ERR_FC      .byte "Function call",$00
08871    ERR_OV      .byte "Overflow",$00
08872    ERR_OM      .byte "Out of memory",$00
08873    ERR_US      .byte "Undefined statement",$00
08874    ERR_BS      .byte "Array bounds",$00
08875    ERR_DD      .byte "Double dimension",$00
08876    ERR_D0      .byte "Divide by zero",$00
08877    ERR_ID      .byte "Illegal direct",$00
08878    ERR_TM      .byte "Type mismatch",$00
08879    ERR_LS      .byte "String too long",$00
08880    ERR_ST      .byte "String too complex",$00
08881    ERR_CN      .byte "Can't continue",$00
08882    ERR_UF      .byte "Undefined function",$00
08883    ERR_LD      .byte "LOOP without DO",$00
08884    ERR_BF      .byte "Filename too long",$00
08885    
08886    ;ERR_UV     .byte "Undefined variable",$00
08887    
08888    ; the above error has been tested and works (see code and comments below LAB_1D8B)
08889    
08890    ;ERR_UA     .byte "Undimensioned array",$00
08891    
08892    LAB_BMSG    .byte $0D,$0A,"Break",$00
08893    LAB_EMSG    .byte " Error",$00
08894    LAB_LMSG    .byte " in line ",$00
08895    LAB_RMSG    .byte $0D,$0A,"Ready",$0D,$0A,$00
08896    
08897    LAB_IMSG    .byte " Extra ignored",$0D,$0A,$00
08898    LAB_REDO    .byte " Redo from start",$0D,$0A,$00
08899    
08900    AA_end_basic
08901    AA_end_basic
08902    ; put the IRQ and MNI code in RAM so that it can be changed
08903    
08904    ; IRQ_vec	= VEC_SV+2              ; Previous IRQ code vector
08905      FB6B             IRQ_vec		= IRQH_ProcessIRQs	; IRQ code vector
08906      FB75             NMI_vec		= IRQ_vec+$0A           ; NMI code vector
08907    
08908    
08909    ; OS System variables live here
08910    
08911      05E0             MON_sysvars   = $5E0			; base address of the 16 bytes of memory reserved
08912      05E0             os_outsel     = MON_sysvars		; output selection variable
08913      05E1             os_infilt     = os_outsel+1		; Filter switches for character input filtering.
08914    
08915      00E7             TOE_MemptrLo  = $E7			; General purpose memory pointer low byte
08916      00E8             TOE_MemptrHi  = $E8			; General purpose memory pointer high byte
08917    
08918    
08919    ; OS Bit Definitions
08920    
08921      0001             ACIA1_out_sw	= @00000001
08922      0002             ANSI_out_sw	= @00000010
08923      0004             TPB_out_sw	= @00000100
08924      0008             ACIA2_out_sw	= @00001000
08925      0010             TAPE_out_sw	= @00010000
08926    
08927    
08928    ; now the code. This sets up the vectors, interrupt code,
08929    ; and waits for the user to select [C]old or [W]arm start.
08930    ;
08931    ; Also, during the running phase, the extra OS features are hosted here.
08932    
08933      .ROM_AREA $C100,$FFFF
08934      
08935    F000                 *= $F000                            ; Give ourselves room for the OS.
08936      .INCLUDE "ACIA.asm"
08937    ; Duncan's 6551 ACIA Library
08938    ;
08939    
08940    ; This is the configuration section for the ACIA.
08941    ;
08942    ; Make changes to setup here.
08943    ;
08944      001E             ACIA_CTRL_IDLE = ACIA_WL8 | ACIA_RCS_BRG | ACIA_9600 | ACIA_TIC_10
08945      001E             ACIA_CTRL_LISTEN = ACIA_WL8 | ACIA_RCS_BRG | ACIA_9600 | ACIA_TIC_00
08946      008B             ACIA_CMD_SETUP  = ACIA_PMC_DIS | ACIA_PME_DIS | ACIA_REM_OFF | ACIA_TIC_10 | ACIA_INT_DIS | ACIA_DTR_RDY
08947    
08948    
08949    ; ACIA1 Registers
08950    
08951      C010             ACIA1_base     = $C010                 ; Change as needed later.
08952      C010             ACIA1_tx       = ACIA1_base
08953      C010             ACIA1_rx       = ACIA1_base
08954      C011             ACIA1_sts      = ACIA1_base + 1
08955      C012             ACIA1_cmd      = ACIA1_base + 2
08956      C013             ACIA1_ctrl     = ACIA1_base + 3
08957    
08958    
08959    ; ACIA2 Registers
08960    
08961      C014             ACIA2_base     = $C014                 ; Change as needed later.
08962      C014             ACIA2_tx       = ACIA2_base
08963      C014             ACIA2_rx       = ACIA2_base
08964      C015             ACIA2_sts      = ACIA2_base + 1
08965      C016             ACIA2_cmd      = ACIA2_base + 2
08966      C017             ACIA2_ctrl     = ACIA2_base + 3
08967    
08968    
08969    
08970    ; ACIA Speeds
08971    
08972      0000             ACIA_16x      = 0
08973      0001             ACIA_50       = @0001
08974      0002             ACIA_75       = @0010
08975      0003             ACIA_109p92   = @0011
08976      0004             ACIA_134p51   = @0100
08977      0005             ACIA_150      = @0101
08978      0006             ACIA_300      = @0110
08979      0007             ACIA_600      = @0111
08980      0008             ACIA_1200     = @1000
08981      0009             ACIA_1800     = @1001
08982      000A             ACIA_2400     = @1010
08983      000B             ACIA_3600     = @1011
08984      000C             ACIA_4800     = @1100
08985      000D             ACIA_7200     = @1101
08986      000E             ACIA_9600     = @1110
08987      000F             ACIA_19200    = @1111
08988    
08989    
08990    ; ACIA Word lengths
08991    
08992      0000             ACIA_WL8            = @00000000
08993      0020             ACIA_WL7            = @00100000
08994      0040             ACIA_WL6            = @01000000
08995      0060             ACIA_WL5            = @01100000
08996    
08997    
08998    ; ACIA Command bits
08999    
09000      0000             ACIA_PMC_ODD        = @00000000        ; Parity Mode Control bits
09001      0040             ACIA_PMC_EVN        = @01000000
09002      0080             ACIA_PMC_DIS        = @10000000
09003    
09004      0000             ACIA_PME_DIS        = @00000000        ; Parity Mode Enable bit
09005      0020             ACIA_PME_ENA        = @00100000
09006    
09007      0000             ACIA_REM_OFF        = @00000000        ; Receiver Echo Mode bit
09008      0010             ACIA_REM_ON         = @00010000
09009    
09010      0000             ACIA_TIC_00         = @00000000        ; RTSB High, Transmit Int disabled
09011      0004             ACIA_TIC_01         = @00000100        ; RTSB Low, Transmit Int enabled
09012      0008             ACIA_TIC_10         = @00001000        ; RTSB Low, Transmit Int disabled
09013      000C             ACIA_TIC_11         = @00001100        ; RTSB Low, Transmit Int disabled & Transmit break on TxD
09014      0002             ACIA_INT_DIS        = @00000010
09015      0000             ACIA_INT_ENA        = @00000000
09016      0000             ACIA_DTR_NRDY       = @00000000
09017      0001             ACIA_DTR_RDY        = @00000001
09018    
09019    
09020    ; ACIA Clock Source
09021    
09022      0000             ACIA_RCS_EXT	= @00000000
09023      0010             ACIA_RCS_BRG	= @00010000
09024    
09025    
09026    ; Status Flags
09027    
09028      0001             ACIA_PER	= @00000001
09029      0002             ACIA_FER	= @00000010
09030      0004             ACIA_OVR	= @00000100
09031      0008             ACIA_RBF	= @00001000
09032      0010             ACIA_TXE	= @00010000
09033      0020             ACIA_DCD	= @00100000
09034      0040             ACIA_DSR	= @01000000
09035      0080             ACIA_INT	= @10000000
09036    
09037    
09038    ; Filter Switch
09039    
09040      0001             LF_filt_sw1	= @00000001
09041      0002             LF_filt_sw2	= @00000010
09042    
09043    
09044    
09045    ; Tower of Eightness Specific serial routines.
09046    	
09047    INI_ACIA1                         ; As required for a 6551 ACIA
09048    F000  A9 8B          LDA #ACIA_CMD_SETUP
09049    F002  8D 12 C0       STA ACIA1_cmd                    ; Set the command reg for specified baud rate
09050    F005  A9 1E          LDA #ACIA_CTRL_LISTEN
09051    F007  8D 13 C0       STA ACIA1_ctrl                   ; Set the control reg for correct operation
09052    F00A  20 3A F0       JSR ACIA1in                      ; Swallow the first byte (experimental fix)
09053    F00D  60             RTS
09054      
09055      
09056    INI_ACIA2                         ; As required for a 6551 ACIA
09057    F00E  A9 8B          LDA #ACIA_CMD_SETUP
09058    F010  8D 16 C0       STA ACIA2_cmd                    ; Set the command reg for specified baud rate
09059    F013  A9 1E          LDA #ACIA_CTRL_LISTEN
09060    F015  8D 17 C0       STA ACIA2_ctrl                   ; Set the control reg for correct operation
09061    F018  20 4F F0       JSR ACIA2in                      ; Swallow the first byte (experimental fix)
09062    F01B  60             RTS
09063    
09064    
09065    ; byte out to 6551 ACIA1
09066    
09067    ACIA1out
09068    F01C  08             PHP                             ; Save registers as we aren't allowed to change them
09069    F01D  48             PHA
09070    	
09071    F01E  8D 10 C0       STA ACIA1_tx                     ; write to ACIA TX buffer
09072    F021  A9 10          LDA #ACIA_TXE
09073    
09074    ACIA1_wr_wait
09075    F023  2C 11 C0       BIT ACIA1_sts
09076    F026  F0 FB          BEQ ACIA1_wr_wait                ; Wait until written.
09077    	
09078    F028  68             PLA                             ; Restore registers. We're all good.
09079    F029  28             PLP
09080    	
09081    F02A  60             RTS                             ; Done... Hopefully.
09082      
09083      
09084      
09085    ; byte out to 6551 ACIA2
09086    
09087    ACIA2out
09088    F02B  08             PHP                             ; Save registers as we aren't allowed to change them
09089    F02C  48             PHA
09090    	
09091    F02D  8D 14 C0       STA ACIA2_tx                     ; write to ACIA TX buffer
09092    F030  A9 10          LDA #ACIA_TXE
09093    
09094    ACIA2_wr_wait
09095    F032  2C 15 C0       BIT ACIA2_sts
09096    F035  F0 FB          BEQ ACIA2_wr_wait                ; Wait until written.
09097    	
09098    F037  68             PLA                             ; Restore registers. We're all good.
09099    F038  28             PLP
09100    	
09101    F039  60             RTS                             ; Done... Hopefully.
09102    
09103    
09104    ; byte in from 6551 ACIA 1
09105    
09106    ACIA1in
09107    F03A  A9 08          LDA #ACIA_RBF
09108    F03C  2C 11 C0       BIT ACIA1_sts				; do we have a byte?
09109    F03F  F0 2A          BEQ LAB_nobyw				; branch if no byte waiting
09110    
09111    F041  AD 10 C0       LDA ACIA1_rx				; Get byte sent.
09112    F044  38             SEC					; flag byte received
09113      
09114    F045  48             PHA
09115    F046  A9 01          LDA #LF_filt_sw1
09116    F048  2C E1 05       BIT os_infilt
09117    F04B  F0 17          BEQ filter_inp
09118    F04D  68             PLA
09119    F04E  60             RTS
09120    
09121    
09122    ; byte in from 6551 ACIA 2
09123      
09124    ACIA2in
09125    F04F  A9 08          LDA #ACIA_RBF
09126    F051  2C 15 C0       BIT ACIA2_sts				; do we have a byte?
09127    F054  F0 15          BEQ LAB_nobyw				; branch if no byte waiting
09128    
09129    F056  AD 14 C0       LDA ACIA2_rx				; Get byte sent.
09130    F059  38             SEC					; flag byte received
09131      
09132    F05A  48             PHA
09133    F05B  A9 02          LDA #LF_filt_sw2
09134    F05D  2C E1 05       BIT os_infilt
09135    F060  F0 02          BEQ filter_inp
09136    F062  68             PLA
09137    F063  60             RTS
09138    
09139    ; Byte filter feature.  Applicable to both ACIAs.
09140    
09141    
09142    filter_inp  
09143    F064  68             PLA
09144    F065  C9 0A          CMP #$A
09145    F067  F0 02          BEQ LAB_nobyw
09146    F069  38             SEC
09147    F06A  60             RTS
09148      
09149    LAB_nobyw
09150    F06B  A9 00          LDA #0
09151    F06D  18             CLC
09152    F06E  60             RTS                             ; flag no byte received
09153      RTS                             ; flag no byte received
09154      .INCLUDE "ANSICARD.asm"
09155    ; Duncan's ANSI Video card library
09156    ;
09157    ; This card is based on a 6522 VIA chip.
09158    
09159    
09160    ; Register addresses
09161    
09162      C000             ANSI_base	= $C000
09163      C000             ANSI_reg_b	= ANSI_base
09164      C001             ANSI_reg_a	= ANSI_base+1
09165      C002             ANSI_ddr_b	= ANSI_base+2
09166      C003             ANSI_ddr_a	= ANSI_base+3
09167    
09168    ; Control Bits
09169    
09170      0040             ANSI_AVAIL	= @01000000
09171      0080             ANSI_ACK	= @10000000
09172    
09173    
09174    ; Memory allocations
09175    
09176      05F0             ANSI_area	= $5F0
09177      05F0             ANSI_LastACK	= ANSI_area
09178      05F1             ANSI_LastAVL	= ANSI_area+1
09179    
09180    
09181    ; Initialisation Routine
09182    
09183    ANSI_INIT
09184    F06F  A9 0C          LDA #12
09185    F071  8D 00 C0       STA ANSI_reg_b
09186    F074  A9 40          LDA #ANSI_AVAIL
09187    F076  8D 03 C0       STA ANSI_ddr_a
09188    F079  A9 FF          LDA #$FF
09189    F07B  8D 02 C0       STA ANSI_ddr_b
09190    F07E  AD 01 C0       LDA ANSI_reg_a
09191    F081  25 80          AND ANSI_ACK
09192    F083  8D F0 05       STA ANSI_LastACK
09193    F086  0A             ASL
09194    F087  8D F1 05       STA ANSI_LastAVL
09195    F08A  0D F0 05       ORA ANSI_LastACK
09196    F08D  8D 01 C0       STA ANSI_reg_a
09197    F090  60             RTS
09198      
09199    
09200    ; ANSI Write.
09201    ; *================================*
09202    ; *                                *
09203    ; *  ENTRY: A=char                 *
09204    ; *  EXIT: As found                *
09205    ; *                                *
09206    ; **********************************
09207    
09208    ANSI_write
09209    
09210    F091  08             PHP			; Save Register States
09211    F092  48             PHA
09212      
09213    F093  20 A7 F0       JSR ANSI_wait		; Wait until AVAIL and ACK agree
09214      
09215    F096  8D 00 C0       STA ANSI_reg_b	; Write the char to output
09216    F099  AD F1 05       LDA ANSI_LastAVL	; Flip and re-write avail bit to tell
09217    F09C  49 40          EOR #ANSI_AVAIL	; the ANSI processor of new data
09218    F09E  8D 01 C0       STA ANSI_reg_a
09219    F0A1  8D F1 05       STA ANSI_LastAVL
09220      
09221    F0A4  68             PLA
09222    F0A5  28             PLP
09223    F0A6  60             RTS
09224      
09225    ANSI_wait
09226    F0A7  48             PHA
09227      
09228    ANSI_w_loop
09229    F0A8  AD 01 C0       LDA ANSI_reg_a	; Check ACK against AVAIL
09230    F0AB  29 80          AND #ANSI_ACK
09231    F0AD  4A             LSR
09232    F0AE  CD F1 05       CMP ANSI_LastAVL
09233    F0B1  D0 F5          BNE ANSI_w_loop	; Until they match
09234      
09235    F0B3  68             PLA
09236    F0B4  60             RTS
09237      .INCLUDE "TPBCARD.asm"
09238    ; Duncan's TPB Card driver
09239    ;
09240    ; This card is based on a 6522 VIA chip.
09241    
09242    
09243    ; Register addresses
09244    
09245      C020             TPB_base        = $C020
09246      C020             TPB_reg_b       = TPB_base
09247      C021             TPB_reg_a       = TPB_base+1
09248      C022             TPB_ddr_b       = TPB_base+2
09249      C023             TPB_ddr_a       = TPB_base+3
09250      C02C             TPB_pcr         = TPB_base+$C
09251      C02D             TPB_ifr         = TPB_base+$D
09252    
09253    
09254    ; LPT Control Bits
09255    
09256      0002             TPB_LPT_stb_b   = @00000010
09257      0001             TPB_LPT_ack_b   = @00000001
09258      0002             TPB_ACK_CA1_b   = @00000010
09259      0001             TPB_CA1_pe_b    = @00000001
09260    
09261    
09262    ; TPB Bus Control Bits
09263    
09264      0010             TPB_BUS_clkout  = @00010000       ; Clock line output (Port B, out)
09265      0040             TPB_BUS_clkin   = @01000000       ; Clock line readback (Port B, in)
09266      0020             TPB_BUS_datout  = @00100000       ; Data line output (Port B, out)
09267      0080             TPB_BUS_datin   = @10000000       ; Data line readback (Port B, in)
09268      0008             TPB_BUS_select  = @00001000       ; TPB bus select (Port B, out) signals bus selection.
09269      0004             TPB_BUS_atnin   = @00000100       ; ATN signal readback (Port B, in) indicates a peripheral needs attention or select signal
09270      0001             TPB_BUS_atnout  = @00000001       ; ATN signal output.  When used, tells a device that the data is a select signal.
09271    
09272    
09273    ; TPB Configuration parameters
09274    
09275      00FF             TPB_BUS_lim_c   = 255             ; Number of samples before giving up on device
09276      000F             TPB_BUS_dev_max = 15              ; Highest device address permitted, host being 0.
09277    
09278    ; *****************************************************************************
09279    ; *                           TABLE 1: BLOCK TYPES                            *
09280    ; *                           --------------------                            *
09281    ; * 1.  Command Block (Always the same size 4 bytes at current).              *
09282    ; * 2.  Response Block (Same size as the command block).                      *
09283    ; * 3.  Data Block.  Upto 65535 bytes. It is not reccomended to go that big,  *
09284    ; *     you would touch registers that way!                                   *
09285    ; * 4.  Broadcast Block (4 bytes long).                                       *
09286    ; *                                                                           *
09287    ; *****************************************************************************
09288    
09289      0001             TPB_BLK_cmd        = 1
09290      0002             TPB_BLK_rsp        = 2
09291      0003             TPB_BLK_dat        = 3
09292      0004             TPB_BLK_brd        = 4
09293    
09294    
09295    ; *****************************************************************************
09296    ; *                                                                           *
09297    ; *                          TABLE 2: DEVICE TYPES                            *
09298    ; *                          ---------------------                            *
09299    ; * 1.  DEVType_BlkStorage.  Block storage device.                            *
09300    ; * 2.  DEVType_IOStream.    Input/Output Stream device.                      *
09301    ; * 15. DEVType_User.        User defined device.  Must use own code.         *
09302    ; *                                                                           *
09303    ; *                                                                           *
09304    ; *                                                                           *
09305    ; *                                                                           *
09306    ; *****************************************************************************
09307    
09308      0001             DEVType_blkstorage = 1
09309      0002             DEVType_IOstream   = 2
09310      000F             DEVType_User       = 15
09311    
09312    
09313    ; Memory allocations
09314    
09315      05F2             TPB_worksp         = $5F2                 ; Start of TPB card memory allocation
09316      05F2             TPB_curr_dev       = TPB_worksp           ; Currently selected TPB devce ID
09317      05F3             TPB_dev_type       = TPB_worksp+1         ; Device class of selected device
09318      05F4             TPB_last_rd        = TPB_worksp+2         ; last byte read from TPB device
09319      05F5             TPB_BUS_status     = TPB_worksp+3         ; Status word from TPB engine (subject to change)
09320      05F6             TPB_BUS_tries      = TPB_worksp+4         ; Bus device counter.  This ensures fewer hangs.
09321      05F7             TPB_BUS_lim        = TPB_worksp+5         ; Bus countdown timer limit. (Reload value).
09322      05F8             TPB_BUS_blk_lenlo  = TPB_worksp+6         ; Length of block in or out
09323      05F9             TPB_BUS_blk_lenhi  = TPB_worksp+7         ; Length of block in or out
09324      05F8             TPB_BUS_blk_len    = TPB_BUS_blk_lenlo    ; Convenience pointer to TPB_BUS_blk_lenlo
09325      05FA             TPB_BUS_blk_stlo   = TPB_worksp+8         ; Start address low byte of block
09326      05FB             TPB_BUS_blk_sthi   = TPB_worksp+9         ; Start address high byte of block
09327      05FA             TPB_BUS_blk_st     = TPB_BUS_blk_stlo     ; Convenience pointer to TPB_BUS_BLK_stlo
09328      05FC             TPB_BUS_blk_type   = TPB_worksp+$A        ; Type of block transfer. See table 1
09329      00E2             TPB_Temp1          = $E2                  ; Temporary memory location 1
09330      00E3             TPB_Temp2          = $E3                  ; Temporary memory location 2
09331      00E4             TPB_Temp3          = $E4                  ; Temporary memory location 3
09332    
09333    ; 3 spaces remain between the system variables and the buffer block.
09334    ; This means we end up with $5FD to $5FF unused.
09335    
09336    ; Last TPB workspace allocation @ $5FC before buffers.
09337    
09338    
09339    ; TPB Command Codes
09340    
09341      0000             PRESENCE           = 0                  ; Check for device presence by ID   <DONE>
09342      0001             ATN_CHK            = 1                  ; Check if device is asserting ATN   <DONE>
09343      0002             REQ_DEV_TYPE       = 2                  ; Request device type-code.
09344      0003             CTRL_BLK_WR        = 3                  ; Write to control block
09345      0004             CTRL_BLK_RD        = 4                  ; Read from control block
09346      0005             BUFF_BLK_WR        = 5                  ; Write to device buffer
09347      0006             BUFF_BLK_RD        = 6                  ; Read from device buffer
09348      0007             BUFF_PROCESS       = 7                  ; Process buffer contents
09349      0008             STREAM_OUT         = 8                  ; Stream out (each char requires an ACK or NACK after)
09350      0009             STREAM_IN          = 9                  ; Stream in (for each char in, you must send an ACK or NACK)
09351    
09352    
09353    ; ACK and NACK codes
09354    
09355      00F1             TPB_ACK            = $F1                ; Acknowledge code (Continuance signal)
09356      00F5             TPB_NACK           = $F5                ; Not Acknoledge code. (Terminator)
09357    
09358    
09359      0600             TPB_BUS_RAMBASE    = $600
09360      0600             TPB_Dev_table      = TPB_BUS_RAMBASE                     ; Start of the TPB bus device table.
09361      0610             TPB_BUS_IO_buff    = TPB_Dev_table + TPB_BUS_dev_max + 1 ; Page of buffer for TPB transfers
09362      0700             TPB_BUFFER         = $700                                ; Block transfers go here. Max 1 page.
09363    
09364    
09365    ; Control Block Structure and Location.
09366    
09367      0610             TPB_ctrl_blk       = TPB_BUS_IO_buff
09368      0610             DEV_ID             = TPB_ctrl_blk
09369      0611             DEV_BLK_TYPE       = TPB_ctrl_blk + 1
09370      0612             DEV_CMD_RSP        = TPB_ctrl_blk + 2
09371      0613             CHECKSUM           = TPB_ctrl_blk + 3
09372    
09373    ; Initialisation Routine
09374    
09375      0002             TPB_PbInitial   = TPB_LPT_stb_b
09376      003B             TPB_PbOutputs   = TPB_LPT_stb_b | TPB_BUS_clkout | TPB_BUS_datout | TPB_BUS_atnout | TPB_BUS_select
09377    
09378    
09379    TPB_INIT
09380    ;  This first part initialises the on-card 6522 VIA pins for both features.
09381    
09382    F0B5  A9 00          LDA #0                          ; Set our registers to defaults
09383    F0B7  8D 21 C0       STA TPB_reg_a
09384    F0BA  A9 02          LDA #TPB_PbInitial
09385    F0BC  8D 20 C0       STA TPB_reg_b
09386      
09387    F0BF  A9 FF          LDA #$FF
09388    F0C1  8D 23 C0       STA TPB_ddr_a                   ; Setup port a as outputs to our LPT
09389    F0C4  A9 3B          LDA #TPB_PbOutputs
09390    F0C6  8D 22 C0       STA TPB_ddr_b                   ; Setup port B for both LPT and TPB initial state.
09391    F0C9  A9 01          LDA #TPB_CA1_pe_b               ; Configure for positive edge interrupt trigger.
09392    F0CB  8D 2C C0       STA TPB_pcr                     ; on CA1
09393      
09394      ;  This second part initialises the Tower Peripheral Bus engine.
09395      
09396    F0CE  A9 00          LDA #0
09397    F0D0  8D F5 05       STA TPB_BUS_status              ; Set the bus to listening.
09398    
09399    F0D3  A9 FF          LDA #TPB_BUS_lim_c
09400    F0D5  8D F7 05       STA TPB_BUS_lim                 ; Set the bus response tries limit (variable for latency)
09401    F0D8  60             RTS
09402    
09403    
09404    ; TPB Write to remote device control block
09405    ; *******************************************************
09406    ; *                                                     *
09407    ; *  ENTRY:                                             *
09408    ; *  EXIT:                                              *
09409    ; *         Affects, A,X,Y,P.                           *
09410    ; *         C = 0: Fail                                 *
09411    ; *         C = 1: Success.                             *
09412    ; *                                                     *
09413    ; *******************************************************
09414    
09415    TPB_Ctrl_Blk_Wr
09416    F0D9  AD F2 05       LDA TPB_curr_dev                ; Setup Command Block
09417    F0DC  8D 10 06       STA DEV_ID
09418    F0DF  A9 01          LDA #TPB_BLK_cmd
09419    F0E1  8D 11 06       STA DEV_BLK_TYPE
09420    F0E4  A9 03          LDA #CTRL_BLK_WR
09421    F0E6  8D 12 06       STA DEV_CMD_RSP
09422    F0E9  20 2F F2       JSR TPB_calc_ctrl_csum
09423    
09424    F0EC  20 9E F1       JSR TPB_Tx_CMD                  ; Issue write to remote control block command.
09425        
09426    F0EF  20 B6 F1       JSR TPB_WaitATN                 ; Wait for Attention signal
09427    F0F2  90 19          BCC CBW_Fail                    ; If no device then quit with carry clear.
09428      
09429    F0F4  A9 00          LDA #<TPB_BUFFER                ; Setup for device control block transmit.
09430    F0F6  8D FA 05       STA TPB_BUS_blk_stlo
09431    F0F9  A9 07          LDA #>TPB_BUFFER
09432    F0FB  8D FB 05       STA TPB_BUS_blk_sthi
09433    F0FE  A9 10          LDA #16                         ; Control blocks are 16 bytes in length
09434    F100  8D F8 05       STA TPB_BUS_blk_lenlo           ; at present.  I may change this...
09435    F103  A9 00          LDA #0
09436    F105  8D F9 05       STA TPB_BUS_blk_lenhi
09437      
09438    F108  20 DA F2       JSR TPB_tx_block                ; Transmit the control block.
09439      
09440    F10B  38             SEC                             ; Exit signalling success.
09441    F10C  60             RTS
09442      
09443    CBW_Fail  
09444    F10D  18             CLC                             ; Exit signalling fail.
09445    F10E  60             RTS
09446      
09447      
09448      ; TPB Read from remote device control block
09449    ; *******************************************************
09450    ; *                                                     *
09451    ; *  ENTRY:                                             *
09452    ; *  EXIT:                                              *
09453    ; *         Affects, A,X,Y,P.                           *
09454    ; *         C = 0: Fail                                 *
09455    ; *         C = 1: Success.                             *
09456    ; *                                                     *
09457    ; *******************************************************
09458    
09459    TPB_Ctrl_Blk_Rd
09460    F10F  AD F2 05       LDA TPB_curr_dev                ; Setup Command Block
09461    F112  8D 10 06       STA DEV_ID
09462    F115  A9 01          LDA #TPB_BLK_cmd
09463    F117  8D 11 06       STA DEV_BLK_TYPE
09464    F11A  A9 04          LDA #CTRL_BLK_RD
09465    F11C  8D 12 06       STA DEV_CMD_RSP
09466    F11F  20 2F F2       JSR TPB_calc_ctrl_csum
09467    
09468    F122  20 9E F1       JSR TPB_Tx_CMD                  ; Issue write to remote control block command.
09469     
09470    F125  20 B6 F1       JSR TPB_WaitATN                 ; Wait for Attention signal
09471    F128  90 1A          BCC CBR_Fail                    ; If no device then quit with carry clear.
09472      
09473    F12A  A9 00          LDA #<TPB_BUFFER                ; Setup for device control block receive.
09474    F12C  8D FA 05       STA TPB_BUS_blk_stlo
09475    F12F  A9 07          LDA #>TPB_BUFFER
09476    F131  8D FB 05       STA TPB_BUS_blk_sthi
09477    F134  A9 10          LDA #16                         ; Control blocks are 16 bytes in length
09478    F136  8D F8 05       STA TPB_BUS_blk_lenlo           ; at present.  I may change this...
09479    F139  A9 00          LDA #0
09480    F13B  8D F9 05       STA TPB_BUS_blk_lenhi
09481      
09482    F13E  20 1E F3       JSR TPB_rx_block                ; Receive the control block.
09483    F141  90 01          BCC CBR_Fail
09484        
09485    F143  60             RTS                             ; Exit successfully.
09486      
09487    CBR_Fail  
09488    F144  18             CLC                             ; Exit signalling fail.
09489    F145  60             RTS
09490      
09491      
09492      
09493    
09494    ; TPB Request device type code
09495    ; *******************************************************
09496    ; *                                                     *
09497    ; *  ENTRY: A=Device ID                                 *
09498    ; *  EXIT:  A=Device Type                               *
09499    ; *         Affects, A,X,Y,P.                           *
09500    ; *         C = 0: Fail                                 *
09501    ; *         C = 1: Success.                             *
09502    ; *                                                     *
09503    ; *******************************************************
09504      
09505    TPB_Req_Dev_Type
09506    F146  8D 10 06       STA DEV_ID                      ; Setup Command Block
09507    F149  A9 01          LDA #TPB_BLK_cmd
09508    F14B  8D 11 06       STA DEV_BLK_TYPE
09509    F14E  A9 02          LDA #REQ_DEV_TYPE
09510    F150  8D 12 06       STA DEV_CMD_RSP
09511    F153  20 2F F2       JSR TPB_calc_ctrl_csum
09512      
09513    F156  20 9E F1       JSR TPB_Tx_CMD                  ; Issue Req_Dev_Type command
09514        
09515    F159  20 B6 F1       JSR TPB_WaitATN                 ; Wait for Attention signal
09516    F15C  90 34          BCC DevType_Fail                ; If no device then quit with carry clear.
09517    
09518    F15E  A9 10          LDA #<TPB_ctrl_blk              ; Setup for device reply to the control block
09519    F160  8D FA 05       STA TPB_BUS_blk_stlo
09520    F163  A9 06          LDA #>TPB_ctrl_blk
09521    F165  8D FB 05       STA TPB_BUS_blk_sthi
09522    F168  A9 04          LDA #4
09523    F16A  8D F8 05       STA TPB_BUS_blk_lenlo
09524    F16D  A9 00          LDA #0
09525    F16F  8D F9 05       STA TPB_BUS_blk_lenhi
09526      
09527    F172  20 1E F3       JSR TPB_rx_block                ; Get our reply block.
09528    F175  90 1B          BCC DevType_Fail                ; Error if TPB_rx_block fails.
09529      
09530    F177  18             CLC                            ; Calculate Checksum
09531    F178  AD 10 06       LDA DEV_ID
09532    F17B  6D 11 06       ADC DEV_BLK_TYPE
09533    F17E  6D 12 06       ADC DEV_CMD_RSP
09534      
09535    F181  CD 13 06       CMP CHECKSUM                   ; Compare with received checksum
09536    F184  D0 0C          BNE DevType_Fail               ; Signal appropriately with the carry bit.
09537      
09538    F186  AD 11 06       LDA DEV_BLK_TYPE               ; Check for the appropriate response.
09539    F189  C9 02          CMP #TPB_BLK_rsp
09540    F18B  D0 05          BNE DevType_Fail               ; ...and fail if incorrect.
09541      
09542    F18D  AD 12 06       LDA DEV_CMD_RSP                ; Reply with device type.
09543      
09544    F190  38             SEC
09545    F191  60             RTS
09546    
09547    DevType_Fail
09548    F192  18             CLC                            ; General failiure exit point.
09549    F193  60             RTS
09550      
09551      
09552    ; TPB Check ATN state.
09553    ; *******************************************************
09554    ; *                                                     *
09555    ; *  ENTRY:                                             *
09556    ; *  EXIT: A, P, carry is set when asserted, otherwise  *
09557    ; *           cleared.                                  *
09558    ; *                                                     *
09559    ; *******************************************************
09560    
09561    
09562    TPB_Check_ATN
09563    F194  AD 20 C0       LDA TPB_reg_b                   ; Check if ATN is asserted
09564    F197  29 04          AND #TPB_BUS_atnin
09565    F199  38             SEC
09566    F19A  F0 01          BEQ ATN_asserted                ; Skip clearing C if ATN is asserted.
09567    F19C  18             CLC                             ; Carry is cleared as ATN isn't asserted.
09568    ATN_asserted
09569    F19D  60             RTS 
09570                       
09571    
09572    ; TPB Transmit Command
09573    ; ****************************************************
09574    ; *                                                  *
09575    ; *  ENTRY:                                          *
09576    ; *  EXIT:  A, X, Y, P affected                      *
09577    ; *                                                  *
09578    ; ****************************************************
09579    
09580    
09581    TPB_Tx_CMD
09582    F19E  A9 10          LDA #<DEV_ID                   ; Setup pointers and transmit control block.
09583    F1A0  8D FA 05       STA TPB_BUS_blk_stlo
09584    F1A3  A9 06          LDA #>DEV_ID
09585    F1A5  8D FB 05       STA TPB_BUS_blk_sthi
09586    F1A8  A9 04          LDA #4
09587    F1AA  8D F8 05       STA TPB_BUS_blk_lenlo
09588    F1AD  A9 00          LDA #0
09589    F1AF  8D F9 05       STA TPB_BUS_blk_lenhi
09590      
09591    F1B2  20 DA F2       JSR TPB_tx_block
09592      
09593    F1B5  60             RTS
09594    
09595    
09596    ; TPB Attention Signal handler with wait.
09597    ; ****************************************************
09598    ; *                                                  *
09599    ; *  ENTRY:                                          *
09600    ; *  EXIT:  A,X,P                                    *
09601    ; *         C=0 ATN line not asserted or timeout.    *
09602    ; *         C=1 ATN line asserted                    *
09603    ; *                                                  *
09604    ; ****************************************************
09605    
09606    TPB_WaitATN
09607    F1B6  A2 FF          LDX #TPB_BUS_lim_c                ; Set number of tries
09608      
09609    TPB_WaitATN_try
09610    F1B8  20 A5 F3       JSR TPB_delay                     ; Wait and check
09611    F1BB  20 94 F1       JSR TPB_Check_ATN
09612    F1BE  B0 04          BCS FinWaitATN
09613    F1C0  CA             DEX                               ; Reduce counter and try again
09614    F1C1  D0 F5          BNE TPB_WaitATN_try
09615    F1C3  18             CLC  
09616    FinWaitATN
09617    F1C4  60             RTS
09618    
09619    
09620    ; TPB DEVICE_PRESENCE handler (Currently broken)
09621    ; ****************************************************
09622    ; *                                                  *
09623    ; *  ENTRY: A=ID                                     *
09624    ; *  EXIT:  TPB_BUS_IO_buff = reply block            *
09625    ; *         C=0 (No device or block fail),           *
09626    ; *         C=1 Success.                             *
09627    ; *                                                  *
09628    ; ****************************************************
09629    
09630    
09631    ; Setup Command Block 
09632    
09633    TPB_Dev_Presence
09634      ; Command Setup
09635    F1C5  8D 10 06       STA DEV_ID                     ; Store device ID
09636    F1C8  A9 01          LDA #TPB_BLK_cmd
09637    F1CA  8D 11 06       STA DEV_BLK_TYPE
09638    F1CD  A9 00          LDA #PRESENCE                  ; Command: PRESENCE check.
09639    F1CF  8D 12 06       STA DEV_CMD_RSP  
09640    F1D2  20 2F F2       JSR TPB_calc_ctrl_csum         ; Calculate checksum
09641      ; Command Issue
09642    F1D5  20 9E F1       JSR TPB_Tx_CMD                 ; Transmit Command
09643      ; Process Outcome
09644    F1D8  20 B6 F1       JSR TPB_WaitATN                ; Wait for Attention signal
09645    F1DB  90 2A          BCC PRESENCE_NoRESP            ; If no device then skip RESP fetch
09646    
09647    F1DD  A9 10          LDA #<DEV_ID                   ; Setup pointers for RESP block.
09648    F1DF  8D FA 05       STA TPB_BUS_blk_stlo
09649    F1E2  A9 06          LDA #>DEV_ID
09650    F1E4  8D FB 05       STA TPB_BUS_blk_sthi
09651    F1E7  A9 04          LDA #4
09652    F1E9  8D F8 05       STA TPB_BUS_blk_lenlo
09653    F1EC  A9 00          LDA #0
09654    F1EE  8D F9 05       STA TPB_BUS_blk_lenhi
09655      
09656    F1F1  20 1E F3       JSR TPB_rx_block               ; Get RESPonse block
09657      
09658    F1F4  90 11          BCC PRESENCE_NoRESP            ; If failed or no response fall through.
09659      
09660    F1F6  18             CLC                            ; Calculate Checksum
09661    F1F7  AD 10 06       LDA DEV_ID
09662    F1FA  6D 11 06       ADC DEV_BLK_TYPE
09663    F1FD  6D 12 06       ADC DEV_CMD_RSP
09664      
09665    F200  CD 13 06       CMP CHECKSUM                   ; Compare with received checksum
09666    F203  D0 02          BNE PRESENCE_NoRESP            ; Signal appropriately with the carry bit.
09667    F205  38             SEC
09668    F206  60             RTS                            ; Return with positive response
09669      
09670    PRESENCE_NoRESP
09671    F207  18             CLC
09672    F208  60             RTS                            ; ...Else return negative.
09673    
09674    
09675    ; TPB Attention handler (Needs work, do not use)
09676    ; ****************************************************
09677    ; *                                                  *
09678    ; *  ENTRY:                                          *
09679    ; *  EXIT:                                           *
09680    ; *                                                  *
09681    ; *                                                  *
09682    ; *                                                  *
09683    ; ****************************************************
09684    
09685    TPB_ATN_handler
09686      
09687    F209  A0 00          LDY #0
09688    ATN_next                          ; Work our way through the device table
09689    F20B  B9 00 06       LDA TPB_Dev_table,Y           
09690      
09691    F20E  F0 1E          BEQ TPB_EOT                     ; Check for end of table marker (0).
09692                                      ; Initialise our control block for attention check
09693    F210  8D 10 06       STA DEV_ID                      ; Store device ID.
09694    F213  98             TYA
09695    F214  48             PHA                             ; Stack our table pointer for later.
09696    F215  A9 01          LDA #TPB_BLK_cmd
09697    F217  8D 11 06       STA DEV_BLK_TYPE
09698    F21A  A9 01          LDA #ATN_CHK
09699    F21C  8D 12 06       STA DEV_CMD_RSP
09700      
09701    F21F  20 2F F2       JSR TPB_calc_ctrl_csum
09702      
09703    F222  20 9E F1       JSR TPB_Tx_CMD                  ; Transmit Command
09704      
09705    F225  20 DA F2       JSR TPB_tx_block
09706      
09707      ;JSR TPB_ctrl_rd
09708      
09709    F228  68             PLA                             ; Get our id table pointer back.
09710    F229  A8             TAY
09711    F22A  C8             INY                             ; Advance to next table entry  
09712    F22B  4C 0B F2       JMP ATN_next
09713    TPB_EOT
09714    F22E  60             RTS
09715      
09716    TPB_calc_ctrl_csum
09717    F22F  18             CLC
09718    F230  A9 00          LDA #0                          ; Calculate and store checksum for block.
09719    F232  6D 10 06       ADC DEV_ID
09720    F235  6D 11 06       ADC DEV_BLK_TYPE
09721    F238  6D 12 06       ADC DEV_CMD_RSP
09722    F23B  8D 13 06       STA CHECKSUM
09723    F23E  60             RTS
09724     
09725     
09726    ; TPB transmit byte
09727    ; *================================*
09728    ; *                                *
09729    ; *  ENTRY: A=byte                 *
09730    ; *  EXIT: Affects X, P            *
09731    ; *                                *
09732    ; *================================*
09733    
09734    TPB_tx_byte
09735    F23F  A2 0A          LDX #10                   ; 1 start bit, 8 data bits and 1 stop bit.
09736    F241  38             SEC                       ; We want a start bit.
09737    F242  48             PHA
09738    TPB_bit_out  
09739    F243  90 0F          BCC TPB_out_zero          ; Determine whether a 1 or 0 to be sent.
09740      
09741    ; output 1 on TPB data
09742    F245  AD 20 C0       LDA TPB_reg_b
09743    F248  09 20          ORA #TPB_BUS_datout
09744    F24A  8D 20 C0       STA TPB_reg_b
09745    F24D  EA             NOP                       ; This NOP compensates for the branch timing.
09746    F24E  20 62 F2       JSR TPB_pulseclk
09747      
09748    F251  4C 79 F2       JMP TPB_shiftbit
09749       
09750    ; output 0 on TPB data  
09751    TPB_out_zero
09752    F254  AD 20 C0       LDA TPB_reg_b
09753    F257  29 DF          AND #~TPB_BUS_datout
09754    F259  8D 20 C0       STA TPB_reg_b
09755    F25C  20 62 F2       JSR TPB_pulseclk 
09756      
09757    F25F  4C 79 F2       JMP TPB_shiftbit
09758    
09759    
09760    ; Clock line Pulse function
09761    ; **********************************
09762    ; *                                *
09763    ; *   ENTRY: None                  *
09764    ; *   EXIT: A,P Affected           *
09765    ; *   USES: TPB_delay              *
09766    ; *                                *
09767    ; **********************************
09768    
09769    TPB_pulseclk  
09770    F262  AD 20 C0       LDA TPB_reg_b
09771    F265  09 10          ORA #TPB_BUS_clkout       ; Set the clock line output
09772    F267  8D 20 C0       STA TPB_reg_b
09773      
09774    F26A  20 A5 F3       JSR TPB_delay
09775    
09776    F26D  AD 20 C0       LDA TPB_reg_b
09777    F270  29 EF          AND #~TPB_BUS_clkout      ; Clear the clock line output
09778    F272  8D 20 C0       STA TPB_reg_b
09779      
09780    F275  20 A5 F3       JSR TPB_delay
09781    F278  60             RTS
09782    
09783          
09784    TPB_shiftbit  
09785    F279  CA             DEX
09786    F27A  F0 06          BEQ TPB_wr_done
09787    F27C  68             PLA
09788    F27D  0A             ASL
09789    F27E  48             PHA
09790    F27F  4C 43 F2       JMP TPB_bit_out
09791      
09792    TPB_wr_done
09793    F282  68             PLA
09794    F283  60             RTS
09795    
09796    
09797    ; TPB recieve byte
09798    ; *======================================*
09799    ; *                                      *
09800    ; *  ENTRY:                              *
09801    ; *  EXIT: Affects A,X,Y,P               *
09802    ; *        A = byte                      *
09803    ; *        C = 1 Sucess, 0 Fail          *
09804    ; *                                      *
09805    ; *======================================*
09806    
09807    TPB_rx_byte                       ; Read one byte
09808    F284  A9 00          LDA #0                          ; This is our starting value
09809    F286  85 E4          STA TPB_Temp3                   ; Keep it safe in Temp3
09810      
09811    F288  AD 20 C0       LDA TPB_reg_b                   ; Signal start bit required.
09812    F28B  09 10          ORA #TPB_BUS_clkout             ; Set the clock line output
09813    F28D  8D 20 C0       STA TPB_reg_b
09814      
09815    F290  18             CLC
09816    F291  A0 FF          LDY #TPB_BUS_lim_c              ; Load our limit (preventing bus hangs)
09817    TPB_chk_databit
09818    F293  20 A5 F3       JSR TPB_delay                   ; Small delay.  This may change later.
09819    F296  AD 20 C0       LDA TPB_reg_b
09820    F299  29 80          AND #TPB_BUS_datin
09821    F29B  F0 12          BEQ TPB_sbit_asserted
09822      
09823    F29D  88             DEY                             ; Check for timeout & branch if still waiting.
09824    F29E  D0 F3          BNE TPB_chk_databit
09825      
09826    TPB_rx_fail
09827    F2A0  AD 20 C0       LDA TPB_reg_b                   ; Clear clock line output
09828    F2A3  29 EF          AND #~TPB_BUS_clkout
09829    F2A5  8D 20 C0       STA TPB_reg_b
09830    F2A8  20 A5 F3       JSR TPB_delay                   ; ...and include a small delay
09831    
09832    F2AB  A9 00          LDA #0                          ; We timed out so let's signal that
09833    F2AD  18             CLC
09834    F2AE  60             RTS
09835      
09836    TPB_sbit_asserted
09837    F2AF  AD 20 C0       LDA TPB_reg_b                   ; Clear clock line output
09838    F2B2  29 EF          AND #~TPB_BUS_clkout
09839    F2B4  8D 20 C0       STA TPB_reg_b
09840    F2B7  20 A5 F3       JSR TPB_delay                   ; ...and include a small delay
09841      
09842    
09843    F2BA  A2 08          LDX #8                          ; Receive and store 8 bits.
09844    TPB_rcv_nextbit  
09845    F2BC  20 CD F2       JSR TPB_Takebit
09846    F2BF  26 E4          ROL TPB_Temp3                   ; Push our sampled bit into our output.
09847    
09848    F2C1  CA             DEX
09849    F2C2  D0 F8          BNE TPB_rcv_nextbit
09850      
09851    F2C4  20 CD F2       JSR TPB_Takebit                 ; Receive the stop bit.  
09852    F2C7  B0 D7          BCS TPB_rx_fail
09853      
09854    F2C9  A5 E4          LDA TPB_Temp3                   ; Retrieve our finished byte
09855    F2CB  38             SEC                             ; and signal that we were successful
09856    F2CC  60             RTS
09857      
09858    TPB_Takebit  
09859    F2CD  20 62 F2       JSR TPB_pulseclk                ; Sample the bus and set or clear carry as required.
09860    F2D0  AD 20 C0       LDA TPB_reg_b
09861    F2D3  29 80          AND #TPB_BUS_datin
09862    F2D5  18             CLC
09863    F2D6  D0 01          BNE TPB_skip_setbit
09864    F2D8  38             SEC
09865    TPB_skip_setbit
09866    F2D9  60             RTS
09867      
09868    
09869    ; TPB transmit block
09870    ; *==================================================*
09871    ; *                                                  *
09872    ; *  ENTRY: TPB_BUS_blk_lenlo = length of block (LO) *
09873    ; *         TPB_BUS_blk_lenhi = length of block (HI) *
09874    ; *                                                  *
09875    ; *         TPB_BUS_blk_st  = start of block         *
09876    ; *                                                  *
09877    ; *  EXIT:  TPB_BUS_blk_len = unchanged              *
09878    ; *         TPB_BUS_blk_st  = st+len                 *
09879    ; *         A,X,Y,P affected.                        *
09880    ; *                                                  *
09881    ; *                                                  *
09882    ; *==================================================*
09883    
09884    TPB_tx_block
09885    F2DA  AD FA 05       LDA TPB_BUS_blk_stlo             ; Copy block address to temp1/2
09886    F2DD  85 E2          STA TPB_Temp1
09887    F2DF  AD FB 05       LDA TPB_BUS_blk_sthi
09888    F2E2  85 E3          STA TPB_Temp2
09889      
09890    TPB_BUS_tx_next                    ; Transmitter inside loop
09891    F2E4  AD F8 05       LDA TPB_BUS_blk_lenlo            ; Finish when TPB_blk_len(lo and hi) = 0
09892    F2E7  0D F9 05       ORA TPB_BUS_blk_lenhi
09893    F2EA  F0 31          BEQ TPB_tx_block_done
09894      
09895    F2EC  A0 00          LDY #0                           ; Get and transmit byte.
09896    F2EE  B1 E2          LDA (TPB_Temp1),Y
09897    F2F0  20 3F F2       JSR TPB_tx_byte
09898    
09899    F2F3  AD F8 05       LDA TPB_BUS_blk_lenlo            ; Decrement our length counter
09900    F2F6  38             SEC
09901    F2F7  E9 01          SBC #1
09902    F2F9  8D F8 05       STA TPB_BUS_blk_lenlo
09903    F2FC  AD F9 05       LDA TPB_BUS_blk_lenhi
09904    F2FF  E9 00          SBC #0
09905    F301  8D F9 05       STA TPB_BUS_blk_lenhi
09906      
09907    F304  18             CLC                              ; Increment TPB_BUS_blk_len copy in TPB_Temp1/2
09908    F305  A5 E2          LDA TPB_Temp1
09909    F307  69 01          ADC #1
09910    F309  85 E2          STA TPB_Temp1
09911    F30B  A5 E3          LDA TPB_Temp2
09912    F30D  69 00          ADC #0
09913    F30F  85 E3          STA TPB_Temp2
09914      
09915    F311  20 A5 F3       JSR TPB_delay                    ; Add a little delay between bytes.
09916    F314  20 A5 F3       JSR TPB_delay                    ; thereby allowing the receiver to do something useful.
09917    F317  20 A5 F3       JSR TPB_delay
09918      
09919    F31A  4C E4 F2       JMP TPB_BUS_tx_next
09920      
09921    TPB_tx_block_done
09922    F31D  60             RTS
09923     
09924    
09925    ; TPB receive block
09926    ; *==================================================*
09927    ; *                                                  *
09928    ; *  ENTRY: TPB_BUS_blk_lenlo = length of block (LO) *
09929    ; *         TPB_BUS_blk_lenhi = length of block (HI) *
09930    ; *                                                  *
09931    ; *         TPB_BUS_blk_st  = start of block         *
09932    ; *                                                  *
09933    ; *  EXIT:  TPB_BUS_blk_len = unchanged              *
09934    ; *         TPB_BUS_blk_st  = st+len                 *
09935    ; *         Temp1, Temp2 Corrupted                   *
09936    ; *         A,X,Y,P all affected.                    *
09937    ; *         C=0 Fail, C=1 Success                    *
09938    ; *                                                  *
09939    ; *==================================================*
09940     
09941    TPB_rx_block
09942    F31E  AD FA 05       LDA TPB_BUS_blk_stlo             ; Copy block address to temp1/2
09943    F321  85 E2          STA TPB_Temp1
09944    F323  AD FB 05       LDA TPB_BUS_blk_sthi
09945    F326  85 E3          STA TPB_Temp2
09946      
09947    TPB_BUS_rx_next
09948    F328  AD F8 05       LDA TPB_BUS_blk_lenlo            ; While block length > 0.
09949    F32B  0D F9 05       ORA TPB_BUS_blk_lenhi
09950    F32E  F0 2B          BEQ TPB_rx_block_done
09951      
09952    F330  20 84 F2       JSR TPB_rx_byte                  ; Get byte.
09953      
09954    F333  B0 01          BCS TPB_rx_continue              ; Continue unless TPB_rx_byte signals failiure.
09955    F335  60             RTS
09956      
09957    TPB_rx_continue
09958    F336  A0 00          LDY #0                           
09959    F338  91 E2          STA (TPB_Temp1),Y                ; Store our successfully received byte.
09960      
09961    F33A  AD F8 05       LDA TPB_BUS_blk_lenlo            ; Decrement our length counter
09962    F33D  38             SEC
09963    F33E  E9 01          SBC #1
09964    F340  8D F8 05       STA TPB_BUS_blk_lenlo
09965    F343  AD F9 05       LDA TPB_BUS_blk_lenhi
09966    F346  E9 00          SBC #0
09967    F348  8D F9 05       STA TPB_BUS_blk_lenhi
09968      
09969    F34B  18             CLC                              ; Increment TPB_BUS_blk_len copy in TPB_Temp1/2
09970    F34C  A5 E2          LDA TPB_Temp1
09971    F34E  69 01          ADC #1
09972    F350  85 E2          STA TPB_Temp1
09973    F352  A5 E3          LDA TPB_Temp2
09974    F354  69 00          ADC #0
09975    F356  85 E3          STA TPB_Temp2
09976      
09977    F358  4C 28 F3       JMP TPB_BUS_rx_next
09978      
09979    TPB_rx_block_done
09980    F35B  38             SEC
09981    F35C  60             RTS
09982      
09983      
09984    ; TPB Device Select
09985    ; *==================================================*
09986    ; *                                                  *
09987    ; *   ENTRY:   A = Device to select                  *
09988    ; *   EXIT:    None                                  *
09989    ; *   AFFECTS: A,X,Y,P                               *
09990    ; *                                                  *
09991    ; *                                                  *
09992    ; *==================================================*
09993    
09994    TPB_dev_select
09995    F35D  A8             TAY                       ; Save our device ID
09996      
09997      
09998    F35E  A9 08          LDA #TPB_BUS_select       ; Assert SELECT signal
09999    F360  8D 20 C0       STA TPB_reg_b
10000    
10001    F363  A2 00          LDX #$0                   ; Give device time to act
10002    ATN_Resp_Dwell
10003    F365  CA             DEX
10004    F366  EA             NOP
10005    F367  EA             NOP
10006    F368  D0 FB          BNE ATN_Resp_Dwell
10007      
10008    F36A  98             TYA                       ; Get our ID from Y
10009    F36B  20 3F F2       JSR TPB_tx_byte           ; Transmit our device ID
10010      
10011    F36E  A9 F7          LDA #~TPB_BUS_select      ; Deassert SELECT
10012    F370  8D 20 C0       STA TPB_reg_b
10013      
10014    F373  8C F2 05       STY TPB_curr_dev          ; Update current dev variable
10015      
10016    F376  60             RTS
10017      
10018    
10019    
10020        
10021    FINDME:
10022    
10023    ; TPB LPT Write.
10024    ; *================================*
10025    ; *                                *
10026    ; *  ENTRY: A=char                 *
10027    ; *  EXIT: As found                *
10028    ; *                                *
10029    ; **********************************
10030    
10031    TPB_LPT_write
10032    
10033    F377  08             PHP                             ; Save Register States
10034    F378  48             PHA
10035      
10036    F379  20 9B F3       JSR STB_ack_wait                ; Wait until Ack=1
10037      
10038    F37C  20 A5 F3       JSR TPB_delay
10039      
10040    F37F  8D 21 C0       STA TPB_reg_a                   ; Write the char to output
10041      
10042    F382  20 A5 F3       JSR TPB_delay
10043      
10044    F385  AD 20 C0       LDA TPB_reg_b                   ; Set the strobe bit low (Active)
10045    F388  29 FD          AND #~TPB_LPT_stb_b             ; and only the strobe bit.
10046    F38A  8D 20 C0       STA TPB_reg_b
10047      
10048    F38D  20 A5 F3       JSR TPB_delay
10049      
10050    F390  AD 20 C0       LDA TPB_reg_b                   ; Now we return the strobe bit to it's
10051    F393  09 02          ORA #TPB_LPT_stb_b              ; 'idle' state.
10052    F395  8D 20 C0       STA TPB_reg_b
10053      
10054    F398  68             PLA
10055    F399  28             PLP
10056    F39A  60             RTS  
10057      
10058    STB_ack_wait
10059    F39B  48             PHA
10060      
10061    TPB_w_loop
10062    F39C  AD 2D C0       LDA TPB_ifr                     ; Check IFR for interrupt flag on CB1 set
10063    F39F  29 02          AND #TPB_ACK_CA1_b
10064    F3A1  F0 F9          BEQ TPB_w_loop                  ; Until they match
10065      
10066    F3A3  68             PLA
10067    F3A4  60             RTS
10068     
10069     
10070    ; Delay routine for TPB, there are better ways but this will do for now.
10071      
10072    TPB_delay
10073    F3A5  48             PHA
10074      
10075    F3A6  A9 06          LDA #6
10076    F3A8  38             SEC
10077      
10078    TPB_delay_loop
10079    F3A9  E9 01          SBC #1
10080    F3AB  D0 FC          BNE TPB_delay_loop
10081      
10082    F3AD  68             PLA
10083    F3AE  60             RTS
10084    
10085    ; *****************************************************************
10086    ;
10087    ;                       END OF TPBCARD.asm
10088    ;
10089    ; *****************************************************************
10090    ; *****************************************************************
10091      .INCLUDE "TAPE_IO.asm"
10092    ; Tape Interface Functions for ToE Tape and Joystick interface.
10093    
10094    ; Compatible with versions 1 and 1.1 of the interface as of 30/12/2020
10095    
10096    
10097    ; Tape interface bitfield definitions
10098    
10099      0080             TAPE_out		= @10000000			; This is the bit to toggle for tape writing.
10100      0040             TAPE_in			= @01000000			; This is the bit to sample for tape reading.
10101      003F             JOYSTICK_bits		= @00111111			; These bits are used by the joystick interface.
10102      0001             JOYSTICK_sel		= @00000001			; 0 selects Joystick 0, 1 selects joystick 2. Easy.
10103    
10104      0001             TAPE_Stat_overrun	= @00000001			; Stop bit was a one!
10105      0002             TAPE_Stat_par_err	= @00000010			; Parity error.  It remains to be seen if this gets implemented.
10106      0004             TAPE_Stat_RXFull	= @00000100			; Byte received
10107      0008             TAPE_Stat_Escape	= @00001000			; Indication that the escape key has been pressed
10108    
10109      0001             TAPE_BlockIn_Complete	= @00000001
10110      0002             TAPE_BlockIn_Escape	= @00000010
10111      0004             TAPE_BlockIn_Error	= @00000100
10112    
10113      0001             TAPE_Verify_Good	= @00000001
10114      0002             TAPE_Verify_Escape	= @00000010
10115      0004             TAPE_Verify_Error	= @00000100
10116    
10117    ; Tape interface port addresses
10118    
10119      C040             TAPE_IOBASE		= $C040				; Base address for our tape port.  This is normally set to whatever the GPIO card is.
10120      C040             TAPE_IOP		= TAPE_IOBASE			; We are currently using PORT B on the user port card for IO.
10121      C042             TAPE_DDRB		= TAPE_IOBASE + 2
10122    
10123    
10124    ; Tape system storage zeropage addresses
10125      00E4             TAPE_temp		= $E4				; Let's use one of the zero page addresses
10126      00E5             TAPE_BlockLo		= $E5
10127      00E6             TAPE_BlockHi		= $E6
10128    
10129    ; Tape timing values.
10130    
10131    ; Please note that all this is subject to changes as and when needed because I'm in uncharted territory
10132    ; and don't quite know what I'm doing yet.
10133    
10134    
10135      0008             C_TAPE_Phasetime	= 8				; How long to wait between phases.  Bigger is slower
10136      0014             C_TAPE_Sample_Offset	= 20				; How far is the middle of the bit. Note: timing errors will cause this to stretch
10137      0036             C_TAPE_Bitlength	= 54				; How many passes for a full bit
10138      0008             C_TAPE_bitcycles	= 8				; Number of cycles to a bit
10139      000A             C_TAPE_BitsPerFrame	= 10				; Total number of bits per frame including start and stop bits.
10140      00AA             C_TAPE_LeaderByte	= $AA				; Leader byte
10141      0055             C_TAPE_EndOfLeaderByte  = $55				; End of leader signal byte
10142      AFC8             C_TAPE_Interblock_pause = 45000				; How long between blocks to wait before starting the next one.
10143    
10144      0064             TAPE_Leader_Bytes	= 100				; Set leader length in bits.
10145    
10146    ; File type constants
10147    
10148      0000             C_TAPE_FType_BASIC	= 0				; BASIC program
10149      0001             C_TAPE_FType_BINARY	= 1				; Binary Data
10150      0002             C_TAPE_FType_TEXT	= 2				; Pure text.  NOTE: Good for merging snippets of code.
10151    
10152    
10153    ; System variables for tape routines.
10154    
10155    
10156    ; +================================+
10157    ; !                                !
10158    ; ! TAPE SPACE FROM $900 TO $AFF   !
10159    ; !                                !
10160    ; !                                !
10161    ; !                                !
10162    ; +================================+
10163    
10164      0900             TAPE_RAM_Start			= $900				; Base address of the tape filing system main memory
10165    
10166      0900             V_TAPE_BlockSize		= TAPE_RAM_Start		; 2 Byte address for block size
10167      0902             TAPE_temp2			= TAPE_RAM_Start + 2		; Second temporary store for tape functions.
10168      0903             TAPE_temp3			= TAPE_RAM_Start + 3		; Third temporary store for tape functions.
10169      0904             TAPE_temp4			= TAPE_RAM_Start + 4		; Fourth temporary store for tape functions.
10170      0905             TAPE_LineUptime			= TAPE_RAM_Start + 5		; How many passes of the superloop the line has been up.
10171      0906             TAPE_Demod_Status		= TAPE_RAM_Start + 6		; Demodulated bit status.
10172      0907             TAPE_Demod_Last			= TAPE_RAM_Start + 7		; Our previous demod status.  Used for edge detection etc.
10173      0908             TAPE_StartDet			= TAPE_RAM_Start + 8		; Start bit detected is 1, 0 otherwise
10174      0909             TAPE_RX_Status			= TAPE_RAM_Start + 9		; Receive engine status bitfield.
10175      090A             TAPE_BitsToDecode		= TAPE_RAM_Start + 10		; Bit countdown counter when decoding
10176      090B             TAPE_ByteReceived		= TAPE_RAM_Start + 11		; Last byte received
10177      090C             TAPE_Sample_Position		= TAPE_RAM_Start + 12		; Countdown timer for bit engine sample synchronization
10178      090D             TAPE_BlockIn_Status		= TAPE_RAM_Start + 13		; Status register for the F_TAPE_BlockIn function.
10179    
10180      090E             TAPE_Header_Buffer		= TAPE_BlockIn_Status + 1	; This is where the tape header data starts
10181      090E             TAPE_HeaderID			= TAPE_Header_Buffer		; Just stores 'HEAD'.  Used to identify headers from other stuff.
10182      0912             TAPE_FileType			= TAPE_HeaderID + 4		; This is the file type ID goes. 0 is for BASIC, otherwise ignored by LOAD.
10183      0913             TAPE_FileSizeLo			= TAPE_FileType + 1		; Low byte of the file size
10184      0914             TAPE_FileSizeHi			= TAPE_FileSizeLo + 1		; High byte of the file size
10185      0915             TAPE_LoadAddrLo			= TAPE_FileSizeHi + 1		; Low byte of the file load address
10186      0916             TAPE_LoadAddrHi			= TAPE_LoadAddrLo + 1		; High byte of the file load address
10187      0917             TAPE_FileName			= TAPE_LoadAddrHi + 1		; Null terminated filename field 17 bytes long.
10188      0928             TAPE_ChecksumLo			= TAPE_FileName + 17		; Checksum Low byte
10189      0929             TAPE_ChecksumHi			= TAPE_ChecksumLo + 1		; Checksum High byte
10190      0929             TAPE_Header_End			= TAPE_ChecksumHi		; End of header space
10191    
10192      092A             TAPE_CS_AccLo			= TAPE_Header_End + 1		; Tape checksum Accumulator low byte
10193      092B             TAPE_CS_AccHi			= TAPE_CS_AccLo + 1		; Tape checksum Accumulator high byte
10194    
10195      092C             V_TAPE_Phasetime		= TAPE_CS_AccHi + 1		; Tape phasetime variable
10196      092D             V_TAPE_Sample_Offset		= V_TAPE_Phasetime + 1		; Sample offset variable
10197      092E             V_TAPE_Bitlength		= V_TAPE_Sample_Offset + 1	; How long a bit is in passes variable
10198      092F             V_TAPE_bitcycles		= V_TAPE_Bitlength + 1		; Number of cycles to a bit variable
10199    
10200      0930             V_TAPE_Verify_Status		= V_TAPE_bitcycles + 1		; Status register for the F_TAPE_Verify function.
10201      0931             V_TAPE_Fname_Buffer		= V_TAPE_Verify_Status + 1	; Filename Buffer for null terminated filename.
10202    
10203    
10204    ; Some more handy constants
10205    
10206      0011             C_TAPE_Fname_BufferSize		= 17
10207      0942             C_TAPE_Fname_BuffEnd		= V_TAPE_Fname_Buffer + C_TAPE_Fname_BufferSize 
10208      001B             C_TAPE_HeaderSize		= TAPE_Header_End - TAPE_Header_Buffer
10209    
10210    
10211    
10212    
10213    
10214    ; Next is $93F.
10215    
10216    ; +-------------------------------------------------------------------------------------------+
10217    ; +                                                                                           +
10218    ; +                              TAPE FILING SYSTEM MESSAGE STRINGS.                          +
10219    ; +                                                                                           +
10220    ; +-------------------------------------------------------------------------------------------+
10221    
10222    
10223    TMSG_init_msg						; Filing System initialisation string.
10224     
10225      .BYTE $0C,1,$18,$03,$0D,$0A
10226      .BYTE "TowerTAPE Filing System",$0D,$0A
10227      .BYTE "V2.1",$0D,$0A,$0D,$0A,$00
10228      
10229    
10230    TMSG_Ready
10231    
10232      .BYTE $D,$A
10233      .BYTE "Ready",$D,$A,0
10234      
10235      
10236    TMSG_Saving
10237    
10238      .BYTE $D,$A
10239      .BYTE "Saving ",0
10240      
10241      
10242    TMSG_Searching
10243    
10244      .BYTE $D,$A
10245      .BYTE "Searching...",$D,$A,0
10246    
10247    
10248    TMSG_Found
10249      .BYTE $D,$A
10250      .BYTE "Found ",0 
10251    
10252    TMSG_Loading
10253    
10254      .BYTE $D,$A
10255      .BYTE "Loading...",$D,$A,0
10256      
10257    TMSG_Verifying
10258    
10259      .BYTE $D,$A
10260      .BYTE "Verifying.",$D,$A,0
10261      
10262    TMSG_Verified
10263    
10264      .BYTE $D,$A
10265      .BYTE "Verified OK.",$D,$A,0
10266      
10267    TMSG_VerifyError
10268    
10269      .BYTE $D,$A
10270      .BYTE "Verify Error.",$D,$A,0
10271    
10272    TMSG_TapeError
10273    
10274      .BYTE $D,$A
10275      .BYTE "Tape loading Error.",$D,$A,0
10276      
10277    TMSG_HeaderError  
10278    
10279      .BYTE $D,$A
10280      .BYTE "Header error. Retrying.",$D,$A,0
10281      
10282    TMSG_TypeBASIC
10283    
10284      .BYTE "BASIC: ",0
10285      
10286    TMSG_TypeBINARY
10287    
10288      .BYTE "binary: ",0
10289      
10290    TMSG_TypeTEXT
10291    
10292      .BYTE "text: ",0
10293      
10294    TMSG_TypeOTHER
10295      .BYTE "other: ",0
10296      
10297    
10298    
10299    ; +-------------------------------------------------------------------------------------------------+
10300    ; +                                                                                                 +
10301    ; +                        Functions for tape loading and saving start here.                        +
10302    ; +                        =================================================                        +
10303    ; +                                                                                                 +
10304    ; +                                                                                                 +
10305    ; +-------------------------------------------------------------------------------------------------+
10306    
10307    
10308    ;*****************************************************************************************
10309    ;**                                                                                     **
10310    ;**                                                                                     **
10311    ;**                HOUSEKEEPING AND INITIALISATION FUNCTIONS GO HERE.                   **
10312    ;**                                                                                     **
10313    ;**                                                                                     **
10314    ;*****************************************************************************************
10315    
10316    F_TAPE_Init
10317    F49A  A9 81          LDA #TAPE_out | JOYSTICK_sel				; Setup tape and joystick 6522 DDR Bits.
10318    F49C  8D 42 C0       STA TAPE_DDRB
10319    
10320    F49F  A0 00          LDY #0						; Setup our index to the start of the string
10321      
10322    L_TAPE_init_msg  
10323    F4A1  B9 AF F3       LDA TMSG_init_msg,Y					; Get the character
10324    F4A4  F0 07          BEQ TAPE_msg_done					; Break out of the loop when we're done.
10325      
10326    F4A6  20 02 E2       JSR V_OUTP						; output character
10327      
10328    F4A9  C8             INY							; Do the next character
10329    F4AA  4C A1 F4       JMP L_TAPE_init_msg
10330    
10331    TAPE_msg_done  
10332    F4AD  60             RTS
10333        
10334    
10335      
10336    
10337    
10338    ;*****************************************************************************************
10339    ;**                                                                                     **
10340    ;**                                                                                     **
10341    ;**          Helper and high level functions for tape loading and saving.               **
10342    ;**                                                                                     **
10343    ;**                                                                                     **
10344    ;*****************************************************************************************
10345    
10346    
10347    ; Compares the filename in the buffer to the one in the header and returns C=1 on equality, otherwise C=0
10348    ;
10349    
10350    F_TAPE_CompareFileNames
10351    F4AE  A0 00          LDY #0						; Setup our index
10352      
10353    F4B0  AD 31 09       LDA V_TAPE_Fname_Buffer				; Short circuit to match on null filename specified.
10354    F4B3  C9 00          CMP #0
10355    F4B5  F0 10          BEQ TAPE_CompareByte_Match_B
10356      
10357    TAPE_CompareByte_L
10358    F4B7  B9 31 09       LDA V_TAPE_Fname_Buffer,Y				; Get our byte to compare
10359    
10360    F4BA  D9 17 09       CMP TAPE_FileName,Y					; Branch on mismatch.
10361    F4BD  D0 0A          BNE TAPE_CompareMismatch_B
10362      
10363    F4BF  98             TYA							; Decrement index and branch when done
10364    F4C0  C8             INY
10365    F4C1  C9 10          CMP #16
10366    F4C3  F0 02          BEQ TAPE_CompareByte_Match_B
10367    F4C5  80 F0          BRA TAPE_CompareByte_L
10368      
10369    TAPE_CompareByte_Match_B				; Signal match and exit
10370    F4C7  38             SEC
10371    F4C8  60             RTS 
10372      
10373    TAPE_CompareMismatch_B
10374    F4C9  18             CLC							; Signal mismatch and exit
10375    F4CA  60             RTS
10376    
10377    ; Just prints 'Found ', followed by the filename.  That's all.
10378    
10379    F_TAPE_PrintFound
10380    F4CB  A9 FC          LDA #<TMSG_Found					; Print 'Found '
10381    F4CD  85 E7          STA TOE_MemptrLo
10382    F4CF  A9 F3          LDA #>TMSG_Found 
10383    F4D1  85 E8          STA TOE_MemptrHi
10384    F4D3  20 60 FF       JSR TOE_PrintStr_vec
10385      
10386    
10387    F4D6  AD 12 09       LDA TAPE_FileType					; Check and print BASIC if necessary.
10388    F4D9  C9 00          CMP #C_TAPE_FType_BASIC
10389    F4DB  D0 0D          BNE TAPE_Skip_RepBASIC_B
10390      
10391    F4DD  A9 7A          LDA #<TMSG_TypeBASIC
10392    F4DF  85 E7          STA TOE_MemptrLo
10393    F4E1  A9 F4          LDA #>TMSG_TypeBASIC
10394    F4E3  85 E8          STA TOE_MemptrHi
10395    F4E5  20 60 FF       JSR TOE_PrintStr_vec
10396      
10397    F4E8  80 33          BRA TAPE_DoPrintFname_B
10398       
10399    TAPE_Skip_RepBASIC_B
10400    
10401    F4EA  AD 12 09       LDA TAPE_FileType					; Check and print BASIC if necessary.
10402    F4ED  C9 01          CMP #C_TAPE_FType_BINARY
10403    F4EF  D0 0D          BNE TAPE_Skip_RepBinary_B
10404      
10405    F4F1  A9 82          LDA #<TMSG_TypeBINARY
10406    F4F3  85 E7          STA TOE_MemptrLo
10407    F4F5  A9 F4          LDA #>TMSG_TypeBINARY
10408    F4F7  85 E8          STA TOE_MemptrHi
10409    F4F9  20 60 FF       JSR TOE_PrintStr_vec
10410      
10411    F4FC  80 1F          BRA TAPE_DoPrintFname_B
10412      
10413    TAPE_Skip_RepBinary_B
10414    
10415    F4FE  AD 12 09       LDA TAPE_FileType					; Check and print BASIC if necessary.
10416    F501  C9 02          CMP #C_TAPE_FType_TEXT
10417    F503  D0 0D          BNE TAPE_Skip_RepText_B
10418      
10419    F505  A9 8B          LDA #<TMSG_TypeTEXT
10420    F507  85 E7          STA TOE_MemptrLo
10421    F509  A9 F4          LDA #>TMSG_TypeTEXT
10422    F50B  85 E8          STA TOE_MemptrHi
10423    F50D  20 60 FF       JSR TOE_PrintStr_vec
10424    
10425    F510  80 0B          BRA TAPE_DoPrintFname_B
10426      
10427    TAPE_Skip_RepText_B
10428    
10429    F512  A9 92          LDA #<TMSG_TypeOTHER
10430    F514  85 E7          STA TOE_MemptrLo
10431    F516  A9 F4          LDA #>TMSG_TypeOTHER
10432    F518  85 E8          STA TOE_MemptrHi
10433    F51A  20 60 FF       JSR TOE_PrintStr_vec
10434    
10435    TAPE_DoPrintFname_B
10436    F51D  20 BF F5       JSR F_TAPE_PrintFname_in_Header			; Print our filename.
10437    F520  20 99 C9       JSR   LAB_CRLF					; print CR/LF. 
10438    F523  60             RTS
10439      
10440    
10441    ; Write HEAD to the header ID field.  Yes, it's primitive but it really is the easiest way.
10442    ;  
10443    F_TAPE_WriteHeaderID
10444    F524  A9 48          LDA #'H'
10445    F526  8D 0E 09       STA TAPE_HeaderID
10446    F529  A9 45          LDA #'E'
10447    F52B  8D 0F 09       STA TAPE_HeaderID + 1
10448    F52E  A9 41          LDA #'A'
10449    F530  8D 10 09       STA TAPE_HeaderID + 2
10450    F533  A9 44          LDA #'D'
10451    F535  8D 11 09       STA TAPE_HeaderID + 3
10452    F538  60             RTS
10453    
10454    
10455    ; Check to see if our header block IS a header block.
10456    ;
10457    F_TAPE_CheckHeaderID
10458    F539  AD 0E 09       LDA TAPE_HeaderID
10459    F53C  C9 48          CMP #'H'
10460    F53E  D0 17          BNE TAPE_NotAHeader_B
10461      
10462    F540  AD 0F 09       LDA TAPE_HeaderID + 1
10463    F543  C9 45          CMP #'E'
10464    F545  D0 10          BNE TAPE_NotAHeader_B
10465      
10466    F547  AD 10 09       LDA TAPE_HeaderID + 2
10467    F54A  C9 41          CMP #'A'
10468    F54C  D0 09          BNE TAPE_NotAHeader_B
10469      
10470    F54E  AD 11 09       LDA TAPE_HeaderID + 3
10471    F551  C9 44          CMP #'D'
10472    F553  D0 02          BNE TAPE_NotAHeader_B
10473      
10474    F555  38             SEC					; Is a confirmed header
10475    F556  60             RTS
10476      
10477    TAPE_NotAHeader_B  
10478    F557  18             CLC					; Is not a header or is a bad header.
10479    F558  60             RTS
10480      
10481    
10482    ; Fill out V_TAPE_Fname_buffer with filename.
10483    ; TOE_MemptrLo and Hi contain the address bytes for the source.  A contains the length.
10484    ; This function also null terminates the string.
10485    
10486    F_TAPE_Fill_Fname
10487    F559  A0 00          LDY #0						; Clear our index so we point to the start of the string.
10488      
10489    F55B  C9 00          CMP #0						; Handle null string swiftly
10490    F55D  F0 0B          BEQ TAPE_Fill_Null_L
10491      
10492    F55F  AA             TAX							; Set up our byte counter
10493      
10494    TAPE_Fill_Fname_L					; Fill_Fname loop start
10495    F560  B1 E7          LDA (TOE_MemptrLo),Y					; Get our byte
10496    F562  99 31 09       STA V_TAPE_Fname_Buffer,Y				; Save our byte in our buffer.
10497    
10498    F565  C8             INY							; Increment our index
10499    F566  CA             DEX							; Decrement our counter
10500    F567  8A             TXA
10501    F568  D0 F6          BNE TAPE_Fill_Fname_L					; Repeat while counter not zero
10502    
10503    TAPE_Fill_Null_L					; At this point, we're putting the null characters in
10504    F56A  A9 00          LDA #0
10505      
10506    F56C  99 31 09       STA V_TAPE_Fname_Buffer,Y
10507    F56F  98             TYA
10508    F570  C8             INY
10509    F571  C9 10          CMP #16
10510    F573  D0 F5          BNE TAPE_Fill_Null_L
10511      
10512    F575  60             RTS							; End of F_TAPE_Fill_Fname routine.
10513      
10514      
10515    ; Copies V_TAPE_Fname_Buffer to the header
10516      
10517    F_TAPE_Fname_Buf_to_Header
10518    F576  A0 00          LDY #0						; Set our index
10519    
10520    TAPE_Fname_Buf_to_Header_L
10521    
10522    F578  B9 31 09       LDA V_TAPE_Fname_Buffer,Y				; Get our first byte
10523    F57B  99 17 09       STA TAPE_FileName,Y					; And transfer it to the header.
10524      
10525    F57E  C8             INY							; Increment and repeat until done.
10526    F57F  C9 00          CMP #0
10527    F581  D0 F5          BNE TAPE_Fname_Buf_to_Header_L
10528      
10529    TAPE_Fname_BlankRest_B					; Fill out rest of header with zero's for checksum purposes.
10530    F583  A9 00          LDA #0
10531    F585  99 17 09       STA TAPE_FileName,Y
10532    F588  98             TYA
10533    F589  C9 11          CMP #17
10534    F58B  F0 03          BEQ TAPE_Done_BlankRest_B
10535    F58D  C8             INY
10536    F58E  80 F3          BRA TAPE_Fname_BlankRest_B
10537      
10538    TAPE_Done_BlankRest_B
10539    F590  60             RTS							; Done
10540    
10541    
10542    ; Get filename from command line into buffer.  Also handle errors.  This may not be the final thing.
10543    
10544    F_TAPE_GetName
10545    F591  20 E7 CB       JSR   LAB_EVEX					; evaluate string
10546    F594  20 55 D4       JSR   LAB_EVST					; test it is a string
10547    F597  8D 02 09       STA TAPE_temp2					; Store our string length for later
10548      
10549    F59A  A5 5F          LDA Dtypef						; Find out if it is a string and error if it isn't.  $FF=Str, $0=Numeric
10550    F59C  F0 10          BEQ TAPE_SYN_ERR
10551      
10552    F59E  AD 02 09       LDA TAPE_temp2					; Recover our string length
10553    F5A1  38             SEC
10554    F5A2  E9 11          SBC #17
10555    F5A4  30 0E          BMI TAPE_NameToBuffer_B
10556    F5A6  80 00          BRA TAPE_LEN_ERR
10557    
10558    TAPE_LEN_ERR  
10559    F5A8  A2 24          LDX #$24 ;ERR_BF					; Issue a Bad filename Error
10560    F5AA  20 3F C2       JSR LAB_XERR
10561    F5AD  60             RTS							; Does LAB_XERR really return??
10562      
10563    TAPE_SYN_ERR
10564    ; Syntax Error output
10565    F5AE  A2 02          LDX #$2 ;ERR_SN					; Issue a Syntax Error.  
10566    F5B0  20 3F C2       JSR LAB_XERR
10567    F5B3  60             RTS							; Does LAB_XERR really return??							
10568    
10569    TAPE_NameToBuffer_B
10570    
10571    F5B4  86 E7          STX TOE_MemptrLo					; Copy our String to the 
10572    F5B6  84 E8          STY TOE_MemptrHi					; TOE_Memptr contains starting location
10573    F5B8  AD 02 09       LDA TAPE_temp2					; and A contains size.
10574    F5BB  20 59 F5       JSR F_TAPE_Fill_Fname
10575    F5BE  60             RTS
10576    
10577    
10578    ; Print Filename in header
10579    
10580    F_TAPE_PrintFname_in_Header
10581    F5BF  A9 17          LDA #<TAPE_FileName				; Print our Filename in the header space
10582    F5C1  85 E7          STA TOE_MemptrLo
10583    F5C3  A9 09          LDA #>TAPE_FileName 
10584    F5C5  85 E8          STA TOE_MemptrHi
10585    F5C7  20 60 FF       JSR TOE_PrintStr_vec  
10586    F5CA  60             RTS
10587      
10588    
10589    ; Saves A BASIC program.  Meant to be called from within BASIC
10590    ;
10591    
10592    F_TAPE_SAVE_BASIC
10593    
10594    F5CB  20 91 F5       JSR F_TAPE_GetName
10595    F5CE  20 76 F5       JSR F_TAPE_Fname_Buf_to_Header			; Put it in the header
10596      
10597    F5D1  20 24 F5       JSR F_TAPE_WriteHeaderID				; Include the Header ID 'HEAD'
10598      
10599    F5D4  A9 E1          LDA #<TMSG_Saving					; Tell the user that we are saving.
10600    F5D6  85 E7          STA TOE_MemptrLo
10601    F5D8  A9 F3          LDA #>TMSG_Saving
10602    F5DA  85 E8          STA TOE_MemptrHi
10603    F5DC  20 60 FF       JSR TOE_PrintStr_vec
10604      
10605    F5DF  20 BF F5       JSR F_TAPE_PrintFname_in_Header			; Print our filename.
10606    
10607    F5E2  20 29 F8       JSR F_TAPE_GetBASIC_Size				; Measure our program
10608      
10609    F5E5  AD 00 09       LDA V_TAPE_BlockSize					; Save our program size to the header
10610    F5E8  8D 13 09       STA TAPE_FileSizeLo
10611    F5EB  AD 01 09       LDA V_TAPE_BlockSize + 1
10612    F5EE  8D 14 09       STA TAPE_FileSizeHi
10613      
10614    F5F1  A9 00          LDA #<Ram_base					; Get our starting pointer for calculating our checksum loaded.
10615    F5F3  85 E5          STA TAPE_BlockLo
10616    F5F5  A9 0C          LDA #>Ram_base
10617    F5F7  85 E6          STA TAPE_BlockHi
10618      
10619    F5F9  20 EE F7       JSR F_TAPE_CalcChecksum				; Get our checksum value
10620    
10621    F5FC  AD 2A 09       LDA TAPE_CS_AccLo					; Store our calculated Checksum
10622    F5FF  8D 28 09       STA TAPE_ChecksumLo
10623    F602  AD 2B 09       LDA TAPE_CS_AccHi
10624    F605  8D 29 09       STA TAPE_ChecksumHi
10625      
10626    F608  A9 00          LDA #<Ram_base					; Include the start of basic to the load address in the header
10627    F60A  8D 15 09       STA TAPE_LoadAddrLo
10628    F60D  A9 0C          LDA #>Ram_base
10629    F60F  8D 16 09       STA TAPE_LoadAddrHi
10630      
10631    F612  A9 00          LDA #C_TAPE_FType_BASIC				; Setup the file type in the header to BASIC
10632    F614  8D 12 09       STA TAPE_FileType
10633      
10634    F617  A9 0E          LDA #<TAPE_Header_Buffer				; Setup our block pointer to the start of the header
10635    F619  85 E5          STA TAPE_BlockLo
10636    F61B  A9 09          LDA #>TAPE_Header_Buffer
10637    F61D  85 E6          STA TAPE_BlockHi
10638      
10639    F61F  A9 1B          LDA #<C_TAPE_HeaderSize				; Load our blocksize with the size of our header buffer
10640    F621  8D 00 09       STA V_TAPE_BlockSize
10641    F624  A9 00          LDA #>C_TAPE_HeaderSize
10642    F626  8D 01 09       STA V_TAPE_BlockSize + 1
10643      
10644    F629  20 C3 F8       JSR F_TAPE_BlockOut					; Write our block to tape
10645      
10646    F62C  A2 C8          LDX #<C_TAPE_Interblock_pause				; Wait a little before writing the actual program data block.
10647    F62E  A0 AF          LDY #>C_TAPE_Interblock_pause
10648    F630  20 DB F7       JSR F_TAPE_Pause
10649      
10650    F633  AD 15 09       LDA TAPE_LoadAddrLo					; Transfer our start address to our Block pointer
10651    F636  85 E5          STA TAPE_BlockLo
10652    F638  AD 16 09       LDA TAPE_LoadAddrHi
10653    F63B  85 E6          STA TAPE_BlockHi
10654      
10655    F63D  AD 13 09       LDA TAPE_FileSizeLo					; Setup our blocksize counter
10656    F640  8D 00 09       STA V_TAPE_BlockSize
10657    F643  AD 14 09       LDA TAPE_FileSizeHi
10658    F646  8D 01 09       STA V_TAPE_BlockSize + 1
10659      
10660    F649  20 C3 F8       JSR F_TAPE_BlockOut					; Write our file
10661        
10662    F64C  60             RTS							; We're done for now.
10663      
10664      
10665    
10666    ; Tape VERIFY routine.
10667    ; --------------------
10668    
10669    F_TAPE_VERIFY_BASIC
10670    
10671    F64D  20 91 F5       JSR F_TAPE_GetName					; Get the filename string into our buffer
10672    
10673    TAPE_VERIFY_Searching_B
10674    
10675    F650  A9 EB          LDA #<TMSG_Searching					; Tell the user that we are searching.
10676    F652  85 E7          STA TOE_MemptrLo
10677    F654  A9 F3          LDA #>TMSG_Searching
10678    F656  85 E8          STA TOE_MemptrHi
10679    F658  20 60 FF       JSR TOE_PrintStr_vec
10680    
10681    TAPE_VERIFY_Header_B
10682    
10683    F65B  A9 0E          LDA #<TAPE_Header_Buffer				; Point to start of header buffer
10684    F65D  85 E5          STA TAPE_BlockLo
10685    F65F  A9 09          LDA #>TAPE_Header_Buffer
10686    F661  85 E6          STA TAPE_BlockHi
10687      
10688    F663  A9 1B          LDA #<C_TAPE_HeaderSize				; Specify how big our header is.
10689    F665  8D 00 09       STA V_TAPE_BlockSize
10690    F668  A9 00          LDA #>C_TAPE_HeaderSize
10691    F66A  8D 01 09       STA V_TAPE_BlockSize + 1
10692      
10693    F66D  20 9F F9       JSR F_TAPE_BlockIn					; Load the header block.
10694      
10695    F670  D0 03          BNE TAPE_BlockIn_EscNotPressed_B
10696    F672  4C FD F6       JMP TAPE_BlockIn_EscHandler				; If escaping jump to the escape handler
10697    
10698    TAPE_BlockIn_EscNotPressed_B
10699    
10700    F675  20 39 F5       JSR F_TAPE_CheckHeaderID				; try again if not a valid header
10701    F678  90 E1          BCC TAPE_VERIFY_Header_B
10702    
10703    F67A  C9 04          CMP #TAPE_Verify_Error
10704    F67C  D0 0E          BNE TAPE_BASVERIFY_Fname_Check
10705    
10706    F67E  A9 5E          LDA #<TMSG_HeaderError				; Tell the user of the header error and retry
10707    F680  85 E7          STA TOE_MemptrLo
10708    F682  A9 F4          LDA #>TMSG_HeaderError
10709    F684  85 E8          STA TOE_MemptrHi
10710    F686  20 60 FF       JSR TOE_PrintStr_vec
10711      
10712    F689  4C 5B F6       JMP TAPE_VERIFY_Header_B				; Keep coming back until the header is read valid or the user presses escape
10713    
10714    
10715    TAPE_BASVERIFY_Fname_Check
10716    F68C  20 CB F4       JSR F_TAPE_PrintFound
10717      
10718    F68F  20 AE F4       JSR F_TAPE_CompareFileNames
10719    F692  90 C7          BCC TAPE_VERIFY_Header_B
10720      
10721    F694  AD 12 09       LDA TAPE_FileType					; We're only interested in verifying BASIC files.
10722    F697  D0 C2          BNE TAPE_VERIFY_Header_B
10723      
10724    TAPE_BASIC_Verify_Stage
10725    
10726    F699  20 29 F8       JSR F_TAPE_GetBASIC_Size				; Put our BASIC program size into V_TAPE_BlockSize.
10727    
10728    F69C  AD 13 09       LDA TAPE_FileSizeLo					; Check our file is the same size as our stored program.
10729    F69F  CD 00 09       CMP V_TAPE_BlockSize
10730    F6A2  D0 35          BNE TAPE_Verify_Error_B
10731    F6A4  AD 14 09       LDA TAPE_FileSizeHi
10732    F6A7  CD 01 09       CMP V_TAPE_BlockSize + 1
10733    F6AA  D0 2D          BNE TAPE_Verify_Error_B
10734       
10735    F6AC  AD 13 09       LDA TAPE_FileSizeLo					; Tell the system how big the file to verify is.
10736    F6AF  8D 00 09       STA V_TAPE_BlockSize
10737    F6B2  AD 14 09       LDA TAPE_FileSizeHi
10738    F6B5  8D 01 09       STA V_TAPE_BlockSize + 1
10739      
10740    F6B8  A9 00          LDA #<Ram_base					; Tell the system where to start verifying the BASIC program,
10741    F6BA  85 E5          STA TAPE_BlockLo					; this should point to Ram_base.
10742    F6BC  A9 0C          LDA #>Ram_base
10743    F6BE  85 E6          STA TAPE_BlockHi
10744      
10745    F6C0  A9 14          LDA #<TMSG_Verifying					; Tell the user that we are verifying.
10746    F6C2  85 E7          STA TOE_MemptrLo
10747    F6C4  A9 F4          LDA #>TMSG_Verifying
10748    F6C6  85 E8          STA TOE_MemptrHi
10749    F6C8  20 60 FF       JSR TOE_PrintStr_vec 
10750        
10751    F6CB  20 F8 F9       JSR F_TAPE_VerifyBlock				; Verify the BASIC program.
10752    
10753    F6CE  AD 30 09       LDA V_TAPE_Verify_Status				; Branch on non load conditions
10754    F6D1  C9 02          CMP #TAPE_Verify_Escape
10755    F6D3  F0 28          BEQ TAPE_BlockIn_EscHandler				; If escaping jump to the escape handler
10756      
10757    F6D5  C9 04          CMP #TAPE_Verify_Error				; Check if verify passed or not.
10758    F6D7  D0 0C          BNE TAPE_BASIC_Verify_OK
10759      
10760    TAPE_Verify_Error_B  
10761    F6D9  A9 34          LDA #<TMSG_VerifyError				; Inform the user of the verification error.
10762    F6DB  85 E7          STA TOE_MemptrLo
10763    F6DD  A9 F4          LDA #>TMSG_VerifyError
10764    F6DF  85 E8          STA TOE_MemptrHi
10765    F6E1  20 60 FF       JSR TOE_PrintStr_vec
10766    F6E4  60             RTS
10767      
10768    TAPE_BASIC_Verify_OK
10769    F6E5  A9 23          LDA #<TMSG_Verified					; Inform the user of verification success.
10770    F6E7  85 E7          STA TOE_MemptrLo
10771    F6E9  A9 F4          LDA #>TMSG_Verified
10772    F6EB  85 E8          STA TOE_MemptrHi
10773    F6ED  20 60 FF       JSR TOE_PrintStr_vec
10774    
10775    TAPE_BASIC_Verify_Done  
10776    F6F0  60             RTS
10777      
10778    
10779    
10780    
10781    
10782    
10783    
10784    ; Tape Reporting routines.
10785    ; ------------------------
10786    
10787    TAPE_BlockIn_LoadErr
10788    F6F1  A9 46          LDA #<TMSG_TapeError					; Tell the user that we are have encountered an error.
10789    F6F3  85 E7          STA TOE_MemptrLo
10790    F6F5  A9 F4          LDA #>TMSG_TapeError
10791    F6F7  85 E8          STA TOE_MemptrHi
10792    F6F9  20 60 FF       JSR TOE_PrintStr_vec
10793    F6FC  60             RTS
10794      
10795    TAPE_BlockIn_EscHandler
10796    F6FD  A9 18          LDA #<LAB_BMSG					; Tell the user that we are have pressed Escape.
10797    F6FF  85 E7          STA TOE_MemptrLo
10798    F701  A9 E9          LDA #>LAB_BMSG
10799    F703  85 E8          STA TOE_MemptrHi
10800    F705  20 60 FF       JSR TOE_PrintStr_vec
10801    F708  60             RTS
10802      
10803      
10804    ;To BASIC 'LOAD' entry point.
10805      
10806    F_TAPE_LOAD_BASIC
10807    
10808    F709  20 91 F5       JSR F_TAPE_GetName					; Get the filename string into our buffer
10809    
10810    TAPE_LOAD_Header_B  
10811    
10812    F70C  A9 EB          LDA #<TMSG_Searching					; Tell the user that we are searching.
10813    F70E  85 E7          STA TOE_MemptrLo
10814    F710  A9 F3          LDA #>TMSG_Searching
10815    F712  85 E8          STA TOE_MemptrHi
10816    F714  20 60 FF       JSR TOE_PrintStr_vec
10817    
10818    TAPE_LOAD_Header_Silent_B
10819    
10820    F717  A9 0E          LDA #<TAPE_Header_Buffer				; Point to start of header buffer
10821    F719  85 E5          STA TAPE_BlockLo
10822    F71B  A9 09          LDA #>TAPE_Header_Buffer
10823    F71D  85 E6          STA TAPE_BlockHi
10824      
10825    F71F  A9 1B          LDA #<C_TAPE_HeaderSize				; Specify how big our header is.
10826    F721  8D 00 09       STA V_TAPE_BlockSize
10827    F724  A9 00          LDA #>C_TAPE_HeaderSize
10828    F726  8D 01 09       STA V_TAPE_BlockSize + 1
10829    
10830    F729  20 9F F9       JSR F_TAPE_BlockIn					; Load the header block.
10831      
10832    F72C  AD 0D 09       LDA TAPE_BlockIn_Status				; Branch on non load conditions
10833    F72F  C9 02          CMP #TAPE_BlockIn_Escape
10834    F731  F0 CA          BEQ TAPE_BlockIn_EscHandler				; If escaping jump to the escape handler
10835      
10836    F733  20 39 F5       JSR F_TAPE_CheckHeaderID				; try again if not a valid header
10837    F736  90 DF          BCC TAPE_LOAD_Header_Silent_B
10838    
10839    F738  C9 04          CMP #TAPE_BlockIn_Error
10840    F73A  D0 0E          BNE TAPE_BASLOAD_Fname_Check
10841    
10842    F73C  A9 5E          LDA #<TMSG_HeaderError				; Tell the user of the header error and retry
10843    F73E  85 E7          STA TOE_MemptrLo
10844    F740  A9 F4          LDA #>TMSG_HeaderError
10845    F742  85 E8          STA TOE_MemptrHi
10846    F744  20 60 FF       JSR TOE_PrintStr_vec
10847    F747  4C 0C F7       JMP TAPE_LOAD_Header_B
10848      
10849    
10850    TAPE_BASLOAD_Fname_Check
10851    F74A  20 CB F4       JSR F_TAPE_PrintFound					; Tell the user what we found.
10852      
10853    F74D  20 AE F4       JSR F_TAPE_CompareFileNames				; Check if our file is the right name
10854    F750  90 BA          BCC TAPE_LOAD_Header_B
10855      
10856    F752  AD 12 09       LDA TAPE_FileType					; We're only interested in loading BASIC files.
10857    F755  D0 B5          BNE TAPE_LOAD_Header_B
10858    
10859    TAPE_BASIC_Load_Stage
10860    F757  AD 13 09       LDA TAPE_FileSizeLo					; Tell the system how big the file to load is.
10861    F75A  8D 00 09       STA V_TAPE_BlockSize
10862    F75D  AD 14 09       LDA TAPE_FileSizeHi
10863    F760  8D 01 09       STA V_TAPE_BlockSize + 1
10864      
10865    F763  A9 00          LDA #<Ram_base					; Tell the system where to load the BASIC program. This should point to Ram_base
10866    F765  85 E5          STA TAPE_BlockLo
10867    F767  A9 0C          LDA #>Ram_base
10868    F769  85 E6          STA TAPE_BlockHi
10869      
10870    F76B  A9 05          LDA #<TMSG_Loading					; Tell the user that we are loading.
10871    F76D  85 E7          STA TOE_MemptrLo
10872    F76F  A9 F4          LDA #>TMSG_Loading
10873    F771  85 E8          STA TOE_MemptrHi
10874    F773  20 60 FF       JSR TOE_PrintStr_vec
10875      
10876    F776  20 9F F9       JSR F_TAPE_BlockIn					; Load the BASIC program.
10877      
10878    F779  AD 0D 09       LDA TAPE_BlockIn_Status				; Branch on non load conditions
10879    F77C  C9 02          CMP #TAPE_BlockIn_Escape
10880    F77E  D0 03          BNE TAPE_Skip_EscHandler_B
10881    F780  4C FD F6       JMP TAPE_BlockIn_EscHandler				; If escaping jump to the escape handler
10882      
10883    TAPE_Skip_EscHandler_B  
10884    
10885    F783  C9 01          CMP #TAPE_BlockIn_Complete
10886    F785  F0 0E          BEQ TAPE_BASIC_LoadingDone
10887    
10888    F787  A9 5E          LDA #<TMSG_HeaderError				; Tell the user of the header error and retry
10889    F789  85 E7          STA TOE_MemptrLo
10890    F78B  A9 F4          LDA #>TMSG_HeaderError
10891    F78D  85 E8          STA TOE_MemptrHi
10892    F78F  20 60 FF       JSR TOE_PrintStr_vec
10893    F792  4C F1 F6       JMP TAPE_BlockIn_LoadErr
10894      
10895    TAPE_BASIC_LoadingDone  
10896    F795  A9 00          LDA #<Ram_base					; Setup our pointer to the start of BASIC Program memory
10897    F797  85 E5          STA TAPE_BlockLo
10898    F799  A9 0C          LDA #>Ram_base
10899    F79B  85 E6          STA TAPE_BlockHi
10900      
10901    F79D  20 EE F7       JSR F_TAPE_CalcChecksum				; Get our checksum value into TAPE_CS_Acc_Lo and Hi
10902      
10903    F7A0  AD 28 09       LDA TAPE_ChecksumLo					; First we check the low byte.
10904    F7A3  CD 2A 09       CMP TAPE_CS_AccLo
10905    F7A6  D0 26          BNE TAPE_CS_Fail
10906      
10907    F7A8  AD 29 09       LDA TAPE_ChecksumHi					; And then if necessary, we check the high byte.
10908    F7AB  CD 2B 09       CMP TAPE_CS_AccHi
10909    F7AE  D0 1E          BNE TAPE_CS_Fail
10910    
10911    F7B0  A9 D7          LDA #<TMSG_Ready					; Inform the user they are back in immediate mode.
10912    F7B2  85 E7          STA TOE_MemptrLo
10913    F7B4  A9 F3          LDA #>TMSG_Ready
10914    F7B6  85 E8          STA TOE_MemptrHi
10915    F7B8  20 60 FF       JSR TOE_PrintStr_vec
10916    
10917    TAPE_BASICload_exit
10918    
10919    F7BB  A5 E5          LDA TAPE_BlockLo					; Return the system to a useable state
10920    F7BD  85 7B          STA Svarl
10921    F7BF  85 7D          STA Sarryl
10922    F7C1  85 7F          STA Earryl
10923    F7C3  A5 E6          LDA TAPE_BlockHi
10924    F7C5  85 7C          STA Svarh
10925    F7C7  85 7E          STA Sarryh
10926    F7C9  85 80          STA Earryh
10927    F7CB  4C 17 C3       JMP LAB_1319						; Tidy up system.
10928      
10929    TAPE_CS_Fail
10930    F7CE  A9 46          LDA #<TMSG_TapeError					; Inform the user of their loading error.
10931    F7D0  85 E7          STA TOE_MemptrLo
10932    F7D2  A9 F4          LDA #>TMSG_TapeError
10933    F7D4  85 E8          STA TOE_MemptrHi
10934    F7D6  20 60 FF       JSR TOE_PrintStr_vec
10935    F7D9  80 E0          BRA TAPE_BASICload_exit
10936      
10937      
10938    F_TAPE_Pause
10939    
10940    F7DB  EA             NOP
10941    F7DC  EA             NOP
10942    F7DD  EA             NOP
10943    F7DE  EA             NOP
10944    F7DF  EA             NOP
10945    F7E0  EA             NOP
10946    F7E1  EA             NOP
10947    F7E2  EA             NOP
10948      
10949    F7E3  CA             DEX
10950    F7E4  E0 FF          CPX #$FF
10951    F7E6  D0 F3          BNE F_TAPE_Pause
10952      
10953    F7E8  88             DEY
10954    F7E9  C0 00          CPY #0
10955    F7EB  D0 EE          BNE F_TAPE_Pause
10956      
10957    F7ED  60             RTS
10958    
10959    
10960    F_TAPE_CalcChecksum
10961    
10962    F7EE  AE 00 09       LDX V_TAPE_BlockSize					; Set up our block counter
10963    F7F1  AC 01 09       LDY V_TAPE_BlockSize + 1
10964        
10965    F7F4  A9 00          LDA #0						; Clear the checksum accumulator
10966    F7F6  8D 2A 09       STA TAPE_CS_AccLo
10967    F7F9  8D 2B 09       STA TAPE_CS_AccHi
10968    
10969    L_TAPE_CS_NEXT  
10970    F7FC  AD 2A 09       LDA TAPE_CS_AccLo					; Add our byte to the checksum
10971    F7FF  18             CLC
10972    F800  72 E5          ADC (TAPE_BlockLo)
10973    F802  8D 2A 09       STA TAPE_CS_AccLo
10974    F805  AD 2B 09       LDA TAPE_CS_AccHi
10975    F808  69 00          ADC #0
10976    F80A  8D 2B 09       STA TAPE_CS_AccHi
10977      
10978    F80D  A5 E5          LDA TAPE_BlockLo					; Advance our pointer.
10979    F80F  18             CLC
10980    F810  69 01          ADC #1
10981    F812  85 E5          STA TAPE_BlockLo
10982    F814  A5 E6          LDA TAPE_BlockHi
10983    F816  69 00          ADC #0
10984    F818  85 E6          STA TAPE_BlockHi
10985      
10986    F81A  CA             DEX							; Repeat until 0
10987    F81B  E0 FF          CPX #$FF
10988    F81D  D0 01          BNE CS_No_Y_update  
10989    F81F  88             DEY
10990    CS_No_Y_update
10991    F820  C0 00          CPY #0
10992    F822  D0 D8          BNE L_TAPE_CS_NEXT
10993    F824  E0 00          CPX #0
10994    F826  D0 D4          BNE L_TAPE_CS_NEXT
10995      
10996    F828  60             RTS
10997    
10998    
10999    F_TAPE_GetBASIC_Size
11000    
11001    F829  38             SEC
11002    F82A  A5 7B          LDA Svarl
11003    F82C  E9 00          SBC #<Ram_base
11004    F82E  8D 00 09       STA V_TAPE_BlockSize
11005    F831  A5 7C          LDA Svarh
11006    F833  E9 0C          SBC #>Ram_base
11007    F835  8D 01 09       STA V_TAPE_BlockSize + 1
11008      
11009    F838  60             RTS
11010    
11011    
11012    ;*****************************************************************************************
11013    ;**                                                                                     **
11014    ;**                Timing and Synchronization functions go here.                        **
11015    ;**                ---------------------------------------------                        **
11016    ;**                                                                                     **
11017    ;*****************************************************************************************
11018    
11019    
11020    ; Wait for 50uS.  Note that JSR's cost 6 cycles
11021    
11022    F_TAPE_Phasetime_pause
11023    ; Each pass takes 10 cycles unless across a page boundary then it's 11 for an error of 10%!!
11024    
11025    ; Also, we need to make up the loss of 12 Cycles in calling it and in theory also the variable loading
11026    ; at the time of the call.
11027    
11028    ; First we disregard 20 cycles, then we burn them at 10 cycles a pass.
11029    
11030    F839  A2 08          LDX #C_TAPE_Phasetime					; 2 Cycles
11031    F83B  CA             DEX							; 2 Cycles saving 10
11032    F83C  CA             DEX							; 2 Cycles saving 10
11033    F83D  EA             NOP							; 2 Cycles
11034    F83E  EA             NOP							; 2 Cycles
11035    F83F  EA             NOP							; 2 Cycles
11036    F840  EA             NOP							; 2 Cycles
11037      
11038    TAPE_Phasetime_loop
11039    F841  CA             DEX							; 2 Cycles
11040    F842  EA             NOP							; 2 Cycles
11041    F843  EA             NOP							; 2 Cycles
11042    F844  EA             NOP							; 2 Cycles
11043    F845  D0 FA          BNE TAPE_Phasetime_loop				; 2 Cycles unless across pages.
11044      
11045    F847  60             RTS							; 6 Cycles
11046      
11047      
11048      
11049      
11050    ;*****************************************************************************************
11051    ;**                                                                                     **
11052    ;**             Output Generating Functions.  Spoiler, It's all bitbashed!              **
11053    ;**             ----------------------------------------------------------              **
11054    ;**                                                                                     **
11055    ;*****************************************************************************************
11056      
11057        
11058    ;===============================================================================================
11059    ; TAPE Bit pulse generator  Takes the Z bit into consideration.
11060    
11061    
11062    F_TAPE_BitGen
11063    
11064    F848  A0 08          LDY #C_TAPE_bitcycles					; Setup bitcycles loop
11065      
11066    TAPE_bitcycles_loop
11067    F84A  48             PHA
11068    F84B  C9 00          CMP #0
11069    F84D  F0 05          BEQ TAPE_No_Pulse
11070      
11071    
11072    F84F  A9 80          LDA #TAPE_out						; Set high phase
11073    F851  8D 40 C0       STA TAPE_IOP
11074    TAPE_No_Pulse
11075    F854  20 39 F8       JSR F_TAPE_Phasetime_pause				; Wait hightone time which is eight times phase time.
11076    F857  20 39 F8       JSR F_TAPE_Phasetime_pause				; This is so that the same loop can be used to capture the data for serial input
11077    F85A  20 39 F8       JSR F_TAPE_Phasetime_pause
11078    F85D  20 39 F8       JSR F_TAPE_Phasetime_pause
11079    F860  20 39 F8       JSR F_TAPE_Phasetime_pause
11080    F863  20 39 F8       JSR F_TAPE_Phasetime_pause
11081    F866  20 39 F8       JSR F_TAPE_Phasetime_pause
11082    F869  20 39 F8       JSR F_TAPE_Phasetime_pause
11083      
11084    
11085      
11086    
11087    F86C  A9 00          LDA #0
11088    F86E  8D 40 C0       STA TAPE_IOP						; Set low phase
11089    F871  20 39 F8       JSR F_TAPE_Phasetime_pause				; Wait hightone time
11090    F874  20 39 F8       JSR F_TAPE_Phasetime_pause
11091    F877  20 39 F8       JSR F_TAPE_Phasetime_pause
11092    F87A  20 39 F8       JSR F_TAPE_Phasetime_pause
11093    F87D  20 39 F8       JSR F_TAPE_Phasetime_pause
11094    F880  20 39 F8       JSR F_TAPE_Phasetime_pause
11095    F883  20 39 F8       JSR F_TAPE_Phasetime_pause
11096    F886  20 39 F8       JSR F_TAPE_Phasetime_pause
11097      
11098    F889  68             PLA
11099    F88A  88             DEY
11100    F88B  D0 BD          BNE TAPE_bitcycles_loop
11101    
11102    F88D  60             RTS
11103      
11104      
11105    ;===============================================================================================  
11106    ; Tape byte output routine LSb first.  Accumulator holds the current byte.
11107    
11108    F_TAPE_ByteOut
11109    F88E  08             PHP								; Save and disable IRQ status.
11110    F88F  78             SEI
11111      
11112    F890  48             PHA								; Generate start bit.
11113    F891  A9 01          LDA #1
11114    F893  20 48 F8       JSR F_TAPE_BitGen
11115    F896  68             PLA
11116    
11117    F897  A2 08          LDX #8							; Set our bit counter for 8 bits.
11118      
11119    TAPE_Nextbit
11120    F899  48             PHA								; Save the byte for later use.
11121    F89A  DA             PHX								; Save our counter
11122      
11123    F89B  29 01          AND #1							; Keep just the bit of interest.
11124    F89D  20 48 F8       JSR F_TAPE_BitGen						; Output our bit.
11125    
11126    F8A0  FA             PLX								; Recover our counter
11127    F8A1  68             PLA								; Recover our working byte out
11128      
11129    F8A2  4A             LSR								; Move on to the next bit
11130    F8A3  CA             DEX								; Decrement our counter
11131      
11132    F8A4  D0 F3          BNE TAPE_Nextbit						; Keep going until completed.
11133      
11134    F8A6  48             PHA								; Generate stop bit
11135    F8A7  A9 00          LDA #0
11136    F8A9  20 48 F8       JSR F_TAPE_BitGen
11137    F8AC  A9 00          LDA #0							; Generate first guard bit
11138    F8AE  20 48 F8       JSR F_TAPE_BitGen
11139    F8B1  A9 00          LDA #0							; Generate second guard bit
11140    F8B3  20 48 F8       JSR F_TAPE_BitGen
11141    F8B6  A9 00          LDA #0							; Generate third guard bit!
11142    F8B8  20 48 F8       JSR F_TAPE_BitGen
11143    F8BB  A9 00          LDA #0							; Generate fourth guard bit!
11144    F8BD  20 48 F8       JSR F_TAPE_BitGen
11145    ;  LDA #0							; Generate fifth guard bit!
11146    ;  JSR F_TAPE_BitGen
11147    ;  LDA #0							; Generate sixth guard bit!
11148    ;  JSR F_TAPE_BitGen
11149    ;  LDA #0							; Generate seventh guard bit!
11150    ;  JSR F_TAPE_BitGen
11151    ;  LDA #0							; Generate EIGHTH guard bit!
11152    ;  JSR F_TAPE_BitGen
11153    F8C0  68             PLA
11154      
11155    F8C1  28             PLP								; Restore IRQ status
11156      
11157    F8C2  60             RTS
11158    
11159    
11160    ;===============================================================================================  
11161    ; Block output routine
11162    ;
11163    ; This requires the starting address and number of bytes output to operate.
11164    ; X contains the low byte of the count, Y contains the high byte and a two byte zero page variable
11165    ; holds the starting address, which is incremented as used.
11166    
11167    F_TAPE_BlockOut
11168    
11169    F8C3  20 F1 F8       JSR F_TAPE_Leader						; Generate block leader
11170    
11171    F8C6  AE 00 09       LDX V_TAPE_BlockSize						; Get the low byte of BlockStart
11172    F8C9  AC 01 09       LDY V_TAPE_BlockSize+1					; Get the high byte of BlockStart
11173      
11174    L_TAPE_BlockOut
11175      
11176    F8CC  B2 E5          LDA (TAPE_BlockLo)						; Get the byte to output to tape
11177      
11178    F8CE  DA             PHX
11179    F8CF  5A             PHY
11180    F8D0  20 8E F8       JSR F_TAPE_ByteOut						; Transmit the byte.
11181    F8D3  7A             PLY
11182    F8D4  FA             PLX
11183      
11184    F8D5  A5 E5          LDA TAPE_BlockLo						; Increment our byte pointer
11185    F8D7  18             CLC
11186    F8D8  69 01          ADC #1
11187    F8DA  85 E5          STA TAPE_BlockLo
11188    F8DC  A5 E6          LDA TAPE_BlockHi
11189    F8DE  69 00          ADC #0
11190    F8E0  85 E6          STA TAPE_BlockHi
11191    
11192    TAPE_BlockOut_DecCounter
11193    F8E2  CA             DEX
11194    F8E3  E0 FF          CPX #$FF
11195    F8E5  D0 01          BNE TAPE_BlockOut_CheckZero_B
11196    F8E7  88             DEY
11197      
11198    TAPE_BlockOut_CheckZero_B
11199    F8E8  C0 00          CPY #0
11200    F8EA  D0 E0          BNE L_TAPE_BlockOut
11201    F8EC  E0 00          CPX #0
11202    F8EE  D0 DC          BNE L_TAPE_BlockOut
11203    
11204    TAPE_BlockOut_Finish  
11205    F8F0  60             RTS
11206      
11207    
11208    ;===============================================================================================  
11209    ; Tape leader_tone  
11210    
11211    F_TAPE_Leader
11212    F8F1  A2 64          LDX #TAPE_Leader_Bytes				; Put the leader cycles low byte into X
11213    
11214    TAPE_leader_lp
11215    F8F3  DA             PHX							; Save our cycle counter for later
11216      
11217    F8F4  A9 AA          LDA #C_TAPE_LeaderByte
11218    F8F6  20 8E F8       JSR F_TAPE_ByteOut					; Send leader byte
11219    
11220    
11221    F8F9  FA             PLX							; Retrieve our counter
11222    
11223    F8FA  CA             DEX							; Decrement our counter
11224    F8FB  D0 F6          BNE TAPE_leader_lp					; and loopback as necessary
11225    F8FD  A9 55          LDA #C_TAPE_EndOfLeaderByte
11226    F8FF  20 8E F8       JSR F_TAPE_ByteOut					; Send Terminating byte
11227    
11228    F902  60             RTS
11229    
11230    
11231    ;*****************************************************************************************
11232    ;**                                                                                     **
11233    ;**              Input Generating Functions.  Spoiler, It's all bitbashed!              **
11234    ;**              ---------------------------------------------------------              **
11235    ;**                                                                                     **
11236    ;*****************************************************************************************
11237    
11238    
11239    ;===============================================================================================  
11240    ; Tape line status sampler, temporarily flipped  
11241    
11242    
11243    F_TAPE_Sample_Tapeline
11244    F903  AD 40 C0       LDA TAPE_IOP						; Get sample
11245    F906  29 40          AND #TAPE_in
11246      
11247    F908  F0 02          BEQ TAPE_line_low					; Set or clear carry as needed.
11248    F90A  38             SEC
11249    F90B  60             RTS
11250      
11251    TAPE_line_low
11252    F90C  18             CLC
11253    F90D  60             RTS
11254    
11255    
11256    ;===============================================================================================
11257    ; Pulse Decoding engine.  This is where deserialisation happens.
11258    
11259    TAPE_PulseDecoder
11260    F90E  AD 08 09       LDA TAPE_StartDet					; If the start bit has been detected
11261    F911  D0 1A          BNE TAPE_SamplePos_Check				; Seek rising edge and end otherwise
11262      
11263    F913  AD 06 09       LDA TAPE_Demod_Status					; Detect rising edge
11264    F916  F0 14          BEQ TAPE_NotRising
11265    F918  AD 07 09       LDA TAPE_Demod_Last
11266    F91B  D0 0F          BNE TAPE_NotRising
11267    
11268    F91D  A9 01          LDA #1						; Store rising edge signal
11269    F91F  8D 08 09       STA TAPE_StartDet
11270    F922  A9 14          LDA #C_TAPE_Sample_Offset				; Start the counter for mid-bit
11271    F924  8D 0C 09       STA TAPE_Sample_Position
11272    F927  A9 0A          LDA #C_TAPE_BitsPerFrame
11273    F929  8D 0A 09       STA TAPE_BitsToDecode
11274    
11275    TAPE_NotRising
11276    F92C  60             RTS
11277    
11278    TAPE_SamplePos_Check
11279    F92D  A9 00          LDA #0						; Are we at the bit sample position
11280    F92F  CD 0C 09       CMP TAPE_Sample_Position
11281    F932  F0 04          BEQ TAPE_AtStartBit
11282      
11283    F934  CE 0C 09       DEC TAPE_Sample_Position				; Decrement sample position end.
11284    F937  60             RTS
11285      
11286    TAPE_AtStartBit						; At start bit?
11287    F938  AD 0A 09       LDA TAPE_BitsToDecode
11288    F93B  C9 0A          CMP #C_TAPE_BitsPerFrame
11289    F93D  D0 17          BNE TAPE_AtStopBit
11290      
11291    F93F  AD 06 09       LDA TAPE_Demod_Status					; Branch on start bit state.
11292    F942  D0 09          BNE TAPE_AdjustCountersStart
11293      
11294    F944  A9 00          LDA #0						; Path of invalid start bit.
11295    F946  8D 08 09       STA TAPE_StartDet					; Clear start condition
11296    F949  8D 09 09       STA TAPE_RX_Status					; and status register.
11297    F94C  60             RTS
11298      
11299    TAPE_AdjustCountersStart
11300    F94D  A9 36          LDA #C_TAPE_Bitlength					; Start the counter for the next bit to sample
11301    F94F  8D 0C 09       STA TAPE_Sample_Position
11302    F952  CE 0A 09       DEC TAPE_BitsToDecode
11303    F955  60             RTS
11304      
11305    TAPE_AtStopBit						; Stop bit?
11306    F956  AD 0A 09       LDA TAPE_BitsToDecode
11307    F959  C9 01          CMP #1
11308    F95B  D0 1B          BNE TAPE_AtDataBit
11309    
11310    F95D  AD 06 09       LDA TAPE_Demod_Status
11311    F960  D0 0B          BNE TAPE_Overrun
11312      
11313    F962  A9 00          LDA #0						; Clear Start detect bit
11314    F964  8D 08 09       STA TAPE_StartDet
11315    F967  A9 04          LDA #TAPE_Stat_RXFull					; Indicate byte received
11316    F969  8D 09 09       STA TAPE_RX_Status
11317    F96C  60             RTS
11318      
11319    TAPE_Overrun
11320    F96D  A9 00          LDA #0						; Clear Start detect bit
11321    F96F  8D 08 09       STA TAPE_StartDet
11322    F972  A9 01          LDA #TAPE_Stat_overrun				; Indicate byte received
11323    F974  8D 09 09       STA TAPE_RX_Status
11324    F977  60             RTS
11325    
11326    TAPE_AtDataBit
11327    F978  AD 06 09       LDA TAPE_Demod_Status					; Shift our bit into the byte received LSb when not a stop bit
11328    F97B  6A             ROR
11329    F97C  6E 0B 09       ROR TAPE_ByteReceived
11330      
11331    
11332    F97F  CE 0A 09       DEC TAPE_BitsToDecode					; Adjust counters accordingly
11333    F982  A9 36          LDA #C_TAPE_Bitlength
11334    F984  8D 0C 09       STA TAPE_Sample_Position
11335     
11336    F987  60             RTS
11337      
11338      
11339    
11340    
11341    ;*****************************************************************************************
11342    ;**                                                                                     **
11343    ;**           Tape Input Functions.  These are all hand calibrated so take care.        **
11344    ;**           ------------------------------------------------------------------        **
11345    ;**                                                                                     **
11346    ;*****************************************************************************************
11347    
11348    
11349    
11350    
11351    
11352    F_TAPE_FindStart
11353    F988  20 53 FA       JSR F_TAPE_GetByte
11354    F98B  AD 09 09       LDA TAPE_RX_Status
11355      
11356    F98E  C9 08          CMP #TAPE_Stat_Escape						; Break on Escape condition
11357    F990  D0 01          BNE TAPE_LeaderNoBreak
11358      
11359    F992  60             RTS
11360      
11361    TAPE_LeaderNoBreak
11362    F993  C9 01          CMP #TAPE_Stat_overrun
11363    F995  F0 F1          BEQ F_TAPE_FindStart
11364      
11365    F997  AD 0B 09       LDA TAPE_ByteReceived
11366    F99A  C9 55          CMP #C_TAPE_EndOfLeaderByte					; Keep trying until end of leader byte is received
11367    F99C  D0 EA          BNE F_TAPE_FindStart
11368      
11369    F99E  60             RTS
11370    
11371    
11372    
11373    
11374    ;===============================================================================================  
11375    ; Block read routine
11376    ;
11377    ; This requires the starting address and number of bytes output to operate.
11378    ; X contains the low byte of the count, Y contains the high byte and a two byte zero page variable
11379    ; holds the starting address, which is incremented as used.
11380    
11381    F_TAPE_BlockIn
11382    
11383    F99F  20 88 F9       JSR F_TAPE_FindStart						; Follow the leader signal
11384      
11385    F9A2  AD 09 09       LDA TAPE_RX_Status
11386    F9A5  C9 08          CMP #TAPE_Stat_Escape
11387    F9A7  F0 1D          BEQ TAPE_BlockIn_Sig_Escape
11388      
11389    F9A9  AE 00 09       LDX V_TAPE_BlockSize						; Get the low byte of BlockStart
11390    F9AC  AC 01 09       LDY V_TAPE_BlockSize+1					; Get the high byte of BlockStart
11391      
11392    F9AF  A9 00          LDA #0							; Initialise BlockIn's status register
11393    F9B1  8D 0D 09       STA TAPE_BlockIn_Status
11394      
11395    L_TAPE_BlockIn
11396    
11397    F9B4  DA             PHX								; Get a byte from the tape interface
11398    F9B5  5A             PHY
11399    F9B6  20 53 FA       JSR F_TAPE_GetByte
11400    F9B9  7A             PLY
11401    F9BA  FA             PLX
11402      
11403    F9BB  AD 09 09       LDA TAPE_RX_Status						; failing gracefully upon bad events.
11404    F9BE  C9 04          CMP #TAPE_Stat_RXFull
11405    F9C0  F0 10          BEQ TAPE_BlockIn_Store
11406      
11407    F9C2  C9 08          CMP #TAPE_Stat_Escape
11408    F9C4  D0 06          BNE TAPE_BlockIn_CheckError
11409      
11410    TAPE_BlockIn_Sig_Escape  
11411    F9C6  A9 02          LDA #TAPE_BlockIn_Escape
11412    F9C8  8D 0D 09       STA TAPE_BlockIn_Status
11413    F9CB  60             RTS								; Escape
11414      
11415    TAPE_BlockIn_CheckError  
11416    F9CC  A9 04          LDA #TAPE_BlockIn_Error
11417    F9CE  8D 0D 09       STA TAPE_BlockIn_Status
11418    F9D1  60             RTS								; Failed  
11419      
11420    TAPE_BlockIn_Store
11421    F9D2  AD 0B 09       LDA TAPE_ByteReceived						; Store our received byte to our current pointer address.
11422    F9D5  92 E5          STA (TAPE_BlockLo)
11423    
11424    F9D7  A5 E5          LDA TAPE_BlockLo						; Increment our byte pointer
11425    F9D9  18             CLC
11426    F9DA  69 01          ADC #1
11427    F9DC  85 E5          STA TAPE_BlockLo
11428    F9DE  A5 E6          LDA TAPE_BlockHi
11429    F9E0  69 00          ADC #0
11430    F9E2  85 E6          STA TAPE_BlockHi
11431    
11432    TAPE_BlockIn_DecCounter
11433    F9E4  CA             DEX
11434    F9E5  E0 FF          CPX #$FF
11435    F9E7  D0 01          BNE TAPE_CheckBlockInCounterZero_B
11436    F9E9  88             DEY
11437    
11438    TAPE_CheckBlockInCounterZero_B  
11439    F9EA  C0 00          CPY #0
11440    F9EC  D0 C6          BNE L_TAPE_BlockIn
11441    F9EE  E0 00          CPX #0
11442    F9F0  D0 C2          BNE L_TAPE_BlockIn
11443    
11444    TAPE_BlockIn_Finish
11445    F9F2  A9 01          LDA #TAPE_BlockIn_Complete					; Indicate tast completion
11446    F9F4  8D 0D 09       STA TAPE_BlockIn_Status
11447    F9F7  60             RTS
11448       
11449      
11450    F_TAPE_VerifyBlock
11451    
11452    F9F8  20 88 F9       JSR F_TAPE_FindStart						; Follow the leader signal
11453      
11454    F9FB  AD 09 09       LDA TAPE_RX_Status
11455    F9FE  C9 08          CMP #TAPE_Stat_Escape
11456    FA00  F0 1D          BEQ TAPE_Verify_Sig_Escape
11457      
11458    FA02  AE 00 09       LDX V_TAPE_BlockSize						; Get the low byte of BlockStart
11459    FA05  AC 01 09       LDY V_TAPE_BlockSize+1					; Get the high byte of BlockStart
11460      
11461    FA08  A9 01          LDA #TAPE_Verify_Good						; Initialise Verify's status register
11462    FA0A  8D 30 09       STA V_TAPE_Verify_Status
11463      
11464    L_TAPE_BlockVerify
11465    
11466    FA0D  DA             PHX								; Get a byte from the tape interface
11467    FA0E  5A             PHY
11468    FA0F  20 53 FA       JSR F_TAPE_GetByte
11469    FA12  7A             PLY
11470    FA13  FA             PLX
11471      
11472    FA14  AD 09 09       LDA TAPE_RX_Status						; did we capture a good byte?
11473    FA17  C9 04          CMP #TAPE_Stat_RXFull
11474    FA19  F0 10          BEQ TAPE_Verify_Check
11475      
11476    FA1B  C9 08          CMP #TAPE_Stat_Escape						; Did we press escape?
11477    FA1D  D0 06          BNE TAPE_Verify_CheckError
11478      
11479    TAPE_Verify_Sig_Escape  
11480    FA1F  A9 02          LDA #TAPE_Verify_Escape					; Signal that we pressed escape and return.
11481    FA21  8D 30 09       STA V_TAPE_Verify_Status
11482    FA24  60             RTS
11483      
11484    TAPE_Verify_CheckError						; Signal the encountered error and return.
11485    FA25  A9 04          LDA #TAPE_Verify_Error
11486    FA27  8D 30 09       STA V_TAPE_Verify_Status
11487    FA2A  60             RTS  
11488      
11489    TAPE_Verify_Check
11490    FA2B  AD 0B 09       LDA TAPE_ByteReceived						; Compare our fectched byte with the one in BASIC memory.
11491    FA2E  D2 E5          CMP (TAPE_BlockLo)
11492    FA30  D0 F3          BNE TAPE_Verify_CheckError					; Signal inconsistency as an error.
11493      
11494    FA32  A5 E5          LDA TAPE_BlockLo						; Increment our byte pointer
11495    FA34  18             CLC
11496    FA35  69 01          ADC #1
11497    FA37  85 E5          STA TAPE_BlockLo
11498    FA39  A5 E6          LDA TAPE_BlockHi
11499    FA3B  69 00          ADC #0
11500    FA3D  85 E6          STA TAPE_BlockHi
11501    
11502    TAPE_Verify_DecCounter
11503    FA3F  CA             DEX
11504    FA40  E0 FF          CPX #$FF
11505    FA42  D0 01          BNE TAPE_CheckCounterZero_B
11506    FA44  88             DEY
11507      
11508    TAPE_CheckCounterZero_B
11509    FA45  C0 00          CPY #0							; Check to see if we have done yet.
11510    FA47  D0 C4          BNE L_TAPE_BlockVerify
11511    FA49  E0 00          CPX #0
11512    FA4B  D0 C0          BNE L_TAPE_BlockVerify
11513      
11514    TAPE_Verify_Finish
11515    FA4D  A9 01          LDA #TAPE_Verify_Good						; Indicate test completion
11516    FA4F  8D 30 09       STA V_TAPE_Verify_Status
11517    FA52  60             RTS
11518    
11519    
11520    ;===============================================================================================
11521    ; Byte Reader.
11522    
11523    F_TAPE_GetByte
11524    
11525    ; First some initial housekeeping
11526    
11527    FA53  08             PHP							; Save and disable IRQ status
11528    FA54  78             SEI
11529    
11530    FA55  A9 00          LDA #0
11531    FA57  8D 06 09       STA TAPE_Demod_Status					; Start our bit demod with zero.
11532    FA5A  8D 07 09       STA TAPE_Demod_Last					; Set our initial demod status too.
11533    FA5D  8D 05 09       STA TAPE_LineUptime					; Set our initial uptime counter to zero.
11534    FA60  8D 09 09       STA TAPE_RX_Status					; Clear our Status register
11535      
11536    TAPE_pulselatch
11537      
11538    FA63  AD 09 09       LDA TAPE_RX_Status
11539    FA66  D0 0A          BNE TAPE_ByteCaptured					; Check status for received byte.
11540      
11541    FA68  20 3A F0       JSR ACIA1in						; Just in case the user needs to get out of this loop
11542    FA6B  90 07          BCC TAPE_ContLoop					; Caught in a landsliiiide, no escape TO re-al-ih-teeeee!
11543    FA6D  A9 08          LDA #TAPE_Stat_Escape
11544    FA6F  8D 09 09       STA TAPE_RX_Status
11545      
11546    
11547    TAPE_ByteCaptured
11548    FA72  28             PLP							; Restore IRQ status
11549      
11550    FA73  60             RTS							; Done
11551    
11552    
11553    ; Services that use the pulse decoded go here.
11554    
11555    TAPE_ContLoop
11556      ; JSR TAPE_TestOutput					; Set our status
11557    FA74  20 0E F9       JSR TAPE_PulseDecoder					; We gotta do something with these pulses right...?
11558    
11559    FA77  AD 06 09       LDA TAPE_Demod_Status					; Update some variables
11560    FA7A  8D 07 09       STA TAPE_Demod_Last
11561    
11562    ; =-=-=-=-=-=-=-=-----------------=-=-=-=-=-=-=-=---------=-=-=-=-=-=-=-=-
11563    ;
11564    ; The actual pulse demodulation code starts here
11565    ;
11566    ; =-=-=-=-=-=-=-=-----------------=-=-=-=-=-=-=-=---------=-=-=-=-=-=-=-=-
11567      
11568    FA7D  20 39 F8       JSR F_TAPE_Phasetime_pause				; and delay for our respective looptime
11569      
11570    FA80  20 03 F9       JSR F_TAPE_Sample_Tapeline				; Update status
11571    FA83  90 0A          BCC TAPE_DontSet
11572      
11573    FA85  A9 01          LDA #1
11574    FA87  8D 06 09       STA TAPE_Demod_Status					; Set our line status to up
11575    FA8A  A9 0A          LDA #10						; THIS WAS WORKING AT 7
11576    FA8C  8D 05 09       STA TAPE_LineUptime					; Reset our latch counter
11577      
11578    TAPE_DontSet
11579    FA8F  AD 05 09       LDA TAPE_LineUptime
11580    FA92  F0 06          BEQ TAPE_AtMinimum
11581      
11582    FA94  CE 05 09       DEC TAPE_LineUptime
11583    FA97  4C 63 FA       JMP TAPE_pulselatch
11584        
11585    TAPE_AtMinimum
11586    FA9A  A9 00          LDA #0						; Clear our line status
11587    FA9C  8D 06 09       STA TAPE_Demod_Status
11588    FA9F  4C 63 FA       JMP TAPE_pulselatch
11589    
11590    
11591      .INCLUDE "AY_DRIVER.asm"
11592    ; AY-3-891x Register Driver
11593    ;
11594    ; By Duncan Gunn.
11595    
11596    
11597    ; AY_6522 Registers
11598    
11599      C0E0             AY_6522_Base	 	=	$C0E0
11600      C0E0             AY_6522_ORB		=	AY_6522_Base
11601      C0E1             AY_6522_ORA		=	AY_6522_Base + $01
11602      C0E2             AY_6522_DDRB		=	AY_6522_Base + $02
11603      C0E3             AY_6522_DDRA		=	AY_6522_Base + $03
11604      C0E4             AY_6522_T1C_L		=	AY_6522_Base + $04
11605      C0E5             AY_6522_T1C_H		=	AY_6522_Base + $05
11606      C0E6             AY_6522_L1L_L		=	AY_6522_Base + $06
11607      C0E7             AY_6522_L1L_H		=	AY_6522_Base + $07
11608      C0E8             AY_6522_T2C_L		=	AY_6522_Base + $08
11609      C0E9             AY_6522_T2C_H		=	AY_6522_Base + $09
11610      C0EA             AY_6522_SR		=	AY_6522_Base + $0A
11611      C0EB             AY_6522_ACR		=	AY_6522_Base + $0B
11612      C0EC             AY_6522_PCR		=	AY_6522_Base + $0C
11613      C0ED             AY_6522_IFR		=	AY_6522_Base + $0D
11614      C0EE             AY_6522_IER		=	AY_6522_Base + $0E
11615      C0EF             AY_6522_ORA_IRA		=	AY_6522_Base + $0F
11616    
11617    
11618    ; AY_6522 HW Mappings.
11619    
11620      C0E0             AY_DATAPORT		=	AY_6522_ORB
11621      C0E2             AY_DDR_DATA		=	AY_6522_DDRB
11622    
11623      C0E1             AY_CTRLPORT		=	AY_6522_ORA
11624      C0E3             AY_DDR_CTRL		=	AY_6522_DDRA
11625    
11626      0001             AY_CTRL_bit_BC1		= 	@00000001
11627      0002             AY_CTRL_bit_BDIR	=	@00000010
11628    
11629      0003             AY_CTRL_dir		=	AY_CTRL_bit_BC1 | AY_CTRL_bit_BDIR	; Set relevant port bits as outputs
11630      00FF             AY_DATA_out		=	$FF
11631      0000             AY_DATA_in		=	$0
11632    
11633    
11634    
11635    ; AY Registers
11636    
11637      0000             AY_CH_A_TP_FINE		= $0
11638      0001             AY_CH_A_TP_COARSE	= $1	; Bottom four bits only
11639      0002             AY_CH_B_TP_FINE		= $2
11640      0003             AY_CH_B_TP_COARSE	= $3	; Bottom four bits only
11641      0004             AY_CH_C_TP_FINE		= $4
11642      0005             AY_CH_C_TP_COARSE	= $5
11643      0006             AY_NOISE_PERIOD		= $6	; Bottom five bits only
11644      0007             AY_NOT_ENABLE		= $7	; Bitfield: See table 1 below
11645      0008             AY_CH_A_AMP		= $8	; M (Bit 5) when set uses the Envelope gen, otherwise B3-B0 sets the volume
11646      0009             AY_CH_B_AMP		= $9	; See channel A
11647      000A             AY_CH_C_AMP		= $A	; See channel A
11648      000B             AY_ENV_P_FINE		= $B	
11649      000C             AY_ENV_P_COARSE		= $C
11650      000D             AY_ENV_SH_CYC		= $D	; See table 2 below
11651      000E             AY_PORTA_REG		= $E	; Not implemented for the AY-3-8912
11652      000F             AY_PORTB_REG		= $F	; Not implemented for the AY-3-8912
11653    
11654    
11655    ; Table 1.  AY_NOT_ENABLE bitfield.
11656    ;
11657    ; +---------+-----------+-----------+
11658    ; | IN/nOUT |   nNOISE  |   nTONE   |
11659    ; +----+----+---+---+---+---+---+---+
11660    ; |IOB |IOA | C | B | A | C | B | A |
11661    ; +----+----+---+---+---+---+---+---+
11662    
11663      0020             AY_bit_nNOISE_C		= @00100000
11664      0010             AY_bit_nNOISE_B		= @00010000
11665      0008             AY_bit_nNOISE_A		= @00001000
11666      0004             AY_bit_nTONE_C		= @00000100
11667      0002             AY_bit_nTONE_B		= @00000010
11668      0001             AY_bit_nTONE_A		= @00000001
11669    
11670    
11671    ; Table 2.  Envelope shape/cycle bitfield.
11672    ;
11673    ; +--------+--------+--------+--------+--------+--------+--------+--------+
11674    ; |   B7   |   B6   |   B5   |   B4   |   B3   |   B2   |   B1   |   B0   |
11675    ; +--------+--------+--------+--------+--------+--------+--------+--------+
11676    ; |          B7-B4 Not used.          | Cont   | Attack | Alt    | Hold   |
11677    ; +--------+--------+--------+--------+--------+--------+--------+--------+
11678    ;
11679    ; CONTinue causes the pattern to cycle when set.
11680    ; Setting Attack makes the envelope counter count up, but when cleared causes a count down instead.
11681    ; Setting ALTernate causes the counter to reverse direction at the end of each cycle.
11682    ; Setting HOLD limits the envelope generator to one cycle
11683    
11684      0008             AY_bit_CONT		= @00001000
11685      0004             AY_bit_ATTACK		= @00000100
11686      0002             AY_bit_ALT		= @00000010
11687      0001             AY_bit_HOLD		= @00000001
11688    
11689    
11690    ; AY control modes
11691    
11692      0000             AY_INACK		= 0
11693      0001             AY_READ			= AY_CTRL_bit_BC1
11694      0002             AY_WRITE		= AY_CTRL_bit_BDIR
11695      0003             AY_LAT_ADDR		= AY_CTRL_bit_BC1 | AY_CTRL_bit_BDIR
11696    
11697    
11698    ; AY Soundcard memory allocations.
11699    
11700      0A00             AY_Memstart		= $A00
11701      0A00             AY_Reg			= AY_Memstart
11702      0A01             AY_Data			= AY_Reg + 1
11703    
11704    
11705    ; AY_Initialisation routine.
11706    
11707    AY_Init
11708    FAA2  A9 00          LDA #0
11709    FAA4  8D E1 C0       STA AY_CTRLPORT	; Let's make our control port inactive first.
11710    FAA7  A9 03          LDA #AY_CTRL_dir
11711    FAA9  8D E3 C0       STA AY_DDR_CTRL
11712      
11713    
11714    FAAC  A2 0F          LDX #$F		; Clear all the registers
11715    AY_Init_Loop
11716    
11717    FAAE  A9 00          LDA #0
11718    FAB0  20 F2 FA       JSR AY_wr_to_reg
11719    FAB3  CA             DEX
11720    FAB4  D0 F8          BNE AY_Init_Loop
11721    FAB6  60             RTS
11722      
11723    
11724    ; AY register read-write primitives
11725    ;
11726    
11727    ; Writes the register address to the AY
11728    ;
11729    ; Takes A as the register parameter. Corrupts A
11730    AY_wr_reg
11731    FAB7  8D E0 C0       STA AY_DATAPORT	; Place our register value on the AY bus
11732      
11733    FABA  A9 FF          LDA #AY_DATA_out
11734    FABC  8D E2 C0       STA AY_DDR_DATA	; And ensure the bus is an output.
11735      
11736    FABF  A9 03          LDA #AY_LAT_ADDR	; Latch our data to the AY
11737    FAC1  8D E1 C0       STA AY_CTRLPORT
11738      ;NOP
11739      ;NOP
11740    FAC4  A9 00          LDA #AY_INACK		; And ensure out bus goes inactive again.
11741    FAC6  8D E1 C0       STA AY_CTRLPORT
11742    FAC9  60             RTS
11743    
11744    ; Writes data to the currently selected register
11745    ;
11746    ; Takes A as the register parameter. Corrupts A
11747    AY_wr_data
11748    FACA  8D E0 C0       STA AY_DATAPORT	; Place our data on the AY bus
11749    
11750    FACD  A9 FF          LDA #AY_DATA_out
11751    FACF  8D E2 C0       STA AY_DDR_DATA
11752        
11753    FAD2  A9 02          LDA #AY_WRITE
11754    FAD4  8D E1 C0       STA AY_CTRLPORT
11755      ;NOP
11756      ;NOP
11757    FAD7  A9 00          LDA #AY_INACK		; And ensure the bus is an output.
11758    FAD9  8D E1 C0       STA AY_CTRLPORT
11759    FADC  60             RTS
11760    
11761    ; Read register		; Corrupts Y, returns the result in A.
11762    AY_rd_data
11763    FADD  A9 00          LDA #AY_DATA_in	; Make our bus an input so that the AY can drive it.
11764    FADF  8D E2 C0       STA AY_DDR_DATA
11765      
11766    FAE2  A9 01          LDA #AY_READ		; Set our AY to output it's register contents
11767    FAE4  8D E1 C0       STA AY_CTRLPORT
11768      
11769    FAE7  AD E0 C0       LDA AY_DATAPORT	; Grab those contents and put them in Y
11770    FAEA  A8             TAY
11771      
11772    FAEB  A9 00          LDA #AY_INACK		; Put our AY but back inactive.
11773    FAED  8D E1 C0       STA AY_CTRLPORT
11774      
11775    FAF0  98             TYA			; Put our result back into A
11776      
11777    FAF1  60             RTS			; Were finished.
11778      
11779      
11780    ; The 'All in one' function.
11781    ;
11782    AY_wr_to_reg
11783    FAF2  48             PHA
11784    FAF3  8A             TXA
11785      
11786    FAF4  20 B7 FA       JSR AY_wr_reg
11787    FAF7  68             PLA
11788    FAF8  20 CA FA       JSR AY_wr_data
11789    FAFB  60             RTS
11790      
11791    
11792    ; For the users of BASIC, here's the easier read/write functions. 
11793    
11794    AY_Userwrite
11795    FAFC  AD 01 0A       LDA AY_Data
11796    FAFF  AE 00 0A       LDX AY_Reg
11797    FB02  20 F2 FA       JSR AY_wr_to_reg
11798    FB05  60             RTS
11799      
11800    AY_Userread
11801    FB06  AD 00 0A       LDA AY_Reg		; Select our register of interest.
11802    FB09  20 B7 FA       JSR AY_wr_reg
11803      
11804    FB0C  20 DD FA       JSR AY_rd_data	; Get the contents of the register of interest.
11805    FB0F  8D 01 0A       STA AY_Data
11806    FB12  60             RTS
11807      .INCLUDE "IRQ_Handler.asm"
11808    ; IRQ Manager.
11809    ;
11810    ; Interrupt request handling and masking on per device basis.
11811    
11812    
11813    ; System constants
11814    
11815      0000             IRQH_Version_C		= 0					; Version 0 (Pre-release)
11816    
11817    
11818    ; IRQ Handler command codes
11819    ;
11820      0000             IRQH_Service_CMD	= 0					; Request IRQ Service
11821      0001             IRQH_Shutdown_CMD	= 1					; Shutdown IRQ gracefully
11822      0002             IRQH_Reset_CMD		= 2					; Reset the IRQ handler.
11823    
11824    
11825    ; IRQ Memory table
11826    ;
11827      0A20             IRQH_Table_Base		= $A20 					; Beginning of IRQ Handler Memory.
11828      0A20             IRQH_CallList		= IRQH_Table_Base			; All sixteen bytes for eight addresses.
11829      0A30             IRQH_CallReg		= IRQH_CallList + 16			; Two bytes containing an address being transferred.
11830      0A32             IRQH_ClaimsList		= IRQH_CallReg + 2			; Byte with list of calls that returned and IRQ Claim
11831      0A33             IRQH_MaskByte		= IRQH_ClaimsList + 1			; Byte containing IRQ Table entry mask bits. IRQ entry LSb is IRQ entry 0.
11832      0A34             IRQH_WorkingMask	= IRQH_MaskByte + 1			; Walking bit for masking and setting purposes.
11833      0A35             IRQH_CurrentEntry	= IRQH_WorkingMask + 1			; Pointer for IRQ Table entries.
11834      0A36             IRQH_CMD_Table		= IRQH_CurrentEntry + 1			; Table of IRQ handler commands with parameter space.  16 bytes.
11835    
11836      0016             IRQH_zero_range_C	= IRQH_CurrentEntry+17-IRQH_CallReg	; Amount to zero after IRQH_CallList.
11837    
11838    ; Table current size is 21 bytes.
11839    
11840    
11841    ; IRQ Handler Initialisation Call
11842    
11843    IRQH_Handler_Init_F
11844    FB13  78             SEI						; Disable IRQ's so we don't break anything already happening.
11845      
11846    FB14  A9 3B          LDA #<IRQH_Null_F				; Put the null IRQ Function address into IRQ_CallReg
11847    FB16  8D 30 0A       STA IRQH_CallReg
11848    FB19  A9 FB          LDA #>IRQH_Null_F
11849    FB1B  8D 31 0A       STA IRQH_CallReg + 1
11850      
11851    FB1E  A9 07          LDA #7					; Point at the last table entry
11852    FB20  A8             TAY
11853    
11854    IRQH_FillTable_L
11855    FB21  20 47 FB       JSR IRQH_SetIRQ_F				; Iterate copy to whole table
11856      
11857    FB24  98             TYA
11858    FB25  38             SEC
11859    FB26  E9 01          SBC #1
11860    FB28  A8             TAY
11861      
11862    FB29  B0 F6          BCS IRQH_FillTable_L
11863      
11864    FB2B  A9 00          LDA #0					; Clear rest of the IRQ Handler's structure.
11865    FB2D  A2 00          LDX #0
11866      
11867    IRQH_FillRemaining_L
11868    FB2F  A9 00          LDA #0
11869    FB31  9D 30 0A       STA IRQH_CallReg,X
11870    FB34  E8             INX
11871      
11872    FB35  8A             TXA						; Stop when the table is full.
11873    FB36  C9 16          CMP #IRQH_zero_range_C
11874    FB38  D0 F5          BNE IRQH_FillRemaining_L
11875      
11876    FB3A  60             RTS						; Return to caller.
11877      
11878      
11879    ; IRQ Null function
11880    
11881    IRQH_Null_F
11882    FB3B  AD 34 0A       LDA IRQH_WorkingMask				; Get our Working position
11883      
11884    FB3E  49 FF          EOR #$FF					; Unset our Claim bit.
11885    FB40  2D 32 0A       AND IRQH_ClaimsList
11886    FB43  8D 32 0A       STA IRQH_ClaimsList
11887      
11888    FB46  60             RTS
11889      
11890    
11891    ; Function to atomically add an IRQ to the IRQ Table.
11892    
11893    IRQH_SetIRQ_F
11894    
11895    FB47  08             PHP						; Assure atomic
11896    FB48  78             SEI
11897      
11898    FB49  0A             ASL						; Multiply our pointer by two as the table uses words not bytes.
11899      
11900    FB4A  AA             TAX						; Transfer our table reference to index X
11901      
11902    FB4B  AD 30 0A       LDA IRQH_CallReg				; Get our call low-byte
11903    FB4E  9D 20 0A       STA IRQH_CallList,X				; Store our low byte
11904      
11905    FB51  AD 31 0A       LDA IRQH_CallReg + 1				; Get our call high-byte
11906    FB54  E8             INX
11907    FB55  9D 20 0A       STA IRQH_CallList,X				; Store our high byte.
11908      
11909    FB58  28             PLP						; End atomic operation
11910    FB59  60             RTS
11911      
11912      
11913    ; Function to atomically clear an IRQ from the table
11914    
11915    IRQH_ClrIRQ_F
11916    FB5A  08             PHP						; Assure atomic
11917    FB5B  78             SEI
11918    
11919    FB5C  0A             ASL						; Multiply our pointer by two
11920    FB5D  AA             TAX						; and place it in X
11921    
11922    FB5E  A9 3B          LDA #<IRQH_Null_F				; Transfer our Null function address to the table
11923    FB60  9D 20 0A       STA IRQH_CallList,X
11924    FB63  A9 FB          LDA #>IRQH_Null_F
11925    FB65  E8             INX
11926    FB66  9D 20 0A       STA IRQH_CallList,X
11927      
11928    FB69  28             PLP						; End atomic operation
11929    FB6A  60             RTS
11930      
11931      
11932    ; IRQ Handler function.
11933    
11934    IRQH_ProcessIRQs
11935    FB6B  48             PHA						; Save processor registers
11936    FB6C  DA             PHX
11937    FB6D  5A             PHY
11938      
11939    FB6E  D8             CLD						; We have no idea what mode the processor was in when this was called so let's clear it.
11940      
11941    FB6F  AD 33 0A       LDA IRQH_MaskByte				; Get IRQ mask
11942    FB72  F0 29          BEQ IRQH_FinishIRQs_B				; and quit early if all disabled.
11943      
11944    FB74  A9 01          LDA #1					; Put 1 into our working mask
11945    FB76  8D 34 0A       STA IRQH_WorkingMask				
11946    
11947    FB79  A2 00          LDX #0					; Start with X at table entry 0
11948      
11949    IRQH_CheckCall_B  
11950    FB7B  AD 33 0A       LDA IRQH_MaskByte				; Check if we need to call that table entry or not
11951    FB7E  2D 34 0A       AND IRQH_WorkingMask
11952    FB81  F0 0A          BEQ IRQH_SkipCall_B
11953      
11954    
11955    FB83  A9 FB          LDA #>IRQH_Return_B				; Place our return address-1 on the stack for the ensuing RTS (which adds 1)
11956    FB85  48             PHA
11957    FB86  A9 8C          LDA #<IRQH_Return_B
11958    FB88  48             PHA
11959      
11960    FB89  7C 20 0A       JMP (IRQH_CallList,X)				; Make the call, including the table offset
11961      
11962    IRQH_Return_B					; Since the 65C02 won't JSR to our chosen address, this is the return address
11963    FB8C  EA             NOP						; non executed packer.  It's cheaper than the arithmetic approach.
11964    
11965    IRQH_SkipCall_B
11966    FB8D  EE 35 0A       INC IRQH_CurrentEntry				; Advance to the next table entry
11967    FB90  E8             INX
11968    FB91  E8             INX
11969      
11970    FB92  8A             TXA						; Have we processed them all?
11971    FB93  C9 10          CMP #16					; If so, we shall go to the finish-line.
11972    FB95  F0 06          BEQ IRQH_FinishIRQs_B
11973      
11974    FB97  18             CLC						; Move our working mask to the next IRQ
11975    FB98  2E 34 0A       ROL IRQH_WorkingMask
11976      
11977    FB9B  80 DE          BRA IRQH_CheckCall_B				; Check the next call.
11978      
11979    IRQH_FinishIRQs_B
11980    FB9D  7A             PLY						; Retrieve processor registers
11981    FB9E  FA             PLX
11982    FB9F  68             PLA
11983      
11984    FBA0  40             RTI
11985      
11986      
11987    ; Function to return table base address and version number.
11988    ; Used for keeping programs compatible over generational changes.
11989    
11990    IRQH_SystemReport_F
11991    
11992    FBA1  A9 00          LDA #IRQH_Version_C
11993    FBA3  A2 20          LDX #<IRQH_Table_Base
11994    FBA5  A0 0A          LDY #>IRQH_Table_Base
11995    FBA7  60             RTS
11996      .INCLUDE "COUNTDOWN_IRQ.asm"
11997    ; Countdown IRQ.
11998    
11999    ; Adds a system countdown timer.  This is to be driven from the timer on the GPIO card.
12000    
12001    
12002    ; Variables
12003    
12004      0A46             CTR_V			= IRQH_CMD_Table+16		; This is our counter variable base address.
12005      0A48             CTR_LOAD_VAL_V		= CTR_V + 2			; This is the interval between counts in PHI2 ticks
12006    
12007    
12008    ; Constants
12009    
12010      9C3F             TIM_DELAY_C		= 39999		; This is the value we are going to use to set the timer. 10ms @4MHz
12011    
12012    
12013    ; Hardware constants
12014    
12015      C044             TIM_T1L			= TAPE_IOBASE + 4
12016      C045             TIM_T1H			= TAPE_IOBASE + 5
12017    
12018      C04B             TIM_ACR			= TAPE_IOBASE + $B
12019      C04D             TIM_IFR			= TAPE_IOBASE + $D
12020      C04E             TIM_IER			= TAPE_IOBASE + $E
12021    
12022      0080             IFR_IRQ_FLAG		= @10000000
12023      0040             IFR_TIM1_FLAG		= @01000000
12024    
12025    
12026    INIT_COUNTDOWN_IRQ
12027      
12028    FBA8  08             PHP					; Add our interrupt guard
12029    FBA9  78             SEI
12030      
12031    FBAA  0D 33 0A       ORA IRQH_MaskByte			; Mark our IRQ as active.
12032    FBAD  8D 33 0A       STA IRQH_MaskByte
12033      
12034    FBB0  A9 3F          LDA #<TIM_DELAY_C			; Load timer value to our variable
12035    FBB2  8D 48 0A       STA CTR_LOAD_VAL_V
12036    FBB5  A9 9C          LDA #>TIM_DELAY_C
12037    FBB7  8D 49 0A       STA CTR_LOAD_VAL_V + 1
12038      
12039    FBBA  AD 4B C0       LDA TIM_ACR
12040    FBBD  09 40          ORA #@01000000			; Load Auxilliary Control Register with continuous interrupts on T1 with latching
12041    FBBF  8D 4B C0       STA TIM_ACR
12042      
12043    FBC2  AD 4E C0       LDA TIM_IER				; Start our interrupts running
12044    FBC5  09 C0          ORA #@11000000
12045    FBC7  8D 4E C0       STA TIM_IER
12046      
12047    FBCA  20 21 FC       JSR TIM_Update_T1_F
12048      
12049    FBCD  28             PLP					; Restore our IRQ status
12050    
12051    FBCE  60             RTS
12052      
12053      
12054    
12055    COUNTDOWN_IRQ
12056    
12057    FBCF  BD 36 0A       LDA IRQH_CMD_Table,X			; Process command shutdown command when asked.
12058    FBD2  C9 01          CMP #IRQH_Shutdown_CMD
12059    FBD4  F0 2F          BEQ COUNTDOWN_IRQ_SHUTDOWN
12060      
12061    FBD6  AD 4D C0       LDA TIM_IFR				; Check whether this is our interrupt to claim
12062    FBD9  29 C0          AND #IFR_IRQ_FLAG | IFR_TIM1_FLAG
12063    FBDB  C9 C0          CMP #IFR_IRQ_FLAG | IFR_TIM1_FLAG
12064      
12065    FBDD  D0 25          BNE TIM_NOT_OUR_IRQ_B			; Branch politely if it isn't ours.
12066      
12067    FBDF  AD 46 0A       LDA CTR_V				; When we reach zero, shutdown.
12068    FBE2  0D 47 0A       ORA CTR_V + 1
12069    FBE5  F0 1E          BEQ COUNTDOWN_IRQ_SHUTDOWN
12070    
12071    FBE7  38             SEC					; Update our countdown counter.
12072    FBE8  AD 46 0A       LDA CTR_V
12073    FBEB  E9 01          SBC #1
12074    FBED  8D 46 0A       STA CTR_V
12075    FBF0  AD 47 0A       LDA CTR_V + 1
12076    FBF3  E9 00          SBC #0
12077    FBF5  8D 47 0A       STA CTR_V + 1
12078      
12079    FBF8  AD 44 C0       LDA TIM_T1L				; Read to this register to clear the interrupt.
12080      
12081    FBFB  AD 34 0A       LDA IRQH_WorkingMask			; Set our claims bit.
12082    FBFE  0D 32 0A       ORA IRQH_ClaimsList
12083    FC01  8D 32 0A       STA IRQH_ClaimsList
12084    
12085    TIM_NOT_OUR_IRQ_B
12086    FC04  60             RTS					; IRQ Handler done
12087    
12088        
12089    COUNTDOWN_IRQ_SHUTDOWN
12090    
12091    FC05  AD 44 C0       LDA TIM_T1L				; Read this register to clear the interrupt
12092    
12093    FC08  AD 4B C0       LDA TIM_ACR				; Disable Timer 1
12094    FC0B  29 3F          AND #@00111111			; only affecting our specific hardware
12095    FC0D  8D 4B C0       STA TIM_ACR
12096      
12097    FC10  A9 40          LDA #IFR_TIM1_FLAG			; Disable Our interrupt
12098    FC12  8D 4E C0       STA TIM_IER
12099      
12100    FC15  AD 34 0A       LDA IRQH_WorkingMask			; Unset our IRQ from the handler
12101    FC18  49 FF          EOR #$FF
12102    FC1A  2D 33 0A       AND IRQH_MaskByte
12103    FC1D  8D 33 0A       STA IRQH_MaskByte
12104        
12105    FC20  60             RTS					; IRQ Handler done.
12106      
12107      
12108      
12109    TIM_Update_T1_F
12110    
12111    FC21  08             PHP					; Save IRQ state and disable interrupts
12112    FC22  78             SEI
12113      
12114    FC23  AD 48 0A       LDA CTR_LOAD_VAL_V			; Load timer
12115    FC26  8D 44 C0       STA TIM_T1L
12116    FC29  AD 49 0A       LDA CTR_LOAD_VAL_V + 1
12117    FC2C  8D 45 C0       STA TIM_T1H				; Count commences from here (if running)
12118      
12119    FC2F  28             PLP					; Restore IRQ status
12120      
12121    FC30  60             RTS
12122    
12123    
12124    ; reset vector points here
12125    
12126    RES_vec
12127    FC31  78             SEI					; Ensure IRQ's are turned off.
12128    FC32  D8             CLD					; clear decimal mode
12129    FC33  A2 FF          LDX #$FF				; empty stack
12130    FC35  9A             TXS					; set the stack
12131    
12132    
12133    ; Set up system timing function
12134    
12135    FC36  20 DB FF       JSR IRQH_Handler_Init_vec		; Initialise the IRQ Handler
12136    
12137    FC39  A9 CF          LDA #<COUNTDOWN_IRQ			; Put the test IRQ address into the table at IRQ Location 0
12138    FC3B  8D 30 0A       STA IRQH_CallReg
12139    FC3E  A9 FB          LDA #>COUNTDOWN_IRQ
12140    FC40  8D 31 0A       STA IRQH_CallReg + 1
12141    FC43  A9 00          LDA #0
12142    FC45  20 DE FF       JSR IRQH_SetIRQ_vec
12143       
12144    FC48  58             CLI					; Enable IRQs globally.
12145    
12146    FC49  20 A5 F3       JSR TPB_delay
12147      
12148    FC4C  A9 02          LDA #ANSI_out_sw                    ; Set our default output options for ANSI output mode.
12149    ;  LDA #ACIA_out_sw                   ; Set our default output options for ACIA output mode.
12150    FC4E  8D E0 05       STA os_outsel                       ; to the ANSI card only.
12151    FC51  A9 01          LDA #LF_filt_sw1
12152    FC53  8D E1 05       STA os_infilt                       ; Switch on $A filtering on the ACIA.
12153      
12154    FC56  20 00 F0       JSR INI_ACIA1                       ; Init ACIA1. We currently need this for the keyboard.
12155    FC59  20 0E F0       JSR INI_ACIA2                       ; Init ACIA2. Just in case.
12156    FC5C  20 90 FF       JSR ANSI_init_vec                   ; Initialise the ANSI text video card.
12157    FC5F  20 96 FF       JSR TPB_init_vec                    ; Init Tower Peripheral Bus
12158    FC62  20 A2 FA       JSR AY_Init                         ; Initialise the AY sound system.
12159      
12160    ; set up vectors and interrupt code, copy them to page 2
12161    
12162    FC65  A0 73          LDY #END_CODE-LAB_vec               ; set index/count
12163    LAB_stlp
12164    FC67  B9 94 FC       LDA LAB_vec-1,Y                     ; get byte from interrupt code
12165    FC6A  99 04 02       STA VEC_IN-1,Y                      ; save to RAM
12166    FC6D  88             DEY                                 ; decrement index/count
12167    FC6E  D0 F7          BNE LAB_stlp                        ; loop if more to do
12168    
12169      
12170    ; Initialise filing system
12171    
12172    FC70  20 C9 FF       JSR TAPE_init_vec                   ; Initialise TowerTAPE filing system.
12173        
12174    ; now do the signon message
12175    
12176    FC73  A0 00          LDY #0
12177    LAB_signon
12178    
12179    FC75  B9 08 FD       LDA LAB_mess,Y                      ; get byte from sign on message
12180    FC78  F0 06          BEQ LAB_nokey                       ; exit loop if done
12181    
12182    FC7A  20 02 E2       JSR V_OUTP                          ; output character
12183    FC7D  C8             INY                                 ; increment index
12184    FC7E  D0 F5          BNE LAB_signon                      ; loop, branch always
12185    
12186    LAB_nokey
12187    FC80  20 FF E1       JSR V_INPT                          ; call scan input device
12188    FC83  90 FB          BCC LAB_nokey                       ; loop if no key
12189    
12190    FC85  29 DF          AND #$DF                            ; mask xx0x xxxx, ensure upper case
12191    FC87  C9 57          CMP #'W'                            ; compare with [W]arm start
12192    FC89  F0 07          BEQ LAB_dowarm                      ; branch if [W]arm start
12193    
12194    FC8B  C9 43          CMP #'C'                            ; compare with [C]old start.
12195    FC8D  D0 E6          BNE LAB_signon                      ; loop if not [C]old start
12196    
12197    FC8F  4C 00 C1       JMP LAB_COLD                        ; do EhBASIC cold start
12198    
12199    LAB_dowarm
12200    FC92  4C 00 00       JMP LAB_WARM                        ; do EhBASIC warm start
12201    
12202    
12203    ; EhBASIC vector tables
12204    
12205    LAB_vec
12206      .word ACIA1in                       ; byte in from ACIA1
12207      .word WR_char                       ; byte out to ACIA1
12208      .word TAPE_LOAD_BASIC_vec           ; null load vector for EhBASIC
12209      .word TAPE_SAVE_BASIC_vec           ; save vector for EhBASIC
12210      .word TAPE_VERIFY_BASIC_vec         ; verify vector for EhBASIC
12211      
12212    
12213    ; EhBASIC IRQ support
12214    
12215    IRQ_CODE
12216    FC9F  48             PHA                                 ; save A
12217    FCA0  A5 DF          LDA IrqBase                         ; get the IRQ flag byte
12218    FCA2  4A             LSR                                 ; shift the set b7 to b6, and on down ...
12219    FCA3  05 DF          ORA IrqBase                         ; OR the original back in
12220    FCA5  85 DF          STA IrqBase                         ; save the new IRQ flag byte
12221    FCA7  68             PLA                                 ; restore A
12222    FCA8  40             RTI
12223    
12224    
12225    ; EhBASIC NMI support
12226    
12227    NMI_CODE
12228    FCA9  48             PHA                                 ; save A
12229    FCAA  A5 DC          LDA NmiBase                         ; get the NMI flag byte
12230    FCAC  4A             LSR                                 ; shift the set b7 to b6, and on down ...
12231    FCAD  05 DC          ORA NmiBase                         ; OR the original back in
12232    FCAF  85 DC          STA NmiBase                         ; save the new NMI flag byte
12233    FCB1  68             PLA                                 ; restore A
12234    FCB2  40             RTI
12235    
12236    
12237    ; OS output stream management support.
12238    
12239    WR_char
12240    FCB3  08             PHP                                 ; Save our registers in case we need 'em
12241    FCB4  DA             PHX
12242    FCB5  5A             PHY
12243    FCB6  48             PHA
12244    FCB7  48             PHA
12245       
12246    FCB8  A9 01          LDA #ACIA1_out_sw
12247    FCBA  2C E0 05       BIT os_outsel
12248    FCBD  F0 05          BEQ no_ACIA1
12249    FCBF  68             PLA
12250    FCC0  20 1C F0       JSR ACIA1out                         ; Print to ACIA1
12251    
12252    FCC3  48             PHA
12253    no_ACIA1  
12254    FCC4  A9 08          LDA #ACIA2_out_sw
12255    FCC6  2C E0 05       BIT os_outsel
12256    FCC9  F0 05          BEQ no_ACIA2
12257    FCCB  68             PLA
12258    FCCC  20 2B F0       JSR ACIA2out                         ; Print to ACIA1
12259      
12260    FCCF  48             PHA
12261    no_ACIA2
12262    FCD0  A9 02          LDA #ANSI_out_sw
12263    FCD2  2C E0 05       BIT os_outsel
12264    FCD5  F0 05          BEQ no_ANSI
12265    FCD7  68             PLA
12266    FCD8  20 93 FF       JSR ANSI_write_vec                  ; Print to ANSI video card
12267        
12268    FCDB  48             PHA
12269    no_ANSI
12270    FCDC  A9 04          LDA #TPB_out_sw
12271    FCDE  2C E0 05       BIT os_outsel
12272    FCE1  F0 05          BEQ no_TPB_LPT
12273    FCE3  68             PLA
12274    FCE4  20 99 FF       JSR TPB_LPT_write_vec               ; Print to TPB LPT card
12275    
12276    FCE7  48             PHA  
12277    no_TPB_LPT                            ; "Print" to the TAPE interface
12278    FCE8  A9 10          LDA #TAPE_out_sw
12279    FCEA  2C E0 05       BIT os_outsel
12280    FCED  F0 06          BEQ MON_EndWRITE_B                  ; Dont write to tape unless selected.
12281    FCEF  68             PLA
12282    FCF0  20 C0 FF       JSR TAPE_ByteOut_vec
12283      
12284    FCF3  80 01          BRA MON_EndWRITE_B2
12285    
12286    MON_EndWRITE_B
12287    FCF5  68             PLA                                   ; Clean up stack including restoring P and return.
12288    MON_EndWRITE_B2
12289    FCF6  68             PLA
12290    FCF7  7A             PLY
12291    FCF8  FA             PLX
12292    FCF9  28             PLP
12293    FCFA  60             RTS
12294      
12295      
12296    ; Tower string printing routine.
12297    TOE_PrintStr
12298    FCFB  A0 00          LDY #0					; Initialise loop index.
12299    TOE_PrintStr_L
12300    FCFD  B1 E7          LDA (TOE_MemptrLo),Y				; Print character.
12301    FCFF  F0 06          BEQ TOE_DonePrinting
12302    FD01  20 02 E2       JSR V_OUTP
12303    FD04  C8             INY
12304    FD05  80 F6          BRA TOE_PrintStr_L
12305    
12306    TOE_DonePrinting
12307    FD07  60             RTS
12308      
12309    END_CODE
12310    
12311    LAB_mess
12312                                          ; sign on string
12313    
12314      .byte "Tower of Eightness OS 18.9.2021.1",$0D,$0A,$0D,$0A
12315      .byte $0D,$0A,"6502 EhBASIC [C]old/[W]arm ?",$00
12316    
12317    
12318    ; ToE OS Vectors
12319    
12320    FF60                 *= $FF60
12321    ; Stream output vector.  
12322    
12323    TOE_PrintStr_vec
12324    FF60  4C FB FC       JMP TOE_PrintStr         ; FF60
12325    
12326      
12327    ; ... existing vectors continue from here.
12328    
12329    FF90                 *= $FF90
12330    
12331    ; ANSI Card vectors
12332    
12333    ANSI_init_vec
12334    FF90  4C 6F F0       JMP ANSI_INIT            ; FF90
12335    ANSI_write_vec
12336    FF93  4C 91 F0       JMP ANSI_write           ; FF93
12337      
12338    
12339    ; Tower Peripheral Bus vectors
12340    
12341    TPB_init_vec
12342    FF96  4C B5 F0       JMP TPB_INIT             ; FF96
12343    TPB_LPT_write_vec
12344    FF99  4C 77 F3       JMP TPB_LPT_write        ; FF99
12345    TPB_tx_byte_vec
12346    FF9C  4C 3F F2       JMP TPB_tx_byte          ; FF9C
12347    TPB_tx_block_vec
12348    FF9F  4C DA F2       JMP TPB_tx_block         ; FF9F
12349    TPB_ATN_handler_vec
12350    FFA2  4C 09 F2       JMP TPB_ATN_handler      ; FFA2
12351    TPB_rx_byte_vec  
12352    FFA5  4C 84 F2       JMP TPB_rx_byte          ; FFA5
12353    TPB_rx_block_vec
12354    FFA8  4C 1E F3       JMP TPB_rx_block         ; FFA8
12355    TPB_Dev_Presence_vec
12356    FFAB  4C C5 F1       JMP TPB_Dev_Presence     ; FFAB
12357    TPB_Req_Dev_Type_vec
12358    FFAE  4C 46 F1       JMP TPB_Req_Dev_Type     ; FFAE
12359    TPB_dev_select_vec
12360    FFB1  4C 5D F3       JMP TPB_dev_select       ; FFB1
12361    TPB_Ctrl_Blk_Wr_vec
12362    FFB4  4C D9 F0       JMP TPB_Ctrl_Blk_Wr      ; FFB4
12363    TPB_Ctrl_Blk_Rd_vec
12364    FFB7  4C 0F F1       JMP TPB_Ctrl_Blk_Rd      ; FFB7
12365    
12366    
12367    ; TAPE subsystem vectors
12368    
12369    TAPE_Leader_vec
12370    FFBA  4C F1 F8       JMP F_TAPE_Leader        ; FFBA
12371    TAPE_BlockOut_vec
12372    FFBD  4C C3 F8       JMP F_TAPE_BlockOut      ; FFBD
12373    TAPE_ByteOut_vec
12374    FFC0  4C 8E F8       JMP F_TAPE_ByteOut       ; FFC0
12375    TAPE_BlockIn_vec
12376    FFC3  4C 9F F9       JMP F_TAPE_BlockIn       ; FFC3
12377    TAPE_ByteIn_vec
12378    FFC6  4C 53 FA       JMP F_TAPE_GetByte       ; FFC6
12379    TAPE_init_vec
12380    FFC9  4C 9A F4       JMP F_TAPE_Init          ; FFC9
12381    TAPE_SAVE_BASIC_vec  
12382    FFCC  4C CB F5       JMP F_TAPE_SAVE_BASIC    ; FFCC
12383    TAPE_LOAD_BASIC_vec  
12384    FFCF  4C 09 F7       JMP F_TAPE_LOAD_BASIC    ; FFCF
12385    TAPE_VERIFY_BASIC_vec
12386    FFD2  4C 4D F6       JMP F_TAPE_VERIFY_BASIC  ; FFD2
12387    
12388    
12389    ; AY Soundcard vectors.
12390      
12391    AY_Userwrite_vec           ; FFD5
12392    FFD5  4C FC FA       JMP AY_Userwrite
12393    AY_Userread_vec            ; FFD8
12394    FFD8  4C 06 FB       JMP AY_Userread
12395    
12396    
12397    ; IRQ Handler Subsystem vectors
12398      
12399    IRQH_Handler_Init_vec	   ; FFDB
12400    FFDB  4C 13 FB       JMP IRQH_Handler_Init_F
12401    IRQH_SetIRQ_vec		   ; FFDE
12402    FFDE  4C 47 FB       JMP IRQH_SetIRQ_F
12403    IRQH_ClrIRQ_vec		   ; FFE1
12404    FFE1  4C 5A FB       JMP IRQH_ClrIRQ_F
12405    IRQH_SystemReport_vec	   ; FFE4
12406    FFE4  4C A1 FB       JMP IRQH_SystemReport_F
12407      
12408    ; Timer System vectors
12409    
12410    INIT_COUNTDOWN_IRQ_vec	   ; FFE7
12411    FFE7  4C A8 FB       JMP INIT_COUNTDOWN_IRQ
12412      
12413    
12414    ; Processor hardware vectors.  These are fixed in hardware and cannot be moved.
12415    
12416    FFFA                 *= $FFFA
12417    
12418      .word NMI_vec                ; NMI vector
12419      .word RES_vec                ; RESET vector
12420      .word IRQ_vec                ; IRQ vector
12421    
12422    
12423    
