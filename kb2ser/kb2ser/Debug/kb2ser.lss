
kb2ser.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  0000095e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000008ea  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000036e  00800100  00800100  0000095e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000095e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000990  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000c0  00000000  00000000  000009d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001017  00000000  00000000  00000a90  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000869  00000000  00000000  00001aa7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000d30  00000000  00000000  00002310  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000254  00000000  00000000  00003040  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000690  00000000  00000000  00003294  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000836  00000000  00000000  00003924  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b0  00000000  00000000  0000415a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 b8 00 	jmp	0x170	; 0x170 <__ctors_end>
   4:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
   8:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
   c:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  10:	0c 94 12 01 	jmp	0x224	; 0x224 <__vector_4>
  14:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  18:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  1c:	0c 94 69 03 	jmp	0x6d2	; 0x6d2 <__vector_7>
  20:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  24:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  28:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  2c:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  30:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  34:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  38:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  3c:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  40:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  44:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  48:	0c 94 cd 01 	jmp	0x39a	; 0x39a <__vector_18>
  4c:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  50:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  54:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  58:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  5c:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  60:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>
  64:	0c 94 ca 00 	jmp	0x194	; 0x194 <__bad_interrupt>

00000068 <__trampolines_end>:
  68:	00 95       	com	r16
  6a:	00 91 8f 8d 	lds	r16, 0x8D8F	; 0x808d8f <__bss_end+0x8921>
  6e:	8e 98       	cbi	0x11, 6	; 17
  70:	00 96       	adiw	r24, 0x00	; 0
  72:	94 92       	xch	Z, r9
  74:	90 00       	.word	0x0090	; ????
  76:	ac 00       	.word	0x00ac	; ????
  78:	00 00       	nop
  7a:	00 00       	nop
  7c:	00 51       	subi	r16, 0x10	; 16
  7e:	21 00       	.word	0x0021	; ????
  80:	00 00       	nop
  82:	5a 53       	subi	r21, 0x3A	; 58
  84:	41 57       	subi	r20, 0x71	; 113
  86:	22 00       	.word	0x0022	; ????
  88:	00 43       	sbci	r16, 0x30	; 48
  8a:	58 44       	sbci	r21, 0x48	; 72
  8c:	45 24       	eor	r4, r5
  8e:	9c 3a       	cpi	r25, 0xAC	; 172
  90:	00 20       	and	r0, r0
  92:	56 46       	sbci	r21, 0x66	; 102
  94:	54 52       	subi	r21, 0x24	; 36
  96:	25 00       	.word	0x0025	; ????
  98:	00 4e       	sbci	r16, 0xE0	; 224
  9a:	42 48       	sbci	r20, 0x82	; 130
  9c:	47 59       	subi	r20, 0x97	; 151
  9e:	5e 00       	.word	0x005e	; ????
  a0:	00 4c       	sbci	r16, 0xC0	; 192
  a2:	4d 4a       	sbci	r20, 0xAD	; 173
  a4:	55 26       	eor	r5, r21
  a6:	2a 00       	.word	0x002a	; ????
  a8:	00 3c       	cpi	r16, 0xC0	; 192
  aa:	4b 49       	sbci	r20, 0x9B	; 155
  ac:	4f 29       	or	r20, r15
  ae:	28 00       	.word	0x0028	; ????
  b0:	00 3e       	cpi	r16, 0xE0	; 224
  b2:	3f 4c       	sbci	r19, 0xCF	; 207
  b4:	3a 50       	subi	r19, 0x0A	; 10
  b6:	5f 00       	.word	0x005f	; ????
  b8:	00 00       	nop
  ba:	40 00       	.word	0x0040	; ????
  bc:	7b 2b       	or	r23, r27
  be:	00 00       	nop
  c0:	00 00       	nop
  c2:	0d 7d       	andi	r16, 0xDD	; 221
  c4:	00 7e       	andi	r16, 0xE0	; 224
  c6:	00 00       	nop
  c8:	00 7c       	andi	r16, 0xC0	; 192
  ca:	00 00       	nop
  cc:	00 08       	sbc	r0, r0
  ce:	00 00       	nop
  d0:	31 00       	.word	0x0031	; ????
  d2:	34 37       	cpi	r19, 0x74	; 116
  d4:	00 00       	nop
  d6:	00 00       	nop
  d8:	30 2e       	mov	r3, r16
  da:	32 35       	cpi	r19, 0x52	; 82
  dc:	36 38       	cpi	r19, 0x86	; 134
  de:	03 00       	.word	0x0003	; ????
  e0:	97 2b       	or	r25, r23
  e2:	33 2d       	mov	r19, r3
  e4:	2a 39       	cpi	r18, 0x9A	; 154
  e6:	00 00       	nop
  e8:	00 00       	nop
  ea:	00 87       	std	Z+8, r16	; 0x08

000000ec <kbNormal>:
  ec:	00 89 00 85 83 81 82 8c 00 8a 88 86 84 07 06 00     ................
  fc:	00 00 00 00 00 71 31 00 00 00 7a 73 61 77 32 00     .....q1...zsaw2.
 10c:	00 63 78 64 65 34 33 3b 00 20 76 66 74 72 35 00     .cxde43;. vftr5.
 11c:	00 6e 62 68 67 79 36 07 08 2c 6d 6a 75 37 38 00     .nbhgy6..,mju78.
 12c:	00 2c 6b 69 6f 30 39 00 00 2e 2f 6c 3b 70 2d 00     .,kio09.../l;p-.
 13c:	00 00 27 00 5b 3d 00 00 00 00 0d 5d 00 23 00 00     ..'.[=.....].#..
 14c:	00 5c 00 00 00 00 08 00 00 31 00 34 37 00 00 00     .\.......1.47...
 15c:	30 2e 32 35 36 38 03 00 8b 2b 33 2d 2a 39 00 00     0.2568...+3-*9..
 16c:	00 00 00 87                                         ....

00000170 <__ctors_end>:
 170:	11 24       	eor	r1, r1
 172:	1f be       	out	0x3f, r1	; 63
 174:	cf ef       	ldi	r28, 0xFF	; 255
 176:	d4 e0       	ldi	r29, 0x04	; 4
 178:	de bf       	out	0x3e, r29	; 62
 17a:	cd bf       	out	0x3d, r28	; 61

0000017c <__do_clear_bss>:
 17c:	24 e0       	ldi	r18, 0x04	; 4
 17e:	a0 e0       	ldi	r26, 0x00	; 0
 180:	b1 e0       	ldi	r27, 0x01	; 1
 182:	01 c0       	rjmp	.+2      	; 0x186 <.do_clear_bss_start>

00000184 <.do_clear_bss_loop>:
 184:	1d 92       	st	X+, r1

00000186 <.do_clear_bss_start>:
 186:	ae 36       	cpi	r26, 0x6E	; 110
 188:	b2 07       	cpc	r27, r18
 18a:	e1 f7       	brne	.-8      	; 0x184 <.do_clear_bss_loop>
 18c:	0e 94 9b 03 	call	0x736	; 0x736 <main>
 190:	0c 94 73 04 	jmp	0x8e6	; 0x8e6 <_exit>

00000194 <__bad_interrupt>:
 194:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000198 <setRTS>:

//	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWSTO); // Send stop - NOT USED BECAUSE DATA STREAM REMAINS OPEN
}

void sendToDisplay(unsigned char c)
{
 198:	80 91 69 04 	lds	r24, 0x0469	; 0x800469 <serInPointer>
 19c:	90 91 6a 04 	lds	r25, 0x046A	; 0x80046a <serInPointer+0x1>
 1a0:	20 91 59 04 	lds	r18, 0x0459	; 0x800459 <serOutPointer>
 1a4:	30 91 5a 04 	lds	r19, 0x045A	; 0x80045a <serOutPointer+0x1>
 1a8:	82 17       	cp	r24, r18
 1aa:	93 07       	cpc	r25, r19
 1ac:	18 f0       	brcs	.+6      	; 0x1b4 <setRTS+0x1c>
 1ae:	82 1b       	sub	r24, r18
 1b0:	93 0b       	sbc	r25, r19
 1b2:	04 c0       	rjmp	.+8      	; 0x1bc <setRTS+0x24>
 1b4:	80 5e       	subi	r24, 0xE0	; 224
 1b6:	9c 4f       	sbci	r25, 0xFC	; 252
 1b8:	82 1b       	sub	r24, r18
 1ba:	93 0b       	sbc	r25, r19
 1bc:	80 32       	cpi	r24, 0x20	; 32
 1be:	91 05       	cpc	r25, r1
 1c0:	08 f4       	brcc	.+2      	; 0x1c4 <setRTS+0x2c>
 1c2:	43 98       	cbi	0x08, 3	; 8
 1c4:	81 30       	cpi	r24, 0x01	; 1
 1c6:	93 40       	sbci	r25, 0x03	; 3
 1c8:	08 f0       	brcs	.+2      	; 0x1cc <setRTS+0x34>
 1ca:	43 9a       	sbi	0x08, 3	; 8
 1cc:	08 95       	ret

000001ce <setKeyboardToReceiveMode>:
 1ce:	e2 eb       	ldi	r30, 0xB2	; 178
 1d0:	f0 e0       	ldi	r31, 0x00	; 0
 1d2:	10 82       	st	Z, r1
 1d4:	86 e6       	ldi	r24, 0x66	; 102
 1d6:	95 e0       	ldi	r25, 0x05	; 5
 1d8:	01 97       	sbiw	r24, 0x01	; 1
 1da:	f1 f7       	brne	.-4      	; 0x1d8 <setKeyboardToReceiveMode+0xa>
 1dc:	00 00       	nop
 1de:	39 9a       	sbi	0x07, 1	; 7
 1e0:	41 98       	cbi	0x08, 1	; 8
 1e2:	86 e6       	ldi	r24, 0x66	; 102
 1e4:	95 e0       	ldi	r25, 0x05	; 5
 1e6:	01 97       	sbiw	r24, 0x01	; 1
 1e8:	f1 f7       	brne	.-4      	; 0x1e6 <setKeyboardToReceiveMode+0x18>
 1ea:	00 00       	nop
 1ec:	3a 9a       	sbi	0x07, 2	; 7
 1ee:	42 98       	cbi	0x08, 2	; 8
 1f0:	86 e6       	ldi	r24, 0x66	; 102
 1f2:	95 e0       	ldi	r25, 0x05	; 5
 1f4:	01 97       	sbiw	r24, 0x01	; 1
 1f6:	f1 f7       	brne	.-4      	; 0x1f4 <setKeyboardToReceiveMode+0x26>
 1f8:	00 00       	nop
 1fa:	39 98       	cbi	0x07, 1	; 7
 1fc:	41 98       	cbi	0x08, 1	; 8
 1fe:	10 82       	st	Z, r1
 200:	81 e0       	ldi	r24, 0x01	; 1
 202:	80 93 62 04 	sts	0x0462, r24	; 0x800462 <kbWrPar>
 206:	10 92 33 01 	sts	0x0133, r1	; 0x800133 <kbClockCount>
 20a:	80 93 65 04 	sts	0x0465, r24	; 0x800465 <kbWriteActive>
 20e:	08 95       	ret

00000210 <setKeyboardToSendMode>:
 210:	87 b1       	in	r24, 0x07	; 7
 212:	89 7f       	andi	r24, 0xF9	; 249
 214:	87 b9       	out	0x07, r24	; 7
 216:	08 95       	ret

00000218 <sendBitToKB>:
 218:	81 30       	cpi	r24, 0x01	; 1
 21a:	11 f4       	brne	.+4      	; 0x220 <sendBitToKB+0x8>
 21c:	42 9a       	sbi	0x08, 2	; 8
 21e:	08 95       	ret
 220:	42 98       	cbi	0x08, 2	; 8
 222:	08 95       	ret

00000224 <__vector_4>:
 224:	1f 92       	push	r1
 226:	0f 92       	push	r0
 228:	0f b6       	in	r0, 0x3f	; 63
 22a:	0f 92       	push	r0
 22c:	11 24       	eor	r1, r1
 22e:	2f 93       	push	r18
 230:	3f 93       	push	r19
 232:	4f 93       	push	r20
 234:	5f 93       	push	r21
 236:	6f 93       	push	r22
 238:	7f 93       	push	r23
 23a:	8f 93       	push	r24
 23c:	9f 93       	push	r25
 23e:	af 93       	push	r26
 240:	bf 93       	push	r27
 242:	ef 93       	push	r30
 244:	ff 93       	push	r31
 246:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__DATA_REGION_ORIGIN__+0x52>
 24a:	80 91 65 04 	lds	r24, 0x0465	; 0x800465 <kbWriteActive>
 24e:	81 30       	cpi	r24, 0x01	; 1
 250:	f1 f5       	brne	.+124    	; 0x2ce <__vector_4+0xaa>
 252:	31 9b       	sbis	0x06, 1	; 6
 254:	75 c0       	rjmp	.+234    	; 0x340 <__vector_4+0x11c>
 256:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <kbClockCount>
 25a:	8f 5f       	subi	r24, 0xFF	; 255
 25c:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <kbClockCount>
 260:	8a 30       	cpi	r24, 0x0A	; 10
 262:	11 f4       	brne	.+4      	; 0x268 <__vector_4+0x44>
 264:	0e 94 08 01 	call	0x210	; 0x210 <setKeyboardToSendMode>
 268:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <kbClockCount>
 26c:	8b 30       	cpi	r24, 0x0B	; 11
 26e:	39 f4       	brne	.+14     	; 0x27e <__vector_4+0x5a>
 270:	10 92 65 04 	sts	0x0465, r1	; 0x800465 <kbWriteActive>
 274:	10 92 33 01 	sts	0x0133, r1	; 0x800133 <kbClockCount>
 278:	10 92 58 04 	sts	0x0458, r1	; 0x800458 <kbTemp>
 27c:	61 c0       	rjmp	.+194    	; 0x340 <__vector_4+0x11c>
 27e:	89 30       	cpi	r24, 0x09	; 9
 280:	59 f4       	brne	.+22     	; 0x298 <__vector_4+0x74>
 282:	80 91 62 04 	lds	r24, 0x0462	; 0x800462 <kbWrPar>
 286:	81 30       	cpi	r24, 0x01	; 1
 288:	19 f4       	brne	.+6      	; 0x290 <__vector_4+0x6c>
 28a:	0e 94 0c 01 	call	0x218	; 0x218 <sendBitToKB>
 28e:	58 c0       	rjmp	.+176    	; 0x340 <__vector_4+0x11c>
 290:	80 e0       	ldi	r24, 0x00	; 0
 292:	0e 94 0c 01 	call	0x218	; 0x218 <sendBitToKB>
 296:	54 c0       	rjmp	.+168    	; 0x340 <__vector_4+0x11c>
 298:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 29c:	80 ff       	sbrs	r24, 0
 29e:	0e c0       	rjmp	.+28     	; 0x2bc <__vector_4+0x98>
 2a0:	81 e0       	ldi	r24, 0x01	; 1
 2a2:	0e 94 0c 01 	call	0x218	; 0x218 <sendBitToKB>
 2a6:	80 91 62 04 	lds	r24, 0x0462	; 0x800462 <kbWrPar>
 2aa:	81 30       	cpi	r24, 0x01	; 1
 2ac:	19 f4       	brne	.+6      	; 0x2b4 <__vector_4+0x90>
 2ae:	10 92 62 04 	sts	0x0462, r1	; 0x800462 <kbWrPar>
 2b2:	07 c0       	rjmp	.+14     	; 0x2c2 <__vector_4+0x9e>
 2b4:	81 e0       	ldi	r24, 0x01	; 1
 2b6:	80 93 62 04 	sts	0x0462, r24	; 0x800462 <kbWrPar>
 2ba:	03 c0       	rjmp	.+6      	; 0x2c2 <__vector_4+0x9e>
 2bc:	80 e0       	ldi	r24, 0x00	; 0
 2be:	0e 94 0c 01 	call	0x218	; 0x218 <sendBitToKB>
 2c2:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 2c6:	86 95       	lsr	r24
 2c8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
 2cc:	39 c0       	rjmp	.+114    	; 0x340 <__vector_4+0x11c>
 2ce:	31 99       	sbic	0x06, 1	; 6
 2d0:	37 c0       	rjmp	.+110    	; 0x340 <__vector_4+0x11c>
 2d2:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <kbClockCount>
 2d6:	8f 5f       	subi	r24, 0xFF	; 255
 2d8:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <kbClockCount>
 2dc:	81 30       	cpi	r24, 0x01	; 1
 2de:	81 f1       	breq	.+96     	; 0x340 <__vector_4+0x11c>
 2e0:	8a 30       	cpi	r24, 0x0A	; 10
 2e2:	71 f1       	breq	.+92     	; 0x340 <__vector_4+0x11c>
 2e4:	8b 30       	cpi	r24, 0x0B	; 11
 2e6:	19 f4       	brne	.+6      	; 0x2ee <__vector_4+0xca>
 2e8:	10 92 33 01 	sts	0x0133, r1	; 0x800133 <kbClockCount>
 2ec:	29 c0       	rjmp	.+82     	; 0x340 <__vector_4+0x11c>
 2ee:	90 91 58 04 	lds	r25, 0x0458	; 0x800458 <kbTemp>
 2f2:	96 95       	lsr	r25
 2f4:	90 93 58 04 	sts	0x0458, r25	; 0x800458 <kbTemp>
 2f8:	32 9b       	sbis	0x06, 2	; 6
 2fa:	03 c0       	rjmp	.+6      	; 0x302 <__vector_4+0xde>
 2fc:	90 58       	subi	r25, 0x80	; 128
 2fe:	90 93 58 04 	sts	0x0458, r25	; 0x800458 <kbTemp>
 302:	89 30       	cpi	r24, 0x09	; 9
 304:	e9 f4       	brne	.+58     	; 0x340 <__vector_4+0x11c>
 306:	80 91 6c 04 	lds	r24, 0x046C	; 0x80046c <kbInPointer>
 30a:	90 91 6d 04 	lds	r25, 0x046D	; 0x80046d <kbInPointer+0x1>
 30e:	01 96       	adiw	r24, 0x01	; 1
 310:	82 33       	cpi	r24, 0x32	; 50
 312:	91 05       	cpc	r25, r1
 314:	10 f0       	brcs	.+4      	; 0x31a <__vector_4+0xf6>
 316:	80 e0       	ldi	r24, 0x00	; 0
 318:	90 e0       	ldi	r25, 0x00	; 0
 31a:	20 91 60 04 	lds	r18, 0x0460	; 0x800460 <kbOutPointer>
 31e:	30 91 61 04 	lds	r19, 0x0461	; 0x800461 <kbOutPointer+0x1>
 322:	82 17       	cp	r24, r18
 324:	93 07       	cpc	r25, r19
 326:	51 f0       	breq	.+20     	; 0x33c <__vector_4+0x118>
 328:	fc 01       	movw	r30, r24
 32a:	ef 5f       	subi	r30, 0xFF	; 255
 32c:	fe 4f       	sbci	r31, 0xFE	; 254
 32e:	20 91 58 04 	lds	r18, 0x0458	; 0x800458 <kbTemp>
 332:	20 83       	st	Z, r18
 334:	90 93 6d 04 	sts	0x046D, r25	; 0x80046d <kbInPointer+0x1>
 338:	80 93 6c 04 	sts	0x046C, r24	; 0x80046c <kbInPointer>
 33c:	10 92 58 04 	sts	0x0458, r1	; 0x800458 <kbTemp>
 340:	ff 91       	pop	r31
 342:	ef 91       	pop	r30
 344:	bf 91       	pop	r27
 346:	af 91       	pop	r26
 348:	9f 91       	pop	r25
 34a:	8f 91       	pop	r24
 34c:	7f 91       	pop	r23
 34e:	6f 91       	pop	r22
 350:	5f 91       	pop	r21
 352:	4f 91       	pop	r20
 354:	3f 91       	pop	r19
 356:	2f 91       	pop	r18
 358:	0f 90       	pop	r0
 35a:	0f be       	out	0x3f, r0	; 63
 35c:	0f 90       	pop	r0
 35e:	1f 90       	pop	r1
 360:	18 95       	reti

00000362 <updateKeyboardLEDs>:
 362:	81 e0       	ldi	r24, 0x01	; 1
 364:	90 91 63 04 	lds	r25, 0x0463	; 0x800463 <kbScrollLock>
 368:	91 30       	cpi	r25, 0x01	; 1
 36a:	09 f0       	breq	.+2      	; 0x36e <updateKeyboardLEDs+0xc>
 36c:	80 e0       	ldi	r24, 0x00	; 0
 36e:	90 91 67 04 	lds	r25, 0x0467	; 0x800467 <kbNumLock>
 372:	91 30       	cpi	r25, 0x01	; 1
 374:	09 f4       	brne	.+2      	; 0x378 <updateKeyboardLEDs+0x16>
 376:	8e 5f       	subi	r24, 0xFE	; 254
 378:	90 91 68 04 	lds	r25, 0x0468	; 0x800468 <kbCaps>
 37c:	91 30       	cpi	r25, 0x01	; 1
 37e:	09 f4       	brne	.+2      	; 0x382 <updateKeyboardLEDs+0x20>
 380:	8c 5f       	subi	r24, 0xFC	; 252
 382:	9d ee       	ldi	r25, 0xED	; 237
 384:	90 93 5f 04 	sts	0x045F, r25	; 0x80045f <kbBuffer2>
 388:	80 93 5d 04 	sts	0x045D, r24	; 0x80045d <kbBuffer1>
 38c:	82 e0       	ldi	r24, 0x02	; 2
 38e:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <kbWriteCount>
 392:	81 e0       	ldi	r24, 0x01	; 1
 394:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <kbAckReceived>
 398:	08 95       	ret

0000039a <__vector_18>:
 39a:	1f 92       	push	r1
 39c:	0f 92       	push	r0
 39e:	0f b6       	in	r0, 0x3f	; 63
 3a0:	0f 92       	push	r0
 3a2:	11 24       	eor	r1, r1
 3a4:	2f 93       	push	r18
 3a6:	3f 93       	push	r19
 3a8:	4f 93       	push	r20
 3aa:	5f 93       	push	r21
 3ac:	6f 93       	push	r22
 3ae:	7f 93       	push	r23
 3b0:	8f 93       	push	r24
 3b2:	9f 93       	push	r25
 3b4:	af 93       	push	r26
 3b6:	bf 93       	push	r27
 3b8:	ef 93       	push	r30
 3ba:	ff 93       	push	r31
 3bc:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
 3c0:	20 91 c6 00 	lds	r18, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
 3c4:	8c 71       	andi	r24, 0x1C	; 28
 3c6:	09 f0       	breq	.+2      	; 0x3ca <__vector_18+0x30>
 3c8:	2f e3       	ldi	r18, 0x3F	; 63
 3ca:	80 91 69 04 	lds	r24, 0x0469	; 0x800469 <serInPointer>
 3ce:	90 91 6a 04 	lds	r25, 0x046A	; 0x80046a <serInPointer+0x1>
 3d2:	01 96       	adiw	r24, 0x01	; 1
 3d4:	80 32       	cpi	r24, 0x20	; 32
 3d6:	33 e0       	ldi	r19, 0x03	; 3
 3d8:	93 07       	cpc	r25, r19
 3da:	14 f0       	brlt	.+4      	; 0x3e0 <__vector_18+0x46>
 3dc:	80 e0       	ldi	r24, 0x00	; 0
 3de:	90 e0       	ldi	r25, 0x00	; 0
 3e0:	40 91 59 04 	lds	r20, 0x0459	; 0x800459 <serOutPointer>
 3e4:	50 91 5a 04 	lds	r21, 0x045A	; 0x80045a <serOutPointer+0x1>
 3e8:	84 17       	cp	r24, r20
 3ea:	95 07       	cpc	r25, r21
 3ec:	41 f0       	breq	.+16     	; 0x3fe <__vector_18+0x64>
 3ee:	fc 01       	movw	r30, r24
 3f0:	e8 5c       	subi	r30, 0xC8	; 200
 3f2:	fe 4f       	sbci	r31, 0xFE	; 254
 3f4:	20 83       	st	Z, r18
 3f6:	90 93 6a 04 	sts	0x046A, r25	; 0x80046a <serInPointer+0x1>
 3fa:	80 93 69 04 	sts	0x0469, r24	; 0x800469 <serInPointer>
 3fe:	0e 94 cc 00 	call	0x198	; 0x198 <setRTS>
 402:	ff 91       	pop	r31
 404:	ef 91       	pop	r30
 406:	bf 91       	pop	r27
 408:	af 91       	pop	r26
 40a:	9f 91       	pop	r25
 40c:	8f 91       	pop	r24
 40e:	7f 91       	pop	r23
 410:	6f 91       	pop	r22
 412:	5f 91       	pop	r21
 414:	4f 91       	pop	r20
 416:	3f 91       	pop	r19
 418:	2f 91       	pop	r18
 41a:	0f 90       	pop	r0
 41c:	0f be       	out	0x3f, r0	; 63
 41e:	0f 90       	pop	r0
 420:	1f 90       	pop	r1
 422:	18 95       	reti

00000424 <initUSART>:
 424:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
 428:	87 e4       	ldi	r24, 0x47	; 71
 42a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
 42e:	86 e0       	ldi	r24, 0x06	; 6
 430:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
 434:	88 e9       	ldi	r24, 0x98	; 152
 436:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
 43a:	08 95       	ret

0000043c <sendUSART>:
 43c:	e0 ec       	ldi	r30, 0xC0	; 192
 43e:	f0 e0       	ldi	r31, 0x00	; 0
 440:	90 81       	ld	r25, Z
 442:	95 ff       	sbrs	r25, 5
 444:	fd cf       	rjmp	.-6      	; 0x440 <sendUSART+0x4>
 446:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
 44a:	08 95       	ret

0000044c <getInChar>:
		//send8BitToDisplay(c);
	//}
}

unsigned char getInChar()
{
 44c:	cf 93       	push	r28
	unsigned char retVal=0;
	unsigned int tempPointer;
	while (serInPointer==serOutPointer)
 44e:	20 91 69 04 	lds	r18, 0x0469	; 0x800469 <serInPointer>
 452:	30 91 6a 04 	lds	r19, 0x046A	; 0x80046a <serInPointer+0x1>
 456:	80 91 59 04 	lds	r24, 0x0459	; 0x800459 <serOutPointer>
 45a:	90 91 5a 04 	lds	r25, 0x045A	; 0x80045a <serOutPointer+0x1>
 45e:	28 17       	cp	r18, r24
 460:	39 07       	cpc	r19, r25
 462:	61 f4       	brne	.+24     	; 0x47c <getInChar+0x30>
	{
		asm volatile ("nop");
 464:	00 00       	nop

unsigned char getInChar()
{
	unsigned char retVal=0;
	unsigned int tempPointer;
	while (serInPointer==serOutPointer)
 466:	20 91 69 04 	lds	r18, 0x0469	; 0x800469 <serInPointer>
 46a:	30 91 6a 04 	lds	r19, 0x046A	; 0x80046a <serInPointer+0x1>
 46e:	80 91 59 04 	lds	r24, 0x0459	; 0x800459 <serOutPointer>
 472:	90 91 5a 04 	lds	r25, 0x045A	; 0x80045a <serOutPointer+0x1>
 476:	28 17       	cp	r18, r24
 478:	39 07       	cpc	r19, r25
 47a:	a1 f3       	breq	.-24     	; 0x464 <getInChar+0x18>
	{
		asm volatile ("nop");
	}
	cli();
 47c:	f8 94       	cli
	tempPointer=serOutPointer+1;
 47e:	80 91 59 04 	lds	r24, 0x0459	; 0x800459 <serOutPointer>
 482:	90 91 5a 04 	lds	r25, 0x045A	; 0x80045a <serOutPointer+0x1>
 486:	01 96       	adiw	r24, 0x01	; 1
	if (tempPointer >(SERBUFSIZE-1))
 488:	80 32       	cpi	r24, 0x20	; 32
 48a:	23 e0       	ldi	r18, 0x03	; 3
 48c:	92 07       	cpc	r25, r18
 48e:	10 f0       	brcs	.+4      	; 0x494 <getInChar+0x48>
	{
		tempPointer = 0;
 490:	80 e0       	ldi	r24, 0x00	; 0
 492:	90 e0       	ldi	r25, 0x00	; 0
	}
	retVal=serBuffer[tempPointer];
 494:	fc 01       	movw	r30, r24
 496:	e8 5c       	subi	r30, 0xC8	; 200
 498:	fe 4f       	sbci	r31, 0xFE	; 254
 49a:	c0 81       	ld	r28, Z
	serOutPointer=tempPointer;
 49c:	90 93 5a 04 	sts	0x045A, r25	; 0x80045a <serOutPointer+0x1>
 4a0:	80 93 59 04 	sts	0x0459, r24	; 0x800459 <serOutPointer>
	sei();
 4a4:	78 94       	sei
	setRTS();
 4a6:	0e 94 cc 00 	call	0x198	; 0x198 <setRTS>

	return retVal;
}
 4aa:	8c 2f       	mov	r24, r28
 4ac:	cf 91       	pop	r28
 4ae:	08 95       	ret

000004b0 <isInCharAvailable>:


unsigned char isInCharAvailable()
{
	if (serInPointer==serOutPointer)
 4b0:	40 91 69 04 	lds	r20, 0x0469	; 0x800469 <serInPointer>
 4b4:	50 91 6a 04 	lds	r21, 0x046A	; 0x80046a <serInPointer+0x1>
 4b8:	20 91 59 04 	lds	r18, 0x0459	; 0x800459 <serOutPointer>
 4bc:	30 91 5a 04 	lds	r19, 0x045A	; 0x80045a <serOutPointer+0x1>
 4c0:	81 e0       	ldi	r24, 0x01	; 1
 4c2:	42 17       	cp	r20, r18
 4c4:	53 07       	cpc	r21, r19
 4c6:	09 f4       	brne	.+2      	; 0x4ca <isInCharAvailable+0x1a>
 4c8:	80 e0       	ldi	r24, 0x00	; 0
	}
	else
	{
		return 1;
	}
}
 4ca:	08 95       	ret

000004cc <getKbCode>:

unsigned char getKbCode()
{
	unsigned char retVal=0;
	unsigned int tempPointer;
	if (kbInPointer==kbOutPointer)
 4cc:	20 91 6c 04 	lds	r18, 0x046C	; 0x80046c <kbInPointer>
 4d0:	30 91 6d 04 	lds	r19, 0x046D	; 0x80046d <kbInPointer+0x1>
 4d4:	80 91 60 04 	lds	r24, 0x0460	; 0x800460 <kbOutPointer>
 4d8:	90 91 61 04 	lds	r25, 0x0461	; 0x800461 <kbOutPointer+0x1>
 4dc:	28 17       	cp	r18, r24
 4de:	39 07       	cpc	r19, r25
 4e0:	b1 f0       	breq	.+44     	; 0x50e <__stack+0xf>
	{
		return 0;
	}
	cli();
 4e2:	f8 94       	cli
	tempPointer=kbOutPointer+1;
 4e4:	20 91 60 04 	lds	r18, 0x0460	; 0x800460 <kbOutPointer>
 4e8:	30 91 61 04 	lds	r19, 0x0461	; 0x800461 <kbOutPointer+0x1>
 4ec:	2f 5f       	subi	r18, 0xFF	; 255
 4ee:	3f 4f       	sbci	r19, 0xFF	; 255
	if (tempPointer >(KBBUFSIZE-1))
 4f0:	22 33       	cpi	r18, 0x32	; 50
 4f2:	31 05       	cpc	r19, r1
 4f4:	10 f0       	brcs	.+4      	; 0x4fa <getKbCode+0x2e>
	{
		tempPointer = 0;
 4f6:	20 e0       	ldi	r18, 0x00	; 0
 4f8:	30 e0       	ldi	r19, 0x00	; 0
	}
	retVal=kbBuffer[tempPointer];
 4fa:	f9 01       	movw	r30, r18
 4fc:	ef 5f       	subi	r30, 0xFF	; 255
 4fe:	fe 4f       	sbci	r31, 0xFE	; 254
 500:	80 81       	ld	r24, Z
	kbOutPointer=tempPointer;
 502:	30 93 61 04 	sts	0x0461, r19	; 0x800461 <kbOutPointer+0x1>
 506:	20 93 60 04 	sts	0x0460, r18	; 0x800460 <kbOutPointer>
	sei();
 50a:	78 94       	sei
	return retVal;
 50c:	08 95       	ret
{
	unsigned char retVal=0;
	unsigned int tempPointer;
	if (kbInPointer==kbOutPointer)
	{
		return 0;
 50e:	80 e0       	ldi	r24, 0x00	; 0
	}
	retVal=kbBuffer[tempPointer];
	kbOutPointer=tempPointer;
	sei();
	return retVal;
}
 510:	08 95       	ret

00000512 <processATKeyboard>:

void processATKeyboard()
{
 512:	cf 93       	push	r28
	unsigned char  kbCode=0;
	unsigned char keyValue=0;
	kbCode = getKbCode();
 514:	0e 94 66 02 	call	0x4cc	; 0x4cc <getKbCode>
 518:	c8 2f       	mov	r28, r24
	if (kbCode>0)
 51a:	88 23       	and	r24, r24
 51c:	09 f4       	brne	.+2      	; 0x520 <processATKeyboard+0xe>
 51e:	d7 c0       	rjmp	.+430    	; 0x6ce <processATKeyboard+0x1bc>
	{
		if (kbCode==0xFA)
 520:	8a 3f       	cpi	r24, 0xFA	; 250
 522:	39 f4       	brne	.+14     	; 0x532 <processATKeyboard+0x20>
		{
			kbAckReceived = 1;
 524:	81 e0       	ldi	r24, 0x01	; 1
 526:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <kbAckReceived>
			prevKbCode=kbCode;
 52a:	8a ef       	ldi	r24, 0xFA	; 250
 52c:	80 93 6b 04 	sts	0x046B, r24	; 0x80046b <prevKbCode>
			return;
 530:	ce c0       	rjmp	.+412    	; 0x6ce <processATKeyboard+0x1bc>
		}
		//Ignore E0 prefixes if part of the key up as they are not significant
		//prev code will remain as F0 to ensure the following is processed properly
		if (prevKbCode==0xF0 && kbCode==0xE0)
 532:	80 91 6b 04 	lds	r24, 0x046B	; 0x80046b <prevKbCode>
 536:	80 3f       	cpi	r24, 0xF0	; 240
 538:	b1 f4       	brne	.+44     	; 0x566 <processATKeyboard+0x54>
 53a:	c0 3e       	cpi	r28, 0xE0	; 224
 53c:	09 f4       	brne	.+2      	; 0x540 <processATKeyboard+0x2e>
 53e:	c7 c0       	rjmp	.+398    	; 0x6ce <processATKeyboard+0x1bc>
		{
			return;	
		}				
		if (prevKbCode==0xF0)
		{
			prevKbCode=kbCode;
 540:	c0 93 6b 04 	sts	0x046B, r28	; 0x80046b <prevKbCode>
			if (kbCode == 0x12 || kbCode ==0x59)
 544:	c2 31       	cpi	r28, 0x12	; 18
 546:	11 f0       	breq	.+4      	; 0x54c <processATKeyboard+0x3a>
 548:	c9 35       	cpi	r28, 0x59	; 89
 54a:	11 f4       	brne	.+4      	; 0x550 <processATKeyboard+0x3e>
			{
				kbShift = 0;
 54c:	10 92 64 04 	sts	0x0464, r1	; 0x800464 <kbShift>
			}
			if (kbCode == 0x14)
 550:	c4 31       	cpi	r28, 0x14	; 20
 552:	19 f4       	brne	.+6      	; 0x55a <processATKeyboard+0x48>
			{
				kbCrtl = 0;
 554:	10 92 34 01 	sts	0x0134, r1	; 0x800134 <kbCrtl>
 558:	ba c0       	rjmp	.+372    	; 0x6ce <processATKeyboard+0x1bc>
			}
			if (kbCode == 0x11)
 55a:	c1 31       	cpi	r28, 0x11	; 17
 55c:	09 f0       	breq	.+2      	; 0x560 <processATKeyboard+0x4e>
 55e:	b7 c0       	rjmp	.+366    	; 0x6ce <processATKeyboard+0x1bc>
			{
				kbAlt = 0;
 560:	10 92 66 04 	sts	0x0466, r1	; 0x800466 <kbAlt>
 564:	b4 c0       	rjmp	.+360    	; 0x6ce <processATKeyboard+0x1bc>
			}
			return;
		}
		if (prevKbCode==0xE0 || kbNumLock==0)
 566:	80 3e       	cpi	r24, 0xE0	; 224
 568:	21 f0       	breq	.+8      	; 0x572 <processATKeyboard+0x60>
 56a:	80 91 67 04 	lds	r24, 0x0467	; 0x800467 <kbNumLock>
 56e:	81 11       	cpse	r24, r1
 570:	3e c0       	rjmp	.+124    	; 0x5ee <processATKeyboard+0xdc>
		{
			prevKbCode=kbCode;
 572:	c0 93 6b 04 	sts	0x046B, r28	; 0x80046b <prevKbCode>
			// Cursor keys - no ascii equiv, so sending "Wordstar" equivalents - CTRL E,S,D,X
			if (kbCode == 0x75) //up
 576:	c5 37       	cpi	r28, 0x75	; 117
 578:	21 f4       	brne	.+8      	; 0x582 <processATKeyboard+0x70>
			{
				sendUSART(5);
 57a:	85 e0       	ldi	r24, 0x05	; 5
 57c:	0e 94 1e 02 	call	0x43c	; 0x43c <sendUSART>
				return;
 580:	a6 c0       	rjmp	.+332    	; 0x6ce <processATKeyboard+0x1bc>
			}
			if (kbCode == 0x72) //down
 582:	c2 37       	cpi	r28, 0x72	; 114
 584:	21 f4       	brne	.+8      	; 0x58e <processATKeyboard+0x7c>
			{
				sendUSART(24);
 586:	88 e1       	ldi	r24, 0x18	; 24
 588:	0e 94 1e 02 	call	0x43c	; 0x43c <sendUSART>
				return;
 58c:	a0 c0       	rjmp	.+320    	; 0x6ce <processATKeyboard+0x1bc>
			}
			if (kbCode == 0x6B) //left
 58e:	cb 36       	cpi	r28, 0x6B	; 107
 590:	21 f4       	brne	.+8      	; 0x59a <processATKeyboard+0x88>
			{
				sendUSART(16);
 592:	80 e1       	ldi	r24, 0x10	; 16
 594:	0e 94 1e 02 	call	0x43c	; 0x43c <sendUSART>
				return;
 598:	9a c0       	rjmp	.+308    	; 0x6ce <processATKeyboard+0x1bc>
			}
			if (kbCode == 0x74) //right
 59a:	c4 37       	cpi	r28, 0x74	; 116
 59c:	21 f4       	brne	.+8      	; 0x5a6 <processATKeyboard+0x94>
			{
				sendUSART(4);
 59e:	84 e0       	ldi	r24, 0x04	; 4
 5a0:	0e 94 1e 02 	call	0x43c	; 0x43c <sendUSART>
				return;
 5a4:	94 c0       	rjmp	.+296    	; 0x6ce <processATKeyboard+0x1bc>
			}
			if (kbCode == 0x70) //ins
 5a6:	c0 37       	cpi	r28, 0x70	; 112
 5a8:	21 f4       	brne	.+8      	; 0x5b2 <processATKeyboard+0xa0>
			{
				sendUSART(1);
 5aa:	81 e0       	ldi	r24, 0x01	; 1
 5ac:	0e 94 1e 02 	call	0x43c	; 0x43c <sendUSART>
				return;
 5b0:	8e c0       	rjmp	.+284    	; 0x6ce <processATKeyboard+0x1bc>
			}
			if (kbCode == 0x71) //del
 5b2:	c1 37       	cpi	r28, 0x71	; 113
 5b4:	21 f4       	brne	.+8      	; 0x5be <processATKeyboard+0xac>
			{
				sendUSART(1);
 5b6:	81 e0       	ldi	r24, 0x01	; 1
 5b8:	0e 94 1e 02 	call	0x43c	; 0x43c <sendUSART>
				return;
 5bc:	88 c0       	rjmp	.+272    	; 0x6ce <processATKeyboard+0x1bc>
			}
			if (kbCode == 0x6C) //home
 5be:	cc 36       	cpi	r28, 0x6C	; 108
 5c0:	21 f4       	brne	.+8      	; 0x5ca <processATKeyboard+0xb8>
			{
				sendUSART(1);
 5c2:	81 e0       	ldi	r24, 0x01	; 1
 5c4:	0e 94 1e 02 	call	0x43c	; 0x43c <sendUSART>
				return;
 5c8:	82 c0       	rjmp	.+260    	; 0x6ce <processATKeyboard+0x1bc>
			}
			if (kbCode == 0x69) //end
 5ca:	c9 36       	cpi	r28, 0x69	; 105
 5cc:	21 f4       	brne	.+8      	; 0x5d6 <processATKeyboard+0xc4>
			{
				sendUSART(1);
 5ce:	81 e0       	ldi	r24, 0x01	; 1
 5d0:	0e 94 1e 02 	call	0x43c	; 0x43c <sendUSART>
				return;
 5d4:	7c c0       	rjmp	.+248    	; 0x6ce <processATKeyboard+0x1bc>
			}
			if (kbCode == 0x7D) //page up
 5d6:	cd 37       	cpi	r28, 0x7D	; 125
 5d8:	21 f4       	brne	.+8      	; 0x5e2 <processATKeyboard+0xd0>
			{
				sendUSART(1);
 5da:	81 e0       	ldi	r24, 0x01	; 1
 5dc:	0e 94 1e 02 	call	0x43c	; 0x43c <sendUSART>
				return;
 5e0:	76 c0       	rjmp	.+236    	; 0x6ce <processATKeyboard+0x1bc>
			}
			if (kbCode == 0x7A) //page down
 5e2:	ca 37       	cpi	r28, 0x7A	; 122
 5e4:	21 f4       	brne	.+8      	; 0x5ee <processATKeyboard+0xdc>
			{
				sendUSART(1);
 5e6:	81 e0       	ldi	r24, 0x01	; 1
 5e8:	0e 94 1e 02 	call	0x43c	; 0x43c <sendUSART>
				return;
 5ec:	70 c0       	rjmp	.+224    	; 0x6ce <processATKeyboard+0x1bc>
			}
		}

		if (kbCode == 0x12 || kbCode ==0x59)
 5ee:	c2 31       	cpi	r28, 0x12	; 18
 5f0:	11 f0       	breq	.+4      	; 0x5f6 <processATKeyboard+0xe4>
 5f2:	c9 35       	cpi	r28, 0x59	; 89
 5f4:	21 f4       	brne	.+8      	; 0x5fe <processATKeyboard+0xec>
		{
			kbShift = 1;
 5f6:	81 e0       	ldi	r24, 0x01	; 1
 5f8:	80 93 64 04 	sts	0x0464, r24	; 0x800464 <kbShift>
 5fc:	66 c0       	rjmp	.+204    	; 0x6ca <processATKeyboard+0x1b8>
		}
		else if (kbCode == 0x14)
 5fe:	c4 31       	cpi	r28, 0x14	; 20
 600:	21 f4       	brne	.+8      	; 0x60a <processATKeyboard+0xf8>
		{
			kbCrtl = 1;
 602:	81 e0       	ldi	r24, 0x01	; 1
 604:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <kbCrtl>
 608:	60 c0       	rjmp	.+192    	; 0x6ca <processATKeyboard+0x1b8>
		}
		else if (kbCode == 0x11)
 60a:	c1 31       	cpi	r28, 0x11	; 17
 60c:	21 f4       	brne	.+8      	; 0x616 <processATKeyboard+0x104>
		{
			kbAlt = 1;
 60e:	81 e0       	ldi	r24, 0x01	; 1
 610:	80 93 66 04 	sts	0x0466, r24	; 0x800466 <kbAlt>
 614:	5a c0       	rjmp	.+180    	; 0x6ca <processATKeyboard+0x1b8>
		}
		else if (kbCode == 0x58)
 616:	c8 35       	cpi	r28, 0x58	; 88
 618:	69 f4       	brne	.+26     	; 0x634 <processATKeyboard+0x122>
		{
			if (kbCaps==1)
 61a:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <kbCaps>
 61e:	81 30       	cpi	r24, 0x01	; 1
 620:	19 f4       	brne	.+6      	; 0x628 <processATKeyboard+0x116>
			{
				kbCaps=0;
 622:	10 92 68 04 	sts	0x0468, r1	; 0x800468 <kbCaps>
 626:	03 c0       	rjmp	.+6      	; 0x62e <processATKeyboard+0x11c>
			}
			else
			{
				kbCaps=1;
 628:	81 e0       	ldi	r24, 0x01	; 1
 62a:	80 93 68 04 	sts	0x0468, r24	; 0x800468 <kbCaps>
			}
			updateKeyboardLEDs();
 62e:	0e 94 b1 01 	call	0x362	; 0x362 <updateKeyboardLEDs>
 632:	4b c0       	rjmp	.+150    	; 0x6ca <processATKeyboard+0x1b8>
		}
		else if (kbCode == 0x77)
 634:	c7 37       	cpi	r28, 0x77	; 119
 636:	69 f4       	brne	.+26     	; 0x652 <processATKeyboard+0x140>
		{
			if (kbNumLock==1)
 638:	80 91 67 04 	lds	r24, 0x0467	; 0x800467 <kbNumLock>
 63c:	81 30       	cpi	r24, 0x01	; 1
 63e:	19 f4       	brne	.+6      	; 0x646 <processATKeyboard+0x134>
			{
				kbNumLock=0;
 640:	10 92 67 04 	sts	0x0467, r1	; 0x800467 <kbNumLock>
 644:	03 c0       	rjmp	.+6      	; 0x64c <processATKeyboard+0x13a>
			}
			else
			{
				kbNumLock=1;
 646:	81 e0       	ldi	r24, 0x01	; 1
 648:	80 93 67 04 	sts	0x0467, r24	; 0x800467 <kbNumLock>
			}
			updateKeyboardLEDs();
 64c:	0e 94 b1 01 	call	0x362	; 0x362 <updateKeyboardLEDs>
 650:	3c c0       	rjmp	.+120    	; 0x6ca <processATKeyboard+0x1b8>
		}
		else if (kbCode == 0x7E)
 652:	ce 37       	cpi	r28, 0x7E	; 126
 654:	69 f4       	brne	.+26     	; 0x670 <processATKeyboard+0x15e>
		{
			if (kbScrollLock==1)
 656:	80 91 63 04 	lds	r24, 0x0463	; 0x800463 <kbScrollLock>
 65a:	81 30       	cpi	r24, 0x01	; 1
 65c:	19 f4       	brne	.+6      	; 0x664 <processATKeyboard+0x152>
			{
				kbScrollLock=0;
 65e:	10 92 63 04 	sts	0x0463, r1	; 0x800463 <kbScrollLock>
 662:	03 c0       	rjmp	.+6      	; 0x66a <processATKeyboard+0x158>
			}
			else
			{
				kbScrollLock=1;
 664:	81 e0       	ldi	r24, 0x01	; 1
 666:	80 93 63 04 	sts	0x0463, r24	; 0x800463 <kbScrollLock>
			}
			updateKeyboardLEDs();
 66a:	0e 94 b1 01 	call	0x362	; 0x362 <updateKeyboardLEDs>
 66e:	2d c0       	rjmp	.+90     	; 0x6ca <processATKeyboard+0x1b8>
		}

		else if (kbCode<132)
 670:	c4 38       	cpi	r28, 0x84	; 132
 672:	58 f5       	brcc	.+86     	; 0x6ca <processATKeyboard+0x1b8>
		{
			if (kbShift==0)
 674:	80 91 64 04 	lds	r24, 0x0464	; 0x800464 <kbShift>
 678:	81 11       	cpse	r24, r1
 67a:	06 c0       	rjmp	.+12     	; 0x688 <processATKeyboard+0x176>
			{
				keyValue = pgm_read_byte(&kbNormal[kbCode]);
 67c:	ec 2f       	mov	r30, r28
 67e:	f0 e0       	ldi	r31, 0x00	; 0
 680:	e4 51       	subi	r30, 0x14	; 20
 682:	ff 4f       	sbci	r31, 0xFF	; 255
 684:	84 91       	lpm	r24, Z
 686:	05 c0       	rjmp	.+10     	; 0x692 <processATKeyboard+0x180>
			}
			else
			{
				keyValue = pgm_read_byte(&kbShifted[kbCode]);
 688:	ec 2f       	mov	r30, r28
 68a:	f0 e0       	ldi	r31, 0x00	; 0
 68c:	e8 59       	subi	r30, 0x98	; 152
 68e:	ff 4f       	sbci	r31, 0xFF	; 255
 690:	84 91       	lpm	r24, Z
			}

			if (keyValue>0)
 692:	88 23       	and	r24, r24
 694:	d1 f0       	breq	.+52     	; 0x6ca <processATKeyboard+0x1b8>
			{
				if ((keyValue>='a') && (keyValue<='z') && (kbCaps==1))
 696:	9f e9       	ldi	r25, 0x9F	; 159
 698:	98 0f       	add	r25, r24
 69a:	9a 31       	cpi	r25, 0x1A	; 26
 69c:	30 f4       	brcc	.+12     	; 0x6aa <processATKeyboard+0x198>
 69e:	90 91 68 04 	lds	r25, 0x0468	; 0x800468 <kbCaps>
 6a2:	91 30       	cpi	r25, 0x01	; 1
 6a4:	59 f4       	brne	.+22     	; 0x6bc <processATKeyboard+0x1aa>
				{
					keyValue=keyValue-32;
 6a6:	80 52       	subi	r24, 0x20	; 32
 6a8:	09 c0       	rjmp	.+18     	; 0x6bc <processATKeyboard+0x1aa>
				}
				else if ((keyValue>='A') && (keyValue<='Z') && (kbCaps==1))
 6aa:	9f eb       	ldi	r25, 0xBF	; 191
 6ac:	98 0f       	add	r25, r24
 6ae:	9a 31       	cpi	r25, 0x1A	; 26
 6b0:	28 f4       	brcc	.+10     	; 0x6bc <processATKeyboard+0x1aa>
 6b2:	90 91 68 04 	lds	r25, 0x0468	; 0x800468 <kbCaps>
 6b6:	91 30       	cpi	r25, 0x01	; 1
 6b8:	09 f4       	brne	.+2      	; 0x6bc <processATKeyboard+0x1aa>
				{
					keyValue=keyValue+32;
 6ba:	80 5e       	subi	r24, 0xE0	; 224
				}

				if (kbCrtl==1)
 6bc:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <kbCrtl>
 6c0:	91 30       	cpi	r25, 0x01	; 1
 6c2:	09 f4       	brne	.+2      	; 0x6c6 <processATKeyboard+0x1b4>
				{
					keyValue=keyValue & 0x1F;
 6c4:	8f 71       	andi	r24, 0x1F	; 31
				}

				sendUSART(keyValue);
 6c6:	0e 94 1e 02 	call	0x43c	; 0x43c <sendUSART>
			}
		}
		prevKbCode=kbCode;
 6ca:	c0 93 6b 04 	sts	0x046B, r28	; 0x80046b <prevKbCode>
	}
}
 6ce:	cf 91       	pop	r28
 6d0:	08 95       	ret

000006d2 <__vector_7>:

//20ms interrupt resets the keyboard values unless clock read within this time
ISR(TIMER2_COMPA_vect)
{
 6d2:	1f 92       	push	r1
 6d4:	0f 92       	push	r0
 6d6:	0f b6       	in	r0, 0x3f	; 63
 6d8:	0f 92       	push	r0
 6da:	11 24       	eor	r1, r1
 6dc:	2f 93       	push	r18
 6de:	3f 93       	push	r19
 6e0:	4f 93       	push	r20
 6e2:	5f 93       	push	r21
 6e4:	6f 93       	push	r22
 6e6:	7f 93       	push	r23
 6e8:	8f 93       	push	r24
 6ea:	9f 93       	push	r25
 6ec:	af 93       	push	r26
 6ee:	bf 93       	push	r27
 6f0:	ef 93       	push	r30
 6f2:	ff 93       	push	r31

	//Timeout, so reset the keyboard read variables
	kbClockCount=0;
 6f4:	10 92 33 01 	sts	0x0133, r1	; 0x800133 <kbClockCount>
	kbTemp=0;
 6f8:	10 92 58 04 	sts	0x0458, r1	; 0x800458 <kbTemp>
	
	//Also reset any pending command
	kbWriteCount=0;
 6fc:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <kbWriteCount>
	if (kbWriteActive==1)
 700:	80 91 65 04 	lds	r24, 0x0465	; 0x800465 <kbWriteActive>
 704:	81 30       	cpi	r24, 0x01	; 1
 706:	31 f4       	brne	.+12     	; 0x714 <__vector_7+0x42>
	{
		setKeyboardToReceiveMode();
 708:	0e 94 e7 00 	call	0x1ce	; 0x1ce <setKeyboardToReceiveMode>
		setKeyboardToSendMode();
 70c:	0e 94 08 01 	call	0x210	; 0x210 <setKeyboardToSendMode>
		kbWriteActive=0;
 710:	10 92 65 04 	sts	0x0465, r1	; 0x800465 <kbWriteActive>
	}

}
 714:	ff 91       	pop	r31
 716:	ef 91       	pop	r30
 718:	bf 91       	pop	r27
 71a:	af 91       	pop	r26
 71c:	9f 91       	pop	r25
 71e:	8f 91       	pop	r24
 720:	7f 91       	pop	r23
 722:	6f 91       	pop	r22
 724:	5f 91       	pop	r21
 726:	4f 91       	pop	r20
 728:	3f 91       	pop	r19
 72a:	2f 91       	pop	r18
 72c:	0f 90       	pop	r0
 72e:	0f be       	out	0x3f, r0	; 63
 730:	0f 90       	pop	r0
 732:	1f 90       	pop	r1
 734:	18 95       	reti

00000736 <main>:

int main(void)
{
	unsigned char serInChar;
	kbInPointer=0;
 736:	10 92 6d 04 	sts	0x046D, r1	; 0x80046d <kbInPointer+0x1>
 73a:	10 92 6c 04 	sts	0x046C, r1	; 0x80046c <kbInPointer>
	kbOutPointer=0;
 73e:	10 92 61 04 	sts	0x0461, r1	; 0x800461 <kbOutPointer+0x1>
 742:	10 92 60 04 	sts	0x0460, r1	; 0x800460 <kbOutPointer>
	kbClockCount=0;
 746:	10 92 33 01 	sts	0x0133, r1	; 0x800133 <kbClockCount>
	prevKbCode=0;
 74a:	10 92 6b 04 	sts	0x046B, r1	; 0x80046b <prevKbCode>
	unsigned char escParam1;
	unsigned char escParam2;
	
	enableAnsiConversion=1;
 74e:	81 e0       	ldi	r24, 0x01	; 1
 750:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <enableAnsiConversion>

	twiStarted=0;
 754:	10 92 5e 04 	sts	0x045E, r1	; 0x80045e <twiStarted>
	
	serInPointer=0;
 758:	10 92 6a 04 	sts	0x046A, r1	; 0x80046a <serInPointer+0x1>
 75c:	10 92 69 04 	sts	0x0469, r1	; 0x800469 <serInPointer>
	serOutPointer=0;
 760:	10 92 5a 04 	sts	0x045A, r1	; 0x80045a <serOutPointer+0x1>
 764:	10 92 59 04 	sts	0x0459, r1	; 0x800459 <serOutPointer>

	kbWriteActive=0;
 768:	10 92 65 04 	sts	0x0465, r1	; 0x800465 <kbWriteActive>
	kbWriteCount=0;
 76c:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <kbWriteCount>
	kbAckReceived=0;
 770:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <kbAckReceived>
	kbWrPar=0;
 774:	10 92 62 04 	sts	0x0462, r1	; 0x800462 <kbWrPar>

	PORTB = 0b00000110; // TWI and 4 bit interface select pin pull-up
 778:	86 e0       	ldi	r24, 0x06	; 6
 77a:	85 b9       	out	0x05, r24	; 5
	DDRB = 0b00101001;
 77c:	89 e2       	ldi	r24, 0x29	; 41
 77e:	84 b9       	out	0x04, r24	; 4
	PORTD = 0x00;
 780:	1b b8       	out	0x0b, r1	; 11
	PORTC = 0x00; // ACK = low
 782:	18 b8       	out	0x08, r1	; 8

	DDRD = 0b11111111;
 784:	8f ef       	ldi	r24, 0xFF	; 255
 786:	8a b9       	out	0x0a, r24	; 10
	unsigned char twiPin = PINB & 0b00000100; //PB2=0 if two wire interface selected

	if (twiPin==0) // Two wire interface selected so both TWI pins to be inputs by default
 788:	1a 99       	sbic	0x03, 2	; 3
 78a:	08 c0       	rjmp	.+16     	; 0x79c <main+0x66>
	{
		DDRC = 0b00001000; // Only PC3 is an output (/RTS)
 78c:	88 e0       	ldi	r24, 0x08	; 8
 78e:	87 b9       	out	0x07, r24	; 7
		// Two wire speed initialisation
		// SCL freq = CPU freq / (16+2*TWBR*Prescaler)
		TWSR=0; // Prescaler = 1
 790:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__DATA_REGION_ORIGIN__+0x59>
		TWBR=7; // Bit rate 7 = 400KHz for 12MHz clk  (=12 for 16MHz clk)
 794:	87 e0       	ldi	r24, 0x07	; 7
 796:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__DATA_REGION_ORIGIN__+0x58>
 79a:	02 c0       	rjmp	.+4      	; 0x7a0 <main+0x6a>
	}
	else
	{
		DDRC = 0b00101000; // PC3 and PC5 are outputs (/RTS and AVAIL)
 79c:	88 e2       	ldi	r24, 0x28	; 40
 79e:	87 b9       	out	0x07, r24	; 7
	}	

	PCICR=1<<PCIE1; // Interrupt on pin change
 7a0:	c2 e0       	ldi	r28, 0x02	; 2
 7a2:	c0 93 68 00 	sts	0x0068, r28	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
	PCMSK1=1<<PCINT9; // enable pin PC1 change (KB clock) to interrupt
 7a6:	c0 93 6c 00 	sts	0x006C, r28	; 0x80006c <__DATA_REGION_ORIGIN__+0xc>

	kbShift=0;
 7aa:	10 92 64 04 	sts	0x0464, r1	; 0x800464 <kbShift>
	kbCrtl=0;
 7ae:	10 92 34 01 	sts	0x0134, r1	; 0x800134 <kbCrtl>
	kbAlt=0;
 7b2:	10 92 66 04 	sts	0x0466, r1	; 0x800466 <kbAlt>
	kbCaps=1;
 7b6:	81 e0       	ldi	r24, 0x01	; 1
 7b8:	80 93 68 04 	sts	0x0468, r24	; 0x800468 <kbCaps>
	kbNumLock=1;
 7bc:	80 93 67 04 	sts	0x0467, r24	; 0x800467 <kbNumLock>
	kbScrollLock=0;
 7c0:	10 92 63 04 	sts	0x0463, r1	; 0x800463 <kbScrollLock>
	
	initUSART();
 7c4:	0e 94 12 02 	call	0x424	; 0x424 <initUSART>

	TIMSK2 = TIMSK2 | (1<<OCIE2A);  // Enable Interrupt TimerCounter2 Compare Match A (TIMER2_COMPA_vect)
 7c8:	e0 e7       	ldi	r30, 0x70	; 112
 7ca:	f0 e0       	ldi	r31, 0x00	; 0
 7cc:	80 81       	ld	r24, Z
 7ce:	82 60       	ori	r24, 0x02	; 2
 7d0:	80 83       	st	Z, r24
	TCCR2A = 1<<WGM21;  // Mode = CTC
 7d2:	c0 93 b0 00 	sts	0x00B0, r28	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	TCCR2B = (1<<CS22) | (1<<CS21) | (1<<CS20);   // Clock div 1024
 7d6:	87 e0       	ldi	r24, 0x07	; 7
 7d8:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	OCR2A = 215;          // Interrupt every 20mS unless value reset
 7dc:	87 ed       	ldi	r24, 0xD7	; 215
 7de:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>

	sei();
 7e2:	78 94       	sei

	setKeyboardToSendMode();
 7e4:	0e 94 08 01 	call	0x210	; 0x210 <setKeyboardToSendMode>
	updateKeyboardLEDs();
 7e8:	0e 94 b1 01 	call	0x362	; 0x362 <updateKeyboardLEDs>
	setKeyboardToReceiveMode();
 7ec:	0e 94 e7 00 	call	0x1ce	; 0x1ce <setKeyboardToReceiveMode>
					}
					// If a ";" then process the next number
					if (serInChar==';')
					{
						serInChar=getInChar();
						while (serInChar>='0' && serInChar<='9')
 7f0:	d0 e0       	ldi	r29, 0x00	; 0
			}				
			else if (kbWriteCount==2 && kbAckReceived==1)
			{
				kbAckReceived=0;
				kbWriteDataVal=kbBuffer2;
				kbWriteCount--;
 7f2:	01 e0       	ldi	r16, 0x01	; 1
		if (kbWriteActive==0 && kbWriteCount>0)
		{
			if (kbWriteCount==3)
			{
				kbWriteDataVal=kbBuffer3;
				kbWriteCount--;
 7f4:	12 e0       	ldi	r17, 0x02	; 2
	// Loop forever
	while (1==1)
	{
		//Get a character from the serial port
		
		if (isInCharAvailable()==1)
 7f6:	0e 94 58 02 	call	0x4b0	; 0x4b0 <isInCharAvailable>
 7fa:	81 30       	cpi	r24, 0x01	; 1
 7fc:	d9 f5       	brne	.+118    	; 0x874 <main+0x13e>
		{
			serInChar=getInChar();
 7fe:	0e 94 26 02 	call	0x44c	; 0x44c <getInChar>
			//If it is an escape character then get the following characters to interpret
			//them as an ANSI escape sequence
			if (serInChar==27 && enableAnsiConversion==1) // && prevInChar!=26) // If the previous char was a "force character (26)" prefix then don't treat 27 as an escape
 802:	8b 31       	cpi	r24, 0x1B	; 27
 804:	b9 f5       	brne	.+110    	; 0x874 <main+0x13e>
 806:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <enableAnsiConversion>
 80a:	81 30       	cpi	r24, 0x01	; 1
 80c:	99 f5       	brne	.+102    	; 0x874 <main+0x13e>
			{
				escParam1=0;
				escParam2=0;
				serInChar=getInChar();
 80e:	0e 94 26 02 	call	0x44c	; 0x44c <getInChar>

				if (serInChar=='-')
 812:	8d 32       	cpi	r24, 0x2D	; 45
 814:	19 f4       	brne	.+6      	; 0x81c <main+0xe6>
				{
					enableAnsiConversion=0;  // ESC- will turn off the ANSI interpreter
 816:	d0 93 36 01 	sts	0x0136, r29	; 0x800136 <enableAnsiConversion>
 81a:	2c c0       	rjmp	.+88     	; 0x874 <main+0x13e>
				}
				if (serInChar=='[')
 81c:	8b 35       	cpi	r24, 0x5B	; 91
 81e:	51 f5       	brne	.+84     	; 0x874 <main+0x13e>
				{
					serInChar=getInChar();
 820:	0e 94 26 02 	call	0x44c	; 0x44c <getInChar>
					// Process a number after the "[" character
					while (serInChar>='0' && serInChar<='9')
 824:	90 ed       	ldi	r25, 0xD0	; 208
 826:	98 0f       	add	r25, r24
 828:	9a 30       	cpi	r25, 0x0A	; 10
 82a:	78 f4       	brcc	.+30     	; 0x84a <main+0x114>
 82c:	cd 2f       	mov	r28, r29
					{
						serInChar=serInChar-'0';
						if (escParam1<100)
 82e:	c4 36       	cpi	r28, 0x64	; 100
 830:	30 f4       	brcc	.+12     	; 0x83e <main+0x108>
						{
							escParam1=escParam1*10;
 832:	cc 0f       	add	r28, r28
 834:	8c 2f       	mov	r24, r28
 836:	88 0f       	add	r24, r24
 838:	88 0f       	add	r24, r24
 83a:	c8 0f       	add	r28, r24
							escParam1=escParam1+serInChar;
 83c:	c9 0f       	add	r28, r25
						}
 						serInChar=getInChar();
 83e:	0e 94 26 02 	call	0x44c	; 0x44c <getInChar>
				}
				if (serInChar=='[')
				{
					serInChar=getInChar();
					// Process a number after the "[" character
					while (serInChar>='0' && serInChar<='9')
 842:	90 ed       	ldi	r25, 0xD0	; 208
 844:	98 0f       	add	r25, r24
 846:	9a 30       	cpi	r25, 0x0A	; 10
 848:	90 f3       	brcs	.-28     	; 0x82e <main+0xf8>
							escParam1=escParam1+serInChar;
						}
 						serInChar=getInChar();
					}
					// If a ";" then process the next number
					if (serInChar==';')
 84a:	8b 33       	cpi	r24, 0x3B	; 59
 84c:	99 f4       	brne	.+38     	; 0x874 <main+0x13e>
					{
						serInChar=getInChar();
 84e:	0e 94 26 02 	call	0x44c	; 0x44c <getInChar>
						while (serInChar>='0' && serInChar<='9')
 852:	80 53       	subi	r24, 0x30	; 48
 854:	8a 30       	cpi	r24, 0x0A	; 10
 856:	70 f4       	brcc	.+28     	; 0x874 <main+0x13e>
 858:	cd 2f       	mov	r28, r29
						{
							serInChar=serInChar-'0';
							if (escParam2<100)
 85a:	c4 36       	cpi	r28, 0x64	; 100
 85c:	30 f4       	brcc	.+12     	; 0x86a <main+0x134>
							{
								escParam2=escParam2*10;
 85e:	cc 0f       	add	r28, r28
 860:	9c 2f       	mov	r25, r28
 862:	99 0f       	add	r25, r25
 864:	99 0f       	add	r25, r25
 866:	c9 0f       	add	r28, r25
								escParam2=escParam2+serInChar;
 868:	c8 0f       	add	r28, r24
							}
	 						serInChar=getInChar();
 86a:	0e 94 26 02 	call	0x44c	; 0x44c <getInChar>
					}
					// If a ";" then process the next number
					if (serInChar==';')
					{
						serInChar=getInChar();
						while (serInChar>='0' && serInChar<='9')
 86e:	80 53       	subi	r24, 0x30	; 48
 870:	8a 30       	cpi	r24, 0x0A	; 10
 872:	98 f3       	brcs	.-26     	; 0x85a <main+0x124>

	 			sendToDisplay(serInChar);
			}
		}

		processATKeyboard();
 874:	0e 94 89 02 	call	0x512	; 0x512 <processATKeyboard>
		
		if (kbWriteActive==0 && kbWriteCount>0)
 878:	80 91 65 04 	lds	r24, 0x0465	; 0x800465 <kbWriteActive>
 87c:	81 11       	cpse	r24, r1
 87e:	bb cf       	rjmp	.-138    	; 0x7f6 <main+0xc0>
 880:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <kbWriteCount>
 884:	88 23       	and	r24, r24
 886:	09 f4       	brne	.+2      	; 0x88a <main+0x154>
 888:	b6 cf       	rjmp	.-148    	; 0x7f6 <main+0xc0>
		{
			if (kbWriteCount==3)
 88a:	83 30       	cpi	r24, 0x03	; 3
 88c:	49 f4       	brne	.+18     	; 0x8a0 <main+0x16a>
			{
				kbWriteDataVal=kbBuffer3;
 88e:	80 91 5b 04 	lds	r24, 0x045B	; 0x80045b <kbBuffer3>
 892:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
				kbWriteCount--;
 896:	10 93 35 01 	sts	0x0135, r17	; 0x800135 <kbWriteCount>
				setKeyboardToReceiveMode();
 89a:	0e 94 e7 00 	call	0x1ce	; 0x1ce <setKeyboardToReceiveMode>
 89e:	ab cf       	rjmp	.-170    	; 0x7f6 <main+0xc0>
			}				
			else if (kbWriteCount==2 && kbAckReceived==1)
 8a0:	82 30       	cpi	r24, 0x02	; 2
 8a2:	81 f4       	brne	.+32     	; 0x8c4 <main+0x18e>
 8a4:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <kbAckReceived>
 8a8:	81 30       	cpi	r24, 0x01	; 1
 8aa:	09 f0       	breq	.+2      	; 0x8ae <main+0x178>
 8ac:	a4 cf       	rjmp	.-184    	; 0x7f6 <main+0xc0>
			{
				kbAckReceived=0;
 8ae:	d0 93 37 01 	sts	0x0137, r29	; 0x800137 <kbAckReceived>
				kbWriteDataVal=kbBuffer2;
 8b2:	80 91 5f 04 	lds	r24, 0x045F	; 0x80045f <kbBuffer2>
 8b6:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
				kbWriteCount--;
 8ba:	00 93 35 01 	sts	0x0135, r16	; 0x800135 <kbWriteCount>
				setKeyboardToReceiveMode();
 8be:	0e 94 e7 00 	call	0x1ce	; 0x1ce <setKeyboardToReceiveMode>
 8c2:	99 cf       	rjmp	.-206    	; 0x7f6 <main+0xc0>
			}
			else if (kbWriteCount==1 && kbAckReceived==1)
 8c4:	81 30       	cpi	r24, 0x01	; 1
 8c6:	09 f0       	breq	.+2      	; 0x8ca <main+0x194>
 8c8:	96 cf       	rjmp	.-212    	; 0x7f6 <main+0xc0>
 8ca:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <kbAckReceived>
 8ce:	81 30       	cpi	r24, 0x01	; 1
 8d0:	09 f0       	breq	.+2      	; 0x8d4 <main+0x19e>
 8d2:	91 cf       	rjmp	.-222    	; 0x7f6 <main+0xc0>
			{
				kbWriteDataVal=kbBuffer1;
 8d4:	80 91 5d 04 	lds	r24, 0x045D	; 0x80045d <kbBuffer1>
 8d8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
				kbWriteCount--;
 8dc:	d0 93 35 01 	sts	0x0135, r29	; 0x800135 <kbWriteCount>
				setKeyboardToReceiveMode();
 8e0:	0e 94 e7 00 	call	0x1ce	; 0x1ce <setKeyboardToReceiveMode>
 8e4:	88 cf       	rjmp	.-240    	; 0x7f6 <main+0xc0>

000008e6 <_exit>:
 8e6:	f8 94       	cli

000008e8 <__stop_program>:
 8e8:	ff cf       	rjmp	.-2      	; 0x8e8 <__stop_program>
